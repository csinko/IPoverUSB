ARM GAS  /tmp/cctR0i1S.s 			page 1


   1              		.cpu cortex-m7
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"etharp.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.etharp_raw.str1.4,"aMS",%progbits,1
  18              		.align	2
  19              	.LC0:
  20 0000 6E657469 		.ascii	"netif != NULL\000"
  20      6620213D 
  20      204E554C 
  20      4C00
  21 000e 0000     		.align	2
  22              	.LC1:
  23 0010 63686563 		.ascii	"check that first pbuf can hold struct etharp_hdr\000"
  23      6B207468 
  23      61742066 
  23      69727374 
  23      20706275 
  24 0041 000000   		.align	2
  25              	.LC2:
  26 0044 6E657469 		.ascii	"netif->hwaddr_len must be the same as ETH_HWADDR_LE"
  26      662D3E68 
  26      77616464 
  26      725F6C65 
  26      6E206D75 
  27 0077 4E20666F 		.ascii	"N for etharp!\000"
  27      72206574 
  27      68617270 
  27      2100
  28              		.section	.text.etharp_raw,"ax",%progbits
  29              		.align	1
  30              		.p2align 2,,3
  31              		.arch armv7e-m
  32              		.syntax unified
  33              		.thumb
  34              		.thumb_func
  35              		.fpu fpv4-sp-d16
  37              	etharp_raw:
  38              	.LVL0:
  39              	.LFB116:
  40              		.file 1 "lwIP/src/core/ipv4/etharp.c"
   1:lwIP/src/core/ipv4/etharp.c **** /**
   2:lwIP/src/core/ipv4/etharp.c ****  * @file
   3:lwIP/src/core/ipv4/etharp.c ****  * Address Resolution Protocol module for IP over Ethernet
   4:lwIP/src/core/ipv4/etharp.c ****  *
ARM GAS  /tmp/cctR0i1S.s 			page 2


   5:lwIP/src/core/ipv4/etharp.c ****  * Functionally, ARP is divided into two parts. The first maps an IP address
   6:lwIP/src/core/ipv4/etharp.c ****  * to a physical address when sending a packet, and the second part answers
   7:lwIP/src/core/ipv4/etharp.c ****  * requests from other machines for our physical address.
   8:lwIP/src/core/ipv4/etharp.c ****  *
   9:lwIP/src/core/ipv4/etharp.c ****  * This implementation complies with RFC 826 (Ethernet ARP). It supports
  10:lwIP/src/core/ipv4/etharp.c ****  * Gratuitious ARP from RFC3220 (IP Mobility Support for IPv4) section 4.6
  11:lwIP/src/core/ipv4/etharp.c ****  * if an interface calls etharp_gratuitous(our_netif) upon address change.
  12:lwIP/src/core/ipv4/etharp.c ****  */
  13:lwIP/src/core/ipv4/etharp.c **** 
  14:lwIP/src/core/ipv4/etharp.c **** /*
  15:lwIP/src/core/ipv4/etharp.c ****  * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
  16:lwIP/src/core/ipv4/etharp.c ****  * Copyright (c) 2003-2004 Leon Woestenberg <leon.woestenberg@axon.tv>
  17:lwIP/src/core/ipv4/etharp.c ****  * Copyright (c) 2003-2004 Axon Digital Design B.V., The Netherlands.
  18:lwIP/src/core/ipv4/etharp.c ****  * All rights reserved.
  19:lwIP/src/core/ipv4/etharp.c ****  *
  20:lwIP/src/core/ipv4/etharp.c ****  * Redistribution and use in source and binary forms, with or without modification,
  21:lwIP/src/core/ipv4/etharp.c ****  * are permitted provided that the following conditions are met:
  22:lwIP/src/core/ipv4/etharp.c ****  *
  23:lwIP/src/core/ipv4/etharp.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  24:lwIP/src/core/ipv4/etharp.c ****  *    this list of conditions and the following disclaimer.
  25:lwIP/src/core/ipv4/etharp.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  26:lwIP/src/core/ipv4/etharp.c ****  *    this list of conditions and the following disclaimer in the documentation
  27:lwIP/src/core/ipv4/etharp.c ****  *    and/or other materials provided with the distribution.
  28:lwIP/src/core/ipv4/etharp.c ****  * 3. The name of the author may not be used to endorse or promote products
  29:lwIP/src/core/ipv4/etharp.c ****  *    derived from this software without specific prior written permission.
  30:lwIP/src/core/ipv4/etharp.c ****  *
  31:lwIP/src/core/ipv4/etharp.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  32:lwIP/src/core/ipv4/etharp.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  33:lwIP/src/core/ipv4/etharp.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  34:lwIP/src/core/ipv4/etharp.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  35:lwIP/src/core/ipv4/etharp.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  36:lwIP/src/core/ipv4/etharp.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  37:lwIP/src/core/ipv4/etharp.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  38:lwIP/src/core/ipv4/etharp.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  39:lwIP/src/core/ipv4/etharp.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  40:lwIP/src/core/ipv4/etharp.c ****  * OF SUCH DAMAGE.
  41:lwIP/src/core/ipv4/etharp.c ****  *
  42:lwIP/src/core/ipv4/etharp.c ****  * This file is part of the lwIP TCP/IP stack.
  43:lwIP/src/core/ipv4/etharp.c ****  *
  44:lwIP/src/core/ipv4/etharp.c ****  */
  45:lwIP/src/core/ipv4/etharp.c **** 
  46:lwIP/src/core/ipv4/etharp.c **** #include "lwip/opt.h"
  47:lwIP/src/core/ipv4/etharp.c **** 
  48:lwIP/src/core/ipv4/etharp.c **** #if LWIP_IPV4 && LWIP_ARP /* don't build if not configured for use in lwipopts.h */
  49:lwIP/src/core/ipv4/etharp.c **** 
  50:lwIP/src/core/ipv4/etharp.c **** #include "lwip/etharp.h"
  51:lwIP/src/core/ipv4/etharp.c **** #include "lwip/stats.h"
  52:lwIP/src/core/ipv4/etharp.c **** #include "lwip/snmp.h"
  53:lwIP/src/core/ipv4/etharp.c **** #include "lwip/dhcp.h"
  54:lwIP/src/core/ipv4/etharp.c **** #include "lwip/autoip.h"
  55:lwIP/src/core/ipv4/etharp.c **** #include "lwip/prot/iana.h"
  56:lwIP/src/core/ipv4/etharp.c **** #include "netif/ethernet.h"
  57:lwIP/src/core/ipv4/etharp.c **** 
  58:lwIP/src/core/ipv4/etharp.c **** #include <string.h>
  59:lwIP/src/core/ipv4/etharp.c **** 
  60:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_HOOK_FILENAME
  61:lwIP/src/core/ipv4/etharp.c **** #include LWIP_HOOK_FILENAME
ARM GAS  /tmp/cctR0i1S.s 			page 3


  62:lwIP/src/core/ipv4/etharp.c **** #endif
  63:lwIP/src/core/ipv4/etharp.c **** 
  64:lwIP/src/core/ipv4/etharp.c **** /** Re-request a used ARP entry 1 minute before it would expire to prevent
  65:lwIP/src/core/ipv4/etharp.c ****  *  breaking a steadily used connection because the ARP entry timed out. */
  66:lwIP/src/core/ipv4/etharp.c **** #define ARP_AGE_REREQUEST_USED_UNICAST   (ARP_MAXAGE - 30)
  67:lwIP/src/core/ipv4/etharp.c **** #define ARP_AGE_REREQUEST_USED_BROADCAST (ARP_MAXAGE - 15)
  68:lwIP/src/core/ipv4/etharp.c **** 
  69:lwIP/src/core/ipv4/etharp.c **** /** the time an ARP entry stays pending after first request,
  70:lwIP/src/core/ipv4/etharp.c ****  *  for ARP_TMR_INTERVAL = 1000, this is
  71:lwIP/src/core/ipv4/etharp.c ****  *  10 seconds.
  72:lwIP/src/core/ipv4/etharp.c ****  *
  73:lwIP/src/core/ipv4/etharp.c ****  *  @internal Keep this number at least 2, otherwise it might
  74:lwIP/src/core/ipv4/etharp.c ****  *  run out instantly if the timeout occurs directly after a request.
  75:lwIP/src/core/ipv4/etharp.c ****  */
  76:lwIP/src/core/ipv4/etharp.c **** #define ARP_MAXPENDING 5
  77:lwIP/src/core/ipv4/etharp.c **** 
  78:lwIP/src/core/ipv4/etharp.c **** /** ARP states */
  79:lwIP/src/core/ipv4/etharp.c **** enum etharp_state {
  80:lwIP/src/core/ipv4/etharp.c ****   ETHARP_STATE_EMPTY = 0,
  81:lwIP/src/core/ipv4/etharp.c ****   ETHARP_STATE_PENDING,
  82:lwIP/src/core/ipv4/etharp.c ****   ETHARP_STATE_STABLE,
  83:lwIP/src/core/ipv4/etharp.c ****   ETHARP_STATE_STABLE_REREQUESTING_1,
  84:lwIP/src/core/ipv4/etharp.c ****   ETHARP_STATE_STABLE_REREQUESTING_2
  85:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
  86:lwIP/src/core/ipv4/etharp.c ****   , ETHARP_STATE_STATIC
  87:lwIP/src/core/ipv4/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  88:lwIP/src/core/ipv4/etharp.c **** };
  89:lwIP/src/core/ipv4/etharp.c **** 
  90:lwIP/src/core/ipv4/etharp.c **** struct etharp_entry {
  91:lwIP/src/core/ipv4/etharp.c **** #if ARP_QUEUEING
  92:lwIP/src/core/ipv4/etharp.c ****   /** Pointer to queue of pending outgoing packets on this ARP entry. */
  93:lwIP/src/core/ipv4/etharp.c ****   struct etharp_q_entry *q;
  94:lwIP/src/core/ipv4/etharp.c **** #else /* ARP_QUEUEING */
  95:lwIP/src/core/ipv4/etharp.c ****   /** Pointer to a single pending outgoing packet on this ARP entry. */
  96:lwIP/src/core/ipv4/etharp.c ****   struct pbuf *q;
  97:lwIP/src/core/ipv4/etharp.c **** #endif /* ARP_QUEUEING */
  98:lwIP/src/core/ipv4/etharp.c ****   ip4_addr_t ipaddr;
  99:lwIP/src/core/ipv4/etharp.c ****   struct netif *netif;
 100:lwIP/src/core/ipv4/etharp.c ****   struct eth_addr ethaddr;
 101:lwIP/src/core/ipv4/etharp.c ****   u16_t ctime;
 102:lwIP/src/core/ipv4/etharp.c ****   u8_t state;
 103:lwIP/src/core/ipv4/etharp.c **** };
 104:lwIP/src/core/ipv4/etharp.c **** 
 105:lwIP/src/core/ipv4/etharp.c **** static struct etharp_entry arp_table[ARP_TABLE_SIZE];
 106:lwIP/src/core/ipv4/etharp.c **** 
 107:lwIP/src/core/ipv4/etharp.c **** #if !LWIP_NETIF_HWADDRHINT
 108:lwIP/src/core/ipv4/etharp.c **** static netif_addr_idx_t etharp_cached_entry;
 109:lwIP/src/core/ipv4/etharp.c **** #endif /* !LWIP_NETIF_HWADDRHINT */
 110:lwIP/src/core/ipv4/etharp.c **** 
 111:lwIP/src/core/ipv4/etharp.c **** /** Try hard to create a new entry - we want the IP address to appear in
 112:lwIP/src/core/ipv4/etharp.c ****     the cache (even if this means removing an active entry or so). */
 113:lwIP/src/core/ipv4/etharp.c **** #define ETHARP_FLAG_TRY_HARD     1
 114:lwIP/src/core/ipv4/etharp.c **** #define ETHARP_FLAG_FIND_ONLY    2
 115:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 116:lwIP/src/core/ipv4/etharp.c **** #define ETHARP_FLAG_STATIC_ENTRY 4
 117:lwIP/src/core/ipv4/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 118:lwIP/src/core/ipv4/etharp.c **** 
ARM GAS  /tmp/cctR0i1S.s 			page 4


 119:lwIP/src/core/ipv4/etharp.c **** #if LWIP_NETIF_HWADDRHINT
 120:lwIP/src/core/ipv4/etharp.c **** #define ETHARP_SET_ADDRHINT(netif, addrhint)  do { if (((netif) != NULL) && ((netif)->hints != NULL
 121:lwIP/src/core/ipv4/etharp.c ****                                               (netif)->hints->addr_hint = (addrhint); }} while(0)
 122:lwIP/src/core/ipv4/etharp.c **** #else /* LWIP_NETIF_HWADDRHINT */
 123:lwIP/src/core/ipv4/etharp.c **** #define ETHARP_SET_ADDRHINT(netif, addrhint)  (etharp_cached_entry = (addrhint))
 124:lwIP/src/core/ipv4/etharp.c **** #endif /* LWIP_NETIF_HWADDRHINT */
 125:lwIP/src/core/ipv4/etharp.c **** 
 126:lwIP/src/core/ipv4/etharp.c **** 
 127:lwIP/src/core/ipv4/etharp.c **** /* Check for maximum ARP_TABLE_SIZE */
 128:lwIP/src/core/ipv4/etharp.c **** #if (ARP_TABLE_SIZE > NETIF_ADDR_IDX_MAX)
 129:lwIP/src/core/ipv4/etharp.c **** #error "ARP_TABLE_SIZE must fit in an s16_t, you have to reduce it in your lwipopts.h"
 130:lwIP/src/core/ipv4/etharp.c **** #endif
 131:lwIP/src/core/ipv4/etharp.c **** 
 132:lwIP/src/core/ipv4/etharp.c **** 
 133:lwIP/src/core/ipv4/etharp.c **** static err_t etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_add
 134:lwIP/src/core/ipv4/etharp.c **** static err_t etharp_raw(struct netif *netif,
 135:lwIP/src/core/ipv4/etharp.c ****                         const struct eth_addr *ethsrc_addr, const struct eth_addr *ethdst_addr,
 136:lwIP/src/core/ipv4/etharp.c ****                         const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
 137:lwIP/src/core/ipv4/etharp.c ****                         const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
 138:lwIP/src/core/ipv4/etharp.c ****                         const u16_t opcode);
 139:lwIP/src/core/ipv4/etharp.c **** 
 140:lwIP/src/core/ipv4/etharp.c **** #if ARP_QUEUEING
 141:lwIP/src/core/ipv4/etharp.c **** /**
 142:lwIP/src/core/ipv4/etharp.c ****  * Free a complete queue of etharp entries
 143:lwIP/src/core/ipv4/etharp.c ****  *
 144:lwIP/src/core/ipv4/etharp.c ****  * @param q a qeueue of etharp_q_entry's to free
 145:lwIP/src/core/ipv4/etharp.c ****  */
 146:lwIP/src/core/ipv4/etharp.c **** static void
 147:lwIP/src/core/ipv4/etharp.c **** free_etharp_q(struct etharp_q_entry *q)
 148:lwIP/src/core/ipv4/etharp.c **** {
 149:lwIP/src/core/ipv4/etharp.c ****   struct etharp_q_entry *r;
 150:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 151:lwIP/src/core/ipv4/etharp.c ****   while (q) {
 152:lwIP/src/core/ipv4/etharp.c ****     r = q;
 153:lwIP/src/core/ipv4/etharp.c ****     q = q->next;
 154:lwIP/src/core/ipv4/etharp.c ****     LWIP_ASSERT("r->p != NULL", (r->p != NULL));
 155:lwIP/src/core/ipv4/etharp.c ****     pbuf_free(r->p);
 156:lwIP/src/core/ipv4/etharp.c ****     memp_free(MEMP_ARP_QUEUE, r);
 157:lwIP/src/core/ipv4/etharp.c ****   }
 158:lwIP/src/core/ipv4/etharp.c **** }
 159:lwIP/src/core/ipv4/etharp.c **** #else /* ARP_QUEUEING */
 160:lwIP/src/core/ipv4/etharp.c **** 
 161:lwIP/src/core/ipv4/etharp.c **** /** Compatibility define: free the queued pbuf */
 162:lwIP/src/core/ipv4/etharp.c **** #define free_etharp_q(q) pbuf_free(q)
 163:lwIP/src/core/ipv4/etharp.c **** 
 164:lwIP/src/core/ipv4/etharp.c **** #endif /* ARP_QUEUEING */
 165:lwIP/src/core/ipv4/etharp.c **** 
 166:lwIP/src/core/ipv4/etharp.c **** /** Clean up ARP table entries */
 167:lwIP/src/core/ipv4/etharp.c **** static void
 168:lwIP/src/core/ipv4/etharp.c **** etharp_free_entry(int i)
 169:lwIP/src/core/ipv4/etharp.c **** {
 170:lwIP/src/core/ipv4/etharp.c ****   /* remove from SNMP ARP index tree */
 171:lwIP/src/core/ipv4/etharp.c ****   mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
 172:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 173:lwIP/src/core/ipv4/etharp.c ****   if (arp_table[i].q != NULL) {
 174:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 175:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u1
ARM GAS  /tmp/cctR0i1S.s 			page 5


 176:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 177:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 178:lwIP/src/core/ipv4/etharp.c ****   }
 179:lwIP/src/core/ipv4/etharp.c ****   /* recycle entry for re-use */
 180:lwIP/src/core/ipv4/etharp.c ****   arp_table[i].state = ETHARP_STATE_EMPTY;
 181:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 182:lwIP/src/core/ipv4/etharp.c ****   /* for debugging, clean out the complete entry */
 183:lwIP/src/core/ipv4/etharp.c ****   arp_table[i].ctime = 0;
 184:lwIP/src/core/ipv4/etharp.c ****   arp_table[i].netif = NULL;
 185:lwIP/src/core/ipv4/etharp.c ****   ip4_addr_set_zero(&arp_table[i].ipaddr);
 186:lwIP/src/core/ipv4/etharp.c ****   arp_table[i].ethaddr = ethzero;
 187:lwIP/src/core/ipv4/etharp.c **** #endif /* LWIP_DEBUG */
 188:lwIP/src/core/ipv4/etharp.c **** }
 189:lwIP/src/core/ipv4/etharp.c **** 
 190:lwIP/src/core/ipv4/etharp.c **** /**
 191:lwIP/src/core/ipv4/etharp.c ****  * Clears expired entries in the ARP table.
 192:lwIP/src/core/ipv4/etharp.c ****  *
 193:lwIP/src/core/ipv4/etharp.c ****  * This function should be called every ARP_TMR_INTERVAL milliseconds (1 second),
 194:lwIP/src/core/ipv4/etharp.c ****  * in order to expire entries in the ARP table.
 195:lwIP/src/core/ipv4/etharp.c ****  */
 196:lwIP/src/core/ipv4/etharp.c **** void
 197:lwIP/src/core/ipv4/etharp.c **** etharp_tmr(void)
 198:lwIP/src/core/ipv4/etharp.c **** {
 199:lwIP/src/core/ipv4/etharp.c ****   int i;
 200:lwIP/src/core/ipv4/etharp.c **** 
 201:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
 202:lwIP/src/core/ipv4/etharp.c ****   /* remove expired entries from the ARP table */
 203:lwIP/src/core/ipv4/etharp.c ****   for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 204:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 205:lwIP/src/core/ipv4/etharp.c ****     if (state != ETHARP_STATE_EMPTY
 206:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 207:lwIP/src/core/ipv4/etharp.c ****         && (state != ETHARP_STATE_STATIC)
 208:lwIP/src/core/ipv4/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 209:lwIP/src/core/ipv4/etharp.c ****        ) {
 210:lwIP/src/core/ipv4/etharp.c ****       arp_table[i].ctime++;
 211:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 212:lwIP/src/core/ipv4/etharp.c ****           ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 213:lwIP/src/core/ipv4/etharp.c ****            (arp_table[i].ctime >= ARP_MAXPENDING))) {
 214:lwIP/src/core/ipv4/etharp.c ****         /* pending or stable entry has become old! */
 215:lwIP/src/core/ipv4/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %d.\n",
 216:lwIP/src/core/ipv4/etharp.c ****                                    arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending"
 217:lwIP/src/core/ipv4/etharp.c ****         /* clean up entries that have just been expired */
 218:lwIP/src/core/ipv4/etharp.c ****         etharp_free_entry(i);
 219:lwIP/src/core/ipv4/etharp.c ****       } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
 220:lwIP/src/core/ipv4/etharp.c ****         /* Don't send more than one request every 2 seconds. */
 221:lwIP/src/core/ipv4/etharp.c ****         arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
 222:lwIP/src/core/ipv4/etharp.c ****       } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
 223:lwIP/src/core/ipv4/etharp.c ****         /* Reset state to stable, so that the next transmitted packet will
 224:lwIP/src/core/ipv4/etharp.c ****            re-send an ARP request. */
 225:lwIP/src/core/ipv4/etharp.c ****         arp_table[i].state = ETHARP_STATE_STABLE;
 226:lwIP/src/core/ipv4/etharp.c ****       } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 227:lwIP/src/core/ipv4/etharp.c ****         /* still pending, resend an ARP query */
 228:lwIP/src/core/ipv4/etharp.c ****         etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
 229:lwIP/src/core/ipv4/etharp.c ****       }
 230:lwIP/src/core/ipv4/etharp.c ****     }
 231:lwIP/src/core/ipv4/etharp.c ****   }
 232:lwIP/src/core/ipv4/etharp.c **** }
ARM GAS  /tmp/cctR0i1S.s 			page 6


 233:lwIP/src/core/ipv4/etharp.c **** 
 234:lwIP/src/core/ipv4/etharp.c **** /**
 235:lwIP/src/core/ipv4/etharp.c ****  * Search the ARP table for a matching or new entry.
 236:lwIP/src/core/ipv4/etharp.c ****  *
 237:lwIP/src/core/ipv4/etharp.c ****  * If an IP address is given, return a pending or stable ARP entry that matches
 238:lwIP/src/core/ipv4/etharp.c ****  * the address. If no match is found, create a new entry with this address set,
 239:lwIP/src/core/ipv4/etharp.c ****  * but in state ETHARP_EMPTY. The caller must check and possibly change the
 240:lwIP/src/core/ipv4/etharp.c ****  * state of the returned entry.
 241:lwIP/src/core/ipv4/etharp.c ****  *
 242:lwIP/src/core/ipv4/etharp.c ****  * If ipaddr is NULL, return a initialized new entry in state ETHARP_EMPTY.
 243:lwIP/src/core/ipv4/etharp.c ****  *
 244:lwIP/src/core/ipv4/etharp.c ****  * In all cases, attempt to create new entries from an empty entry. If no
 245:lwIP/src/core/ipv4/etharp.c ****  * empty entries are available and ETHARP_FLAG_TRY_HARD flag is set, recycle
 246:lwIP/src/core/ipv4/etharp.c ****  * old entries. Heuristic choose the least important entry for recycling.
 247:lwIP/src/core/ipv4/etharp.c ****  *
 248:lwIP/src/core/ipv4/etharp.c ****  * @param ipaddr IP address to find in ARP cache, or to add if not found.
 249:lwIP/src/core/ipv4/etharp.c ****  * @param flags See @ref etharp_state
 250:lwIP/src/core/ipv4/etharp.c ****  * @param netif netif related to this address (used for NETIF_HWADDRHINT)
 251:lwIP/src/core/ipv4/etharp.c ****  *
 252:lwIP/src/core/ipv4/etharp.c ****  * @return The ARP entry index that matched or is created, ERR_MEM if no
 253:lwIP/src/core/ipv4/etharp.c ****  * entry is found or could be recycled.
 254:lwIP/src/core/ipv4/etharp.c ****  */
 255:lwIP/src/core/ipv4/etharp.c **** static s16_t
 256:lwIP/src/core/ipv4/etharp.c **** etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif *netif)
 257:lwIP/src/core/ipv4/etharp.c **** {
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 259:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 260:lwIP/src/core/ipv4/etharp.c ****   s16_t i = 0;
 261:lwIP/src/core/ipv4/etharp.c ****   /* oldest entry with packets on queue */
 262:lwIP/src/core/ipv4/etharp.c ****   s16_t old_queue = ARP_TABLE_SIZE;
 263:lwIP/src/core/ipv4/etharp.c ****   /* its age */
 264:lwIP/src/core/ipv4/etharp.c ****   u16_t age_queue = 0, age_pending = 0, age_stable = 0;
 265:lwIP/src/core/ipv4/etharp.c **** 
 266:lwIP/src/core/ipv4/etharp.c ****   LWIP_UNUSED_ARG(netif);
 267:lwIP/src/core/ipv4/etharp.c **** 
 268:lwIP/src/core/ipv4/etharp.c ****   /**
 269:lwIP/src/core/ipv4/etharp.c ****    * a) do a search through the cache, remember candidates
 270:lwIP/src/core/ipv4/etharp.c ****    * b) select candidate entry
 271:lwIP/src/core/ipv4/etharp.c ****    * c) create new entry
 272:lwIP/src/core/ipv4/etharp.c ****    */
 273:lwIP/src/core/ipv4/etharp.c **** 
 274:lwIP/src/core/ipv4/etharp.c ****   /* a) in a single search sweep, do all of this
 275:lwIP/src/core/ipv4/etharp.c ****    * 1) remember the first empty entry (if any)
 276:lwIP/src/core/ipv4/etharp.c ****    * 2) remember the oldest stable entry (if any)
 277:lwIP/src/core/ipv4/etharp.c ****    * 3) remember the oldest pending entry without queued packets (if any)
 278:lwIP/src/core/ipv4/etharp.c ****    * 4) remember the oldest pending entry with queued packets (if any)
 279:lwIP/src/core/ipv4/etharp.c ****    * 5) search for a matching IP entry, either pending or stable
 280:lwIP/src/core/ipv4/etharp.c ****    *    until 5 matches, or all entries are searched for.
 281:lwIP/src/core/ipv4/etharp.c ****    */
 282:lwIP/src/core/ipv4/etharp.c **** 
 283:lwIP/src/core/ipv4/etharp.c ****   for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 284:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 285:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 286:lwIP/src/core/ipv4/etharp.c ****     if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 287:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 288:lwIP/src/core/ipv4/etharp.c ****       /* remember first empty entry */
 289:lwIP/src/core/ipv4/etharp.c ****       empty = i;
ARM GAS  /tmp/cctR0i1S.s 			page 7


 290:lwIP/src/core/ipv4/etharp.c ****     } else if (state != ETHARP_STATE_EMPTY) {
 291:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 292:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 293:lwIP/src/core/ipv4/etharp.c ****       /* if given, does IP address match IP address in ARP entry? */
 294:lwIP/src/core/ipv4/etharp.c ****       if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
 295:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 296:lwIP/src/core/ipv4/etharp.c ****           && ((netif == NULL) || (netif == arp_table[i].netif))
 297:lwIP/src/core/ipv4/etharp.c **** #endif /* ETHARP_TABLE_MATCH_NETIF */
 298:lwIP/src/core/ipv4/etharp.c ****          ) {
 299:lwIP/src/core/ipv4/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %d\n",
 300:lwIP/src/core/ipv4/etharp.c ****         /* found exact IP address match, simply bail out */
 301:lwIP/src/core/ipv4/etharp.c ****         return i;
 302:lwIP/src/core/ipv4/etharp.c ****       }
 303:lwIP/src/core/ipv4/etharp.c ****       /* pending entry? */
 304:lwIP/src/core/ipv4/etharp.c ****       if (state == ETHARP_STATE_PENDING) {
 305:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 306:lwIP/src/core/ipv4/etharp.c ****         if (arp_table[i].q != NULL) {
 307:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 308:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 309:lwIP/src/core/ipv4/etharp.c ****             age_queue = arp_table[i].ctime;
 310:lwIP/src/core/ipv4/etharp.c ****           }
 311:lwIP/src/core/ipv4/etharp.c ****         } else
 312:lwIP/src/core/ipv4/etharp.c ****           /* pending without queued packets? */
 313:lwIP/src/core/ipv4/etharp.c ****         {
 314:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_pending) {
 315:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 316:lwIP/src/core/ipv4/etharp.c ****             age_pending = arp_table[i].ctime;
 317:lwIP/src/core/ipv4/etharp.c ****           }
 318:lwIP/src/core/ipv4/etharp.c ****         }
 319:lwIP/src/core/ipv4/etharp.c ****         /* stable entry? */
 320:lwIP/src/core/ipv4/etharp.c ****       } else if (state >= ETHARP_STATE_STABLE) {
 321:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 322:lwIP/src/core/ipv4/etharp.c ****         /* don't record old_stable for static entries since they never expire */
 323:lwIP/src/core/ipv4/etharp.c ****         if (state < ETHARP_STATE_STATIC)
 324:lwIP/src/core/ipv4/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 325:lwIP/src/core/ipv4/etharp.c ****         {
 326:lwIP/src/core/ipv4/etharp.c ****           /* remember entry with oldest stable entry in oldest, its age in maxtime */
 327:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_stable) {
 328:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 329:lwIP/src/core/ipv4/etharp.c ****             age_stable = arp_table[i].ctime;
 330:lwIP/src/core/ipv4/etharp.c ****           }
 331:lwIP/src/core/ipv4/etharp.c ****         }
 332:lwIP/src/core/ipv4/etharp.c ****       }
 333:lwIP/src/core/ipv4/etharp.c ****     }
 334:lwIP/src/core/ipv4/etharp.c ****   }
 335:lwIP/src/core/ipv4/etharp.c ****   /* { we have no match } => try to create a new entry */
 336:lwIP/src/core/ipv4/etharp.c **** 
 337:lwIP/src/core/ipv4/etharp.c ****   /* don't create new entry, only search? */
 338:lwIP/src/core/ipv4/etharp.c ****   if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 339:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 340:lwIP/src/core/ipv4/etharp.c ****       ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 341:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not al
 342:lwIP/src/core/ipv4/etharp.c ****     return (s16_t)ERR_MEM;
 343:lwIP/src/core/ipv4/etharp.c ****   }
 344:lwIP/src/core/ipv4/etharp.c **** 
 345:lwIP/src/core/ipv4/etharp.c ****   /* b) choose the least destructive entry to recycle:
 346:lwIP/src/core/ipv4/etharp.c ****    * 1) empty entry
ARM GAS  /tmp/cctR0i1S.s 			page 8


 347:lwIP/src/core/ipv4/etharp.c ****    * 2) oldest stable entry
 348:lwIP/src/core/ipv4/etharp.c ****    * 3) oldest pending entry without queued packets
 349:lwIP/src/core/ipv4/etharp.c ****    * 4) oldest pending entry with queued packets
 350:lwIP/src/core/ipv4/etharp.c ****    *
 351:lwIP/src/core/ipv4/etharp.c ****    * { ETHARP_FLAG_TRY_HARD is set at this point }
 352:lwIP/src/core/ipv4/etharp.c ****    */
 353:lwIP/src/core/ipv4/etharp.c **** 
 354:lwIP/src/core/ipv4/etharp.c ****   /* 1) empty entry available? */
 355:lwIP/src/core/ipv4/etharp.c ****   if (empty < ARP_TABLE_SIZE) {
 356:lwIP/src/core/ipv4/etharp.c ****     i = empty;
 357:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %d\n", (i
 358:lwIP/src/core/ipv4/etharp.c ****   } else {
 359:lwIP/src/core/ipv4/etharp.c ****     /* 2) found recyclable stable entry? */
 360:lwIP/src/core/ipv4/etharp.c ****     if (old_stable < ARP_TABLE_SIZE) {
 361:lwIP/src/core/ipv4/etharp.c ****       /* recycle oldest stable*/
 362:lwIP/src/core/ipv4/etharp.c ****       i = old_stable;
 363:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry
 364:lwIP/src/core/ipv4/etharp.c ****       /* no queued packets should exist on stable entries */
 365:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 366:lwIP/src/core/ipv4/etharp.c ****       /* 3) found recyclable pending entry without queued packets? */
 367:lwIP/src/core/ipv4/etharp.c ****     } else if (old_pending < ARP_TABLE_SIZE) {
 368:lwIP/src/core/ipv4/etharp.c ****       /* recycle oldest pending */
 369:lwIP/src/core/ipv4/etharp.c ****       i = old_pending;
 370:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entr
 371:lwIP/src/core/ipv4/etharp.c ****       /* 4) found recyclable pending entry with queued packets? */
 372:lwIP/src/core/ipv4/etharp.c ****     } else if (old_queue < ARP_TABLE_SIZE) {
 373:lwIP/src/core/ipv4/etharp.c ****       /* recycle oldest pending (queued packets are free in etharp_free_entry) */
 374:lwIP/src/core/ipv4/etharp.c ****       i = old_queue;
 375:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entr
 376:lwIP/src/core/ipv4/etharp.c ****       /* no empty or recyclable entries found */
 377:lwIP/src/core/ipv4/etharp.c ****     } else {
 378:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entrie
 379:lwIP/src/core/ipv4/etharp.c ****       return (s16_t)ERR_MEM;
 380:lwIP/src/core/ipv4/etharp.c ****     }
 381:lwIP/src/core/ipv4/etharp.c **** 
 382:lwIP/src/core/ipv4/etharp.c ****     /* { empty or recyclable entry found } */
 383:lwIP/src/core/ipv4/etharp.c ****     LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 384:lwIP/src/core/ipv4/etharp.c ****     etharp_free_entry(i);
 385:lwIP/src/core/ipv4/etharp.c ****   }
 386:lwIP/src/core/ipv4/etharp.c **** 
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 388:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 389:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 390:lwIP/src/core/ipv4/etharp.c **** 
 391:lwIP/src/core/ipv4/etharp.c ****   /* IP address given? */
 392:lwIP/src/core/ipv4/etharp.c ****   if (ipaddr != NULL) {
 393:lwIP/src/core/ipv4/etharp.c ****     /* set IP address */
 394:lwIP/src/core/ipv4/etharp.c ****     ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
 395:lwIP/src/core/ipv4/etharp.c ****   }
 396:lwIP/src/core/ipv4/etharp.c ****   arp_table[i].ctime = 0;
 397:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 398:lwIP/src/core/ipv4/etharp.c ****   arp_table[i].netif = netif;
 399:lwIP/src/core/ipv4/etharp.c **** #endif /* ETHARP_TABLE_MATCH_NETIF */
 400:lwIP/src/core/ipv4/etharp.c ****   return (s16_t)i;
 401:lwIP/src/core/ipv4/etharp.c **** }
 402:lwIP/src/core/ipv4/etharp.c **** 
 403:lwIP/src/core/ipv4/etharp.c **** /**
ARM GAS  /tmp/cctR0i1S.s 			page 9


 404:lwIP/src/core/ipv4/etharp.c ****  * Update (or insert) a IP/MAC address pair in the ARP cache.
 405:lwIP/src/core/ipv4/etharp.c ****  *
 406:lwIP/src/core/ipv4/etharp.c ****  * If a pending entry is resolved, any queued packets will be sent
 407:lwIP/src/core/ipv4/etharp.c ****  * at this point.
 408:lwIP/src/core/ipv4/etharp.c ****  *
 409:lwIP/src/core/ipv4/etharp.c ****  * @param netif netif related to this entry (used for NETIF_ADDRHINT)
 410:lwIP/src/core/ipv4/etharp.c ****  * @param ipaddr IP address of the inserted ARP entry.
 411:lwIP/src/core/ipv4/etharp.c ****  * @param ethaddr Ethernet address of the inserted ARP entry.
 412:lwIP/src/core/ipv4/etharp.c ****  * @param flags See @ref etharp_state
 413:lwIP/src/core/ipv4/etharp.c ****  *
 414:lwIP/src/core/ipv4/etharp.c ****  * @return
 415:lwIP/src/core/ipv4/etharp.c ****  * - ERR_OK Successfully updated ARP cache.
 416:lwIP/src/core/ipv4/etharp.c ****  * - ERR_MEM If we could not add a new ARP entry when ETHARP_FLAG_TRY_HARD was set.
 417:lwIP/src/core/ipv4/etharp.c ****  * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 418:lwIP/src/core/ipv4/etharp.c ****  *
 419:lwIP/src/core/ipv4/etharp.c ****  * @see pbuf_free()
 420:lwIP/src/core/ipv4/etharp.c ****  */
 421:lwIP/src/core/ipv4/etharp.c **** static err_t
 422:lwIP/src/core/ipv4/etharp.c **** etharp_update_arp_entry(struct netif *netif, const ip4_addr_t *ipaddr, struct eth_addr *ethaddr, u8
 423:lwIP/src/core/ipv4/etharp.c **** {
 424:lwIP/src/core/ipv4/etharp.c ****   s16_t i;
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 426:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 427:lwIP/src/core/ipv4/etharp.c ****               ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr
 428:lwIP/src/core/ipv4/etharp.c ****               ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
 429:lwIP/src/core/ipv4/etharp.c ****               ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
 430:lwIP/src/core/ipv4/etharp.c ****   /* non-unicast address? */
 431:lwIP/src/core/ipv4/etharp.c ****   if (ip4_addr_isany(ipaddr) ||
 432:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_isbroadcast(ipaddr, netif) ||
 433:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_ismulticast(ipaddr)) {
 434:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast 
 435:lwIP/src/core/ipv4/etharp.c ****     return ERR_ARG;
 436:lwIP/src/core/ipv4/etharp.c ****   }
 437:lwIP/src/core/ipv4/etharp.c ****   /* find or create ARP entry */
 438:lwIP/src/core/ipv4/etharp.c ****   i = etharp_find_entry(ipaddr, flags, netif);
 439:lwIP/src/core/ipv4/etharp.c ****   /* bail out if no entry could be found */
 440:lwIP/src/core/ipv4/etharp.c ****   if (i < 0) {
 441:lwIP/src/core/ipv4/etharp.c ****     return (err_t)i;
 442:lwIP/src/core/ipv4/etharp.c ****   }
 443:lwIP/src/core/ipv4/etharp.c **** 
 444:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 445:lwIP/src/core/ipv4/etharp.c ****   if (flags & ETHARP_FLAG_STATIC_ENTRY) {
 446:lwIP/src/core/ipv4/etharp.c ****     /* record static type */
 447:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].state = ETHARP_STATE_STATIC;
 448:lwIP/src/core/ipv4/etharp.c ****   } else if (arp_table[i].state == ETHARP_STATE_STATIC) {
 449:lwIP/src/core/ipv4/etharp.c ****     /* found entry is a static type, don't overwrite it */
 450:lwIP/src/core/ipv4/etharp.c ****     return ERR_VAL;
 451:lwIP/src/core/ipv4/etharp.c ****   } else
 452:lwIP/src/core/ipv4/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 453:lwIP/src/core/ipv4/etharp.c ****   {
 454:lwIP/src/core/ipv4/etharp.c ****     /* mark it stable */
 455:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].state = ETHARP_STATE_STABLE;
 456:lwIP/src/core/ipv4/etharp.c ****   }
 457:lwIP/src/core/ipv4/etharp.c **** 
 458:lwIP/src/core/ipv4/etharp.c ****   /* record network interface */
 459:lwIP/src/core/ipv4/etharp.c ****   arp_table[i].netif = netif;
 460:lwIP/src/core/ipv4/etharp.c ****   /* insert in SNMP ARP index tree */
ARM GAS  /tmp/cctR0i1S.s 			page 10


 461:lwIP/src/core/ipv4/etharp.c ****   mib2_add_arp_entry(netif, &arp_table[i].ipaddr);
 462:lwIP/src/core/ipv4/etharp.c **** 
 463:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16
 464:lwIP/src/core/ipv4/etharp.c ****   /* update address */
 465:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&arp_table[i].ethaddr, ethaddr, ETH_HWADDR_LEN);
 466:lwIP/src/core/ipv4/etharp.c ****   /* reset time stamp */
 467:lwIP/src/core/ipv4/etharp.c ****   arp_table[i].ctime = 0;
 468:lwIP/src/core/ipv4/etharp.c ****   /* this is where we will send out queued packets! */
 469:lwIP/src/core/ipv4/etharp.c **** #if ARP_QUEUEING
 470:lwIP/src/core/ipv4/etharp.c ****   while (arp_table[i].q != NULL) {
 471:lwIP/src/core/ipv4/etharp.c ****     struct pbuf *p;
 472:lwIP/src/core/ipv4/etharp.c ****     /* remember remainder of queue */
 473:lwIP/src/core/ipv4/etharp.c ****     struct etharp_q_entry *q = arp_table[i].q;
 474:lwIP/src/core/ipv4/etharp.c ****     /* pop first item off the queue */
 475:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = q->next;
 476:lwIP/src/core/ipv4/etharp.c ****     /* get the packet pointer */
 477:lwIP/src/core/ipv4/etharp.c ****     p = q->p;
 478:lwIP/src/core/ipv4/etharp.c ****     /* now queue entry can be freed */
 479:lwIP/src/core/ipv4/etharp.c ****     memp_free(MEMP_ARP_QUEUE, q);
 480:lwIP/src/core/ipv4/etharp.c **** #else /* ARP_QUEUEING */
 481:lwIP/src/core/ipv4/etharp.c ****   if (arp_table[i].q != NULL) {
 482:lwIP/src/core/ipv4/etharp.c ****     struct pbuf *p = arp_table[i].q;
 483:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 484:lwIP/src/core/ipv4/etharp.c **** #endif /* ARP_QUEUEING */
 485:lwIP/src/core/ipv4/etharp.c ****     /* send the queued IP packet */
 486:lwIP/src/core/ipv4/etharp.c ****     ethernet_output(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr, ETHTYPE_IP);
 487:lwIP/src/core/ipv4/etharp.c ****     /* free the queued IP packet */
 488:lwIP/src/core/ipv4/etharp.c ****     pbuf_free(p);
 489:lwIP/src/core/ipv4/etharp.c ****   }
 490:lwIP/src/core/ipv4/etharp.c ****   return ERR_OK;
 491:lwIP/src/core/ipv4/etharp.c **** }
 492:lwIP/src/core/ipv4/etharp.c **** 
 493:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 494:lwIP/src/core/ipv4/etharp.c **** /** Add a new static entry to the ARP table. If an entry exists for the
 495:lwIP/src/core/ipv4/etharp.c ****  * specified IP address, this entry is overwritten.
 496:lwIP/src/core/ipv4/etharp.c ****  * If packets are queued for the specified IP address, they are sent out.
 497:lwIP/src/core/ipv4/etharp.c ****  *
 498:lwIP/src/core/ipv4/etharp.c ****  * @param ipaddr IP address for the new static entry
 499:lwIP/src/core/ipv4/etharp.c ****  * @param ethaddr ethernet address for the new static entry
 500:lwIP/src/core/ipv4/etharp.c ****  * @return See return values of etharp_add_static_entry
 501:lwIP/src/core/ipv4/etharp.c ****  */
 502:lwIP/src/core/ipv4/etharp.c **** err_t
 503:lwIP/src/core/ipv4/etharp.c **** etharp_add_static_entry(const ip4_addr_t *ipaddr, struct eth_addr *ethaddr)
 504:lwIP/src/core/ipv4/etharp.c **** {
 505:lwIP/src/core/ipv4/etharp.c ****   struct netif *netif;
 506:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT_CORE_LOCKED();
 507:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_add_static_entry: %"U16_F".%"U16_F".%"U16_F".
 508:lwIP/src/core/ipv4/etharp.c ****               ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr
 509:lwIP/src/core/ipv4/etharp.c ****               ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
 510:lwIP/src/core/ipv4/etharp.c ****               ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
 511:lwIP/src/core/ipv4/etharp.c **** 
 512:lwIP/src/core/ipv4/etharp.c ****   netif = ip4_route(ipaddr);
 513:lwIP/src/core/ipv4/etharp.c ****   if (netif == NULL) {
 514:lwIP/src/core/ipv4/etharp.c ****     return ERR_RTE;
 515:lwIP/src/core/ipv4/etharp.c ****   }
 516:lwIP/src/core/ipv4/etharp.c **** 
 517:lwIP/src/core/ipv4/etharp.c ****   return etharp_update_arp_entry(netif, ipaddr, ethaddr, ETHARP_FLAG_TRY_HARD | ETHARP_FLAG_STATIC_
ARM GAS  /tmp/cctR0i1S.s 			page 11


 518:lwIP/src/core/ipv4/etharp.c **** }
 519:lwIP/src/core/ipv4/etharp.c **** 
 520:lwIP/src/core/ipv4/etharp.c **** /** Remove a static entry from the ARP table previously added with a call to
 521:lwIP/src/core/ipv4/etharp.c ****  * etharp_add_static_entry.
 522:lwIP/src/core/ipv4/etharp.c ****  *
 523:lwIP/src/core/ipv4/etharp.c ****  * @param ipaddr IP address of the static entry to remove
 524:lwIP/src/core/ipv4/etharp.c ****  * @return ERR_OK: entry removed
 525:lwIP/src/core/ipv4/etharp.c ****  *         ERR_MEM: entry wasn't found
 526:lwIP/src/core/ipv4/etharp.c ****  *         ERR_ARG: entry wasn't a static entry but a dynamic one
 527:lwIP/src/core/ipv4/etharp.c ****  */
 528:lwIP/src/core/ipv4/etharp.c **** err_t
 529:lwIP/src/core/ipv4/etharp.c **** etharp_remove_static_entry(const ip4_addr_t *ipaddr)
 530:lwIP/src/core/ipv4/etharp.c **** {
 531:lwIP/src/core/ipv4/etharp.c ****   s16_t i;
 532:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT_CORE_LOCKED();
 533:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_remove_static_entry: %"U16_F".%"U16_F".%"U16_
 534:lwIP/src/core/ipv4/etharp.c ****               ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr
 535:lwIP/src/core/ipv4/etharp.c **** 
 536:lwIP/src/core/ipv4/etharp.c ****   /* find or create ARP entry */
 537:lwIP/src/core/ipv4/etharp.c ****   i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY, NULL);
 538:lwIP/src/core/ipv4/etharp.c ****   /* bail out if no entry could be found */
 539:lwIP/src/core/ipv4/etharp.c ****   if (i < 0) {
 540:lwIP/src/core/ipv4/etharp.c ****     return (err_t)i;
 541:lwIP/src/core/ipv4/etharp.c ****   }
 542:lwIP/src/core/ipv4/etharp.c **** 
 543:lwIP/src/core/ipv4/etharp.c ****   if (arp_table[i].state != ETHARP_STATE_STATIC) {
 544:lwIP/src/core/ipv4/etharp.c ****     /* entry wasn't a static entry, cannot remove it */
 545:lwIP/src/core/ipv4/etharp.c ****     return ERR_ARG;
 546:lwIP/src/core/ipv4/etharp.c ****   }
 547:lwIP/src/core/ipv4/etharp.c ****   /* entry found, free it */
 548:lwIP/src/core/ipv4/etharp.c ****   etharp_free_entry(i);
 549:lwIP/src/core/ipv4/etharp.c ****   return ERR_OK;
 550:lwIP/src/core/ipv4/etharp.c **** }
 551:lwIP/src/core/ipv4/etharp.c **** #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
 552:lwIP/src/core/ipv4/etharp.c **** 
 553:lwIP/src/core/ipv4/etharp.c **** /**
 554:lwIP/src/core/ipv4/etharp.c ****  * Remove all ARP table entries of the specified netif.
 555:lwIP/src/core/ipv4/etharp.c ****  *
 556:lwIP/src/core/ipv4/etharp.c ****  * @param netif points to a network interface
 557:lwIP/src/core/ipv4/etharp.c ****  */
 558:lwIP/src/core/ipv4/etharp.c **** void
 559:lwIP/src/core/ipv4/etharp.c **** etharp_cleanup_netif(struct netif *netif)
 560:lwIP/src/core/ipv4/etharp.c **** {
 561:lwIP/src/core/ipv4/etharp.c ****   int i;
 562:lwIP/src/core/ipv4/etharp.c **** 
 563:lwIP/src/core/ipv4/etharp.c ****   for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 564:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 565:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 566:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 567:lwIP/src/core/ipv4/etharp.c ****     }
 568:lwIP/src/core/ipv4/etharp.c ****   }
 569:lwIP/src/core/ipv4/etharp.c **** }
 570:lwIP/src/core/ipv4/etharp.c **** 
 571:lwIP/src/core/ipv4/etharp.c **** /**
 572:lwIP/src/core/ipv4/etharp.c ****  * Finds (stable) ethernet/IP address pair from ARP table
 573:lwIP/src/core/ipv4/etharp.c ****  * using interface and IP address index.
 574:lwIP/src/core/ipv4/etharp.c ****  * @note the addresses in the ARP table are in network order!
ARM GAS  /tmp/cctR0i1S.s 			page 12


 575:lwIP/src/core/ipv4/etharp.c ****  *
 576:lwIP/src/core/ipv4/etharp.c ****  * @param netif points to interface index
 577:lwIP/src/core/ipv4/etharp.c ****  * @param ipaddr points to the (network order) IP address index
 578:lwIP/src/core/ipv4/etharp.c ****  * @param eth_ret points to return pointer
 579:lwIP/src/core/ipv4/etharp.c ****  * @param ip_ret points to return pointer
 580:lwIP/src/core/ipv4/etharp.c ****  * @return table index if found, -1 otherwise
 581:lwIP/src/core/ipv4/etharp.c ****  */
 582:lwIP/src/core/ipv4/etharp.c **** ssize_t
 583:lwIP/src/core/ipv4/etharp.c **** etharp_find_addr(struct netif *netif, const ip4_addr_t *ipaddr,
 584:lwIP/src/core/ipv4/etharp.c ****                  struct eth_addr **eth_ret, const ip4_addr_t **ip_ret)
 585:lwIP/src/core/ipv4/etharp.c **** {
 586:lwIP/src/core/ipv4/etharp.c ****   s16_t i;
 587:lwIP/src/core/ipv4/etharp.c **** 
 588:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
 589:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 590:lwIP/src/core/ipv4/etharp.c **** 
 591:lwIP/src/core/ipv4/etharp.c ****   LWIP_UNUSED_ARG(netif);
 592:lwIP/src/core/ipv4/etharp.c **** 
 593:lwIP/src/core/ipv4/etharp.c ****   i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY, netif);
 594:lwIP/src/core/ipv4/etharp.c ****   if ((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 595:lwIP/src/core/ipv4/etharp.c ****     *eth_ret = &arp_table[i].ethaddr;
 596:lwIP/src/core/ipv4/etharp.c ****     *ip_ret = &arp_table[i].ipaddr;
 597:lwIP/src/core/ipv4/etharp.c ****     return i;
 598:lwIP/src/core/ipv4/etharp.c ****   }
 599:lwIP/src/core/ipv4/etharp.c ****   return -1;
 600:lwIP/src/core/ipv4/etharp.c **** }
 601:lwIP/src/core/ipv4/etharp.c **** 
 602:lwIP/src/core/ipv4/etharp.c **** /**
 603:lwIP/src/core/ipv4/etharp.c ****  * Possibility to iterate over stable ARP table entries
 604:lwIP/src/core/ipv4/etharp.c ****  *
 605:lwIP/src/core/ipv4/etharp.c ****  * @param i entry number, 0 to ARP_TABLE_SIZE
 606:lwIP/src/core/ipv4/etharp.c ****  * @param ipaddr return value: IP address
 607:lwIP/src/core/ipv4/etharp.c ****  * @param netif return value: points to interface
 608:lwIP/src/core/ipv4/etharp.c ****  * @param eth_ret return value: ETH address
 609:lwIP/src/core/ipv4/etharp.c ****  * @return 1 on valid index, 0 otherwise
 610:lwIP/src/core/ipv4/etharp.c ****  */
 611:lwIP/src/core/ipv4/etharp.c **** int
 612:lwIP/src/core/ipv4/etharp.c **** etharp_get_entry(size_t i, ip4_addr_t **ipaddr, struct netif **netif, struct eth_addr **eth_ret)
 613:lwIP/src/core/ipv4/etharp.c **** {
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 616:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 617:lwIP/src/core/ipv4/etharp.c **** 
 618:lwIP/src/core/ipv4/etharp.c ****   if ((i < ARP_TABLE_SIZE) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 619:lwIP/src/core/ipv4/etharp.c ****     *ipaddr  = &arp_table[i].ipaddr;
 620:lwIP/src/core/ipv4/etharp.c ****     *netif   = arp_table[i].netif;
 621:lwIP/src/core/ipv4/etharp.c ****     *eth_ret = &arp_table[i].ethaddr;
 622:lwIP/src/core/ipv4/etharp.c ****     return 1;
 623:lwIP/src/core/ipv4/etharp.c ****   } else {
 624:lwIP/src/core/ipv4/etharp.c ****     return 0;
 625:lwIP/src/core/ipv4/etharp.c ****   }
 626:lwIP/src/core/ipv4/etharp.c **** }
 627:lwIP/src/core/ipv4/etharp.c **** 
 628:lwIP/src/core/ipv4/etharp.c **** /**
 629:lwIP/src/core/ipv4/etharp.c ****  * Responds to ARP requests to us. Upon ARP replies to us, add entry to cache
 630:lwIP/src/core/ipv4/etharp.c ****  * send out queued IP packets. Updates cache with snooped address pairs.
 631:lwIP/src/core/ipv4/etharp.c ****  *
ARM GAS  /tmp/cctR0i1S.s 			page 13


 632:lwIP/src/core/ipv4/etharp.c ****  * Should be called for incoming ARP packets. The pbuf in the argument
 633:lwIP/src/core/ipv4/etharp.c ****  * is freed by this function.
 634:lwIP/src/core/ipv4/etharp.c ****  *
 635:lwIP/src/core/ipv4/etharp.c ****  * @param p The ARP packet that arrived on netif. Is freed by this function.
 636:lwIP/src/core/ipv4/etharp.c ****  * @param netif The lwIP network interface on which the ARP packet pbuf arrived.
 637:lwIP/src/core/ipv4/etharp.c ****  *
 638:lwIP/src/core/ipv4/etharp.c ****  * @see pbuf_free()
 639:lwIP/src/core/ipv4/etharp.c ****  */
 640:lwIP/src/core/ipv4/etharp.c **** void
 641:lwIP/src/core/ipv4/etharp.c **** etharp_input(struct pbuf *p, struct netif *netif)
 642:lwIP/src/core/ipv4/etharp.c **** {
 643:lwIP/src/core/ipv4/etharp.c ****   struct etharp_hdr *hdr;
 644:lwIP/src/core/ipv4/etharp.c ****   /* these are aligned properly, whereas the ARP header fields might not be */
 645:lwIP/src/core/ipv4/etharp.c ****   ip4_addr_t sipaddr, dipaddr;
 646:lwIP/src/core/ipv4/etharp.c ****   u8_t for_us;
 647:lwIP/src/core/ipv4/etharp.c **** 
 648:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT_CORE_LOCKED();
 649:lwIP/src/core/ipv4/etharp.c **** 
 650:lwIP/src/core/ipv4/etharp.c ****   LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 651:lwIP/src/core/ipv4/etharp.c **** 
 652:lwIP/src/core/ipv4/etharp.c ****   hdr = (struct etharp_hdr *)p->payload;
 653:lwIP/src/core/ipv4/etharp.c **** 
 654:lwIP/src/core/ipv4/etharp.c ****   /* RFC 826 "Packet Reception": */
 655:lwIP/src/core/ipv4/etharp.c ****   if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
 656:lwIP/src/core/ipv4/etharp.c ****       (hdr->hwlen != ETH_HWADDR_LEN) ||
 657:lwIP/src/core/ipv4/etharp.c ****       (hdr->protolen != sizeof(ip4_addr_t)) ||
 658:lwIP/src/core/ipv4/etharp.c ****       (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 659:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
 660:lwIP/src/core/ipv4/etharp.c ****                 ("etharp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet t
 661:lwIP/src/core/ipv4/etharp.c ****                  hdr->hwtype, (u16_t)hdr->hwlen, hdr->proto, (u16_t)hdr->protolen));
 662:lwIP/src/core/ipv4/etharp.c ****     ETHARP_STATS_INC(etharp.proterr);
 663:lwIP/src/core/ipv4/etharp.c ****     ETHARP_STATS_INC(etharp.drop);
 664:lwIP/src/core/ipv4/etharp.c ****     pbuf_free(p);
 665:lwIP/src/core/ipv4/etharp.c ****     return;
 666:lwIP/src/core/ipv4/etharp.c ****   }
 667:lwIP/src/core/ipv4/etharp.c ****   ETHARP_STATS_INC(etharp.recv);
 668:lwIP/src/core/ipv4/etharp.c **** 
 669:lwIP/src/core/ipv4/etharp.c **** #if LWIP_AUTOIP
 670:lwIP/src/core/ipv4/etharp.c ****   /* We have to check if a host already has configured our random
 671:lwIP/src/core/ipv4/etharp.c ****    * created link local address and continuously check if there is
 672:lwIP/src/core/ipv4/etharp.c ****    * a host with this IP-address so we can detect collisions */
 673:lwIP/src/core/ipv4/etharp.c ****   autoip_arp_reply(netif, hdr);
 674:lwIP/src/core/ipv4/etharp.c **** #endif /* LWIP_AUTOIP */
 675:lwIP/src/core/ipv4/etharp.c **** 
 676:lwIP/src/core/ipv4/etharp.c ****   /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
 677:lwIP/src/core/ipv4/etharp.c ****    * structure packing (not using structure copy which breaks strict-aliasing rules). */
 678:lwIP/src/core/ipv4/etharp.c ****   IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&sipaddr, &hdr->sipaddr);
 679:lwIP/src/core/ipv4/etharp.c ****   IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
 680:lwIP/src/core/ipv4/etharp.c **** 
 681:lwIP/src/core/ipv4/etharp.c ****   /* this interface is not configured? */
 682:lwIP/src/core/ipv4/etharp.c ****   if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 683:lwIP/src/core/ipv4/etharp.c ****     for_us = 0;
 684:lwIP/src/core/ipv4/etharp.c ****   } else {
 685:lwIP/src/core/ipv4/etharp.c ****     /* ARP packet directed to us? */
 686:lwIP/src/core/ipv4/etharp.c ****     for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
 687:lwIP/src/core/ipv4/etharp.c ****   }
 688:lwIP/src/core/ipv4/etharp.c **** 
ARM GAS  /tmp/cctR0i1S.s 			page 14


 689:lwIP/src/core/ipv4/etharp.c ****   /* ARP message directed to us?
 690:lwIP/src/core/ipv4/etharp.c ****       -> add IP address in ARP cache; assume requester wants to talk to us,
 691:lwIP/src/core/ipv4/etharp.c ****          can result in directly sending the queued packets for this host.
 692:lwIP/src/core/ipv4/etharp.c ****      ARP message not directed to us?
 693:lwIP/src/core/ipv4/etharp.c ****       ->  update the source IP address in the cache, if present */
 694:lwIP/src/core/ipv4/etharp.c ****   etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 695:lwIP/src/core/ipv4/etharp.c ****                           for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
 696:lwIP/src/core/ipv4/etharp.c **** 
 697:lwIP/src/core/ipv4/etharp.c ****   /* now act on the message itself */
 698:lwIP/src/core/ipv4/etharp.c ****   switch (hdr->opcode) {
 699:lwIP/src/core/ipv4/etharp.c ****     /* ARP request? */
 700:lwIP/src/core/ipv4/etharp.c ****     case PP_HTONS(ARP_REQUEST):
 701:lwIP/src/core/ipv4/etharp.c ****       /* ARP request. If it asked for our address, we send out a
 702:lwIP/src/core/ipv4/etharp.c ****        * reply. In any case, we time-stamp any existing ARP entry,
 703:lwIP/src/core/ipv4/etharp.c ****        * and possibly send out an IP packet that was queued on it. */
 704:lwIP/src/core/ipv4/etharp.c **** 
 705:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: incoming ARP request\n"));
 706:lwIP/src/core/ipv4/etharp.c ****       /* ARP request for our address? */
 707:lwIP/src/core/ipv4/etharp.c ****       if (for_us) {
 708:lwIP/src/core/ipv4/etharp.c ****         /* send ARP response */
 709:lwIP/src/core/ipv4/etharp.c ****         etharp_raw(netif,
 710:lwIP/src/core/ipv4/etharp.c ****                    (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
 711:lwIP/src/core/ipv4/etharp.c ****                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
 712:lwIP/src/core/ipv4/etharp.c ****                    &hdr->shwaddr, &sipaddr,
 713:lwIP/src/core/ipv4/etharp.c ****                    ARP_REPLY);
 714:lwIP/src/core/ipv4/etharp.c ****         /* we are not configured? */
 715:lwIP/src/core/ipv4/etharp.c ****       } else if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 716:lwIP/src/core/ipv4/etharp.c ****         /* { for_us == 0 and netif->ip_addr.addr == 0 } */
 717:lwIP/src/core/ipv4/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: we are unconfigured, ARP request
 718:lwIP/src/core/ipv4/etharp.c ****         /* request was not directed to us */
 719:lwIP/src/core/ipv4/etharp.c ****       } else {
 720:lwIP/src/core/ipv4/etharp.c ****         /* { for_us == 0 and netif->ip_addr.addr != 0 } */
 721:lwIP/src/core/ipv4/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP request was not for us.\n"))
 722:lwIP/src/core/ipv4/etharp.c ****       }
 723:lwIP/src/core/ipv4/etharp.c ****       break;
 724:lwIP/src/core/ipv4/etharp.c ****     case PP_HTONS(ARP_REPLY):
 725:lwIP/src/core/ipv4/etharp.c ****       /* ARP reply. We already updated the ARP cache earlier. */
 726:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: incoming ARP reply\n"));
 727:lwIP/src/core/ipv4/etharp.c **** #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
 728:lwIP/src/core/ipv4/etharp.c ****       /* DHCP wants to know about ARP replies from any host with an
 729:lwIP/src/core/ipv4/etharp.c ****        * IP address also offered to us by the DHCP server. We do not
 730:lwIP/src/core/ipv4/etharp.c ****        * want to take a duplicate IP address on a single network.
 731:lwIP/src/core/ipv4/etharp.c ****        * @todo How should we handle redundant (fail-over) interfaces? */
 732:lwIP/src/core/ipv4/etharp.c ****       dhcp_arp_reply(netif, &sipaddr);
 733:lwIP/src/core/ipv4/etharp.c **** #endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
 734:lwIP/src/core/ipv4/etharp.c ****       break;
 735:lwIP/src/core/ipv4/etharp.c ****     default:
 736:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP unknown opcode type %"S16_F"\n
 737:lwIP/src/core/ipv4/etharp.c ****       ETHARP_STATS_INC(etharp.err);
 738:lwIP/src/core/ipv4/etharp.c ****       break;
 739:lwIP/src/core/ipv4/etharp.c ****   }
 740:lwIP/src/core/ipv4/etharp.c ****   /* free ARP packet */
 741:lwIP/src/core/ipv4/etharp.c ****   pbuf_free(p);
 742:lwIP/src/core/ipv4/etharp.c **** }
 743:lwIP/src/core/ipv4/etharp.c **** 
 744:lwIP/src/core/ipv4/etharp.c **** /** Just a small helper function that sends a pbuf to an ethernet address
 745:lwIP/src/core/ipv4/etharp.c ****  * in the arp_table specified by the index 'arp_idx'.
ARM GAS  /tmp/cctR0i1S.s 			page 15


 746:lwIP/src/core/ipv4/etharp.c ****  */
 747:lwIP/src/core/ipv4/etharp.c **** static err_t
 748:lwIP/src/core/ipv4/etharp.c **** etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, netif_addr_idx_t arp_idx)
 749:lwIP/src/core/ipv4/etharp.c **** {
 750:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 751:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 752:lwIP/src/core/ipv4/etharp.c ****   /* if arp table entry is about to expire: re-request it,
 753:lwIP/src/core/ipv4/etharp.c ****      but only if its state is ETHARP_STATE_STABLE to prevent flooding the
 754:lwIP/src/core/ipv4/etharp.c ****      network with ARP requests if this address is used frequently. */
 755:lwIP/src/core/ipv4/etharp.c ****   if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
 756:lwIP/src/core/ipv4/etharp.c ****     if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
 757:lwIP/src/core/ipv4/etharp.c ****       /* issue a standard request using broadcast */
 758:lwIP/src/core/ipv4/etharp.c ****       if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 759:lwIP/src/core/ipv4/etharp.c ****         arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 760:lwIP/src/core/ipv4/etharp.c ****       }
 761:lwIP/src/core/ipv4/etharp.c ****     } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
 762:lwIP/src/core/ipv4/etharp.c ****       /* issue a unicast request (for 15 seconds) to prevent unnecessary broadcast */
 763:lwIP/src/core/ipv4/etharp.c ****       if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR
 764:lwIP/src/core/ipv4/etharp.c ****         arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 765:lwIP/src/core/ipv4/etharp.c ****       }
 766:lwIP/src/core/ipv4/etharp.c ****     }
 767:lwIP/src/core/ipv4/etharp.c ****   }
 768:lwIP/src/core/ipv4/etharp.c **** 
 769:lwIP/src/core/ipv4/etharp.c ****   return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr,
 770:lwIP/src/core/ipv4/etharp.c **** }
 771:lwIP/src/core/ipv4/etharp.c **** 
 772:lwIP/src/core/ipv4/etharp.c **** /**
 773:lwIP/src/core/ipv4/etharp.c ****  * Resolve and fill-in Ethernet address header for outgoing IP packet.
 774:lwIP/src/core/ipv4/etharp.c ****  *
 775:lwIP/src/core/ipv4/etharp.c ****  * For IP multicast and broadcast, corresponding Ethernet addresses
 776:lwIP/src/core/ipv4/etharp.c ****  * are selected and the packet is transmitted on the link.
 777:lwIP/src/core/ipv4/etharp.c ****  *
 778:lwIP/src/core/ipv4/etharp.c ****  * For unicast addresses, the packet is submitted to etharp_query(). In
 779:lwIP/src/core/ipv4/etharp.c ****  * case the IP address is outside the local network, the IP address of
 780:lwIP/src/core/ipv4/etharp.c ****  * the gateway is used.
 781:lwIP/src/core/ipv4/etharp.c ****  *
 782:lwIP/src/core/ipv4/etharp.c ****  * @param netif The lwIP network interface which the IP packet will be sent on.
 783:lwIP/src/core/ipv4/etharp.c ****  * @param q The pbuf(s) containing the IP packet to be sent.
 784:lwIP/src/core/ipv4/etharp.c ****  * @param ipaddr The IP address of the packet destination.
 785:lwIP/src/core/ipv4/etharp.c ****  *
 786:lwIP/src/core/ipv4/etharp.c ****  * @return
 787:lwIP/src/core/ipv4/etharp.c ****  * - ERR_RTE No route to destination (no gateway to external networks),
 788:lwIP/src/core/ipv4/etharp.c ****  * or the return type of either etharp_query() or ethernet_output().
 789:lwIP/src/core/ipv4/etharp.c ****  */
 790:lwIP/src/core/ipv4/etharp.c **** err_t
 791:lwIP/src/core/ipv4/etharp.c **** etharp_output(struct netif *netif, struct pbuf *q, const ip4_addr_t *ipaddr)
 792:lwIP/src/core/ipv4/etharp.c **** {
 793:lwIP/src/core/ipv4/etharp.c ****   const struct eth_addr *dest;
 794:lwIP/src/core/ipv4/etharp.c ****   struct eth_addr mcastaddr;
 795:lwIP/src/core/ipv4/etharp.c ****   const ip4_addr_t *dst_addr = ipaddr;
 796:lwIP/src/core/ipv4/etharp.c **** 
 797:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT_CORE_LOCKED();
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 800:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 801:lwIP/src/core/ipv4/etharp.c **** 
 802:lwIP/src/core/ipv4/etharp.c ****   /* Determine on destination hardware address. Broadcasts and multicasts
ARM GAS  /tmp/cctR0i1S.s 			page 16


 803:lwIP/src/core/ipv4/etharp.c ****    * are special, other IP addresses are looked up in the ARP table. */
 804:lwIP/src/core/ipv4/etharp.c **** 
 805:lwIP/src/core/ipv4/etharp.c ****   /* broadcast destination IP address? */
 806:lwIP/src/core/ipv4/etharp.c ****   if (ip4_addr_isbroadcast(ipaddr, netif)) {
 807:lwIP/src/core/ipv4/etharp.c ****     /* broadcast on Ethernet also */
 808:lwIP/src/core/ipv4/etharp.c ****     dest = (const struct eth_addr *)&ethbroadcast;
 809:lwIP/src/core/ipv4/etharp.c ****     /* multicast destination IP address? */
 810:lwIP/src/core/ipv4/etharp.c ****   } else if (ip4_addr_ismulticast(ipaddr)) {
 811:lwIP/src/core/ipv4/etharp.c ****     /* Hash IP multicast address to MAC address.*/
 812:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
 813:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
 814:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
 815:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 816:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[4] = ip4_addr3(ipaddr);
 817:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[5] = ip4_addr4(ipaddr);
 818:lwIP/src/core/ipv4/etharp.c ****     /* destination Ethernet address is multicast */
 819:lwIP/src/core/ipv4/etharp.c ****     dest = &mcastaddr;
 820:lwIP/src/core/ipv4/etharp.c ****     /* unicast destination IP address? */
 821:lwIP/src/core/ipv4/etharp.c ****   } else {
 822:lwIP/src/core/ipv4/etharp.c ****     netif_addr_idx_t i;
 823:lwIP/src/core/ipv4/etharp.c ****     /* outside local network? if so, this can neither be a global broadcast nor
 824:lwIP/src/core/ipv4/etharp.c ****        a subnet broadcast. */
 825:lwIP/src/core/ipv4/etharp.c ****     if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 826:lwIP/src/core/ipv4/etharp.c ****         !ip4_addr_islinklocal(ipaddr)) {
 827:lwIP/src/core/ipv4/etharp.c **** #if LWIP_AUTOIP
 828:lwIP/src/core/ipv4/etharp.c ****       struct ip_hdr *iphdr = LWIP_ALIGNMENT_CAST(struct ip_hdr *, q->payload);
 829:lwIP/src/core/ipv4/etharp.c ****       /* According to RFC 3297, chapter 2.6.2 (Forwarding Rules), a packet with
 830:lwIP/src/core/ipv4/etharp.c ****          a link-local source address must always be "directly to its destination
 831:lwIP/src/core/ipv4/etharp.c ****          on the same physical link. The host MUST NOT send the packet to any
 832:lwIP/src/core/ipv4/etharp.c ****          router for forwarding". */
 833:lwIP/src/core/ipv4/etharp.c ****       if (!ip4_addr_islinklocal(&iphdr->src))
 834:lwIP/src/core/ipv4/etharp.c **** #endif /* LWIP_AUTOIP */
 835:lwIP/src/core/ipv4/etharp.c ****       {
 836:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_HOOK_ETHARP_GET_GW
 837:lwIP/src/core/ipv4/etharp.c ****         /* For advanced routing, a single default gateway might not be enough, so get
 838:lwIP/src/core/ipv4/etharp.c ****            the IP address of the gateway to handle the current destination address. */
 839:lwIP/src/core/ipv4/etharp.c ****         dst_addr = LWIP_HOOK_ETHARP_GET_GW(netif, ipaddr);
 840:lwIP/src/core/ipv4/etharp.c ****         if (dst_addr == NULL)
 841:lwIP/src/core/ipv4/etharp.c **** #endif /* LWIP_HOOK_ETHARP_GET_GW */
 842:lwIP/src/core/ipv4/etharp.c ****         {
 843:lwIP/src/core/ipv4/etharp.c ****           /* interface has default gateway? */
 844:lwIP/src/core/ipv4/etharp.c ****           if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
 845:lwIP/src/core/ipv4/etharp.c ****             /* send to hardware address of default gateway IP address */
 846:lwIP/src/core/ipv4/etharp.c ****             dst_addr = netif_ip4_gw(netif);
 847:lwIP/src/core/ipv4/etharp.c ****             /* no default gateway available */
 848:lwIP/src/core/ipv4/etharp.c ****           } else {
 849:lwIP/src/core/ipv4/etharp.c ****             /* no route to destination error (default gateway missing) */
 850:lwIP/src/core/ipv4/etharp.c ****             return ERR_RTE;
 851:lwIP/src/core/ipv4/etharp.c ****           }
 852:lwIP/src/core/ipv4/etharp.c ****         }
 853:lwIP/src/core/ipv4/etharp.c ****       }
 854:lwIP/src/core/ipv4/etharp.c ****     }
 855:lwIP/src/core/ipv4/etharp.c **** #if LWIP_NETIF_HWADDRHINT
 856:lwIP/src/core/ipv4/etharp.c ****     if (netif->hints != NULL) {
 857:lwIP/src/core/ipv4/etharp.c ****       /* per-pcb cached entry was given */
 858:lwIP/src/core/ipv4/etharp.c ****       netif_addr_idx_t etharp_cached_entry = netif->hints->addr_hint;
 859:lwIP/src/core/ipv4/etharp.c ****       if (etharp_cached_entry < ARP_TABLE_SIZE) {
ARM GAS  /tmp/cctR0i1S.s 			page 17


 860:lwIP/src/core/ipv4/etharp.c **** #endif /* LWIP_NETIF_HWADDRHINT */
 861:lwIP/src/core/ipv4/etharp.c ****         if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 862:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 863:lwIP/src/core/ipv4/etharp.c ****             (arp_table[etharp_cached_entry].netif == netif) &&
 864:lwIP/src/core/ipv4/etharp.c **** #endif
 865:lwIP/src/core/ipv4/etharp.c ****             (ip4_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 866:lwIP/src/core/ipv4/etharp.c ****           /* the per-pcb-cached entry is stable and the right one! */
 867:lwIP/src/core/ipv4/etharp.c ****           ETHARP_STATS_INC(etharp.cachehit);
 868:lwIP/src/core/ipv4/etharp.c ****           return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 869:lwIP/src/core/ipv4/etharp.c ****         }
 870:lwIP/src/core/ipv4/etharp.c **** #if LWIP_NETIF_HWADDRHINT
 871:lwIP/src/core/ipv4/etharp.c ****       }
 872:lwIP/src/core/ipv4/etharp.c ****     }
 873:lwIP/src/core/ipv4/etharp.c **** #endif /* LWIP_NETIF_HWADDRHINT */
 874:lwIP/src/core/ipv4/etharp.c **** 
 875:lwIP/src/core/ipv4/etharp.c ****     /* find stable entry: do this here since this is a critical path for
 876:lwIP/src/core/ipv4/etharp.c ****        throughput and etharp_find_entry() is kind of slow */
 877:lwIP/src/core/ipv4/etharp.c ****     for (i = 0; i < ARP_TABLE_SIZE; i++) {
 878:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 879:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 880:lwIP/src/core/ipv4/etharp.c ****           (arp_table[i].netif == netif) &&
 881:lwIP/src/core/ipv4/etharp.c **** #endif
 882:lwIP/src/core/ipv4/etharp.c ****           (ip4_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
 883:lwIP/src/core/ipv4/etharp.c ****         /* found an existing, stable entry */
 884:lwIP/src/core/ipv4/etharp.c ****         ETHARP_SET_ADDRHINT(netif, i);
 885:lwIP/src/core/ipv4/etharp.c ****         return etharp_output_to_arp_index(netif, q, i);
 886:lwIP/src/core/ipv4/etharp.c ****       }
 887:lwIP/src/core/ipv4/etharp.c ****     }
 888:lwIP/src/core/ipv4/etharp.c ****     /* no stable entry found, use the (slower) query function:
 889:lwIP/src/core/ipv4/etharp.c ****        queue on destination Ethernet address belonging to ipaddr */
 890:lwIP/src/core/ipv4/etharp.c ****     return etharp_query(netif, dst_addr, q);
 891:lwIP/src/core/ipv4/etharp.c ****   }
 892:lwIP/src/core/ipv4/etharp.c **** 
 893:lwIP/src/core/ipv4/etharp.c ****   /* continuation for multicast/broadcast destinations */
 894:lwIP/src/core/ipv4/etharp.c ****   /* obtain source Ethernet address of the given interface */
 895:lwIP/src/core/ipv4/etharp.c ****   /* send packet directly on the link */
 896:lwIP/src/core/ipv4/etharp.c ****   return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), dest, ETHTYPE_IP);
 897:lwIP/src/core/ipv4/etharp.c **** }
 898:lwIP/src/core/ipv4/etharp.c **** 
 899:lwIP/src/core/ipv4/etharp.c **** /**
 900:lwIP/src/core/ipv4/etharp.c ****  * Send an ARP request for the given IP address and/or queue a packet.
 901:lwIP/src/core/ipv4/etharp.c ****  *
 902:lwIP/src/core/ipv4/etharp.c ****  * If the IP address was not yet in the cache, a pending ARP cache entry
 903:lwIP/src/core/ipv4/etharp.c ****  * is added and an ARP request is sent for the given address. The packet
 904:lwIP/src/core/ipv4/etharp.c ****  * is queued on this entry.
 905:lwIP/src/core/ipv4/etharp.c ****  *
 906:lwIP/src/core/ipv4/etharp.c ****  * If the IP address was already pending in the cache, a new ARP request
 907:lwIP/src/core/ipv4/etharp.c ****  * is sent for the given address. The packet is queued on this entry.
 908:lwIP/src/core/ipv4/etharp.c ****  *
 909:lwIP/src/core/ipv4/etharp.c ****  * If the IP address was already stable in the cache, and a packet is
 910:lwIP/src/core/ipv4/etharp.c ****  * given, it is directly sent and no ARP request is sent out.
 911:lwIP/src/core/ipv4/etharp.c ****  *
 912:lwIP/src/core/ipv4/etharp.c ****  * If the IP address was already stable in the cache, and no packet is
 913:lwIP/src/core/ipv4/etharp.c ****  * given, an ARP request is sent out.
 914:lwIP/src/core/ipv4/etharp.c ****  *
 915:lwIP/src/core/ipv4/etharp.c ****  * @param netif The lwIP network interface on which ipaddr
 916:lwIP/src/core/ipv4/etharp.c ****  * must be queried for.
ARM GAS  /tmp/cctR0i1S.s 			page 18


 917:lwIP/src/core/ipv4/etharp.c ****  * @param ipaddr The IP address to be resolved.
 918:lwIP/src/core/ipv4/etharp.c ****  * @param q If non-NULL, a pbuf that must be delivered to the IP address.
 919:lwIP/src/core/ipv4/etharp.c ****  * q is not freed by this function.
 920:lwIP/src/core/ipv4/etharp.c ****  *
 921:lwIP/src/core/ipv4/etharp.c ****  * @note q must only be ONE packet, not a packet queue!
 922:lwIP/src/core/ipv4/etharp.c ****  *
 923:lwIP/src/core/ipv4/etharp.c ****  * @return
 924:lwIP/src/core/ipv4/etharp.c ****  * - ERR_BUF Could not make room for Ethernet header.
 925:lwIP/src/core/ipv4/etharp.c ****  * - ERR_MEM Hardware address unknown, and no more ARP entries available
 926:lwIP/src/core/ipv4/etharp.c ****  *   to query for address or queue the packet.
 927:lwIP/src/core/ipv4/etharp.c ****  * - ERR_MEM Could not queue packet due to memory shortage.
 928:lwIP/src/core/ipv4/etharp.c ****  * - ERR_RTE No route to destination (no gateway to external networks).
 929:lwIP/src/core/ipv4/etharp.c ****  * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 930:lwIP/src/core/ipv4/etharp.c ****  *
 931:lwIP/src/core/ipv4/etharp.c ****  */
 932:lwIP/src/core/ipv4/etharp.c **** err_t
 933:lwIP/src/core/ipv4/etharp.c **** etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q)
 934:lwIP/src/core/ipv4/etharp.c **** {
 935:lwIP/src/core/ipv4/etharp.c ****   struct eth_addr *srcaddr = (struct eth_addr *)netif->hwaddr;
 936:lwIP/src/core/ipv4/etharp.c ****   err_t result = ERR_MEM;
 937:lwIP/src/core/ipv4/etharp.c ****   int is_new_entry = 0;
 938:lwIP/src/core/ipv4/etharp.c ****   s16_t i_err;
 939:lwIP/src/core/ipv4/etharp.c ****   netif_addr_idx_t i;
 940:lwIP/src/core/ipv4/etharp.c **** 
 941:lwIP/src/core/ipv4/etharp.c ****   /* non-unicast address? */
 942:lwIP/src/core/ipv4/etharp.c ****   if (ip4_addr_isbroadcast(ipaddr, netif) ||
 943:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_ismulticast(ipaddr) ||
 944:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_isany(ipaddr)) {
 945:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address 
 946:lwIP/src/core/ipv4/etharp.c ****     return ERR_ARG;
 947:lwIP/src/core/ipv4/etharp.c ****   }
 948:lwIP/src/core/ipv4/etharp.c **** 
 949:lwIP/src/core/ipv4/etharp.c ****   /* find entry in ARP cache, ask to create entry if queueing packet */
 950:lwIP/src/core/ipv4/etharp.c ****   i_err = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
 951:lwIP/src/core/ipv4/etharp.c **** 
 952:lwIP/src/core/ipv4/etharp.c ****   /* could not find or create entry? */
 953:lwIP/src/core/ipv4/etharp.c ****   if (i_err < 0) {
 954:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
 955:lwIP/src/core/ipv4/etharp.c ****     if (q) {
 956:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
 957:lwIP/src/core/ipv4/etharp.c ****       ETHARP_STATS_INC(etharp.memerr);
 958:lwIP/src/core/ipv4/etharp.c ****     }
 959:lwIP/src/core/ipv4/etharp.c ****     return (err_t)i_err;
 960:lwIP/src/core/ipv4/etharp.c ****   }
 961:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("type overflow", (size_t)i_err < NETIF_ADDR_IDX_MAX);
 962:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 963:lwIP/src/core/ipv4/etharp.c **** 
 964:lwIP/src/core/ipv4/etharp.c ****   /* mark a fresh entry as pending (we just sent a request) */
 965:lwIP/src/core/ipv4/etharp.c ****   if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 966:lwIP/src/core/ipv4/etharp.c ****     is_new_entry = 1;
 967:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].state = ETHARP_STATE_PENDING;
 968:lwIP/src/core/ipv4/etharp.c ****     /* record network interface for re-sending arp request in etharp_tmr */
 969:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].netif = netif;
 970:lwIP/src/core/ipv4/etharp.c ****   }
 971:lwIP/src/core/ipv4/etharp.c **** 
 972:lwIP/src/core/ipv4/etharp.c ****   /* { i is either a STABLE or (new or existing) PENDING entry } */
 973:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
ARM GAS  /tmp/cctR0i1S.s 			page 19


 974:lwIP/src/core/ipv4/etharp.c ****               ((arp_table[i].state == ETHARP_STATE_PENDING) ||
 975:lwIP/src/core/ipv4/etharp.c ****                (arp_table[i].state >= ETHARP_STATE_STABLE)));
 976:lwIP/src/core/ipv4/etharp.c **** 
 977:lwIP/src/core/ipv4/etharp.c ****   /* do we have a new entry? or an implicit query request? */
 978:lwIP/src/core/ipv4/etharp.c ****   if (is_new_entry || (q == NULL)) {
 979:lwIP/src/core/ipv4/etharp.c ****     /* try to resolve it; send out ARP request */
 980:lwIP/src/core/ipv4/etharp.c ****     result = etharp_request(netif, ipaddr);
 981:lwIP/src/core/ipv4/etharp.c ****     if (result != ERR_OK) {
 982:lwIP/src/core/ipv4/etharp.c ****       /* ARP request couldn't be sent */
 983:lwIP/src/core/ipv4/etharp.c ****       /* We don't re-send arp request in etharp_tmr, but we still queue packets,
 984:lwIP/src/core/ipv4/etharp.c ****          since this failure could be temporary, and the next packet calling
 985:lwIP/src/core/ipv4/etharp.c ****          etharp_query again could lead to sending the queued packets. */
 986:lwIP/src/core/ipv4/etharp.c ****     }
 987:lwIP/src/core/ipv4/etharp.c ****     if (q == NULL) {
 988:lwIP/src/core/ipv4/etharp.c ****       return result;
 989:lwIP/src/core/ipv4/etharp.c ****     }
 990:lwIP/src/core/ipv4/etharp.c ****   }
 991:lwIP/src/core/ipv4/etharp.c **** 
 992:lwIP/src/core/ipv4/etharp.c ****   /* packet given? */
 993:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 994:lwIP/src/core/ipv4/etharp.c ****   /* stable entry? */
 995:lwIP/src/core/ipv4/etharp.c ****   if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 996:lwIP/src/core/ipv4/etharp.c ****     /* we have a valid IP->Ethernet address mapping */
 997:lwIP/src/core/ipv4/etharp.c ****     ETHARP_SET_ADDRHINT(netif, i);
 998:lwIP/src/core/ipv4/etharp.c ****     /* send the packet */
 999:lwIP/src/core/ipv4/etharp.c ****     result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
1000:lwIP/src/core/ipv4/etharp.c ****     /* pending entry? (either just created or already pending */
1001:lwIP/src/core/ipv4/etharp.c ****   } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
1002:lwIP/src/core/ipv4/etharp.c ****     /* entry is still pending, queue the given packet 'q' */
1003:lwIP/src/core/ipv4/etharp.c ****     struct pbuf *p;
1004:lwIP/src/core/ipv4/etharp.c ****     int copy_needed = 0;
1005:lwIP/src/core/ipv4/etharp.c ****     /* IF q includes a pbuf that must be copied, copy the whole chain into a
1006:lwIP/src/core/ipv4/etharp.c ****      * new PBUF_RAM. See the definition of PBUF_NEEDS_COPY for details. */
1007:lwIP/src/core/ipv4/etharp.c ****     p = q;
1008:lwIP/src/core/ipv4/etharp.c ****     while (p) {
1009:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
1010:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
1011:lwIP/src/core/ipv4/etharp.c ****         copy_needed = 1;
1012:lwIP/src/core/ipv4/etharp.c ****         break;
1013:lwIP/src/core/ipv4/etharp.c ****       }
1014:lwIP/src/core/ipv4/etharp.c ****       p = p->next;
1015:lwIP/src/core/ipv4/etharp.c ****     }
1016:lwIP/src/core/ipv4/etharp.c ****     if (copy_needed) {
1017:lwIP/src/core/ipv4/etharp.c ****       /* copy the whole packet into new pbufs */
1018:lwIP/src/core/ipv4/etharp.c ****       p = pbuf_clone(PBUF_LINK, PBUF_RAM, q);
1019:lwIP/src/core/ipv4/etharp.c ****     } else {
1020:lwIP/src/core/ipv4/etharp.c ****       /* referencing the old pbuf is enough */
1021:lwIP/src/core/ipv4/etharp.c ****       p = q;
1022:lwIP/src/core/ipv4/etharp.c ****       pbuf_ref(p);
1023:lwIP/src/core/ipv4/etharp.c ****     }
1024:lwIP/src/core/ipv4/etharp.c ****     /* packet could be taken over? */
1025:lwIP/src/core/ipv4/etharp.c ****     if (p != NULL) {
1026:lwIP/src/core/ipv4/etharp.c ****       /* queue packet ... */
1027:lwIP/src/core/ipv4/etharp.c **** #if ARP_QUEUEING
1028:lwIP/src/core/ipv4/etharp.c ****       struct etharp_q_entry *new_entry;
1029:lwIP/src/core/ipv4/etharp.c ****       /* allocate a new arp queue entry */
1030:lwIP/src/core/ipv4/etharp.c ****       new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
ARM GAS  /tmp/cctR0i1S.s 			page 20


1031:lwIP/src/core/ipv4/etharp.c ****       if (new_entry != NULL) {
1032:lwIP/src/core/ipv4/etharp.c ****         unsigned int qlen = 0;
1033:lwIP/src/core/ipv4/etharp.c ****         new_entry->next = 0;
1034:lwIP/src/core/ipv4/etharp.c ****         new_entry->p = p;
1035:lwIP/src/core/ipv4/etharp.c ****         if (arp_table[i].q != NULL) {
1036:lwIP/src/core/ipv4/etharp.c ****           /* queue was already existent, append the new entry to the end */
1037:lwIP/src/core/ipv4/etharp.c ****           struct etharp_q_entry *r;
1038:lwIP/src/core/ipv4/etharp.c ****           r = arp_table[i].q;
1039:lwIP/src/core/ipv4/etharp.c ****           qlen++;
1040:lwIP/src/core/ipv4/etharp.c ****           while (r->next != NULL) {
1041:lwIP/src/core/ipv4/etharp.c ****             r = r->next;
1042:lwIP/src/core/ipv4/etharp.c ****             qlen++;
1043:lwIP/src/core/ipv4/etharp.c ****           }
1044:lwIP/src/core/ipv4/etharp.c ****           r->next = new_entry;
1045:lwIP/src/core/ipv4/etharp.c ****         } else {
1046:lwIP/src/core/ipv4/etharp.c ****           /* queue did not exist, first item in queue */
1047:lwIP/src/core/ipv4/etharp.c ****           arp_table[i].q = new_entry;
1048:lwIP/src/core/ipv4/etharp.c ****         }
1049:lwIP/src/core/ipv4/etharp.c **** #if ARP_QUEUE_LEN
1050:lwIP/src/core/ipv4/etharp.c ****         if (qlen >= ARP_QUEUE_LEN) {
1051:lwIP/src/core/ipv4/etharp.c ****           struct etharp_q_entry *old;
1052:lwIP/src/core/ipv4/etharp.c ****           old = arp_table[i].q;
1053:lwIP/src/core/ipv4/etharp.c ****           arp_table[i].q = arp_table[i].q->next;
1054:lwIP/src/core/ipv4/etharp.c ****           pbuf_free(old->p);
1055:lwIP/src/core/ipv4/etharp.c ****           memp_free(MEMP_ARP_QUEUE, old);
1056:lwIP/src/core/ipv4/etharp.c ****         }
1057:lwIP/src/core/ipv4/etharp.c **** #endif
1058:lwIP/src/core/ipv4/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"
1059:lwIP/src/core/ipv4/etharp.c ****         result = ERR_OK;
1060:lwIP/src/core/ipv4/etharp.c ****       } else {
1061:lwIP/src/core/ipv4/etharp.c ****         /* the pool MEMP_ARP_QUEUE is empty */
1062:lwIP/src/core/ipv4/etharp.c ****         pbuf_free(p);
1063:lwIP/src/core/ipv4/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_R
1064:lwIP/src/core/ipv4/etharp.c ****         result = ERR_MEM;
1065:lwIP/src/core/ipv4/etharp.c ****       }
1066:lwIP/src/core/ipv4/etharp.c **** #else /* ARP_QUEUEING */
1067:lwIP/src/core/ipv4/etharp.c ****       /* always queue one packet per ARP request only, freeing a previously queued packet */
1068:lwIP/src/core/ipv4/etharp.c ****       if (arp_table[i].q != NULL) {
1069:lwIP/src/core/ipv4/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet
1070:lwIP/src/core/ipv4/etharp.c ****         pbuf_free(arp_table[i].q);
1071:lwIP/src/core/ipv4/etharp.c ****       }
1072:lwIP/src/core/ipv4/etharp.c ****       arp_table[i].q = p;
1073:lwIP/src/core/ipv4/etharp.c ****       result = ERR_OK;
1074:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"U1
1075:lwIP/src/core/ipv4/etharp.c **** #endif /* ARP_QUEUEING */
1076:lwIP/src/core/ipv4/etharp.c ****     } else {
1077:lwIP/src/core/ipv4/etharp.c ****       ETHARP_STATS_INC(etharp.memerr);
1078:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF
1079:lwIP/src/core/ipv4/etharp.c ****       result = ERR_MEM;
1080:lwIP/src/core/ipv4/etharp.c ****     }
1081:lwIP/src/core/ipv4/etharp.c ****   }
1082:lwIP/src/core/ipv4/etharp.c ****   return result;
1083:lwIP/src/core/ipv4/etharp.c **** }
1084:lwIP/src/core/ipv4/etharp.c **** 
1085:lwIP/src/core/ipv4/etharp.c **** /**
1086:lwIP/src/core/ipv4/etharp.c ****  * Send a raw ARP packet (opcode and all addresses can be modified)
1087:lwIP/src/core/ipv4/etharp.c ****  *
ARM GAS  /tmp/cctR0i1S.s 			page 21


1088:lwIP/src/core/ipv4/etharp.c ****  * @param netif the lwip network interface on which to send the ARP packet
1089:lwIP/src/core/ipv4/etharp.c ****  * @param ethsrc_addr the source MAC address for the ethernet header
1090:lwIP/src/core/ipv4/etharp.c ****  * @param ethdst_addr the destination MAC address for the ethernet header
1091:lwIP/src/core/ipv4/etharp.c ****  * @param hwsrc_addr the source MAC address for the ARP protocol header
1092:lwIP/src/core/ipv4/etharp.c ****  * @param ipsrc_addr the source IP address for the ARP protocol header
1093:lwIP/src/core/ipv4/etharp.c ****  * @param hwdst_addr the destination MAC address for the ARP protocol header
1094:lwIP/src/core/ipv4/etharp.c ****  * @param ipdst_addr the destination IP address for the ARP protocol header
1095:lwIP/src/core/ipv4/etharp.c ****  * @param opcode the type of the ARP packet
1096:lwIP/src/core/ipv4/etharp.c ****  * @return ERR_OK if the ARP packet has been sent
1097:lwIP/src/core/ipv4/etharp.c ****  *         ERR_MEM if the ARP packet couldn't be allocated
1098:lwIP/src/core/ipv4/etharp.c ****  *         any other err_t on failure
1099:lwIP/src/core/ipv4/etharp.c ****  */
1100:lwIP/src/core/ipv4/etharp.c **** static err_t
1101:lwIP/src/core/ipv4/etharp.c **** etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
1102:lwIP/src/core/ipv4/etharp.c ****            const struct eth_addr *ethdst_addr,
1103:lwIP/src/core/ipv4/etharp.c ****            const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
1104:lwIP/src/core/ipv4/etharp.c ****            const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
1105:lwIP/src/core/ipv4/etharp.c ****            const u16_t opcode)
1106:lwIP/src/core/ipv4/etharp.c **** {
  41              		.loc 1 1106 1 view -0
  42              		.cfi_startproc
  43              		@ args = 16, pretend = 0, frame = 8
  44              		@ frame_needed = 0, uses_anonymous_args = 0
1107:lwIP/src/core/ipv4/etharp.c ****   struct pbuf *p;
  45              		.loc 1 1107 3 view .LVU1
1108:lwIP/src/core/ipv4/etharp.c ****   err_t result = ERR_OK;
  46              		.loc 1 1108 3 view .LVU2
1109:lwIP/src/core/ipv4/etharp.c ****   struct etharp_hdr *hdr;
  47              		.loc 1 1109 3 view .LVU3
1110:lwIP/src/core/ipv4/etharp.c **** 
1111:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
  48              		.loc 1 1111 3 view .LVU4
  49              		.loc 1 1111 3 view .LVU5
1106:lwIP/src/core/ipv4/etharp.c ****   struct pbuf *p;
  50              		.loc 1 1106 1 is_stmt 0 view .LVU6
  51 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
  52              	.LCFI0:
  53              		.cfi_def_cfa_offset 32
  54              		.cfi_offset 4, -32
  55              		.cfi_offset 5, -28
  56              		.cfi_offset 6, -24
  57              		.cfi_offset 7, -20
  58              		.cfi_offset 8, -16
  59              		.cfi_offset 9, -12
  60              		.cfi_offset 10, -8
  61              		.cfi_offset 14, -4
  62 0004 84B0     		sub	sp, sp, #16
  63              	.LCFI1:
  64              		.cfi_def_cfa_offset 48
1106:lwIP/src/core/ipv4/etharp.c ****   struct pbuf *p;
  65              		.loc 1 1106 1 view .LVU7
  66 0006 DDE90C76 		ldrd	r7, r6, [sp, #48]
  67 000a BDF83C40 		ldrh	r4, [sp, #60]
  68              		.loc 1 1111 3 view .LVU8
  69 000e 00B3     		cbz	r0, .L12
  70              		.loc 1 1111 3 is_stmt 1 discriminator 2 view .LVU9
1112:lwIP/src/core/ipv4/etharp.c **** 
ARM GAS  /tmp/cctR0i1S.s 			page 22


1113:lwIP/src/core/ipv4/etharp.c ****   /* allocate a pbuf for the outgoing ARP request packet */
1114:lwIP/src/core/ipv4/etharp.c ****   p = pbuf_alloc(PBUF_LINK, SIZEOF_ETHARP_HDR, PBUF_RAM);
  71              		.loc 1 1114 3 discriminator 2 view .LVU10
  72 0010 0392     		str	r2, [sp, #12]
  73 0012 8A46     		mov	r10, r1
  74 0014 8046     		mov	r8, r0
  75              		.loc 1 1114 7 is_stmt 0 discriminator 2 view .LVU11
  76 0016 4FF42072 		mov	r2, #640
  77              	.LVL1:
  78              		.loc 1 1114 7 discriminator 2 view .LVU12
  79 001a 1C21     		movs	r1, #28
  80              	.LVL2:
  81              		.loc 1 1114 7 discriminator 2 view .LVU13
  82 001c 0E20     		movs	r0, #14
  83              	.LVL3:
  84              		.loc 1 1114 7 discriminator 2 view .LVU14
  85 001e 9946     		mov	r9, r3
  86 0020 FFF7FEFF 		bl	pbuf_alloc
  87              	.LVL4:
1115:lwIP/src/core/ipv4/etharp.c ****   /* could allocate a pbuf for an ARP request? */
1116:lwIP/src/core/ipv4/etharp.c ****   if (p == NULL) {
  88              		.loc 1 1116 3 is_stmt 1 discriminator 2 view .LVU15
  89              		.loc 1 1116 6 is_stmt 0 discriminator 2 view .LVU16
  90 0024 0546     		mov	r5, r0
  91 0026 0028     		cmp	r0, #0
  92 0028 44D0     		beq	.L9
1117:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
1118:lwIP/src/core/ipv4/etharp.c ****                 ("etharp_raw: could not allocate pbuf for ARP request.\n"));
1119:lwIP/src/core/ipv4/etharp.c ****     ETHARP_STATS_INC(etharp.memerr);
1120:lwIP/src/core/ipv4/etharp.c ****     return ERR_MEM;
1121:lwIP/src/core/ipv4/etharp.c ****   }
1122:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  93              		.loc 1 1122 3 is_stmt 1 view .LVU17
  94              		.loc 1 1122 3 view .LVU18
  95 002a 4289     		ldrh	r2, [r0, #10]
  96 002c 039B     		ldr	r3, [sp, #12]
  97 002e 1B2A     		cmp	r2, #27
  98 0030 0BD9     		bls	.L13
  99              		.loc 1 1122 3 discriminator 2 view .LVU19
1123:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
1124:lwIP/src/core/ipv4/etharp.c **** 
1125:lwIP/src/core/ipv4/etharp.c ****   hdr = (struct etharp_hdr *)p->payload;
 100              		.loc 1 1125 3 discriminator 2 view .LVU20
 101              	.LBB35:
 102              	.LBB36:
 103              		.file 2 "STM32_XPD/CMSIS/Include/cmsis_gcc.h"
   1:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /*
   8:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  10:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
ARM GAS  /tmp/cctR0i1S.s 			page 23


  12:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  16:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  18:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
  24:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  25:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  28:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  34:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  38:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  39:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  43:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  46:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  49:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  55:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  58:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  61:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  64:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  67:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
ARM GAS  /tmp/cctR0i1S.s 			page 24


  69:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  70:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  78:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  86:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  94:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 102:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 110:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 113:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 116:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 117:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 118:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   @{
 122:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 123:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 124:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 125:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
ARM GAS  /tmp/cctR0i1S.s 			page 25


 126:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 129:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 131:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 133:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 134:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 135:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 136:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 140:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 142:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 144:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 145:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 146:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 147:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 151:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 153:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 155:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 158:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 159:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 160:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 162:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 166:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 168:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 170:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 173:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 174:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 175:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 176:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 177:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 181:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/cctR0i1S.s 			page 26


 183:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 185:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 186:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 187:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 189:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 193:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 195:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 197:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 198:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 199:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 200:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 201:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 205:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 207:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 209:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 212:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 213:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 214:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 215:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 219:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 221:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 223:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 226:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 227:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 228:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 229:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 233:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 235:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 237:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/cctR0i1S.s 			page 27


 240:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 241:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 242:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 243:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 247:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 249:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 251:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 254:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 255:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 256:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 258:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 262:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 264:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 266:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 269:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 270:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 271:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 272:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 273:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 277:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 279:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 281:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 282:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 283:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 285:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 289:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 291:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 293:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 294:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 295:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 296:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/cctR0i1S.s 			page 28


 297:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 301:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 303:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 305:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 308:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 309:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 310:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 312:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 316:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 318:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 320:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 323:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 324:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 325:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 326:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 327:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 331:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 333:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 335:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 336:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 337:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 339:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 343:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 345:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 347:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 348:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 349:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 350:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 352:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
ARM GAS  /tmp/cctR0i1S.s 			page 29


 354:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 356:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 358:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 360:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 363:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 364:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 365:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 366:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 370:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 372:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 374:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 375:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 376:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 377:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 378:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 382:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 384:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 386:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 389:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 390:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 391:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 393:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 397:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 399:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 401:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 404:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 405:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 406:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 407:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 408:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
ARM GAS  /tmp/cctR0i1S.s 			page 30


 411:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 412:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 414:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 416:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 417:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 418:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 420:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 424:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 426:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 428:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 429:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 430:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 431:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 435:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 439:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 441:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 443:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 444:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 445:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 446:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 450:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 452:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 454:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 455:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 456:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 457:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 461:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 463:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 465:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/cctR0i1S.s 			page 31


 468:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 469:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 470:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 472:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 476:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 478:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 480:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 483:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 484:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 485:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 486:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 487:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 491:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 493:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 495:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 496:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 497:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 499:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 503:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 505:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 507:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 508:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 509:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 510:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 511:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 516:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 518:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 520:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 521:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 522:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 523:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
ARM GAS  /tmp/cctR0i1S.s 			page 32


 525:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 527:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 529:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 531:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 534:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 535:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 536:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 538:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 542:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 544:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 546:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 549:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 550:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 551:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 552:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 553:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 557:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 559:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 561:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 562:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 563:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 565:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 569:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 571:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 573:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 574:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 575:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 579:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 580:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
ARM GAS  /tmp/cctR0i1S.s 			page 33


 582:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 583:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 584:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   
 589:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 592:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 594:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 599:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 603:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 604:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 605:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 607:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 611:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 614:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 616:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 620:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 624:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 625:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 626:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 627:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 628:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 629:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   
 634:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 637:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/cctR0i1S.s 			page 34


 639:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 644:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 646:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 647:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 648:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 649:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 651:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 655:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 658:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 660:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 664:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 666:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 667:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 668:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 669:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 670:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 671:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 676:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 679:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 681:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 686:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 690:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 691:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 692:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 693:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 695:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
ARM GAS  /tmp/cctR0i1S.s 			page 35


 696:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 699:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 702:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 704:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 708:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 712:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 713:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 714:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 715:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 716:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 717:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 722:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 725:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 727:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 732:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 734:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 735:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 736:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 737:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 739:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 743:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 746:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 748:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 752:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
ARM GAS  /tmp/cctR0i1S.s 			page 36


 753:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 754:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 755:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 756:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 757:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 760:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 761:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 762:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 766:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 768:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 776:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 778:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 781:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 782:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 784:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 785:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 786:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 787:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 788:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 792:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 794:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 802:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 804:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 805:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 807:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 808:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 809:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/cctR0i1S.s 			page 37


 810:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 812:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 813:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   @{
 817:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** */
 818:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 819:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 827:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 831:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 832:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 833:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 836:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 838:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 839:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 842:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 844:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 845:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 846:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 850:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 852:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 853:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 854:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 857:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 859:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 860:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 861:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 866:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
ARM GAS  /tmp/cctR0i1S.s 			page 38


 867:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 868:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 870:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 871:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 872:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 873:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 877:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 879:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 881:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 882:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 883:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 884:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 885:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 886:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 887:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 888:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 890:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 892:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 893:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 894:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 895:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 899:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 900:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 901:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 902:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 903:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 904:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 905:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 906:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 907:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 909:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 910:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 911:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 912:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 913:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 914:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 917:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 918:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 919:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 921:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 922:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 923:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
ARM GAS  /tmp/cctR0i1S.s 			page 39


 924:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 925:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 926:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 927:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 928:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 929:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 933:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 935:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 936:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 104              		.loc 2 937 19 is_stmt 0 discriminator 2 view .LVU21
 105 0032 62BA     		rev16	r2, r4
 106              	.LBE36:
 107              	.LBE35:
 108              		.loc 1 1125 7 discriminator 2 view .LVU22
 109 0034 4468     		ldr	r4, [r0, #4]
 110              	.LVL5:
1126:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
 111              		.loc 1 1126 88 is_stmt 1 discriminator 2 view .LVU23
1127:lwIP/src/core/ipv4/etharp.c ****   hdr->opcode = lwip_htons(opcode);
 112              		.loc 1 1127 3 discriminator 2 view .LVU24
 113              	.LBB38:
 114              	.LBI35:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 115              		.loc 2 934 30 discriminator 2 view .LVU25
 116              	.LBB37:
 117              		.loc 2 937 3 discriminator 2 view .LVU26
 118              		.loc 2 937 3 is_stmt 0 discriminator 2 view .LVU27
 119              	.LBE37:
 120              	.LBE38:
 121              		.loc 1 1127 15 discriminator 2 view .LVU28
 122 0036 E280     		strh	r2, [r4, #6]	@ unaligned
1128:lwIP/src/core/ipv4/etharp.c **** 
1129:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
 123              		.loc 1 1129 3 is_stmt 1 discriminator 2 view .LVU29
 124              		.loc 1 1129 3 discriminator 2 view .LVU30
 125 0038 98F824C0 		ldrb	ip, [r8, #36]	@ zero_extendqisi2
 126 003c BCF1060F 		cmp	ip, #6
 127 0040 0BD0     		beq	.L7
 128              		.loc 1 1129 3 discriminator 1 view .LVU31
 129 0042 1E48     		ldr	r0, .L14
 130              	.LVL6:
 131              		.loc 1 1129 3 is_stmt 0 discriminator 1 view .LVU32
 132 0044 FFF7FEFF 		bl	printf
 133              	.LVL7:
 134              	.L8:
 135              		.loc 1 1129 3 is_stmt 1 discriminator 3 view .LVU33
 136              		.loc 1 1129 3 discriminator 3 view .LVU34
 137              		.loc 1 1129 3 discriminator 3 view .LVU35
 138              		.loc 1 1129 3 discriminator 3 view .LVU36
 139              		.loc 1 1129 3 discriminator 3 view .LVU37
 140              		.loc 1 1129 3 discriminator 3 view .LVU38
 141 0048 FEE7     		b	.L8
ARM GAS  /tmp/cctR0i1S.s 			page 40


 142              	.LVL8:
 143              	.L13:
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 144              		.loc 1 1122 3 discriminator 1 view .LVU39
 145 004a 1D48     		ldr	r0, .L14+4
 146              	.LVL9:
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 147              		.loc 1 1122 3 is_stmt 0 discriminator 1 view .LVU40
 148 004c FFF7FEFF 		bl	printf
 149              	.LVL10:
 150              	.L6:
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 151              		.loc 1 1122 3 is_stmt 1 discriminator 2 view .LVU41
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 152              		.loc 1 1122 3 discriminator 2 view .LVU42
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 153              		.loc 1 1122 3 discriminator 2 view .LVU43
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 154              		.loc 1 1122 3 discriminator 2 view .LVU44
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 155              		.loc 1 1122 3 discriminator 2 view .LVU45
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 156              		.loc 1 1122 3 discriminator 2 view .LVU46
 157 0050 FEE7     		b	.L6
 158              	.LVL11:
 159              	.L12:
1111:lwIP/src/core/ipv4/etharp.c **** 
 160              		.loc 1 1111 3 discriminator 1 view .LVU47
 161 0052 1C48     		ldr	r0, .L14+8
 162              	.LVL12:
1111:lwIP/src/core/ipv4/etharp.c **** 
 163              		.loc 1 1111 3 is_stmt 0 discriminator 1 view .LVU48
 164 0054 FFF7FEFF 		bl	printf
 165              	.LVL13:
 166              	.L3:
1111:lwIP/src/core/ipv4/etharp.c **** 
 167              		.loc 1 1111 3 is_stmt 1 discriminator 1 view .LVU49
1111:lwIP/src/core/ipv4/etharp.c **** 
 168              		.loc 1 1111 3 discriminator 1 view .LVU50
1111:lwIP/src/core/ipv4/etharp.c **** 
 169              		.loc 1 1111 3 discriminator 1 view .LVU51
1111:lwIP/src/core/ipv4/etharp.c **** 
 170              		.loc 1 1111 3 discriminator 1 view .LVU52
1111:lwIP/src/core/ipv4/etharp.c **** 
 171              		.loc 1 1111 3 discriminator 1 view .LVU53
1111:lwIP/src/core/ipv4/etharp.c **** 
 172              		.loc 1 1111 3 discriminator 1 view .LVU54
 173 0058 FEE7     		b	.L3
 174              	.LVL14:
 175              	.L7:
 176              		.loc 1 1129 3 discriminator 2 view .LVU55
1130:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
1131:lwIP/src/core/ipv4/etharp.c **** 
1132:lwIP/src/core/ipv4/etharp.c ****   /* Write the ARP MAC-Addresses */
1133:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&hdr->shwaddr, hwsrc_addr, ETH_HWADDR_LEN);
 177              		.loc 1 1133 3 discriminator 2 view .LVU56
 178 005a D9F80010 		ldr	r1, [r9]	@ unaligned
ARM GAS  /tmp/cctR0i1S.s 			page 41


1134:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
1135:lwIP/src/core/ipv4/etharp.c ****   /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
1136:lwIP/src/core/ipv4/etharp.c ****    * structure packing. */
1137:lwIP/src/core/ipv4/etharp.c ****   IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->sipaddr, ipsrc_addr);
1138:lwIP/src/core/ipv4/etharp.c ****   IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->dipaddr, ipdst_addr);
1139:lwIP/src/core/ipv4/etharp.c **** 
1140:lwIP/src/core/ipv4/etharp.c ****   hdr->hwtype = PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET);
1141:lwIP/src/core/ipv4/etharp.c ****   hdr->proto = PP_HTONS(ETHTYPE_IP);
1142:lwIP/src/core/ipv4/etharp.c ****   /* set hwlen and protolen */
1143:lwIP/src/core/ipv4/etharp.c ****   hdr->hwlen = ETH_HWADDR_LEN;
1144:lwIP/src/core/ipv4/etharp.c ****   hdr->protolen = sizeof(ip4_addr_t);
1145:lwIP/src/core/ipv4/etharp.c **** 
1146:lwIP/src/core/ipv4/etharp.c ****   /* send ARP query */
1147:lwIP/src/core/ipv4/etharp.c **** #if LWIP_AUTOIP
1148:lwIP/src/core/ipv4/etharp.c ****   /* If we are using Link-Local, all ARP packets that contain a Link-Local
1149:lwIP/src/core/ipv4/etharp.c ****    * 'sender IP address' MUST be sent using link-layer broadcast instead of
1150:lwIP/src/core/ipv4/etharp.c ****    * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
1151:lwIP/src/core/ipv4/etharp.c ****   if (ip4_addr_islinklocal(ipsrc_addr)) {
1152:lwIP/src/core/ipv4/etharp.c ****     ethernet_output(netif, p, ethsrc_addr, &ethbroadcast, ETHTYPE_ARP);
1153:lwIP/src/core/ipv4/etharp.c ****   } else
1154:lwIP/src/core/ipv4/etharp.c **** #endif /* LWIP_AUTOIP */
1155:lwIP/src/core/ipv4/etharp.c ****   {
1156:lwIP/src/core/ipv4/etharp.c ****     ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
 179              		.loc 1 1156 5 is_stmt 0 discriminator 2 view .LVU57
 180 005e 40F6060E 		movw	lr, #2054
 181 0062 4046     		mov	r0, r8
 182              	.LVL15:
1144:lwIP/src/core/ipv4/etharp.c **** 
 183              		.loc 1 1144 17 discriminator 2 view .LVU58
 184 0064 4FF00408 		mov	r8, #4
 185              	.LVL16:
1133:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 186              		.loc 1 1133 3 discriminator 2 view .LVU59
 187 0068 A160     		str	r1, [r4, #8]	@ unaligned
 188              		.loc 1 1156 5 discriminator 2 view .LVU60
 189 006a 5246     		mov	r2, r10
1133:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 190              		.loc 1 1133 3 discriminator 2 view .LVU61
 191 006c B9F80410 		ldrh	r1, [r9, #4]	@ unaligned
 192 0070 A181     		strh	r1, [r4, #12]	@ unaligned
1134:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 193              		.loc 1 1134 3 is_stmt 1 discriminator 2 view .LVU62
 194              		.loc 1 1156 5 is_stmt 0 discriminator 2 view .LVU63
 195 0072 2946     		mov	r1, r5
1134:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 196              		.loc 1 1134 3 discriminator 2 view .LVU64
 197 0074 D6F80090 		ldr	r9, [r6]	@ unaligned
 198              	.LVL17:
1134:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 199              		.loc 1 1134 3 discriminator 2 view .LVU65
 200 0078 C4F81290 		str	r9, [r4, #18]	@ unaligned
 201 007c B6F80490 		ldrh	r9, [r6, #4]	@ unaligned
 202 0080 0E9E     		ldr	r6, [sp, #56]
 203 0082 A4F81690 		strh	r9, [r4, #22]	@ unaligned
1137:lwIP/src/core/ipv4/etharp.c ****   IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->dipaddr, ipdst_addr);
 204              		.loc 1 1137 3 is_stmt 1 discriminator 2 view .LVU66
 205 0086 D7F80090 		ldr	r9, [r7]	@ unaligned
ARM GAS  /tmp/cctR0i1S.s 			page 42


1140:lwIP/src/core/ipv4/etharp.c ****   hdr->proto = PP_HTONS(ETHTYPE_IP);
 206              		.loc 1 1140 15 is_stmt 0 discriminator 2 view .LVU67
 207 008a 0F4F     		ldr	r7, .L14+12
1137:lwIP/src/core/ipv4/etharp.c ****   IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->dipaddr, ipdst_addr);
 208              		.loc 1 1137 3 discriminator 2 view .LVU68
 209 008c C4F80E90 		str	r9, [r4, #14]	@ unaligned
1138:lwIP/src/core/ipv4/etharp.c **** 
 210              		.loc 1 1138 3 is_stmt 1 discriminator 2 view .LVU69
 211 0090 3668     		ldr	r6, [r6]	@ unaligned
1143:lwIP/src/core/ipv4/etharp.c ****   hdr->protolen = sizeof(ip4_addr_t);
 212              		.loc 1 1143 14 is_stmt 0 discriminator 2 view .LVU70
 213 0092 84F804C0 		strb	ip, [r4, #4]
1138:lwIP/src/core/ipv4/etharp.c **** 
 214              		.loc 1 1138 3 discriminator 2 view .LVU71
 215 0096 A661     		str	r6, [r4, #24]	@ unaligned
1140:lwIP/src/core/ipv4/etharp.c ****   hdr->proto = PP_HTONS(ETHTYPE_IP);
 216              		.loc 1 1140 3 is_stmt 1 discriminator 2 view .LVU72
1141:lwIP/src/core/ipv4/etharp.c ****   /* set hwlen and protolen */
 217              		.loc 1 1141 3 discriminator 2 view .LVU73
1140:lwIP/src/core/ipv4/etharp.c ****   hdr->proto = PP_HTONS(ETHTYPE_IP);
 218              		.loc 1 1140 15 is_stmt 0 discriminator 2 view .LVU74
 219 0098 2760     		str	r7, [r4]	@ unaligned
1143:lwIP/src/core/ipv4/etharp.c ****   hdr->protolen = sizeof(ip4_addr_t);
 220              		.loc 1 1143 3 is_stmt 1 discriminator 2 view .LVU75
1144:lwIP/src/core/ipv4/etharp.c **** 
 221              		.loc 1 1144 3 discriminator 2 view .LVU76
1144:lwIP/src/core/ipv4/etharp.c **** 
 222              		.loc 1 1144 17 is_stmt 0 discriminator 2 view .LVU77
 223 009a 84F80580 		strb	r8, [r4, #5]
 224              		.loc 1 1156 5 is_stmt 1 discriminator 2 view .LVU78
 225 009e CDF800E0 		str	lr, [sp]
 226 00a2 FFF7FEFF 		bl	ethernet_output
 227              	.LVL18:
1157:lwIP/src/core/ipv4/etharp.c ****   }
1158:lwIP/src/core/ipv4/etharp.c **** 
1159:lwIP/src/core/ipv4/etharp.c ****   ETHARP_STATS_INC(etharp.xmit);
 228              		.loc 1 1159 32 discriminator 2 view .LVU79
1160:lwIP/src/core/ipv4/etharp.c ****   /* free ARP query packet */
1161:lwIP/src/core/ipv4/etharp.c ****   pbuf_free(p);
 229              		.loc 1 1161 3 discriminator 2 view .LVU80
 230 00a6 2846     		mov	r0, r5
 231 00a8 FFF7FEFF 		bl	pbuf_free
 232              	.LVL19:
1162:lwIP/src/core/ipv4/etharp.c ****   p = NULL;
 233              		.loc 1 1162 3 discriminator 2 view .LVU81
1163:lwIP/src/core/ipv4/etharp.c ****   /* could not allocate pbuf for ARP request */
1164:lwIP/src/core/ipv4/etharp.c **** 
1165:lwIP/src/core/ipv4/etharp.c ****   return result;
 234              		.loc 1 1165 3 discriminator 2 view .LVU82
 235              		.loc 1 1165 10 is_stmt 0 discriminator 2 view .LVU83
 236 00ac 0020     		movs	r0, #0
 237              	.LVL20:
 238              	.L4:
1166:lwIP/src/core/ipv4/etharp.c **** }
 239              		.loc 1 1166 1 view .LVU84
 240 00ae 04B0     		add	sp, sp, #16
 241              	.LCFI2:
ARM GAS  /tmp/cctR0i1S.s 			page 43


 242              		.cfi_remember_state
 243              		.cfi_def_cfa_offset 32
 244              		@ sp needed
 245 00b0 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 246              	.LVL21:
 247              	.L9:
 248              	.LCFI3:
 249              		.cfi_restore_state
1120:lwIP/src/core/ipv4/etharp.c ****   }
 250              		.loc 1 1120 12 view .LVU85
 251 00b4 4FF0FF30 		mov	r0, #-1
 252              	.LVL22:
1120:lwIP/src/core/ipv4/etharp.c ****   }
 253              		.loc 1 1120 12 view .LVU86
 254 00b8 F9E7     		b	.L4
 255              	.L15:
 256 00ba 00BF     		.align	2
 257              	.L14:
 258 00bc 44000000 		.word	.LC2
 259 00c0 10000000 		.word	.LC1
 260 00c4 00000000 		.word	.LC0
 261 00c8 00010800 		.word	524544
 262              		.cfi_endproc
 263              	.LFE116:
 265              		.section	.rodata.etharp_output_to_arp_index.str1.4,"aMS",%progbits,1
 266              		.align	2
 267              	.LC3:
 268 0000 6172705F 		.ascii	"arp_table[arp_idx].state >= ETHARP_STATE_STABLE\000"
 268      7461626C 
 268      655B6172 
 268      705F6964 
 268      785D2E73 
 269              		.section	.text.etharp_output_to_arp_index,"ax",%progbits
 270              		.align	1
 271              		.p2align 2,,3
 272              		.syntax unified
 273              		.thumb
 274              		.thumb_func
 275              		.fpu fpv4-sp-d16
 277              	etharp_output_to_arp_index:
 278              	.LVL23:
 279              	.LFB113:
 749:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 280              		.loc 1 749 1 is_stmt 1 view -0
 281              		.cfi_startproc
 282              		@ args = 0, pretend = 0, frame = 0
 283              		@ frame_needed = 0, uses_anonymous_args = 0
 749:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 284              		.loc 1 749 1 is_stmt 0 view .LVU88
 285 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 286              	.LCFI4:
 287              		.cfi_def_cfa_offset 28
 288              		.cfi_offset 4, -28
 289              		.cfi_offset 5, -24
 290              		.cfi_offset 6, -20
 291              		.cfi_offset 7, -16
 292              		.cfi_offset 8, -12
ARM GAS  /tmp/cctR0i1S.s 			page 44


 293              		.cfi_offset 9, -8
 294              		.cfi_offset 14, -4
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 295              		.loc 1 750 3 view .LVU89
 296 0004 274B     		ldr	r3, .L28
 297 0006 02EB4206 		add	r6, r2, r2, lsl #1
 749:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 298              		.loc 1 749 1 view .LVU90
 299 000a 0F46     		mov	r7, r1
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 300              		.loc 1 750 3 is_stmt 1 view .LVU91
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 301              		.loc 1 750 3 view .LVU92
 749:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 302              		.loc 1 749 1 is_stmt 0 view .LVU93
 303 000c 85B0     		sub	sp, sp, #20
 304              	.LCFI5:
 305              		.cfi_def_cfa_offset 48
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 306              		.loc 1 750 3 view .LVU94
 307 000e 03EBC606 		add	r6, r3, r6, lsl #3
 308 0012 317D     		ldrb	r1, [r6, #20]	@ zero_extendqisi2
 309              	.LVL24:
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 310              		.loc 1 750 3 view .LVU95
 311 0014 0129     		cmp	r1, #1
 312 0016 30D9     		bls	.L25
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 313              		.loc 1 750 3 is_stmt 1 discriminator 2 view .LVU96
 755:lwIP/src/core/ipv4/etharp.c ****     if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
 314              		.loc 1 755 3 discriminator 2 view .LVU97
 315 0018 02EB4202 		add	r2, r2, r2, lsl #1
 316              	.LVL25:
 755:lwIP/src/core/ipv4/etharp.c ****     if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
 317              		.loc 1 755 6 is_stmt 0 discriminator 2 view .LVU98
 318 001c 0229     		cmp	r1, #2
 319 001e 0546     		mov	r5, r0
 320 0020 00F11E09 		add	r9, r0, #30
 321 0024 4FEAC204 		lsl	r4, r2, #3
 322 0028 04F10C08 		add	r8, r4, #12
 323 002c 9844     		add	r8, r8, r3
 324 002e 0BD0     		beq	.L26
 325              	.LVL26:
 326              	.L20:
 769:lwIP/src/core/ipv4/etharp.c **** }
 327              		.loc 1 769 3 is_stmt 1 view .LVU99
 769:lwIP/src/core/ipv4/etharp.c **** }
 328              		.loc 1 769 10 is_stmt 0 view .LVU100
 329 0030 4FF40064 		mov	r4, #2048
 330 0034 4346     		mov	r3, r8
 331 0036 4A46     		mov	r2, r9
 332 0038 3946     		mov	r1, r7
 333 003a 2846     		mov	r0, r5
 334 003c 0094     		str	r4, [sp]
 335 003e FFF7FEFF 		bl	ethernet_output
 336              	.LVL27:
 770:lwIP/src/core/ipv4/etharp.c **** 
ARM GAS  /tmp/cctR0i1S.s 			page 45


 337              		.loc 1 770 1 view .LVU101
 338 0042 05B0     		add	sp, sp, #20
 339              	.LCFI6:
 340              		.cfi_remember_state
 341              		.cfi_def_cfa_offset 28
 342              		@ sp needed
 343 0044 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 344              	.LVL28:
 345              	.L26:
 346              	.LCFI7:
 347              		.cfi_restore_state
 756:lwIP/src/core/ipv4/etharp.c ****       /* issue a standard request using broadcast */
 348              		.loc 1 756 5 is_stmt 1 view .LVU102
 756:lwIP/src/core/ipv4/etharp.c ****       /* issue a standard request using broadcast */
 349              		.loc 1 756 27 is_stmt 0 view .LVU103
 350 0048 728A     		ldrh	r2, [r6, #18]
 756:lwIP/src/core/ipv4/etharp.c ****       /* issue a standard request using broadcast */
 351              		.loc 1 756 8 view .LVU104
 352 004a B2F58E7F 		cmp	r2, #284
 353 004e 18D8     		bhi	.L27
 761:lwIP/src/core/ipv4/etharp.c ****       /* issue a unicast request (for 15 seconds) to prevent unnecessary broadcast */
 354              		.loc 1 761 12 is_stmt 1 view .LVU105
 761:lwIP/src/core/ipv4/etharp.c ****       /* issue a unicast request (for 15 seconds) to prevent unnecessary broadcast */
 355              		.loc 1 761 15 is_stmt 0 view .LVU106
 356 0050 B2F5877F 		cmp	r2, #270
 357 0054 ECD3     		bcc	.L20
 763:lwIP/src/core/ipv4/etharp.c ****         arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 358              		.loc 1 763 7 is_stmt 1 view .LVU107
 359              	.LVL29:
 360              	.LBB39:
 361              	.LBI39:
1167:lwIP/src/core/ipv4/etharp.c **** 
1168:lwIP/src/core/ipv4/etharp.c **** /**
1169:lwIP/src/core/ipv4/etharp.c ****  * Send an ARP request packet asking for ipaddr to a specific eth address.
1170:lwIP/src/core/ipv4/etharp.c ****  * Used to send unicast request to refresh the ARP table just before an entry
1171:lwIP/src/core/ipv4/etharp.c ****  * times out
1172:lwIP/src/core/ipv4/etharp.c ****  *
1173:lwIP/src/core/ipv4/etharp.c ****  * @param netif the lwip network interface on which to send the request
1174:lwIP/src/core/ipv4/etharp.c ****  * @param ipaddr the IP address for which to ask
1175:lwIP/src/core/ipv4/etharp.c ****  * @param hw_dst_addr the ethernet address to send this packet to
1176:lwIP/src/core/ipv4/etharp.c ****  * @return ERR_OK if the request has been sent
1177:lwIP/src/core/ipv4/etharp.c ****  *         ERR_MEM if the ARP packet couldn't be allocated
1178:lwIP/src/core/ipv4/etharp.c ****  *         any other err_t on failure
1179:lwIP/src/core/ipv4/etharp.c ****  */
1180:lwIP/src/core/ipv4/etharp.c **** static err_t
1181:lwIP/src/core/ipv4/etharp.c **** etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_addr *hw_dst_add
 362              		.loc 1 1181 1 view .LVU108
 363              	.LBB40:
1182:lwIP/src/core/ipv4/etharp.c **** {
1183:lwIP/src/core/ipv4/etharp.c ****   return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 364              		.loc 1 1183 3 view .LVU109
 365              	.LBE40:
 366              	.LBE39:
 763:lwIP/src/core/ipv4/etharp.c ****         arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 367              		.loc 1 763 37 is_stmt 0 view .LVU110
 368 0056 0434     		adds	r4, r4, #4
 369              	.LVL30:
ARM GAS  /tmp/cctR0i1S.s 			page 46


 370              	.LBB43:
 371              	.LBB41:
 372              		.loc 1 1183 10 view .LVU111
 373 0058 0122     		movs	r2, #1
 374 005a 1349     		ldr	r1, .L28+4
 375              	.LBE41:
 376              	.LBE43:
 763:lwIP/src/core/ipv4/etharp.c ****         arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 377              		.loc 1 763 37 view .LVU112
 378 005c 1C44     		add	r4, r4, r3
 379              	.LBB44:
 380              	.LBB42:
 381              		.loc 1 1183 10 view .LVU113
 382 005e 0392     		str	r2, [sp, #12]
 383 0060 0191     		str	r1, [sp, #4]
 384 0062 4B46     		mov	r3, r9
 385 0064 4246     		mov	r2, r8
 386 0066 4946     		mov	r1, r9
 387 0068 0090     		str	r0, [sp]
 388 006a 0294     		str	r4, [sp, #8]
 389 006c FFF7FEFF 		bl	etharp_raw
 390              	.LVL31:
 391              		.loc 1 1183 10 view .LVU114
 392              	.LBE42:
 393              	.LBE44:
 763:lwIP/src/core/ipv4/etharp.c ****         arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 394              		.loc 1 763 10 view .LVU115
 395 0070 0028     		cmp	r0, #0
 396 0072 DDD1     		bne	.L20
 397              	.L24:
 764:lwIP/src/core/ipv4/etharp.c ****       }
 398              		.loc 1 764 9 is_stmt 1 view .LVU116
 764:lwIP/src/core/ipv4/etharp.c ****       }
 399              		.loc 1 764 34 is_stmt 0 view .LVU117
 400 0074 0323     		movs	r3, #3
 401 0076 3375     		strb	r3, [r6, #20]
 402 0078 DAE7     		b	.L20
 403              	.LVL32:
 404              	.L25:
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 405              		.loc 1 750 3 is_stmt 1 discriminator 1 view .LVU118
 406 007a 0C48     		ldr	r0, .L28+8
 407              	.LVL33:
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 408              		.loc 1 750 3 is_stmt 0 discriminator 1 view .LVU119
 409 007c FFF7FEFF 		bl	printf
 410              	.LVL34:
 411              	.L18:
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 412              		.loc 1 750 3 is_stmt 1 discriminator 1 view .LVU120
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 413              		.loc 1 750 3 discriminator 1 view .LVU121
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 414              		.loc 1 750 3 discriminator 1 view .LVU122
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 415              		.loc 1 750 3 discriminator 1 view .LVU123
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
ARM GAS  /tmp/cctR0i1S.s 			page 47


 416              		.loc 1 750 3 discriminator 1 view .LVU124
 750:lwIP/src/core/ipv4/etharp.c ****               arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
 417              		.loc 1 750 3 discriminator 1 view .LVU125
 418 0080 FEE7     		b	.L18
 419              	.LVL35:
 420              	.L27:
 758:lwIP/src/core/ipv4/etharp.c ****         arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 421              		.loc 1 758 7 view .LVU126
 422              	.LBB45:
 423              	.LBI45:
1184:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
1185:lwIP/src/core/ipv4/etharp.c ****                     ipaddr, ARP_REQUEST);
1186:lwIP/src/core/ipv4/etharp.c **** }
1187:lwIP/src/core/ipv4/etharp.c **** 
1188:lwIP/src/core/ipv4/etharp.c **** /**
1189:lwIP/src/core/ipv4/etharp.c ****  * Send an ARP request packet asking for ipaddr.
1190:lwIP/src/core/ipv4/etharp.c ****  *
1191:lwIP/src/core/ipv4/etharp.c ****  * @param netif the lwip network interface on which to send the request
1192:lwIP/src/core/ipv4/etharp.c ****  * @param ipaddr the IP address for which to ask
1193:lwIP/src/core/ipv4/etharp.c ****  * @return ERR_OK if the request has been sent
1194:lwIP/src/core/ipv4/etharp.c ****  *         ERR_MEM if the ARP packet couldn't be allocated
1195:lwIP/src/core/ipv4/etharp.c ****  *         any other err_t on failure
1196:lwIP/src/core/ipv4/etharp.c ****  */
1197:lwIP/src/core/ipv4/etharp.c **** err_t
1198:lwIP/src/core/ipv4/etharp.c **** etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
 424              		.loc 1 1198 1 view .LVU127
 425              	.LBB46:
1199:lwIP/src/core/ipv4/etharp.c **** {
1200:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
 426              		.loc 1 1200 89 view .LVU128
1201:lwIP/src/core/ipv4/etharp.c ****   return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 427              		.loc 1 1201 3 view .LVU129
 428              	.LBB47:
 429              	.LBI47:
1181:lwIP/src/core/ipv4/etharp.c **** {
 430              		.loc 1 1181 1 view .LVU130
 431              	.LBB48:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 432              		.loc 1 1183 3 view .LVU131
 433              	.LBE48:
 434              	.LBE47:
 435              	.LBE46:
 436              	.LBE45:
 758:lwIP/src/core/ipv4/etharp.c ****         arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 437              		.loc 1 758 33 is_stmt 0 view .LVU132
 438 0082 221D     		adds	r2, r4, #4
 439              	.LBB55:
 440              	.LBB53:
 441              	.LBB51:
 442              	.LBB49:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 443              		.loc 1 1183 10 view .LVU133
 444 0084 0121     		movs	r1, #1
 445 0086 084C     		ldr	r4, .L28+4
 446              	.LVL36:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 447              		.loc 1 1183 10 view .LVU134
ARM GAS  /tmp/cctR0i1S.s 			page 48


 448              	.LBE49:
 449              	.LBE51:
 450              	.LBE53:
 451              	.LBE55:
 758:lwIP/src/core/ipv4/etharp.c ****         arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 452              		.loc 1 758 33 view .LVU135
 453 0088 1A44     		add	r2, r2, r3
 454              	.LBB56:
 455              	.LBB54:
 456              	.LBB52:
 457              	.LBB50:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 458              		.loc 1 1183 10 view .LVU136
 459 008a 0391     		str	r1, [sp, #12]
 460 008c 4B46     		mov	r3, r9
 461 008e 4946     		mov	r1, r9
 462 0090 0292     		str	r2, [sp, #8]
 463 0092 0090     		str	r0, [sp]
 464 0094 064A     		ldr	r2, .L28+12
 465 0096 0194     		str	r4, [sp, #4]
 466 0098 FFF7FEFF 		bl	etharp_raw
 467              	.LVL37:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 468              		.loc 1 1183 10 view .LVU137
 469              	.LBE50:
 470              	.LBE52:
 471              	.LBE54:
 472              	.LBE56:
 758:lwIP/src/core/ipv4/etharp.c ****         arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 473              		.loc 1 758 10 view .LVU138
 474 009c 0028     		cmp	r0, #0
 475 009e C7D1     		bne	.L20
 476 00a0 E8E7     		b	.L24
 477              	.L29:
 478 00a2 00BF     		.align	2
 479              	.L28:
 480 00a4 00000000 		.word	.LANCHOR0
 481 00a8 00000000 		.word	ethzero
 482 00ac 00000000 		.word	.LC3
 483 00b0 00000000 		.word	ethbroadcast
 484              		.cfi_endproc
 485              	.LFE113:
 487              		.section	.rodata.etharp_find_entry.isra.0.str1.4,"aMS",%progbits,1
 488              		.align	2
 489              	.LC4:
 490 0000 6172705F 		.ascii	"arp_table[i].q == NULL\000"
 490      7461626C 
 490      655B695D 
 490      2E71203D 
 490      3D204E55 
 491 0017 00       		.align	2
 492              	.LC5:
 493 0018 6172705F 		.ascii	"arp_table[i].state == ETHARP_STATE_EMPTY\000"
 493      7461626C 
 493      655B695D 
 493      2E737461 
 493      7465203D 
ARM GAS  /tmp/cctR0i1S.s 			page 49


 494              		.section	.text.etharp_find_entry.isra.0,"ax",%progbits
 495              		.align	1
 496              		.p2align 2,,3
 497              		.syntax unified
 498              		.thumb
 499              		.thumb_func
 500              		.fpu fpv4-sp-d16
 502              	etharp_find_entry.isra.0:
 503              	.LVL38:
 504              	.LFB119:
 256:lwIP/src/core/ipv4/etharp.c **** {
 505              		.loc 1 256 1 is_stmt 1 view -0
 506              		.cfi_startproc
 507              		@ args = 0, pretend = 0, frame = 0
 508              		@ frame_needed = 0, uses_anonymous_args = 0
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 509              		.loc 1 283 15 view .LVU140
 256:lwIP/src/core/ipv4/etharp.c **** {
 510              		.loc 1 256 1 is_stmt 0 view .LVU141
 511 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 512              	.LCFI8:
 513              		.cfi_def_cfa_offset 40
 514              		.cfi_offset 3, -40
 515              		.cfi_offset 4, -36
 516              		.cfi_offset 5, -32
 517              		.cfi_offset 6, -28
 518              		.cfi_offset 7, -24
 519              		.cfi_offset 8, -20
 520              		.cfi_offset 9, -16
 521              		.cfi_offset 10, -12
 522              		.cfi_offset 11, -8
 523              		.cfi_offset 14, -4
 524              	.LBB57:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 525              		.loc 1 284 10 view .LVU142
 526 0004 944C     		ldr	r4, .L360
 527 0006 8346     		mov	fp, r0
 528              	.LBE57:
 256:lwIP/src/core/ipv4/etharp.c **** {
 529              		.loc 1 256 1 view .LVU143
 530 0008 8946     		mov	r9, r1
 531              	.LBB58:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 532              		.loc 1 284 10 view .LVU144
 533 000a 237D     		ldrb	r3, [r4, #20]	@ zero_extendqisi2
 534 000c 0028     		cmp	r0, #0
 535 000e 00F0D681 		beq	.L335
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 536              		.loc 1 284 5 is_stmt 1 view .LVU145
 537              	.LVL39:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 538              		.loc 1 286 5 view .LVU146
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 539              		.loc 1 286 8 is_stmt 0 view .LVU147
 540 0012 002B     		cmp	r3, #0
 541 0014 00F08280 		beq	.L81
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
ARM GAS  /tmp/cctR0i1S.s 			page 50


 542              		.loc 1 290 12 is_stmt 1 view .LVU148
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 543              		.loc 1 291 7 view .LVU149
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 544              		.loc 1 291 7 view .LVU150
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 545              		.loc 1 291 7 view .LVU151
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 546              		.loc 1 294 7 view .LVU152
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 547              		.loc 1 294 18 is_stmt 0 view .LVU153
 548 0018 0168     		ldr	r1, [r0]
 549              	.LVL40:
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 550              		.loc 1 294 18 view .LVU154
 551 001a 6268     		ldr	r2, [r4, #4]
 552 001c 9142     		cmp	r1, r2
 553 001e 00F0BA82 		beq	.L187
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 554              		.loc 1 304 7 is_stmt 1 view .LVU155
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 555              		.loc 1 304 10 is_stmt 0 view .LVU156
 556 0022 012B     		cmp	r3, #1
 557 0024 B4F812C0 		ldrh	ip, [r4, #18]
 558 0028 00F06E82 		beq	.L336
 559 002c E646     		mov	lr, ip
 560              	.LBE58:
 262:lwIP/src/core/ipv4/etharp.c ****   /* its age */
 561              		.loc 1 262 9 view .LVU157
 562 002e 0A23     		movs	r3, #10
 563              	.LVL41:
 264:lwIP/src/core/ipv4/etharp.c **** 
 564              		.loc 1 264 24 view .LVU158
 565 0030 4FF0000C 		mov	ip, #0
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 566              		.loc 1 258 9 view .LVU159
 567 0034 1A46     		mov	r2, r3
 264:lwIP/src/core/ipv4/etharp.c **** 
 568              		.loc 1 264 9 view .LVU160
 569 0036 E046     		mov	r8, ip
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 570              		.loc 1 283 10 view .LVU161
 571 0038 6546     		mov	r5, ip
 572              	.L83:
 573              	.LVL42:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 574              		.loc 1 283 35 is_stmt 1 view .LVU162
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 575              		.loc 1 283 15 view .LVU163
 576              	.LBB59:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 577              		.loc 1 284 5 view .LVU164
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 578              		.loc 1 284 10 is_stmt 0 view .LVU165
 579 003a 94F82C10 		ldrb	r1, [r4, #44]	@ zero_extendqisi2
 580              	.LVL43:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
ARM GAS  /tmp/cctR0i1S.s 			page 51


 581              		.loc 1 286 5 is_stmt 1 view .LVU166
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 582              		.loc 1 286 8 is_stmt 0 view .LVU167
 583 003e 0029     		cmp	r1, #0
 584 0040 40F08683 		bne	.L337
 585              	.LVL44:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 586              		.loc 1 286 8 view .LVU168
 587              	.LBE59:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 588              		.loc 1 283 35 is_stmt 1 view .LVU169
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 589              		.loc 1 283 15 view .LVU170
 590              	.LBB60:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 591              		.loc 1 284 5 view .LVU171
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 592              		.loc 1 284 10 is_stmt 0 view .LVU172
 593 0044 94F84410 		ldrb	r1, [r4, #68]	@ zero_extendqisi2
 594              	.LVL45:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 595              		.loc 1 286 5 is_stmt 1 view .LVU173
 596              	.LBE60:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 597              		.loc 1 283 35 is_stmt 0 view .LVU174
 598 0048 0120     		movs	r0, #1
 599              	.LVL46:
 600              	.L153:
 601              	.LBB61:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 602              		.loc 1 290 12 is_stmt 1 view .LVU175
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 603              		.loc 1 290 15 is_stmt 0 view .LVU176
 604 004a 71B1     		cbz	r1, .L90
 605              	.L326:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 606              		.loc 1 291 7 is_stmt 1 view .LVU177
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 607              		.loc 1 291 7 view .LVU178
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 608              		.loc 1 291 7 view .LVU179
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 609              		.loc 1 294 7 view .LVU180
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 610              		.loc 1 294 18 is_stmt 0 view .LVU181
 611 004c DBF80070 		ldr	r7, [fp]
 612 0050 666B     		ldr	r6, [r4, #52]
 613 0052 B742     		cmp	r7, r6
 614 0054 00F06683 		beq	.L191
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 615              		.loc 1 304 7 is_stmt 1 view .LVU182
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 616              		.loc 1 304 10 is_stmt 0 view .LVU183
 617 0058 0129     		cmp	r1, #1
 618 005a B4F84270 		ldrh	r7, [r4, #66]
 619 005e 00F07082 		beq	.L91
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
ARM GAS  /tmp/cctR0i1S.s 			page 52


 620              		.loc 1 320 14 is_stmt 1 view .LVU184
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 621              		.loc 1 327 11 view .LVU185
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 622              		.loc 1 327 14 is_stmt 0 view .LVU186
 623 0062 7745     		cmp	r7, lr
 624 0064 01D3     		bcc	.L90
 625 0066 BE46     		mov	lr, r7
 626              	.LBE61:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 627              		.loc 1 283 35 view .LVU187
 628 0068 0225     		movs	r5, #2
 629              	.LVL47:
 630              	.L90:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 631              		.loc 1 283 35 is_stmt 1 view .LVU188
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 632              		.loc 1 283 15 view .LVU189
 633              	.LBB62:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 634              		.loc 1 284 5 view .LVU190
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 635              		.loc 1 286 8 is_stmt 0 view .LVU191
 636 006a 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 637              		.loc 1 284 10 view .LVU192
 638 006c 94F85C10 		ldrb	r1, [r4, #92]	@ zero_extendqisi2
 639              	.LVL48:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 640              		.loc 1 286 5 is_stmt 1 view .LVU193
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 641              		.loc 1 286 8 is_stmt 0 view .LVU194
 642 0070 77D1     		bne	.L152
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 643              		.loc 1 286 8 view .LVU195
 644 0072 0029     		cmp	r1, #0
 645 0074 76D1     		bne	.L327
 646              	.LVL49:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 647              		.loc 1 286 8 view .LVU196
 648              	.LBE62:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 649              		.loc 1 283 35 is_stmt 1 view .LVU197
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 650              		.loc 1 283 15 view .LVU198
 651              	.LBB63:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 652              		.loc 1 284 5 view .LVU199
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 653              		.loc 1 284 10 is_stmt 0 view .LVU200
 654 0076 94F87410 		ldrb	r1, [r4, #116]	@ zero_extendqisi2
 655              	.LVL50:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 656              		.loc 1 286 5 is_stmt 1 view .LVU201
 657              	.LBE63:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 658              		.loc 1 283 35 is_stmt 0 view .LVU202
ARM GAS  /tmp/cctR0i1S.s 			page 53


 659 007a 0320     		movs	r0, #3
 660              	.LVL51:
 661              	.L151:
 662              	.LBB64:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 663              		.loc 1 290 12 is_stmt 1 view .LVU203
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 664              		.loc 1 290 15 is_stmt 0 view .LVU204
 665 007c 71B1     		cbz	r1, .L100
 666              	.L328:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 667              		.loc 1 291 7 is_stmt 1 view .LVU205
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 668              		.loc 1 291 7 view .LVU206
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 669              		.loc 1 291 7 view .LVU207
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 670              		.loc 1 294 7 view .LVU208
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 671              		.loc 1 294 18 is_stmt 0 view .LVU209
 672 007e DBF80070 		ldr	r7, [fp]
 673 0082 666E     		ldr	r6, [r4, #100]
 674 0084 B742     		cmp	r7, r6
 675 0086 00F05583 		beq	.L193
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 676              		.loc 1 304 7 is_stmt 1 view .LVU210
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 677              		.loc 1 304 10 is_stmt 0 view .LVU211
 678 008a 0129     		cmp	r1, #1
 679 008c B4F87270 		ldrh	r7, [r4, #114]
 680 0090 00F04482 		beq	.L101
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 681              		.loc 1 320 14 is_stmt 1 view .LVU212
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 682              		.loc 1 327 11 view .LVU213
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 683              		.loc 1 327 14 is_stmt 0 view .LVU214
 684 0094 7745     		cmp	r7, lr
 685 0096 01D3     		bcc	.L100
 686 0098 BE46     		mov	lr, r7
 687              	.LBE64:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 688              		.loc 1 283 35 view .LVU215
 689 009a 0425     		movs	r5, #4
 690              	.LVL52:
 691              	.L100:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 692              		.loc 1 283 35 is_stmt 1 view .LVU216
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 693              		.loc 1 283 15 view .LVU217
 694              	.LBB65:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 695              		.loc 1 284 5 view .LVU218
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 696              		.loc 1 286 8 is_stmt 0 view .LVU219
 697 009c 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
ARM GAS  /tmp/cctR0i1S.s 			page 54


 698              		.loc 1 284 10 view .LVU220
 699 009e 94F88C10 		ldrb	r1, [r4, #140]	@ zero_extendqisi2
 700              	.LVL53:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 701              		.loc 1 286 5 is_stmt 1 view .LVU221
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 702              		.loc 1 286 8 is_stmt 0 view .LVU222
 703 00a2 79D1     		bne	.L150
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 704              		.loc 1 286 8 view .LVU223
 705 00a4 0029     		cmp	r1, #0
 706 00a6 78D1     		bne	.L329
 707              	.LVL54:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 708              		.loc 1 286 8 view .LVU224
 709              	.LBE65:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 710              		.loc 1 283 35 is_stmt 1 view .LVU225
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 711              		.loc 1 283 15 view .LVU226
 712              	.LBB66:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 713              		.loc 1 284 5 view .LVU227
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 714              		.loc 1 284 10 is_stmt 0 view .LVU228
 715 00a8 94F8A410 		ldrb	r1, [r4, #164]	@ zero_extendqisi2
 716              	.LVL55:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 717              		.loc 1 286 5 is_stmt 1 view .LVU229
 718              	.LBE66:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 719              		.loc 1 283 35 is_stmt 0 view .LVU230
 720 00ac 0520     		movs	r0, #5
 721              	.LVL56:
 722              	.L149:
 723              	.LBB67:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 724              		.loc 1 290 12 is_stmt 1 view .LVU231
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 725              		.loc 1 290 15 is_stmt 0 view .LVU232
 726 00ae 79B1     		cbz	r1, .L110
 727              	.L330:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 728              		.loc 1 291 7 is_stmt 1 view .LVU233
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 729              		.loc 1 291 7 view .LVU234
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 730              		.loc 1 291 7 view .LVU235
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 731              		.loc 1 294 7 view .LVU236
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 732              		.loc 1 294 18 is_stmt 0 view .LVU237
 733 00b0 DBF80070 		ldr	r7, [fp]
 734 00b4 D4F89460 		ldr	r6, [r4, #148]
 735 00b8 B742     		cmp	r7, r6
 736 00ba 00F03583 		beq	.L195
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
ARM GAS  /tmp/cctR0i1S.s 			page 55


 737              		.loc 1 304 7 is_stmt 1 view .LVU238
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 738              		.loc 1 304 10 is_stmt 0 view .LVU239
 739 00be 0129     		cmp	r1, #1
 740 00c0 B4F8A270 		ldrh	r7, [r4, #162]
 741 00c4 00F03382 		beq	.L111
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 742              		.loc 1 320 14 is_stmt 1 view .LVU240
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 743              		.loc 1 327 11 view .LVU241
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 744              		.loc 1 327 14 is_stmt 0 view .LVU242
 745 00c8 7745     		cmp	r7, lr
 746 00ca 01D3     		bcc	.L110
 747 00cc BE46     		mov	lr, r7
 748              	.LBE67:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 749              		.loc 1 283 35 view .LVU243
 750 00ce 0625     		movs	r5, #6
 751              	.LVL57:
 752              	.L110:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 753              		.loc 1 283 35 is_stmt 1 view .LVU244
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 754              		.loc 1 283 15 view .LVU245
 755              	.LBB68:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 756              		.loc 1 284 5 view .LVU246
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 757              		.loc 1 286 8 is_stmt 0 view .LVU247
 758 00d0 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 759              		.loc 1 284 10 view .LVU248
 760 00d2 94F8BC10 		ldrb	r1, [r4, #188]	@ zero_extendqisi2
 761              	.LVL58:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 762              		.loc 1 286 5 is_stmt 1 view .LVU249
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 763              		.loc 1 286 8 is_stmt 0 view .LVU250
 764 00d6 7AD1     		bne	.L148
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 765              		.loc 1 286 8 view .LVU251
 766 00d8 0029     		cmp	r1, #0
 767 00da 79D1     		bne	.L331
 768              	.LVL59:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 769              		.loc 1 286 8 view .LVU252
 770              	.LBE68:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 771              		.loc 1 283 35 is_stmt 1 view .LVU253
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 772              		.loc 1 283 15 view .LVU254
 773              	.LBB69:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 774              		.loc 1 284 5 view .LVU255
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 775              		.loc 1 284 10 is_stmt 0 view .LVU256
ARM GAS  /tmp/cctR0i1S.s 			page 56


 776 00dc 94F8D410 		ldrb	r1, [r4, #212]	@ zero_extendqisi2
 777              	.LVL60:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 778              		.loc 1 286 5 is_stmt 1 view .LVU257
 779              	.LBE69:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 780              		.loc 1 283 35 is_stmt 0 view .LVU258
 781 00e0 0720     		movs	r0, #7
 782              	.LVL61:
 783              	.L147:
 784              	.LBB70:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 785              		.loc 1 290 12 is_stmt 1 view .LVU259
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 786              		.loc 1 290 15 is_stmt 0 view .LVU260
 787 00e2 0029     		cmp	r1, #0
 788 00e4 40F07781 		bne	.L332
 789              	.LVL62:
 790              	.L120:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 791              		.loc 1 290 15 view .LVU261
 792              	.LBE70:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 793              		.loc 1 283 35 is_stmt 1 view .LVU262
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 794              		.loc 1 283 15 view .LVU263
 795              	.LBB71:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 796              		.loc 1 284 5 view .LVU264
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 797              		.loc 1 286 8 is_stmt 0 view .LVU265
 798 00e8 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 799              		.loc 1 284 10 view .LVU266
 800 00ea 94F8EC10 		ldrb	r1, [r4, #236]	@ zero_extendqisi2
 801              	.LVL63:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 802              		.loc 1 286 5 is_stmt 1 view .LVU267
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 803              		.loc 1 286 8 is_stmt 0 view .LVU268
 804 00ee 40F08A80 		bne	.L123
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 805              		.loc 1 286 8 view .LVU269
 806 00f2 0029     		cmp	r1, #0
 807 00f4 40F08A80 		bne	.L333
 808              	.LVL64:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 809              		.loc 1 286 8 view .LVU270
 810              	.LBE71:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 811              		.loc 1 283 35 is_stmt 1 view .LVU271
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 812              		.loc 1 283 15 view .LVU272
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 813              		.loc 1 338 3 view .LVU273
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 814              		.loc 1 338 6 is_stmt 0 view .LVU274
ARM GAS  /tmp/cctR0i1S.s 			page 57


 815 00f8 B9F1010F 		cmp	r9, #1
 816 00fc 40F05182 		bne	.L201
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 817              		.loc 1 283 35 view .LVU275
 818 0100 0920     		movs	r0, #9
 819              	.LVL65:
 820              	.L124:
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 821              		.loc 1 387 3 is_stmt 1 view .LVU276
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 822              		.loc 1 387 3 view .LVU277
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 823              		.loc 1 387 3 view .LVU278
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 824              		.loc 1 388 3 view .LVU279
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 825              		.loc 1 388 3 view .LVU280
 826 0102 00EB4003 		add	r3, r0, r0, lsl #1
 827 0106 0746     		mov	r7, r0
 828 0108 04EBC303 		add	r3, r4, r3, lsl #3
 829 010c 1B7D     		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 830 010e 002B     		cmp	r3, #0
 831 0110 00F04681 		beq	.L155
 832              	.LVL66:
 833              	.L137:
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 834              		.loc 1 388 3 view .LVU281
 835 0114 5148     		ldr	r0, .L360+4
 836              	.LVL67:
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 837              		.loc 1 388 3 is_stmt 0 view .LVU282
 838 0116 FFF7FEFF 		bl	printf
 839              	.LVL68:
 840              	.L135:
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 841              		.loc 1 388 3 is_stmt 1 view .LVU283
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 842              		.loc 1 388 3 view .LVU284
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 843              		.loc 1 388 3 view .LVU285
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 844              		.loc 1 388 3 view .LVU286
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 845              		.loc 1 388 3 view .LVU287
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 846              		.loc 1 388 3 view .LVU288
 847 011a FEE7     		b	.L135
 848              	.LVL69:
 849              	.L81:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 850              		.loc 1 283 35 view .LVU289
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 851              		.loc 1 283 15 view .LVU290
 852              	.LBB72:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 853              		.loc 1 284 5 view .LVU291
 854              	.LBE72:
ARM GAS  /tmp/cctR0i1S.s 			page 58


 264:lwIP/src/core/ipv4/etharp.c **** 
 855              		.loc 1 264 41 is_stmt 0 view .LVU292
 856 011c 9E46     		mov	lr, r3
 857              	.LBB73:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 858              		.loc 1 284 10 view .LVU293
 859 011e 94F82C10 		ldrb	r1, [r4, #44]	@ zero_extendqisi2
 860              	.LVL70:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 861              		.loc 1 286 5 is_stmt 1 view .LVU294
 862              	.LBE73:
 262:lwIP/src/core/ipv4/etharp.c ****   /* its age */
 863              		.loc 1 262 9 is_stmt 0 view .LVU295
 864 0122 0A23     		movs	r3, #10
 264:lwIP/src/core/ipv4/etharp.c **** 
 865              		.loc 1 264 24 view .LVU296
 866 0124 F046     		mov	r8, lr
 264:lwIP/src/core/ipv4/etharp.c **** 
 867              		.loc 1 264 9 view .LVU297
 868 0126 F446     		mov	ip, lr
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 869              		.loc 1 283 10 view .LVU298
 870 0128 7046     		mov	r0, lr
 871              	.LVL71:
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 872              		.loc 1 258 39 view .LVU299
 873 012a 1D46     		mov	r5, r3
 874              	.LVL72:
 875              	.LBB74:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 876              		.loc 1 290 12 is_stmt 1 view .LVU300
 877              	.LBE74:
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 878              		.loc 1 258 9 is_stmt 0 view .LVU301
 879 012c 1A46     		mov	r2, r3
 880              	.LBB75:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 881              		.loc 1 290 15 view .LVU302
 882 012e 69B1     		cbz	r1, .L85
 883              	.LVL73:
 884              	.L359:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 885              		.loc 1 291 7 is_stmt 1 view .LVU303
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 886              		.loc 1 291 7 view .LVU304
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 887              		.loc 1 291 7 view .LVU305
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 888              		.loc 1 294 7 view .LVU306
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 889              		.loc 1 294 18 is_stmt 0 view .LVU307
 890 0130 DBF80070 		ldr	r7, [fp]
 891 0134 E669     		ldr	r6, [r4, #28]
 892 0136 B742     		cmp	r7, r6
 893 0138 00F00883 		beq	.L190
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 894              		.loc 1 304 7 is_stmt 1 view .LVU308
ARM GAS  /tmp/cctR0i1S.s 			page 59


 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 895              		.loc 1 304 10 is_stmt 0 view .LVU309
 896 013c 0129     		cmp	r1, #1
 897 013e 678D     		ldrh	r7, [r4, #42]
 898 0140 00F01182 		beq	.L86
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 899              		.loc 1 320 14 is_stmt 1 view .LVU310
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 900              		.loc 1 327 11 view .LVU311
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 901              		.loc 1 327 14 is_stmt 0 view .LVU312
 902 0144 7745     		cmp	r7, lr
 903 0146 01D3     		bcc	.L85
 904 0148 BE46     		mov	lr, r7
 905              	.LBE75:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 906              		.loc 1 283 35 view .LVU313
 907 014a 0125     		movs	r5, #1
 908              	.L85:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 909              		.loc 1 283 35 is_stmt 1 view .LVU314
 910              	.LVL74:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 911              		.loc 1 283 15 view .LVU315
 912              	.LBB76:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 913              		.loc 1 284 5 view .LVU316
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 914              		.loc 1 286 8 is_stmt 0 view .LVU317
 915 014c 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 916              		.loc 1 284 10 view .LVU318
 917 014e 94F84410 		ldrb	r1, [r4, #68]	@ zero_extendqisi2
 918              	.LVL75:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 919              		.loc 1 286 5 is_stmt 1 view .LVU319
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 920              		.loc 1 286 8 is_stmt 0 view .LVU320
 921 0152 7FF47AAF 		bne	.L153
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 922              		.loc 1 286 8 view .LVU321
 923 0156 0029     		cmp	r1, #0
 924 0158 7FF478AF 		bne	.L326
 925              	.LVL76:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 926              		.loc 1 286 8 view .LVU322
 927              	.LBE76:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 928              		.loc 1 283 35 is_stmt 1 view .LVU323
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 929              		.loc 1 283 15 view .LVU324
 930              	.LBB77:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 931              		.loc 1 284 5 view .LVU325
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 932              		.loc 1 284 10 is_stmt 0 view .LVU326
 933 015c 94F85C10 		ldrb	r1, [r4, #92]	@ zero_extendqisi2
ARM GAS  /tmp/cctR0i1S.s 			page 60


 934              	.LVL77:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 935              		.loc 1 286 5 is_stmt 1 view .LVU327
 936              	.LBE77:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 937              		.loc 1 283 35 is_stmt 0 view .LVU328
 938 0160 0220     		movs	r0, #2
 939              	.LVL78:
 940              	.L152:
 941              	.LBB78:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 942              		.loc 1 290 12 is_stmt 1 view .LVU329
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 943              		.loc 1 290 15 is_stmt 0 view .LVU330
 944 0162 71B1     		cbz	r1, .L95
 945              	.L327:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 946              		.loc 1 291 7 is_stmt 1 view .LVU331
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 947              		.loc 1 291 7 view .LVU332
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 948              		.loc 1 291 7 view .LVU333
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 949              		.loc 1 294 7 view .LVU334
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 950              		.loc 1 294 18 is_stmt 0 view .LVU335
 951 0164 DBF80070 		ldr	r7, [fp]
 952 0168 E66C     		ldr	r6, [r4, #76]
 953 016a B742     		cmp	r7, r6
 954 016c 00F0E082 		beq	.L192
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 955              		.loc 1 304 7 is_stmt 1 view .LVU336
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 956              		.loc 1 304 10 is_stmt 0 view .LVU337
 957 0170 0129     		cmp	r1, #1
 958 0172 B4F85A70 		ldrh	r7, [r4, #90]
 959 0176 00F0ED81 		beq	.L96
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 960              		.loc 1 320 14 is_stmt 1 view .LVU338
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 961              		.loc 1 327 11 view .LVU339
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 962              		.loc 1 327 14 is_stmt 0 view .LVU340
 963 017a 7745     		cmp	r7, lr
 964 017c 01D3     		bcc	.L95
 965 017e BE46     		mov	lr, r7
 966              	.LBE78:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 967              		.loc 1 283 35 view .LVU341
 968 0180 0325     		movs	r5, #3
 969              	.LVL79:
 970              	.L95:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 971              		.loc 1 283 35 is_stmt 1 view .LVU342
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 972              		.loc 1 283 15 view .LVU343
 973              	.LBB79:
ARM GAS  /tmp/cctR0i1S.s 			page 61


 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 974              		.loc 1 284 5 view .LVU344
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 975              		.loc 1 286 8 is_stmt 0 view .LVU345
 976 0182 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 977              		.loc 1 284 10 view .LVU346
 978 0184 94F87410 		ldrb	r1, [r4, #116]	@ zero_extendqisi2
 979              	.LVL80:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 980              		.loc 1 286 5 is_stmt 1 view .LVU347
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 981              		.loc 1 286 8 is_stmt 0 view .LVU348
 982 0188 7FF478AF 		bne	.L151
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 983              		.loc 1 286 8 view .LVU349
 984 018c 0029     		cmp	r1, #0
 985 018e 7FF476AF 		bne	.L328
 986              	.LVL81:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 987              		.loc 1 286 8 view .LVU350
 988              	.LBE79:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 989              		.loc 1 283 35 is_stmt 1 view .LVU351
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 990              		.loc 1 283 15 view .LVU352
 991              	.LBB80:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 992              		.loc 1 284 5 view .LVU353
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 993              		.loc 1 284 10 is_stmt 0 view .LVU354
 994 0192 94F88C10 		ldrb	r1, [r4, #140]	@ zero_extendqisi2
 995              	.LVL82:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 996              		.loc 1 286 5 is_stmt 1 view .LVU355
 997              	.LBE80:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 998              		.loc 1 283 35 is_stmt 0 view .LVU356
 999 0196 0420     		movs	r0, #4
 1000              	.LVL83:
 1001              	.L150:
 1002              	.LBB81:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1003              		.loc 1 290 12 is_stmt 1 view .LVU357
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1004              		.loc 1 290 15 is_stmt 0 view .LVU358
 1005 0198 71B1     		cbz	r1, .L105
 1006              	.L329:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1007              		.loc 1 291 7 is_stmt 1 view .LVU359
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1008              		.loc 1 291 7 view .LVU360
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1009              		.loc 1 291 7 view .LVU361
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1010              		.loc 1 294 7 view .LVU362
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
ARM GAS  /tmp/cctR0i1S.s 			page 62


 1011              		.loc 1 294 18 is_stmt 0 view .LVU363
 1012 019a DBF80070 		ldr	r7, [fp]
 1013 019e E66F     		ldr	r6, [r4, #124]
 1014 01a0 B742     		cmp	r7, r6
 1015 01a2 00F0C982 		beq	.L194
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1016              		.loc 1 304 7 is_stmt 1 view .LVU364
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1017              		.loc 1 304 10 is_stmt 0 view .LVU365
 1018 01a6 0129     		cmp	r1, #1
 1019 01a8 B4F88A70 		ldrh	r7, [r4, #138]
 1020 01ac 00F09781 		beq	.L106
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 1021              		.loc 1 320 14 is_stmt 1 view .LVU366
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1022              		.loc 1 327 11 view .LVU367
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1023              		.loc 1 327 14 is_stmt 0 view .LVU368
 1024 01b0 7745     		cmp	r7, lr
 1025 01b2 01D3     		bcc	.L105
 1026 01b4 BE46     		mov	lr, r7
 1027              	.LBE81:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1028              		.loc 1 283 35 view .LVU369
 1029 01b6 0525     		movs	r5, #5
 1030              	.LVL84:
 1031              	.L105:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1032              		.loc 1 283 35 is_stmt 1 view .LVU370
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1033              		.loc 1 283 15 view .LVU371
 1034              	.LBB82:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1035              		.loc 1 284 5 view .LVU372
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1036              		.loc 1 286 8 is_stmt 0 view .LVU373
 1037 01b8 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1038              		.loc 1 284 10 view .LVU374
 1039 01ba 94F8A410 		ldrb	r1, [r4, #164]	@ zero_extendqisi2
 1040              	.LVL85:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1041              		.loc 1 286 5 is_stmt 1 view .LVU375
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1042              		.loc 1 286 8 is_stmt 0 view .LVU376
 1043 01be 7FF476AF 		bne	.L149
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1044              		.loc 1 286 8 view .LVU377
 1045 01c2 0029     		cmp	r1, #0
 1046 01c4 7FF474AF 		bne	.L330
 1047              	.LVL86:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1048              		.loc 1 286 8 view .LVU378
 1049              	.LBE82:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1050              		.loc 1 283 35 is_stmt 1 view .LVU379
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
ARM GAS  /tmp/cctR0i1S.s 			page 63


 1051              		.loc 1 283 15 view .LVU380
 1052              	.LBB83:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1053              		.loc 1 284 5 view .LVU381
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1054              		.loc 1 284 10 is_stmt 0 view .LVU382
 1055 01c8 94F8BC10 		ldrb	r1, [r4, #188]	@ zero_extendqisi2
 1056              	.LVL87:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1057              		.loc 1 286 5 is_stmt 1 view .LVU383
 1058              	.LBE83:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1059              		.loc 1 283 35 is_stmt 0 view .LVU384
 1060 01cc 0620     		movs	r0, #6
 1061              	.LVL88:
 1062              	.L148:
 1063              	.LBB84:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1064              		.loc 1 290 12 is_stmt 1 view .LVU385
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1065              		.loc 1 290 15 is_stmt 0 view .LVU386
 1066 01ce 79B1     		cbz	r1, .L115
 1067              	.L331:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1068              		.loc 1 291 7 is_stmt 1 view .LVU387
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1069              		.loc 1 291 7 view .LVU388
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1070              		.loc 1 291 7 view .LVU389
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1071              		.loc 1 294 7 view .LVU390
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1072              		.loc 1 294 18 is_stmt 0 view .LVU391
 1073 01d0 DBF80070 		ldr	r7, [fp]
 1074 01d4 D4F8AC60 		ldr	r6, [r4, #172]
 1075 01d8 B742     		cmp	r7, r6
 1076 01da 00F0A782 		beq	.L196
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1077              		.loc 1 304 7 is_stmt 1 view .LVU392
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1078              		.loc 1 304 10 is_stmt 0 view .LVU393
 1079 01de 0129     		cmp	r1, #1
 1080 01e0 B4F8BA70 		ldrh	r7, [r4, #186]
 1081 01e4 00F08581 		beq	.L116
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 1082              		.loc 1 320 14 is_stmt 1 view .LVU394
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1083              		.loc 1 327 11 view .LVU395
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1084              		.loc 1 327 14 is_stmt 0 view .LVU396
 1085 01e8 7745     		cmp	r7, lr
 1086 01ea 01D3     		bcc	.L115
 1087 01ec BE46     		mov	lr, r7
 1088              	.LBE84:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1089              		.loc 1 283 35 view .LVU397
 1090 01ee 0725     		movs	r5, #7
ARM GAS  /tmp/cctR0i1S.s 			page 64


 1091              	.LVL89:
 1092              	.L115:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1093              		.loc 1 283 35 is_stmt 1 view .LVU398
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1094              		.loc 1 283 15 view .LVU399
 1095              	.LBB85:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1096              		.loc 1 284 5 view .LVU400
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1097              		.loc 1 286 8 is_stmt 0 view .LVU401
 1098 01f0 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1099              		.loc 1 284 10 view .LVU402
 1100 01f2 94F8D410 		ldrb	r1, [r4, #212]	@ zero_extendqisi2
 1101              	.LVL90:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1102              		.loc 1 286 5 is_stmt 1 view .LVU403
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1103              		.loc 1 286 8 is_stmt 0 view .LVU404
 1104 01f6 7FF474AF 		bne	.L147
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1105              		.loc 1 286 8 view .LVU405
 1106 01fa 0029     		cmp	r1, #0
 1107 01fc 40F0EB80 		bne	.L332
 1108              	.LVL91:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1109              		.loc 1 286 8 view .LVU406
 1110              	.LBE85:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1111              		.loc 1 283 35 is_stmt 1 view .LVU407
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1112              		.loc 1 283 15 view .LVU408
 1113              	.LBB86:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1114              		.loc 1 284 5 view .LVU409
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1115              		.loc 1 284 10 is_stmt 0 view .LVU410
 1116 0200 94F8EC10 		ldrb	r1, [r4, #236]	@ zero_extendqisi2
 1117              	.LVL92:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1118              		.loc 1 286 5 is_stmt 1 view .LVU411
 1119              	.LBE86:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1120              		.loc 1 283 35 is_stmt 0 view .LVU412
 1121 0204 0820     		movs	r0, #8
 1122              	.LVL93:
 1123              	.L123:
 1124              	.LBB87:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1125              		.loc 1 290 12 is_stmt 1 view .LVU413
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1126              		.loc 1 290 15 is_stmt 0 view .LVU414
 1127 0206 0029     		cmp	r1, #0
 1128 0208 00F0A080 		beq	.L80
 1129              	.L333:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
ARM GAS  /tmp/cctR0i1S.s 			page 65


 1130              		.loc 1 291 7 is_stmt 1 view .LVU415
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1131              		.loc 1 291 7 view .LVU416
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1132              		.loc 1 291 7 view .LVU417
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1133              		.loc 1 294 7 view .LVU418
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1134              		.loc 1 294 18 is_stmt 0 view .LVU419
 1135 020c DBF80070 		ldr	r7, [fp]
 1136 0210 D4F8DC60 		ldr	r6, [r4, #220]
 1137 0214 B742     		cmp	r7, r6
 1138 0216 00F09182 		beq	.L338
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1139              		.loc 1 304 7 is_stmt 1 view .LVU420
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1140              		.loc 1 304 10 is_stmt 0 view .LVU421
 1141 021a 0129     		cmp	r1, #1
 1142 021c B4F8EA70 		ldrh	r7, [r4, #234]
 1143 0220 00F0B281 		beq	.L339
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 1144              		.loc 1 320 14 is_stmt 1 view .LVU422
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1145              		.loc 1 327 11 view .LVU423
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1146              		.loc 1 327 14 is_stmt 0 view .LVU424
 1147 0224 7745     		cmp	r7, lr
 1148 0226 C0F09180 		bcc	.L80
 1149              	.LVL94:
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1150              		.loc 1 327 14 view .LVU425
 1151              	.LBE87:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1152              		.loc 1 283 35 is_stmt 1 view .LVU426
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1153              		.loc 1 283 15 view .LVU427
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 1154              		.loc 1 338 3 view .LVU428
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 1155              		.loc 1 338 6 is_stmt 0 view .LVU429
 1156 022a B9F1010F 		cmp	r9, #1
 1157 022e 40F0B881 		bne	.L201
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 1158              		.loc 1 338 46 view .LVU430
 1159 0232 0A28     		cmp	r0, #10
 1160 0234 7FF465AF 		bne	.L124
 1161              	.LVL95:
 1162              	.L200:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1163              		.loc 1 283 35 view .LVU431
 1164 0238 0925     		movs	r5, #9
 1165              	.LVL96:
 1166              	.L78:
 362:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry
 1167              		.loc 1 362 7 is_stmt 1 view .LVU432
 363:lwIP/src/core/ipv4/etharp.c ****       /* no queued packets should exist on stable entries */
 1168              		.loc 1 363 116 view .LVU433
ARM GAS  /tmp/cctR0i1S.s 			page 66


 365:lwIP/src/core/ipv4/etharp.c ****       /* 3) found recyclable pending entry without queued packets? */
 1169              		.loc 1 365 7 view .LVU434
 365:lwIP/src/core/ipv4/etharp.c ****       /* 3) found recyclable pending entry without queued packets? */
 1170              		.loc 1 365 7 view .LVU435
 1171 023a 05EB4503 		add	r3, r5, r5, lsl #1
 1172 023e 2F46     		mov	r7, r5
 1173 0240 4FEA4508 		lsl	r8, r5, #1
 1174 0244 54F83330 		ldr	r3, [r4, r3, lsl #3]
 1175 0248 002B     		cmp	r3, #0
 1176 024a 00F09E80 		beq	.L131
 365:lwIP/src/core/ipv4/etharp.c ****       /* 3) found recyclable pending entry without queued packets? */
 1177              		.loc 1 365 7 view .LVU436
 1178 024e 0448     		ldr	r0, .L360+8
 1179              	.LVL97:
 365:lwIP/src/core/ipv4/etharp.c ****       /* 3) found recyclable pending entry without queued packets? */
 1180              		.loc 1 365 7 is_stmt 0 view .LVU437
 1181 0250 FFF7FEFF 		bl	printf
 1182              	.LVL98:
 1183              	.L132:
 365:lwIP/src/core/ipv4/etharp.c ****       /* 3) found recyclable pending entry without queued packets? */
 1184              		.loc 1 365 7 is_stmt 1 view .LVU438
 365:lwIP/src/core/ipv4/etharp.c ****       /* 3) found recyclable pending entry without queued packets? */
 1185              		.loc 1 365 7 view .LVU439
 365:lwIP/src/core/ipv4/etharp.c ****       /* 3) found recyclable pending entry without queued packets? */
 1186              		.loc 1 365 7 view .LVU440
 365:lwIP/src/core/ipv4/etharp.c ****       /* 3) found recyclable pending entry without queued packets? */
 1187              		.loc 1 365 7 view .LVU441
 365:lwIP/src/core/ipv4/etharp.c ****       /* 3) found recyclable pending entry without queued packets? */
 1188              		.loc 1 365 7 view .LVU442
 365:lwIP/src/core/ipv4/etharp.c ****       /* 3) found recyclable pending entry without queued packets? */
 1189              		.loc 1 365 7 view .LVU443
 1190 0254 FEE7     		b	.L132
 1191              	.L361:
 1192 0256 00BF     		.align	2
 1193              	.L360:
 1194 0258 00000000 		.word	.LANCHOR0
 1195 025c 18000000 		.word	.LC5
 1196 0260 00000000 		.word	.LC4
 1197              	.LVL99:
 1198              	.L345:
 1199              	.LBB88:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1200              		.loc 1 286 8 is_stmt 0 view .LVU444
 1201 0264 0A20     		movs	r0, #10
 1202              	.LVL100:
 1203              	.L146:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1204              		.loc 1 290 12 is_stmt 1 view .LVU445
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1205              		.loc 1 290 15 is_stmt 0 view .LVU446
 1206 0266 67B1     		cbz	r7, .L35
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1207              		.loc 1 291 7 is_stmt 1 view .LVU447
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1208              		.loc 1 291 7 view .LVU448
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1209              		.loc 1 291 7 view .LVU449
ARM GAS  /tmp/cctR0i1S.s 			page 67


 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1210              		.loc 1 294 7 view .LVU450
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1211              		.loc 1 304 7 view .LVU451
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1212              		.loc 1 304 10 is_stmt 0 view .LVU452
 1213 0268 012F     		cmp	r7, #1
 1214 026a B4F82AA0 		ldrh	r10, [r4, #42]
 1215 026e 40F06782 		bne	.L36
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1216              		.loc 1 306 9 is_stmt 1 view .LVU453
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1217              		.loc 1 306 12 is_stmt 0 view .LVU454
 1218 0272 A669     		ldr	r6, [r4, #24]
 1219 0274 002E     		cmp	r6, #0
 1220 0276 00F07082 		beq	.L37
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1221              		.loc 1 307 11 is_stmt 1 view .LVU455
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1222              		.loc 1 307 14 is_stmt 0 view .LVU456
 1223 027a F245     		cmp	r10, lr
 1224 027c 01D3     		bcc	.L35
 1225              	.LVL101:
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1226              		.loc 1 307 14 view .LVU457
 1227 027e D646     		mov	lr, r10
 1228              	.LVL102:
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1229              		.loc 1 307 14 view .LVU458
 1230              	.LBE88:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1231              		.loc 1 283 35 view .LVU459
 1232 0280 3B46     		mov	r3, r7
 1233              	.LVL103:
 1234              	.L35:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1235              		.loc 1 283 35 is_stmt 1 view .LVU460
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1236              		.loc 1 283 15 view .LVU461
 1237              	.LBB89:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1238              		.loc 1 284 5 view .LVU462
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1239              		.loc 1 286 8 is_stmt 0 view .LVU463
 1240 0282 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1241              		.loc 1 284 10 view .LVU464
 1242 0284 94F84470 		ldrb	r7, [r4, #68]	@ zero_extendqisi2
 1243              	.LVL104:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1244              		.loc 1 286 5 is_stmt 1 view .LVU465
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1245              		.loc 1 286 8 is_stmt 0 view .LVU466
 1246 0288 40F0C980 		bne	.L145
 1247 028c 002F     		cmp	r7, #0
 1248 028e 40F0C780 		bne	.L318
 1249              	.LVL105:
ARM GAS  /tmp/cctR0i1S.s 			page 68


 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1250              		.loc 1 286 8 view .LVU467
 1251              	.LBE89:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1252              		.loc 1 283 35 is_stmt 1 view .LVU468
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1253              		.loc 1 283 15 view .LVU469
 1254              	.LBB90:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1255              		.loc 1 284 5 view .LVU470
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1256              		.loc 1 284 10 is_stmt 0 view .LVU471
 1257 0292 94F85C70 		ldrb	r7, [r4, #92]	@ zero_extendqisi2
 1258              	.LVL106:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1259              		.loc 1 286 5 is_stmt 1 view .LVU472
 1260              	.LBE90:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1261              		.loc 1 283 35 is_stmt 0 view .LVU473
 1262 0296 0220     		movs	r0, #2
 1263              	.LVL107:
 1264              	.L144:
 1265              	.LBB91:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1266              		.loc 1 290 12 is_stmt 1 view .LVU474
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1267              		.loc 1 290 15 is_stmt 0 view .LVU475
 1268 0298 67B1     		cbz	r7, .L45
 1269              	.L319:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1270              		.loc 1 291 7 is_stmt 1 view .LVU476
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1271              		.loc 1 291 7 view .LVU477
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1272              		.loc 1 291 7 view .LVU478
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1273              		.loc 1 294 7 view .LVU479
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1274              		.loc 1 304 7 view .LVU480
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1275              		.loc 1 304 10 is_stmt 0 view .LVU481
 1276 029a 012F     		cmp	r7, #1
 1277 029c B4F85A80 		ldrh	r8, [r4, #90]
 1278 02a0 40F02382 		bne	.L46
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1279              		.loc 1 306 9 is_stmt 1 view .LVU482
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1280              		.loc 1 306 12 is_stmt 0 view .LVU483
 1281 02a4 A76C     		ldr	r7, [r4, #72]
 1282              	.LVL108:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1283              		.loc 1 306 12 view .LVU484
 1284 02a6 002F     		cmp	r7, #0
 1285 02a8 00F02E82 		beq	.L47
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1286              		.loc 1 307 11 is_stmt 1 view .LVU485
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
ARM GAS  /tmp/cctR0i1S.s 			page 69


 1287              		.loc 1 307 14 is_stmt 0 view .LVU486
 1288 02ac F045     		cmp	r8, lr
 1289 02ae 01D3     		bcc	.L45
 1290 02b0 C646     		mov	lr, r8
 1291              	.LBE91:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1292              		.loc 1 283 35 view .LVU487
 1293 02b2 0323     		movs	r3, #3
 1294              	.L45:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1295              		.loc 1 283 35 is_stmt 1 view .LVU488
 1296              	.LVL109:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1297              		.loc 1 283 15 view .LVU489
 1298              	.LBB92:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1299              		.loc 1 284 5 view .LVU490
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1300              		.loc 1 286 8 is_stmt 0 view .LVU491
 1301 02b4 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1302              		.loc 1 284 10 view .LVU492
 1303 02b6 94F87470 		ldrb	r7, [r4, #116]	@ zero_extendqisi2
 1304              	.LVL110:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1305              		.loc 1 286 5 is_stmt 1 view .LVU493
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1306              		.loc 1 286 8 is_stmt 0 view .LVU494
 1307 02ba 40F0C580 		bne	.L143
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1308              		.loc 1 286 8 view .LVU495
 1309 02be 002F     		cmp	r7, #0
 1310 02c0 40F0C380 		bne	.L320
 1311              	.LVL111:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1312              		.loc 1 286 8 view .LVU496
 1313              	.LBE92:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1314              		.loc 1 283 35 is_stmt 1 view .LVU497
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1315              		.loc 1 283 15 view .LVU498
 1316              	.LBB93:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1317              		.loc 1 284 5 view .LVU499
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1318              		.loc 1 284 10 is_stmt 0 view .LVU500
 1319 02c4 94F88C70 		ldrb	r7, [r4, #140]	@ zero_extendqisi2
 1320              	.LVL112:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1321              		.loc 1 286 5 is_stmt 1 view .LVU501
 1322              	.LBE93:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1323              		.loc 1 283 35 is_stmt 0 view .LVU502
 1324 02c8 0420     		movs	r0, #4
 1325              	.LVL113:
 1326              	.L142:
 1327              	.LBB94:
ARM GAS  /tmp/cctR0i1S.s 			page 70


 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1328              		.loc 1 290 12 is_stmt 1 view .LVU503
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1329              		.loc 1 290 15 is_stmt 0 view .LVU504
 1330 02ca 67B1     		cbz	r7, .L55
 1331              	.L321:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1332              		.loc 1 291 7 is_stmt 1 view .LVU505
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1333              		.loc 1 291 7 view .LVU506
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1334              		.loc 1 291 7 view .LVU507
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1335              		.loc 1 294 7 view .LVU508
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1336              		.loc 1 304 7 view .LVU509
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1337              		.loc 1 304 10 is_stmt 0 view .LVU510
 1338 02cc 012F     		cmp	r7, #1
 1339 02ce B4F88A80 		ldrh	r8, [r4, #138]
 1340 02d2 40F0DC81 		bne	.L56
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1341              		.loc 1 306 9 is_stmt 1 view .LVU511
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1342              		.loc 1 306 12 is_stmt 0 view .LVU512
 1343 02d6 A76F     		ldr	r7, [r4, #120]
 1344              	.LVL114:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1345              		.loc 1 306 12 view .LVU513
 1346 02d8 002F     		cmp	r7, #0
 1347 02da 00F0E481 		beq	.L57
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1348              		.loc 1 307 11 is_stmt 1 view .LVU514
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1349              		.loc 1 307 14 is_stmt 0 view .LVU515
 1350 02de F045     		cmp	r8, lr
 1351 02e0 01D3     		bcc	.L55
 1352 02e2 C646     		mov	lr, r8
 1353              	.LBE94:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1354              		.loc 1 283 35 view .LVU516
 1355 02e4 0523     		movs	r3, #5
 1356              	.L55:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1357              		.loc 1 283 35 is_stmt 1 view .LVU517
 1358              	.LVL115:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1359              		.loc 1 283 15 view .LVU518
 1360              	.LBB95:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1361              		.loc 1 284 5 view .LVU519
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1362              		.loc 1 286 8 is_stmt 0 view .LVU520
 1363 02e6 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1364              		.loc 1 284 10 view .LVU521
 1365 02e8 94F8A470 		ldrb	r7, [r4, #164]	@ zero_extendqisi2
ARM GAS  /tmp/cctR0i1S.s 			page 71


 1366              	.LVL116:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1367              		.loc 1 286 5 is_stmt 1 view .LVU522
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1368              		.loc 1 286 8 is_stmt 0 view .LVU523
 1369 02ec 40F0C180 		bne	.L141
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1370              		.loc 1 286 8 view .LVU524
 1371 02f0 002F     		cmp	r7, #0
 1372 02f2 40F0BF80 		bne	.L322
 1373              	.LVL117:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1374              		.loc 1 286 8 view .LVU525
 1375              	.LBE95:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1376              		.loc 1 283 35 is_stmt 1 view .LVU526
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1377              		.loc 1 283 15 view .LVU527
 1378              	.LBB96:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1379              		.loc 1 284 5 view .LVU528
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1380              		.loc 1 284 10 is_stmt 0 view .LVU529
 1381 02f6 94F8BC70 		ldrb	r7, [r4, #188]	@ zero_extendqisi2
 1382              	.LVL118:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1383              		.loc 1 286 5 is_stmt 1 view .LVU530
 1384              	.LBE96:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1385              		.loc 1 283 35 is_stmt 0 view .LVU531
 1386 02fa 0620     		movs	r0, #6
 1387              	.LVL119:
 1388              	.L140:
 1389              	.LBB97:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1390              		.loc 1 290 12 is_stmt 1 view .LVU532
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1391              		.loc 1 290 15 is_stmt 0 view .LVU533
 1392 02fc 6FB1     		cbz	r7, .L65
 1393              	.L323:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1394              		.loc 1 291 7 is_stmt 1 view .LVU534
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1395              		.loc 1 291 7 view .LVU535
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1396              		.loc 1 291 7 view .LVU536
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1397              		.loc 1 294 7 view .LVU537
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1398              		.loc 1 304 7 view .LVU538
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1399              		.loc 1 304 10 is_stmt 0 view .LVU539
 1400 02fe 012F     		cmp	r7, #1
 1401 0300 B4F8BA80 		ldrh	r8, [r4, #186]
 1402 0304 40F09B81 		bne	.L66
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1403              		.loc 1 306 9 is_stmt 1 view .LVU540
ARM GAS  /tmp/cctR0i1S.s 			page 72


 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1404              		.loc 1 306 12 is_stmt 0 view .LVU541
 1405 0308 D4F8A870 		ldr	r7, [r4, #168]
 1406              	.LVL120:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1407              		.loc 1 306 12 view .LVU542
 1408 030c 002F     		cmp	r7, #0
 1409 030e 00F0A981 		beq	.L67
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1410              		.loc 1 307 11 is_stmt 1 view .LVU543
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1411              		.loc 1 307 14 is_stmt 0 view .LVU544
 1412 0312 F045     		cmp	r8, lr
 1413 0314 01D3     		bcc	.L65
 1414 0316 C646     		mov	lr, r8
 1415              	.LBE97:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1416              		.loc 1 283 35 view .LVU545
 1417 0318 0723     		movs	r3, #7
 1418              	.L65:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1419              		.loc 1 283 35 is_stmt 1 view .LVU546
 1420              	.LVL121:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1421              		.loc 1 283 15 view .LVU547
 1422              	.LBB98:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1423              		.loc 1 284 5 view .LVU548
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1424              		.loc 1 286 8 is_stmt 0 view .LVU549
 1425 031a 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1426              		.loc 1 284 10 view .LVU550
 1427 031c 94F8D470 		ldrb	r7, [r4, #212]	@ zero_extendqisi2
 1428              	.LVL122:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1429              		.loc 1 286 5 is_stmt 1 view .LVU551
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1430              		.loc 1 286 8 is_stmt 0 view .LVU552
 1431 0320 40F0BC80 		bne	.L139
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1432              		.loc 1 286 8 view .LVU553
 1433 0324 002F     		cmp	r7, #0
 1434 0326 40F0BA80 		bne	.L324
 1435              	.LVL123:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1436              		.loc 1 286 8 view .LVU554
 1437              	.LBE98:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1438              		.loc 1 283 35 is_stmt 1 view .LVU555
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1439              		.loc 1 283 15 view .LVU556
 1440              	.LBB99:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1441              		.loc 1 284 5 view .LVU557
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1442              		.loc 1 284 10 is_stmt 0 view .LVU558
ARM GAS  /tmp/cctR0i1S.s 			page 73


 1443 032a 94F8EC70 		ldrb	r7, [r4, #236]	@ zero_extendqisi2
 1444              	.LVL124:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1445              		.loc 1 286 5 is_stmt 1 view .LVU559
 1446              	.LBE99:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1447              		.loc 1 283 35 is_stmt 0 view .LVU560
 1448 032e 0820     		movs	r0, #8
 1449              	.LVL125:
 1450              	.L73:
 1451              	.LBB100:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1452              		.loc 1 290 12 is_stmt 1 view .LVU561
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1453              		.loc 1 290 15 is_stmt 0 view .LVU562
 1454 0330 67B1     		cbz	r7, .L80
 1455              	.L325:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1456              		.loc 1 291 7 is_stmt 1 view .LVU563
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1457              		.loc 1 291 7 view .LVU564
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1458              		.loc 1 291 7 view .LVU565
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1459              		.loc 1 294 7 view .LVU566
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1460              		.loc 1 304 7 view .LVU567
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1461              		.loc 1 304 10 is_stmt 0 view .LVU568
 1462 0332 012F     		cmp	r7, #1
 1463 0334 B4F8EA80 		ldrh	r8, [r4, #234]
 1464 0338 40F07781 		bne	.L340
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1465              		.loc 1 306 9 is_stmt 1 view .LVU569
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1466              		.loc 1 306 12 is_stmt 0 view .LVU570
 1467 033c D4F8D870 		ldr	r7, [r4, #216]
 1468              	.LVL126:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1469              		.loc 1 306 12 view .LVU571
 1470 0340 002F     		cmp	r7, #0
 1471 0342 00F08B81 		beq	.L341
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1472              		.loc 1 307 11 is_stmt 1 view .LVU572
 1473              	.LBE100:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1474              		.loc 1 283 35 is_stmt 0 view .LVU573
 1475 0346 F045     		cmp	r8, lr
 1476 0348 28BF     		it	cs
 1477 034a 0923     		movcs	r3, #9
 1478              	.L80:
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 1479              		.loc 1 338 3 is_stmt 1 view .LVU574
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 1480              		.loc 1 338 6 is_stmt 0 view .LVU575
 1481 034c B9F1010F 		cmp	r9, #1
 1482 0350 40F02781 		bne	.L201
ARM GAS  /tmp/cctR0i1S.s 			page 74


 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 1483              		.loc 1 338 46 view .LVU576
 1484 0354 0A28     		cmp	r0, #10
 1485 0356 40F02781 		bne	.L129
 355:lwIP/src/core/ipv4/etharp.c ****     i = empty;
 1486              		.loc 1 355 3 is_stmt 1 view .LVU577
 360:lwIP/src/core/ipv4/etharp.c ****       /* recycle oldest stable*/
 1487              		.loc 1 360 5 view .LVU578
 360:lwIP/src/core/ipv4/etharp.c ****       /* recycle oldest stable*/
 1488              		.loc 1 360 8 is_stmt 0 view .LVU579
 1489 035a 0A2D     		cmp	r5, #10
 1490 035c 7FF46DAF 		bne	.L78
 367:lwIP/src/core/ipv4/etharp.c ****       /* recycle oldest pending */
 1491              		.loc 1 367 12 is_stmt 1 view .LVU580
 367:lwIP/src/core/ipv4/etharp.c ****       /* recycle oldest pending */
 1492              		.loc 1 367 15 is_stmt 0 view .LVU581
 1493 0360 0A2A     		cmp	r2, #10
 1494 0362 36D1     		bne	.L202
 372:lwIP/src/core/ipv4/etharp.c ****       /* recycle oldest pending (queued packets are free in etharp_free_entry) */
 1495              		.loc 1 372 12 is_stmt 1 view .LVU582
 372:lwIP/src/core/ipv4/etharp.c ****       /* recycle oldest pending (queued packets are free in etharp_free_entry) */
 1496              		.loc 1 372 15 is_stmt 0 view .LVU583
 1497 0364 0A2B     		cmp	r3, #10
 1498 0366 00F01C81 		beq	.L201
 1499 036a 1D46     		mov	r5, r3
 1500              	.L133:
 1501              	.LVL127:
 383:lwIP/src/core/ipv4/etharp.c ****     etharp_free_entry(i);
 1502              		.loc 1 383 5 is_stmt 1 view .LVU584
 383:lwIP/src/core/ipv4/etharp.c ****     etharp_free_entry(i);
 1503              		.loc 1 383 5 view .LVU585
 383:lwIP/src/core/ipv4/etharp.c ****     etharp_free_entry(i);
 1504              		.loc 1 383 5 view .LVU586
 384:lwIP/src/core/ipv4/etharp.c ****   }
 1505              		.loc 1 384 5 view .LVU587
 1506              	.LBB101:
 1507              	.LBB102:
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 1508              		.loc 1 173 19 is_stmt 0 view .LVU588
 1509 036c 05EB4509 		add	r9, r5, r5, lsl #1
 1510              	.LBE102:
 1511              	.LBE101:
 384:lwIP/src/core/ipv4/etharp.c ****   }
 1512              		.loc 1 384 5 view .LVU589
 1513 0370 2F46     		mov	r7, r5
 1514              	.LVL128:
 1515              	.LBB104:
 1516              	.LBI101:
 168:lwIP/src/core/ipv4/etharp.c **** {
 1517              		.loc 1 168 1 is_stmt 1 view .LVU590
 1518              	.LBB103:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 1519              		.loc 1 171 66 view .LVU591
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 1520              		.loc 1 173 3 view .LVU592
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 1521              		.loc 1 173 19 is_stmt 0 view .LVU593
ARM GAS  /tmp/cctR0i1S.s 			page 75


 1522 0372 4FEA4508 		lsl	r8, r5, #1
 1523 0376 4FEAC909 		lsl	r9, r9, #3
 1524 037a 54F80900 		ldr	r0, [r4, r9]
 1525              	.LVL129:
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 1526              		.loc 1 173 6 view .LVU594
 1527 037e 20B1     		cbz	r0, .L131
 1528              	.LVL130:
 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 1529              		.loc 1 175 133 is_stmt 1 view .LVU595
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 1530              		.loc 1 176 5 view .LVU596
 1531 0380 FFF7FEFF 		bl	pbuf_free
 1532              	.LVL131:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 1533              		.loc 1 177 5 view .LVU597
 177:lwIP/src/core/ipv4/etharp.c ****   }
 1534              		.loc 1 177 20 is_stmt 0 view .LVU598
 1535 0384 0023     		movs	r3, #0
 1536 0386 44F80930 		str	r3, [r4, r9]
 1537              	.LVL132:
 1538              	.L131:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 1539              		.loc 1 180 3 is_stmt 1 view .LVU599
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 1540              		.loc 1 180 22 is_stmt 0 view .LVU600
 1541 038a 08EB0503 		add	r3, r8, r5
 1542 038e 0022     		movs	r2, #0
 1543 0390 2846     		mov	r0, r5
 1544 0392 04EBC303 		add	r3, r4, r3, lsl #3
 1545 0396 1A75     		strb	r2, [r3, #20]
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 1546              		.loc 1 180 22 view .LVU601
 1547              	.LBE103:
 1548              	.LBE104:
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 1549              		.loc 1 387 3 is_stmt 1 view .LVU602
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 1550              		.loc 1 387 3 view .LVU603
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 1551              		.loc 1 387 3 view .LVU604
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 1552              		.loc 1 388 3 view .LVU605
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 1553              		.loc 1 388 3 view .LVU606
 1554              	.L134:
 1555              	.LVL133:
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 1556              		.loc 1 388 3 view .LVU607
 392:lwIP/src/core/ipv4/etharp.c ****     /* set IP address */
 1557              		.loc 1 392 3 view .LVU608
 392:lwIP/src/core/ipv4/etharp.c ****     /* set IP address */
 1558              		.loc 1 392 6 is_stmt 0 view .LVU609
 1559 0398 BBF1000F 		cmp	fp, #0
 1560 039c 00F03781 		beq	.L342
 1561              	.L155:
 394:lwIP/src/core/ipv4/etharp.c ****   }
ARM GAS  /tmp/cctR0i1S.s 			page 76


 1562              		.loc 1 394 5 is_stmt 1 view .LVU610
 1563 03a0 07EB4702 		add	r2, r7, r7, lsl #1
 1564 03a4 DBF80010 		ldr	r1, [fp]
 1565 03a8 7B00     		lsls	r3, r7, #1
 1566 03aa 04EBC202 		add	r2, r4, r2, lsl #3
 1567 03ae 5160     		str	r1, [r2, #4]
 1568              	.L136:
 1569              	.LVL134:
 396:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1570              		.loc 1 396 3 view .LVU611
 396:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1571              		.loc 1 396 22 is_stmt 0 view .LVU612
 1572 03b0 3B44     		add	r3, r3, r7
 1573 03b2 0022     		movs	r2, #0
 1574 03b4 04EBC304 		add	r4, r4, r3, lsl #3
 1575 03b8 6282     		strh	r2, [r4, #18]	@ movhi
 400:lwIP/src/core/ipv4/etharp.c **** }
 1576              		.loc 1 400 3 is_stmt 1 view .LVU613
 1577              	.L317:
 401:lwIP/src/core/ipv4/etharp.c **** 
 1578              		.loc 1 401 1 is_stmt 0 view .LVU614
 1579 03ba BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1580              	.LVL135:
 1581              	.L335:
 1582              	.LBB105:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1583              		.loc 1 284 5 is_stmt 1 view .LVU615
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1584              		.loc 1 286 5 view .LVU616
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1585              		.loc 1 286 8 is_stmt 0 view .LVU617
 1586 03be E3B9     		cbnz	r3, .L343
 1587              	.LVL136:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1588              		.loc 1 286 8 view .LVU618
 1589              	.LBE105:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1590              		.loc 1 283 35 is_stmt 1 view .LVU619
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1591              		.loc 1 283 15 view .LVU620
 1592              	.LBB106:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1593              		.loc 1 284 5 view .LVU621
 1594              	.LBE106:
 262:lwIP/src/core/ipv4/etharp.c ****   /* its age */
 1595              		.loc 1 262 9 is_stmt 0 view .LVU622
 1596 03c0 0A23     		movs	r3, #10
 1597              	.LVL137:
 1598              	.LBB107:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1599              		.loc 1 284 10 view .LVU623
 1600 03c2 94F82C70 		ldrb	r7, [r4, #44]	@ zero_extendqisi2
 1601              	.LVL138:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1602              		.loc 1 286 5 is_stmt 1 view .LVU624
 1603              	.LBE107:
 264:lwIP/src/core/ipv4/etharp.c **** 
ARM GAS  /tmp/cctR0i1S.s 			page 77


 1604              		.loc 1 264 41 is_stmt 0 view .LVU625
 1605 03c6 8446     		mov	ip, r0
 264:lwIP/src/core/ipv4/etharp.c **** 
 1606              		.loc 1 264 24 view .LVU626
 1607 03c8 0146     		mov	r1, r0
 1608              	.LVL139:
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 1609              		.loc 1 258 9 view .LVU627
 1610 03ca 1A46     		mov	r2, r3
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 1611              		.loc 1 258 39 view .LVU628
 1612 03cc 1D46     		mov	r5, r3
 264:lwIP/src/core/ipv4/etharp.c **** 
 1613              		.loc 1 264 9 view .LVU629
 1614 03ce 8646     		mov	lr, r0
 1615 03d0 49E7     		b	.L146
 1616              	.LVL140:
 1617              	.L202:
 264:lwIP/src/core/ipv4/etharp.c **** 
 1618              		.loc 1 264 9 view .LVU630
 1619 03d2 1546     		mov	r5, r2
 1620 03d4 CAE7     		b	.L133
 1621              	.LVL141:
 1622              	.L332:
 1623              	.LBB108:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1624              		.loc 1 291 7 is_stmt 1 view .LVU631
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1625              		.loc 1 291 7 view .LVU632
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1626              		.loc 1 291 7 view .LVU633
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1627              		.loc 1 294 7 view .LVU634
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1628              		.loc 1 294 18 is_stmt 0 view .LVU635
 1629 03d6 DBF80070 		ldr	r7, [fp]
 1630 03da D4F8C460 		ldr	r6, [r4, #196]
 1631 03de B742     		cmp	r7, r6
 1632 03e0 00F09E81 		beq	.L197
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1633              		.loc 1 304 7 is_stmt 1 view .LVU636
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1634              		.loc 1 304 10 is_stmt 0 view .LVU637
 1635 03e4 0129     		cmp	r1, #1
 1636 03e6 B4F8D270 		ldrh	r7, [r4, #210]
 1637 03ea 00F0C480 		beq	.L121
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 1638              		.loc 1 320 14 is_stmt 1 view .LVU638
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1639              		.loc 1 327 11 view .LVU639
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1640              		.loc 1 327 14 is_stmt 0 view .LVU640
 1641 03ee 7745     		cmp	r7, lr
 1642 03f0 FFF47AAE 		bcc	.L120
 1643 03f4 BE46     		mov	lr, r7
 1644              	.LBE108:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
ARM GAS  /tmp/cctR0i1S.s 			page 78


 1645              		.loc 1 283 35 view .LVU641
 1646 03f6 0825     		movs	r5, #8
 1647 03f8 76E6     		b	.L120
 1648              	.LVL142:
 1649              	.L343:
 1650              	.LBB109:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1651              		.loc 1 290 12 is_stmt 1 view .LVU642
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1652              		.loc 1 291 7 view .LVU643
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1653              		.loc 1 291 7 view .LVU644
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1654              		.loc 1 291 7 view .LVU645
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1655              		.loc 1 294 7 view .LVU646
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1656              		.loc 1 304 7 view .LVU647
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1657              		.loc 1 304 10 is_stmt 0 view .LVU648
 1658 03fa 012B     		cmp	r3, #1
 1659 03fc 618A     		ldrh	r1, [r4, #18]
 1660              	.LVL143:
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1661              		.loc 1 304 10 view .LVU649
 1662 03fe 00F07A81 		beq	.L344
 1663              	.LBE109:
 262:lwIP/src/core/ipv4/etharp.c ****   /* its age */
 1664              		.loc 1 262 9 view .LVU650
 1665 0402 0A23     		movs	r3, #10
 1666              	.LVL144:
 1667              	.LBB110:
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1668              		.loc 1 304 10 view .LVU651
 1669 0404 8C46     		mov	ip, r1
 1670              	.LBE110:
 264:lwIP/src/core/ipv4/etharp.c **** 
 1671              		.loc 1 264 9 view .LVU652
 1672 0406 8646     		mov	lr, r0
 264:lwIP/src/core/ipv4/etharp.c **** 
 1673              		.loc 1 264 24 view .LVU653
 1674 0408 0146     		mov	r1, r0
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 1675              		.loc 1 258 9 view .LVU654
 1676 040a 1A46     		mov	r2, r3
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1677              		.loc 1 283 10 view .LVU655
 1678 040c 0546     		mov	r5, r0
 1679              	.L33:
 1680              	.LVL145:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1681              		.loc 1 283 35 is_stmt 1 view .LVU656
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1682              		.loc 1 283 15 view .LVU657
 1683              	.LBB111:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1684              		.loc 1 284 5 view .LVU658
ARM GAS  /tmp/cctR0i1S.s 			page 79


 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1685              		.loc 1 284 10 is_stmt 0 view .LVU659
 1686 040e 94F82C70 		ldrb	r7, [r4, #44]	@ zero_extendqisi2
 1687              	.LVL146:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1688              		.loc 1 286 5 is_stmt 1 view .LVU660
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1689              		.loc 1 286 8 is_stmt 0 view .LVU661
 1690 0412 002F     		cmp	r7, #0
 1691 0414 7FF426AF 		bne	.L345
 1692              	.LVL147:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1693              		.loc 1 286 8 view .LVU662
 1694              	.LBE111:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1695              		.loc 1 283 35 is_stmt 1 view .LVU663
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1696              		.loc 1 283 15 view .LVU664
 1697              	.LBB112:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1698              		.loc 1 284 5 view .LVU665
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1699              		.loc 1 284 10 is_stmt 0 view .LVU666
 1700 0418 94F84470 		ldrb	r7, [r4, #68]	@ zero_extendqisi2
 1701              	.LVL148:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1702              		.loc 1 286 5 is_stmt 1 view .LVU667
 1703              	.LBE112:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1704              		.loc 1 283 35 is_stmt 0 view .LVU668
 1705 041c 0120     		movs	r0, #1
 1706              	.LVL149:
 1707              	.L145:
 1708              	.LBB113:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1709              		.loc 1 290 12 is_stmt 1 view .LVU669
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1710              		.loc 1 290 15 is_stmt 0 view .LVU670
 1711 041e 47B1     		cbz	r7, .L40
 1712              	.L318:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1713              		.loc 1 291 7 is_stmt 1 view .LVU671
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1714              		.loc 1 291 7 view .LVU672
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1715              		.loc 1 291 7 view .LVU673
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1716              		.loc 1 294 7 view .LVU674
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1717              		.loc 1 304 7 view .LVU675
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1718              		.loc 1 304 10 is_stmt 0 view .LVU676
 1719 0420 012F     		cmp	r7, #1
 1720 0422 B4F84280 		ldrh	r8, [r4, #66]
 1721 0426 00F04C81 		beq	.L346
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 1722              		.loc 1 320 14 is_stmt 1 view .LVU677
ARM GAS  /tmp/cctR0i1S.s 			page 80


 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1723              		.loc 1 327 11 view .LVU678
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1724              		.loc 1 327 14 is_stmt 0 view .LVU679
 1725 042a E045     		cmp	r8, ip
 1726 042c 01D3     		bcc	.L40
 1727 042e C446     		mov	ip, r8
 1728              	.LBE113:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1729              		.loc 1 283 35 view .LVU680
 1730 0430 0225     		movs	r5, #2
 1731              	.LVL150:
 1732              	.L40:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1733              		.loc 1 283 35 is_stmt 1 view .LVU681
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1734              		.loc 1 283 15 view .LVU682
 1735              	.LBB114:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1736              		.loc 1 284 5 view .LVU683
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1737              		.loc 1 286 8 is_stmt 0 view .LVU684
 1738 0432 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1739              		.loc 1 284 10 view .LVU685
 1740 0434 94F85C70 		ldrb	r7, [r4, #92]	@ zero_extendqisi2
 1741              	.LVL151:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1742              		.loc 1 286 5 is_stmt 1 view .LVU686
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1743              		.loc 1 286 8 is_stmt 0 view .LVU687
 1744 0438 7FF42EAF 		bne	.L144
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1745              		.loc 1 286 8 view .LVU688
 1746 043c 002F     		cmp	r7, #0
 1747 043e 7FF42CAF 		bne	.L319
 1748              	.LVL152:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1749              		.loc 1 286 8 view .LVU689
 1750              	.LBE114:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1751              		.loc 1 283 35 is_stmt 1 view .LVU690
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1752              		.loc 1 283 15 view .LVU691
 1753              	.LBB115:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1754              		.loc 1 284 5 view .LVU692
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1755              		.loc 1 284 10 is_stmt 0 view .LVU693
 1756 0442 94F87470 		ldrb	r7, [r4, #116]	@ zero_extendqisi2
 1757              	.LVL153:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1758              		.loc 1 286 5 is_stmt 1 view .LVU694
 1759              	.LBE115:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1760              		.loc 1 283 35 is_stmt 0 view .LVU695
 1761 0446 0320     		movs	r0, #3
ARM GAS  /tmp/cctR0i1S.s 			page 81


 1762              	.LVL154:
 1763              	.L143:
 1764              	.LBB116:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1765              		.loc 1 290 12 is_stmt 1 view .LVU696
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1766              		.loc 1 290 15 is_stmt 0 view .LVU697
 1767 0448 47B1     		cbz	r7, .L50
 1768              	.L320:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1769              		.loc 1 291 7 is_stmt 1 view .LVU698
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1770              		.loc 1 291 7 view .LVU699
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1771              		.loc 1 291 7 view .LVU700
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1772              		.loc 1 294 7 view .LVU701
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1773              		.loc 1 304 7 view .LVU702
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1774              		.loc 1 304 10 is_stmt 0 view .LVU703
 1775 044a 012F     		cmp	r7, #1
 1776 044c B4F87280 		ldrh	r8, [r4, #114]
 1777 0450 00F02F81 		beq	.L347
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 1778              		.loc 1 320 14 is_stmt 1 view .LVU704
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1779              		.loc 1 327 11 view .LVU705
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1780              		.loc 1 327 14 is_stmt 0 view .LVU706
 1781 0454 E045     		cmp	r8, ip
 1782 0456 01D3     		bcc	.L50
 1783 0458 C446     		mov	ip, r8
 1784              	.LBE116:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1785              		.loc 1 283 35 view .LVU707
 1786 045a 0425     		movs	r5, #4
 1787              	.LVL155:
 1788              	.L50:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1789              		.loc 1 283 35 is_stmt 1 view .LVU708
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1790              		.loc 1 283 15 view .LVU709
 1791              	.LBB117:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1792              		.loc 1 284 5 view .LVU710
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1793              		.loc 1 286 8 is_stmt 0 view .LVU711
 1794 045c 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1795              		.loc 1 284 10 view .LVU712
 1796 045e 94F88C70 		ldrb	r7, [r4, #140]	@ zero_extendqisi2
 1797              	.LVL156:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1798              		.loc 1 286 5 is_stmt 1 view .LVU713
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1799              		.loc 1 286 8 is_stmt 0 view .LVU714
ARM GAS  /tmp/cctR0i1S.s 			page 82


 1800 0462 7FF432AF 		bne	.L142
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1801              		.loc 1 286 8 view .LVU715
 1802 0466 002F     		cmp	r7, #0
 1803 0468 7FF430AF 		bne	.L321
 1804              	.LVL157:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1805              		.loc 1 286 8 view .LVU716
 1806              	.LBE117:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1807              		.loc 1 283 35 is_stmt 1 view .LVU717
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1808              		.loc 1 283 15 view .LVU718
 1809              	.LBB118:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1810              		.loc 1 284 5 view .LVU719
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1811              		.loc 1 284 10 is_stmt 0 view .LVU720
 1812 046c 94F8A470 		ldrb	r7, [r4, #164]	@ zero_extendqisi2
 1813              	.LVL158:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1814              		.loc 1 286 5 is_stmt 1 view .LVU721
 1815              	.LBE118:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1816              		.loc 1 283 35 is_stmt 0 view .LVU722
 1817 0470 0520     		movs	r0, #5
 1818              	.LVL159:
 1819              	.L141:
 1820              	.LBB119:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1821              		.loc 1 290 12 is_stmt 1 view .LVU723
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1822              		.loc 1 290 15 is_stmt 0 view .LVU724
 1823 0472 47B1     		cbz	r7, .L60
 1824              	.L322:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1825              		.loc 1 291 7 is_stmt 1 view .LVU725
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1826              		.loc 1 291 7 view .LVU726
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1827              		.loc 1 291 7 view .LVU727
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1828              		.loc 1 294 7 view .LVU728
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1829              		.loc 1 304 7 view .LVU729
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1830              		.loc 1 304 10 is_stmt 0 view .LVU730
 1831 0474 012F     		cmp	r7, #1
 1832 0476 B4F8A280 		ldrh	r8, [r4, #162]
 1833 047a 00F0FF80 		beq	.L348
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 1834              		.loc 1 320 14 is_stmt 1 view .LVU731
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1835              		.loc 1 327 11 view .LVU732
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1836              		.loc 1 327 14 is_stmt 0 view .LVU733
 1837 047e E045     		cmp	r8, ip
ARM GAS  /tmp/cctR0i1S.s 			page 83


 1838 0480 01D3     		bcc	.L60
 1839 0482 C446     		mov	ip, r8
 1840              	.LBE119:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1841              		.loc 1 283 35 view .LVU734
 1842 0484 0625     		movs	r5, #6
 1843              	.LVL160:
 1844              	.L60:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1845              		.loc 1 283 35 is_stmt 1 view .LVU735
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1846              		.loc 1 283 15 view .LVU736
 1847              	.LBB120:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1848              		.loc 1 284 5 view .LVU737
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1849              		.loc 1 286 8 is_stmt 0 view .LVU738
 1850 0486 0A28     		cmp	r0, #10
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1851              		.loc 1 284 10 view .LVU739
 1852 0488 94F8BC70 		ldrb	r7, [r4, #188]	@ zero_extendqisi2
 1853              	.LVL161:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1854              		.loc 1 286 5 is_stmt 1 view .LVU740
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1855              		.loc 1 286 8 is_stmt 0 view .LVU741
 1856 048c 7FF436AF 		bne	.L140
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1857              		.loc 1 286 8 view .LVU742
 1858 0490 002F     		cmp	r7, #0
 1859 0492 7FF434AF 		bne	.L323
 1860              	.LVL162:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1861              		.loc 1 286 8 view .LVU743
 1862              	.LBE120:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1863              		.loc 1 283 35 is_stmt 1 view .LVU744
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1864              		.loc 1 283 15 view .LVU745
 1865              	.LBB121:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1866              		.loc 1 284 5 view .LVU746
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1867              		.loc 1 284 10 is_stmt 0 view .LVU747
 1868 0496 94F8D470 		ldrb	r7, [r4, #212]	@ zero_extendqisi2
 1869              	.LVL163:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1870              		.loc 1 286 5 is_stmt 1 view .LVU748
 1871              	.LBE121:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1872              		.loc 1 283 35 is_stmt 0 view .LVU749
 1873 049a 0720     		movs	r0, #7
 1874              	.LVL164:
 1875              	.L139:
 1876              	.LBB122:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1877              		.loc 1 290 12 is_stmt 1 view .LVU750
ARM GAS  /tmp/cctR0i1S.s 			page 84


 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 1878              		.loc 1 290 15 is_stmt 0 view .LVU751
 1879 049c 47B1     		cbz	r7, .L70
 1880              	.L324:
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1881              		.loc 1 291 7 is_stmt 1 view .LVU752
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1882              		.loc 1 291 7 view .LVU753
 291:lwIP/src/core/ipv4/etharp.c ****                   state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
 1883              		.loc 1 291 7 view .LVU754
 294:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 1884              		.loc 1 294 7 view .LVU755
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1885              		.loc 1 304 7 view .LVU756
 304:lwIP/src/core/ipv4/etharp.c ****         /* pending with queued packets? */
 1886              		.loc 1 304 10 is_stmt 0 view .LVU757
 1887 049e 012F     		cmp	r7, #1
 1888 04a0 B4F8D280 		ldrh	r8, [r4, #210]
 1889 04a4 00F0D180 		beq	.L349
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 1890              		.loc 1 320 14 is_stmt 1 view .LVU758
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1891              		.loc 1 327 11 view .LVU759
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 1892              		.loc 1 327 14 is_stmt 0 view .LVU760
 1893 04a8 E045     		cmp	r8, ip
 1894 04aa 01D3     		bcc	.L70
 1895 04ac C446     		mov	ip, r8
 1896              	.LBE122:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1897              		.loc 1 283 35 view .LVU761
 1898 04ae 0825     		movs	r5, #8
 1899              	.LVL165:
 1900              	.L70:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1901              		.loc 1 283 35 is_stmt 1 view .LVU762
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1902              		.loc 1 283 15 view .LVU763
 1903              	.LBB123:
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1904              		.loc 1 284 5 view .LVU764
 284:lwIP/src/core/ipv4/etharp.c ****     /* no empty entry found yet and now we do find one? */
 1905              		.loc 1 284 10 is_stmt 0 view .LVU765
 1906 04b0 94F8EC70 		ldrb	r7, [r4, #236]	@ zero_extendqisi2
 1907              	.LVL166:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1908              		.loc 1 286 5 is_stmt 1 view .LVU766
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1909              		.loc 1 286 8 is_stmt 0 view .LVU767
 1910 04b4 002F     		cmp	r7, #0
 1911 04b6 7FF43CAF 		bne	.L325
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 1912              		.loc 1 286 8 view .LVU768
 1913 04ba 0A28     		cmp	r0, #10
 1914 04bc 7FF438AF 		bne	.L73
 1915              	.LVL167:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
ARM GAS  /tmp/cctR0i1S.s 			page 85


 1916              		.loc 1 286 8 view .LVU769
 1917              	.LBE123:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1918              		.loc 1 283 35 is_stmt 1 view .LVU770
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1919              		.loc 1 283 15 view .LVU771
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 1920              		.loc 1 338 3 view .LVU772
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 1921              		.loc 1 338 6 is_stmt 0 view .LVU773
 1922 04c0 B9F1010F 		cmp	r9, #1
 1923 04c4 6DD1     		bne	.L201
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1924              		.loc 1 283 35 view .LVU774
 1925 04c6 0920     		movs	r0, #9
 1926              	.LVL168:
 1927              	.L75:
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 1928              		.loc 1 387 3 is_stmt 1 view .LVU775
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 1929              		.loc 1 387 3 view .LVU776
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 1930              		.loc 1 387 3 view .LVU777
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 1931              		.loc 1 388 3 view .LVU778
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 1932              		.loc 1 388 3 view .LVU779
 1933 04c8 00EB4002 		add	r2, r0, r0, lsl #1
 1934 04cc 0746     		mov	r7, r0
 1935              	.LVL169:
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 1936              		.loc 1 388 3 is_stmt 0 view .LVU780
 1937 04ce 4300     		lsls	r3, r0, #1
 1938 04d0 04EBC202 		add	r2, r4, r2, lsl #3
 1939 04d4 127D     		ldrb	r2, [r2, #20]	@ zero_extendqisi2
 1940 04d6 002A     		cmp	r2, #0
 1941 04d8 7FF41CAE 		bne	.L137
 1942 04dc 68E7     		b	.L136
 1943              	.LVL170:
 1944              	.L106:
 1945              	.LBB124:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1946              		.loc 1 306 9 is_stmt 1 view .LVU781
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1947              		.loc 1 306 12 is_stmt 0 view .LVU782
 1948 04de A16F     		ldr	r1, [r4, #120]
 1949              	.LVL171:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1950              		.loc 1 306 12 view .LVU783
 1951 04e0 0029     		cmp	r1, #0
 1952 04e2 00F09C80 		beq	.L350
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1953              		.loc 1 307 11 is_stmt 1 view .LVU784
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1954              		.loc 1 307 14 is_stmt 0 view .LVU785
 1955 04e6 6745     		cmp	r7, ip
 1956 04e8 FFF466AE 		bcc	.L105
ARM GAS  /tmp/cctR0i1S.s 			page 86


 1957 04ec BC46     		mov	ip, r7
 1958              	.LBE124:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1959              		.loc 1 283 35 view .LVU786
 1960 04ee 0523     		movs	r3, #5
 1961 04f0 62E6     		b	.L105
 1962              	.LVL172:
 1963              	.L116:
 1964              	.LBB125:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1965              		.loc 1 306 9 is_stmt 1 view .LVU787
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1966              		.loc 1 306 12 is_stmt 0 view .LVU788
 1967 04f2 D4F8A810 		ldr	r1, [r4, #168]
 1968              	.LVL173:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1969              		.loc 1 306 12 view .LVU789
 1970 04f6 0029     		cmp	r1, #0
 1971 04f8 00F08B80 		beq	.L351
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1972              		.loc 1 307 11 is_stmt 1 view .LVU790
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 1973              		.loc 1 307 14 is_stmt 0 view .LVU791
 1974 04fc 6745     		cmp	r7, ip
 1975 04fe FFF477AE 		bcc	.L115
 1976 0502 BC46     		mov	ip, r7
 1977              	.LBE125:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1978              		.loc 1 283 35 view .LVU792
 1979 0504 0723     		movs	r3, #7
 1980 0506 73E6     		b	.L115
 1981              	.LVL174:
 1982              	.L336:
 1983              	.LBB126:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1984              		.loc 1 306 9 is_stmt 1 view .LVU793
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 1985              		.loc 1 306 12 is_stmt 0 view .LVU794
 1986 0508 2268     		ldr	r2, [r4]
 1987 050a 002A     		cmp	r2, #0
 1988 050c 79D0     		beq	.L352
 1989              	.LBE126:
 264:lwIP/src/core/ipv4/etharp.c **** 
 1990              		.loc 1 264 41 view .LVU795
 1991 050e 4FF0000E 		mov	lr, #0
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 1992              		.loc 1 258 39 view .LVU796
 1993 0512 0A25     		movs	r5, #10
 264:lwIP/src/core/ipv4/etharp.c **** 
 1994              		.loc 1 264 24 view .LVU797
 1995 0514 F046     		mov	r8, lr
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 1996              		.loc 1 283 10 view .LVU798
 1997 0516 7346     		mov	r3, lr
 1998              	.LVL175:
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 1999              		.loc 1 258 9 view .LVU799
ARM GAS  /tmp/cctR0i1S.s 			page 87


 2000 0518 2A46     		mov	r2, r5
 2001 051a 8EE5     		b	.L83
 2002              	.LVL176:
 2003              	.L101:
 2004              	.LBB127:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2005              		.loc 1 306 9 is_stmt 1 view .LVU800
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2006              		.loc 1 306 12 is_stmt 0 view .LVU801
 2007 051c 216E     		ldr	r1, [r4, #96]
 2008              	.LVL177:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2009              		.loc 1 306 12 view .LVU802
 2010 051e 0029     		cmp	r1, #0
 2011 0520 69D0     		beq	.L353
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2012              		.loc 1 307 11 is_stmt 1 view .LVU803
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2013              		.loc 1 307 14 is_stmt 0 view .LVU804
 2014 0522 6745     		cmp	r7, ip
 2015 0524 FFF4BAAD 		bcc	.L100
 2016 0528 BC46     		mov	ip, r7
 2017              	.LBE127:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2018              		.loc 1 283 35 view .LVU805
 2019 052a 0423     		movs	r3, #4
 2020 052c B6E5     		b	.L100
 2021              	.LVL178:
 2022              	.L111:
 2023              	.LBB128:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2024              		.loc 1 306 9 is_stmt 1 view .LVU806
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2025              		.loc 1 306 12 is_stmt 0 view .LVU807
 2026 052e D4F89010 		ldr	r1, [r4, #144]
 2027              	.LVL179:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2028              		.loc 1 306 12 view .LVU808
 2029 0532 0029     		cmp	r1, #0
 2030 0534 59D0     		beq	.L354
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2031              		.loc 1 307 11 is_stmt 1 view .LVU809
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2032              		.loc 1 307 14 is_stmt 0 view .LVU810
 2033 0536 6745     		cmp	r7, ip
 2034 0538 FFF4CAAD 		bcc	.L110
 2035 053c BC46     		mov	ip, r7
 2036              	.LBE128:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2037              		.loc 1 283 35 view .LVU811
 2038 053e 0623     		movs	r3, #6
 2039 0540 C6E5     		b	.L110
 2040              	.LVL180:
 2041              	.L91:
 2042              	.LBB129:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2043              		.loc 1 306 9 is_stmt 1 view .LVU812
ARM GAS  /tmp/cctR0i1S.s 			page 88


 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2044              		.loc 1 306 12 is_stmt 0 view .LVU813
 2045 0542 216B     		ldr	r1, [r4, #48]
 2046              	.LVL181:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2047              		.loc 1 306 12 view .LVU814
 2048 0544 0029     		cmp	r1, #0
 2049 0546 4AD0     		beq	.L355
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2050              		.loc 1 307 11 is_stmt 1 view .LVU815
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2051              		.loc 1 307 14 is_stmt 0 view .LVU816
 2052 0548 6745     		cmp	r7, ip
 2053 054a FFF48EAD 		bcc	.L90
 2054 054e BC46     		mov	ip, r7
 2055              	.LBE129:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2056              		.loc 1 283 35 view .LVU817
 2057 0550 0223     		movs	r3, #2
 2058 0552 8AE5     		b	.L90
 2059              	.LVL182:
 2060              	.L96:
 2061              	.LBB130:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2062              		.loc 1 306 9 is_stmt 1 view .LVU818
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2063              		.loc 1 306 12 is_stmt 0 view .LVU819
 2064 0554 A16C     		ldr	r1, [r4, #72]
 2065              	.LVL183:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2066              		.loc 1 306 12 view .LVU820
 2067 0556 0029     		cmp	r1, #0
 2068 0558 3BD0     		beq	.L356
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2069              		.loc 1 307 11 is_stmt 1 view .LVU821
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2070              		.loc 1 307 14 is_stmt 0 view .LVU822
 2071 055a 6745     		cmp	r7, ip
 2072 055c FFF411AE 		bcc	.L95
 2073 0560 BC46     		mov	ip, r7
 2074              	.LBE130:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2075              		.loc 1 283 35 view .LVU823
 2076 0562 0323     		movs	r3, #3
 2077 0564 0DE6     		b	.L95
 2078              	.LVL184:
 2079              	.L86:
 2080              	.LBB131:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2081              		.loc 1 306 9 is_stmt 1 view .LVU824
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2082              		.loc 1 306 12 is_stmt 0 view .LVU825
 2083 0566 A669     		ldr	r6, [r4, #24]
 2084 0568 6EB3     		cbz	r6, .L357
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2085              		.loc 1 307 11 is_stmt 1 view .LVU826
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
ARM GAS  /tmp/cctR0i1S.s 			page 89


 2086              		.loc 1 307 14 is_stmt 0 view .LVU827
 2087 056a 6745     		cmp	r7, ip
 2088 056c FFF4EEAD 		bcc	.L85
 2089 0570 BC46     		mov	ip, r7
 2090              	.LBE131:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2091              		.loc 1 283 35 view .LVU828
 2092 0572 0B46     		mov	r3, r1
 2093 0574 EAE5     		b	.L85
 2094              	.LVL185:
 2095              	.L121:
 2096              	.LBB132:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2097              		.loc 1 306 9 is_stmt 1 view .LVU829
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2098              		.loc 1 306 12 is_stmt 0 view .LVU830
 2099 0576 D4F8C010 		ldr	r1, [r4, #192]
 2100              	.LVL186:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2101              		.loc 1 306 12 view .LVU831
 2102 057a F1B1     		cbz	r1, .L358
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2103              		.loc 1 307 11 is_stmt 1 view .LVU832
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2104              		.loc 1 307 14 is_stmt 0 view .LVU833
 2105 057c 6745     		cmp	r7, ip
 2106 057e FFF4B3AD 		bcc	.L120
 2107 0582 BC46     		mov	ip, r7
 2108              	.LBE132:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2109              		.loc 1 283 35 view .LVU834
 2110 0584 0823     		movs	r3, #8
 2111 0586 AFE5     		b	.L120
 2112              	.LVL187:
 2113              	.L339:
 2114              	.LBB133:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2115              		.loc 1 306 9 is_stmt 1 view .LVU835
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2116              		.loc 1 306 12 is_stmt 0 view .LVU836
 2117 0588 D4F8D810 		ldr	r1, [r4, #216]
 2118              	.LVL188:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2119              		.loc 1 306 12 view .LVU837
 2120 058c 29B1     		cbz	r1, .L128
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2121              		.loc 1 307 11 is_stmt 1 view .LVU838
 2122              	.LBE133:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2123              		.loc 1 283 35 is_stmt 0 view .LVU839
 2124 058e 6745     		cmp	r7, ip
 2125 0590 28BF     		it	cs
 2126 0592 0923     		movcs	r3, #9
 2127              	.LBB134:
 2128 0594 DAE6     		b	.L80
 2129              	.LVL189:
 2130              	.L187:
ARM GAS  /tmp/cctR0i1S.s 			page 90


 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2131              		.loc 1 283 35 view .LVU840
 2132              	.LBE134:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2133              		.loc 1 283 10 view .LVU841
 2134 0596 0020     		movs	r0, #0
 2135              	.LVL190:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2136              		.loc 1 283 10 view .LVU842
 2137 0598 0FE7     		b	.L317
 2138              	.LVL191:
 2139              	.L128:
 2140              	.LBB135:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2141              		.loc 1 314 11 is_stmt 1 view .LVU843
 2142              	.LBE135:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2143              		.loc 1 283 35 is_stmt 0 view .LVU844
 2144 059a 4745     		cmp	r7, r8
 2145 059c 28BF     		it	cs
 2146 059e 0922     		movcs	r2, #9
 2147              	.LBB136:
 2148 05a0 D4E6     		b	.L80
 2149              	.LVL192:
 2150              	.L201:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2151              		.loc 1 283 35 view .LVU845
 2152              	.LBE136:
 342:lwIP/src/core/ipv4/etharp.c ****   }
 2153              		.loc 1 342 12 view .LVU846
 2154 05a2 4FF0FF30 		mov	r0, #-1
 2155 05a6 08E7     		b	.L317
 2156              	.LVL193:
 2157              	.L129:
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 2158              		.loc 1 387 3 is_stmt 1 view .LVU847
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 2159              		.loc 1 387 3 view .LVU848
 387:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 2160              		.loc 1 387 3 view .LVU849
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 2161              		.loc 1 388 3 view .LVU850
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 2162              		.loc 1 388 3 view .LVU851
 2163 05a8 1823     		movs	r3, #24
 2164 05aa 0746     		mov	r7, r0
 2165 05ac 03FB0043 		mla	r3, r3, r0, r4
 2166 05b0 1B7D     		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 2167 05b2 002B     		cmp	r3, #0
 2168 05b4 7FF4AEAD 		bne	.L137
 388:lwIP/src/core/ipv4/etharp.c ****               arp_table[i].state == ETHARP_STATE_EMPTY);
 2169              		.loc 1 388 3 is_stmt 0 view .LVU852
 2170 05b8 EEE6     		b	.L134
 2171              	.LVL194:
 2172              	.L358:
 2173              	.LBB137:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
ARM GAS  /tmp/cctR0i1S.s 			page 91


 2174              		.loc 1 314 11 is_stmt 1 view .LVU853
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2175              		.loc 1 314 14 is_stmt 0 view .LVU854
 2176 05ba 4745     		cmp	r7, r8
 2177 05bc FFF494AD 		bcc	.L120
 2178 05c0 B846     		mov	r8, r7
 2179              	.LBE137:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2180              		.loc 1 283 35 view .LVU855
 2181 05c2 0822     		movs	r2, #8
 2182 05c4 90E5     		b	.L120
 2183              	.LVL195:
 2184              	.L357:
 2185              	.LBB138:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2186              		.loc 1 314 11 is_stmt 1 view .LVU856
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2187              		.loc 1 314 14 is_stmt 0 view .LVU857
 2188 05c6 4745     		cmp	r7, r8
 2189 05c8 FFF4C0AD 		bcc	.L85
 2190 05cc B846     		mov	r8, r7
 2191              	.LBE138:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2192              		.loc 1 283 35 view .LVU858
 2193 05ce 0A46     		mov	r2, r1
 2194 05d0 BCE5     		b	.L85
 2195              	.LVL196:
 2196              	.L356:
 2197              	.LBB139:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2198              		.loc 1 314 11 is_stmt 1 view .LVU859
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2199              		.loc 1 314 14 is_stmt 0 view .LVU860
 2200 05d2 4745     		cmp	r7, r8
 2201 05d4 FFF4D5AD 		bcc	.L95
 2202 05d8 B846     		mov	r8, r7
 2203              	.LBE139:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2204              		.loc 1 283 35 view .LVU861
 2205 05da 0322     		movs	r2, #3
 2206 05dc D1E5     		b	.L95
 2207              	.LVL197:
 2208              	.L355:
 2209              	.LBB140:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2210              		.loc 1 314 11 is_stmt 1 view .LVU862
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2211              		.loc 1 314 14 is_stmt 0 view .LVU863
 2212 05de 4745     		cmp	r7, r8
 2213 05e0 FFF443AD 		bcc	.L90
 2214 05e4 B846     		mov	r8, r7
 2215              	.LBE140:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2216              		.loc 1 283 35 view .LVU864
 2217 05e6 0222     		movs	r2, #2
 2218 05e8 3FE5     		b	.L90
 2219              	.LVL198:
ARM GAS  /tmp/cctR0i1S.s 			page 92


 2220              	.L354:
 2221              	.LBB141:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2222              		.loc 1 314 11 is_stmt 1 view .LVU865
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2223              		.loc 1 314 14 is_stmt 0 view .LVU866
 2224 05ea 4745     		cmp	r7, r8
 2225 05ec FFF470AD 		bcc	.L110
 2226 05f0 B846     		mov	r8, r7
 2227              	.LBE141:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2228              		.loc 1 283 35 view .LVU867
 2229 05f2 0622     		movs	r2, #6
 2230 05f4 6CE5     		b	.L110
 2231              	.LVL199:
 2232              	.L353:
 2233              	.LBB142:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2234              		.loc 1 314 11 is_stmt 1 view .LVU868
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2235              		.loc 1 314 14 is_stmt 0 view .LVU869
 2236 05f6 4745     		cmp	r7, r8
 2237 05f8 FFF450AD 		bcc	.L100
 2238 05fc B846     		mov	r8, r7
 2239              	.LBE142:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2240              		.loc 1 283 35 view .LVU870
 2241 05fe 0422     		movs	r2, #4
 2242 0600 4CE5     		b	.L100
 2243              	.LVL200:
 2244              	.L352:
 262:lwIP/src/core/ipv4/etharp.c ****   /* its age */
 2245              		.loc 1 262 9 view .LVU871
 2246 0602 0A23     		movs	r3, #10
 2247              	.LVL201:
 2248              	.LBB143:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2249              		.loc 1 306 12 view .LVU872
 2250 0604 E046     		mov	r8, ip
 2251              	.LBE143:
 264:lwIP/src/core/ipv4/etharp.c **** 
 2252              		.loc 1 264 9 view .LVU873
 2253 0606 9646     		mov	lr, r2
 264:lwIP/src/core/ipv4/etharp.c **** 
 2254              		.loc 1 264 41 view .LVU874
 2255 0608 9446     		mov	ip, r2
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 2256              		.loc 1 258 39 view .LVU875
 2257 060a 1D46     		mov	r5, r3
 2258 060c 15E5     		b	.L83
 2259              	.LVL202:
 2260              	.L342:
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 2261              		.loc 1 258 39 view .LVU876
 2262 060e 7B00     		lsls	r3, r7, #1
 2263 0610 CEE6     		b	.L136
 2264              	.LVL203:
ARM GAS  /tmp/cctR0i1S.s 			page 93


 2265              	.L351:
 2266              	.LBB144:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2267              		.loc 1 314 11 is_stmt 1 view .LVU877
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2268              		.loc 1 314 14 is_stmt 0 view .LVU878
 2269 0612 4745     		cmp	r7, r8
 2270 0614 FFF4ECAD 		bcc	.L115
 2271 0618 B846     		mov	r8, r7
 2272              	.LBE144:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2273              		.loc 1 283 35 view .LVU879
 2274 061a 0722     		movs	r2, #7
 2275 061c E8E5     		b	.L115
 2276              	.LVL204:
 2277              	.L350:
 2278              	.LBB145:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2279              		.loc 1 314 11 is_stmt 1 view .LVU880
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2280              		.loc 1 314 14 is_stmt 0 view .LVU881
 2281 061e 4745     		cmp	r7, r8
 2282 0620 FFF4CAAD 		bcc	.L105
 2283 0624 B846     		mov	r8, r7
 2284              	.LBE145:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2285              		.loc 1 283 35 view .LVU882
 2286 0626 0522     		movs	r2, #5
 2287 0628 C6E5     		b	.L105
 2288              	.LVL205:
 2289              	.L340:
 2290              	.LBB146:
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 2291              		.loc 1 320 14 is_stmt 1 view .LVU883
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2292              		.loc 1 327 11 view .LVU884
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2293              		.loc 1 327 14 is_stmt 0 view .LVU885
 2294 062a E045     		cmp	r8, ip
 2295 062c FFF48EAE 		bcc	.L80
 2296              	.LVL206:
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2297              		.loc 1 327 14 view .LVU886
 2298              	.LBE146:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2299              		.loc 1 283 35 is_stmt 1 view .LVU887
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2300              		.loc 1 283 15 view .LVU888
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 2301              		.loc 1 338 3 view .LVU889
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 2302              		.loc 1 338 6 is_stmt 0 view .LVU890
 2303 0630 B9F1010F 		cmp	r9, #1
 2304 0634 B5D1     		bne	.L201
 338:lwIP/src/core/ipv4/etharp.c ****       /* or no empty entry found and not allowed to recycle? */
 2305              		.loc 1 338 46 view .LVU891
 2306 0636 0A28     		cmp	r0, #10
ARM GAS  /tmp/cctR0i1S.s 			page 94


 2307 0638 3FF4FEAD 		beq	.L200
 2308 063c 44E7     		b	.L75
 2309              	.LVL207:
 2310              	.L66:
 2311              	.LBB147:
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 2312              		.loc 1 320 14 is_stmt 1 view .LVU892
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2313              		.loc 1 327 11 view .LVU893
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2314              		.loc 1 327 14 is_stmt 0 view .LVU894
 2315 063e E045     		cmp	r8, ip
 2316 0640 FFF46BAE 		bcc	.L65
 2317 0644 C446     		mov	ip, r8
 2318              	.LBE147:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2319              		.loc 1 283 35 view .LVU895
 2320 0646 0725     		movs	r5, #7
 2321 0648 67E6     		b	.L65
 2322              	.LVL208:
 2323              	.L349:
 2324              	.LBB148:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2325              		.loc 1 306 9 is_stmt 1 view .LVU896
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2326              		.loc 1 306 12 is_stmt 0 view .LVU897
 2327 064a D4F8C070 		ldr	r7, [r4, #192]
 2328              	.LVL209:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2329              		.loc 1 306 12 view .LVU898
 2330 064e 7FB1     		cbz	r7, .L72
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2331              		.loc 1 307 11 is_stmt 1 view .LVU899
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2332              		.loc 1 307 14 is_stmt 0 view .LVU900
 2333 0650 F045     		cmp	r8, lr
 2334 0652 FFF42DAF 		bcc	.L70
 2335 0656 C646     		mov	lr, r8
 2336              	.LBE148:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2337              		.loc 1 283 35 view .LVU901
 2338 0658 0823     		movs	r3, #8
 2339 065a 29E7     		b	.L70
 2340              	.LVL210:
 2341              	.L341:
 2342              	.LBB149:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2343              		.loc 1 314 11 is_stmt 1 view .LVU902
 2344              	.LBE149:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2345              		.loc 1 283 35 is_stmt 0 view .LVU903
 2346 065c 8845     		cmp	r8, r1
 2347 065e 28BF     		it	cs
 2348 0660 0922     		movcs	r2, #9
 2349 0662 73E6     		b	.L80
 2350              	.LVL211:
 2351              	.L67:
ARM GAS  /tmp/cctR0i1S.s 			page 95


 2352              	.LBB150:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2353              		.loc 1 314 11 is_stmt 1 view .LVU904
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2354              		.loc 1 314 14 is_stmt 0 view .LVU905
 2355 0664 8845     		cmp	r8, r1
 2356 0666 FFF458AE 		bcc	.L65
 2357 066a 4146     		mov	r1, r8
 2358              	.LBE150:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2359              		.loc 1 283 35 view .LVU906
 2360 066c 0722     		movs	r2, #7
 2361 066e 54E6     		b	.L65
 2362              	.LVL212:
 2363              	.L72:
 2364              	.LBB151:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2365              		.loc 1 314 11 is_stmt 1 view .LVU907
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2366              		.loc 1 314 14 is_stmt 0 view .LVU908
 2367 0670 8845     		cmp	r8, r1
 2368 0672 FFF41DAF 		bcc	.L70
 2369 0676 4146     		mov	r1, r8
 2370              	.LBE151:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2371              		.loc 1 283 35 view .LVU909
 2372 0678 0822     		movs	r2, #8
 2373 067a 19E7     		b	.L70
 2374              	.LVL213:
 2375              	.L348:
 2376              	.LBB152:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2377              		.loc 1 306 9 is_stmt 1 view .LVU910
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2378              		.loc 1 306 12 is_stmt 0 view .LVU911
 2379 067c D4F89070 		ldr	r7, [r4, #144]
 2380              	.LVL214:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2381              		.loc 1 306 12 view .LVU912
 2382 0680 5FB1     		cbz	r7, .L62
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2383              		.loc 1 307 11 is_stmt 1 view .LVU913
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2384              		.loc 1 307 14 is_stmt 0 view .LVU914
 2385 0682 F045     		cmp	r8, lr
 2386 0684 FFF4FFAE 		bcc	.L60
 2387 0688 C646     		mov	lr, r8
 2388              	.LBE152:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2389              		.loc 1 283 35 view .LVU915
 2390 068a 0623     		movs	r3, #6
 2391 068c FBE6     		b	.L60
 2392              	.LVL215:
 2393              	.L56:
 2394              	.LBB153:
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 2395              		.loc 1 320 14 is_stmt 1 view .LVU916
ARM GAS  /tmp/cctR0i1S.s 			page 96


 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2396              		.loc 1 327 11 view .LVU917
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2397              		.loc 1 327 14 is_stmt 0 view .LVU918
 2398 068e E045     		cmp	r8, ip
 2399 0690 FFF429AE 		bcc	.L55
 2400 0694 C446     		mov	ip, r8
 2401              	.LBE153:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2402              		.loc 1 283 35 view .LVU919
 2403 0696 0525     		movs	r5, #5
 2404 0698 25E6     		b	.L55
 2405              	.LVL216:
 2406              	.L62:
 2407              	.LBB154:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2408              		.loc 1 314 11 is_stmt 1 view .LVU920
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2409              		.loc 1 314 14 is_stmt 0 view .LVU921
 2410 069a 8845     		cmp	r8, r1
 2411 069c FFF4F3AE 		bcc	.L60
 2412 06a0 4146     		mov	r1, r8
 2413              	.LBE154:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2414              		.loc 1 283 35 view .LVU922
 2415 06a2 0622     		movs	r2, #6
 2416 06a4 EFE6     		b	.L60
 2417              	.LVL217:
 2418              	.L57:
 2419              	.LBB155:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2420              		.loc 1 314 11 is_stmt 1 view .LVU923
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2421              		.loc 1 314 14 is_stmt 0 view .LVU924
 2422 06a6 8845     		cmp	r8, r1
 2423 06a8 FFF41DAE 		bcc	.L55
 2424 06ac 4146     		mov	r1, r8
 2425              	.LBE155:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2426              		.loc 1 283 35 view .LVU925
 2427 06ae 0522     		movs	r2, #5
 2428 06b0 19E6     		b	.L55
 2429              	.LVL218:
 2430              	.L347:
 2431              	.LBB156:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2432              		.loc 1 306 9 is_stmt 1 view .LVU926
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2433              		.loc 1 306 12 is_stmt 0 view .LVU927
 2434 06b2 276E     		ldr	r7, [r4, #96]
 2435              	.LVL219:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2436              		.loc 1 306 12 view .LVU928
 2437 06b4 6FB1     		cbz	r7, .L52
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2438              		.loc 1 307 11 is_stmt 1 view .LVU929
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
ARM GAS  /tmp/cctR0i1S.s 			page 97


 2439              		.loc 1 307 14 is_stmt 0 view .LVU930
 2440 06b6 F045     		cmp	r8, lr
 2441 06b8 FFF4D0AE 		bcc	.L50
 2442 06bc C646     		mov	lr, r8
 2443              	.LBE156:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2444              		.loc 1 283 35 view .LVU931
 2445 06be 0423     		movs	r3, #4
 2446 06c0 CCE6     		b	.L50
 2447              	.LVL220:
 2448              	.L346:
 2449              	.LBB157:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2450              		.loc 1 306 9 is_stmt 1 view .LVU932
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2451              		.loc 1 306 12 is_stmt 0 view .LVU933
 2452 06c2 276B     		ldr	r7, [r4, #48]
 2453              	.LVL221:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2454              		.loc 1 306 12 view .LVU934
 2455 06c4 5FB1     		cbz	r7, .L42
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2456              		.loc 1 307 11 is_stmt 1 view .LVU935
 307:lwIP/src/core/ipv4/etharp.c ****             old_queue = i;
 2457              		.loc 1 307 14 is_stmt 0 view .LVU936
 2458 06c6 F045     		cmp	r8, lr
 2459 06c8 FFF4B3AE 		bcc	.L40
 2460 06cc C646     		mov	lr, r8
 2461              	.LBE157:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2462              		.loc 1 283 35 view .LVU937
 2463 06ce 0223     		movs	r3, #2
 2464 06d0 AFE6     		b	.L40
 2465              	.LVL222:
 2466              	.L52:
 2467              	.LBB158:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2468              		.loc 1 314 11 is_stmt 1 view .LVU938
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2469              		.loc 1 314 14 is_stmt 0 view .LVU939
 2470 06d2 8845     		cmp	r8, r1
 2471 06d4 FFF4C2AE 		bcc	.L50
 2472 06d8 4146     		mov	r1, r8
 2473              	.LBE158:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2474              		.loc 1 283 35 view .LVU940
 2475 06da 0422     		movs	r2, #4
 2476 06dc BEE6     		b	.L50
 2477              	.LVL223:
 2478              	.L42:
 2479              	.LBB159:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2480              		.loc 1 314 11 is_stmt 1 view .LVU941
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2481              		.loc 1 314 14 is_stmt 0 view .LVU942
 2482 06de 8845     		cmp	r8, r1
 2483 06e0 FFF4A7AE 		bcc	.L40
ARM GAS  /tmp/cctR0i1S.s 			page 98


 2484 06e4 4146     		mov	r1, r8
 2485              	.LBE159:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2486              		.loc 1 283 35 view .LVU943
 2487 06e6 0222     		movs	r2, #2
 2488 06e8 A3E6     		b	.L40
 2489              	.LVL224:
 2490              	.L46:
 2491              	.LBB160:
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 2492              		.loc 1 320 14 is_stmt 1 view .LVU944
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2493              		.loc 1 327 11 view .LVU945
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2494              		.loc 1 327 14 is_stmt 0 view .LVU946
 2495 06ea E045     		cmp	r8, ip
 2496 06ec FFF4E2AD 		bcc	.L45
 2497 06f0 C446     		mov	ip, r8
 2498              	.LBE160:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2499              		.loc 1 283 35 view .LVU947
 2500 06f2 0325     		movs	r5, #3
 2501 06f4 DEE5     		b	.L45
 2502              	.LVL225:
 2503              	.L344:
 2504              	.LBB161:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2505              		.loc 1 306 9 is_stmt 1 view .LVU948
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2506              		.loc 1 306 12 is_stmt 0 view .LVU949
 2507 06f6 2368     		ldr	r3, [r4]
 2508              	.LVL226:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2509              		.loc 1 306 12 view .LVU950
 2510 06f8 63B1     		cbz	r3, .L157
 2511              	.LBE161:
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 2512              		.loc 1 258 39 view .LVU951
 2513 06fa 0A25     		movs	r5, #10
 2514              	.LBB162:
 306:lwIP/src/core/ipv4/etharp.c ****           if (arp_table[i].ctime >= age_queue) {
 2515              		.loc 1 306 12 view .LVU952
 2516 06fc 8E46     		mov	lr, r1
 2517              	.LBE162:
 264:lwIP/src/core/ipv4/etharp.c **** 
 2518              		.loc 1 264 24 view .LVU953
 2519 06fe 8446     		mov	ip, r0
 264:lwIP/src/core/ipv4/etharp.c **** 
 2520              		.loc 1 264 41 view .LVU954
 2521 0700 0146     		mov	r1, r0
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 2522              		.loc 1 258 9 view .LVU955
 2523 0702 2A46     		mov	r2, r5
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2524              		.loc 1 283 10 view .LVU956
 2525 0704 0346     		mov	r3, r0
 2526 0706 82E6     		b	.L33
ARM GAS  /tmp/cctR0i1S.s 			page 99


 2527              	.LVL227:
 2528              	.L47:
 2529              	.LBB163:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2530              		.loc 1 314 11 is_stmt 1 view .LVU957
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2531              		.loc 1 314 14 is_stmt 0 view .LVU958
 2532 0708 8845     		cmp	r8, r1
 2533 070a FFF4D3AD 		bcc	.L45
 2534 070e 4146     		mov	r1, r8
 2535              	.LBE163:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2536              		.loc 1 283 35 view .LVU959
 2537 0710 0322     		movs	r2, #3
 2538 0712 CFE5     		b	.L45
 2539              	.LVL228:
 2540              	.L157:
 262:lwIP/src/core/ipv4/etharp.c ****   /* its age */
 2541              		.loc 1 262 9 view .LVU960
 2542 0714 0A23     		movs	r3, #10
 264:lwIP/src/core/ipv4/etharp.c **** 
 2543              		.loc 1 264 41 view .LVU961
 2544 0716 8446     		mov	ip, r0
 264:lwIP/src/core/ipv4/etharp.c **** 
 2545              		.loc 1 264 9 view .LVU962
 2546 0718 8646     		mov	lr, r0
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2547              		.loc 1 283 10 view .LVU963
 2548 071a 0246     		mov	r2, r0
 258:lwIP/src/core/ipv4/etharp.c ****   s16_t empty = ARP_TABLE_SIZE;
 2549              		.loc 1 258 39 view .LVU964
 2550 071c 1D46     		mov	r5, r3
 2551 071e 76E6     		b	.L33
 2552              	.LVL229:
 2553              	.L197:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2554              		.loc 1 283 35 view .LVU965
 2555 0720 0820     		movs	r0, #8
 2556              	.LVL230:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2557              		.loc 1 283 35 view .LVU966
 2558 0722 4AE6     		b	.L317
 2559              	.LVL231:
 2560              	.L191:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2561              		.loc 1 283 35 view .LVU967
 2562 0724 0220     		movs	r0, #2
 2563              	.LVL232:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2564              		.loc 1 283 35 view .LVU968
 2565 0726 48E6     		b	.L317
 2566              	.LVL233:
 2567              	.L195:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2568              		.loc 1 283 35 view .LVU969
 2569 0728 0620     		movs	r0, #6
 2570              	.LVL234:
ARM GAS  /tmp/cctR0i1S.s 			page 100


 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2571              		.loc 1 283 35 view .LVU970
 2572 072a 46E6     		b	.L317
 2573              	.LVL235:
 2574              	.L196:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2575              		.loc 1 283 35 view .LVU971
 2576 072c 0720     		movs	r0, #7
 2577              	.LVL236:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2578              		.loc 1 283 35 view .LVU972
 2579 072e 44E6     		b	.L317
 2580              	.LVL237:
 2581              	.L192:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2582              		.loc 1 283 35 view .LVU973
 2583 0730 0320     		movs	r0, #3
 2584              	.LVL238:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2585              		.loc 1 283 35 view .LVU974
 2586 0732 42E6     		b	.L317
 2587              	.LVL239:
 2588              	.L193:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2589              		.loc 1 283 35 view .LVU975
 2590 0734 0420     		movs	r0, #4
 2591              	.LVL240:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2592              		.loc 1 283 35 view .LVU976
 2593 0736 40E6     		b	.L317
 2594              	.LVL241:
 2595              	.L194:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2596              		.loc 1 283 35 view .LVU977
 2597 0738 0520     		movs	r0, #5
 2598              	.LVL242:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2599              		.loc 1 283 35 view .LVU978
 2600 073a 3EE6     		b	.L317
 2601              	.LVL243:
 2602              	.L338:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2603              		.loc 1 283 35 view .LVU979
 2604 073c 0920     		movs	r0, #9
 2605              	.LVL244:
 2606              	.LBB164:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2607              		.loc 1 283 35 view .LVU980
 2608 073e 3CE6     		b	.L317
 2609              	.LVL245:
 2610              	.L36:
 320:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 2611              		.loc 1 320 14 is_stmt 1 view .LVU981
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2612              		.loc 1 327 11 view .LVU982
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2613              		.loc 1 327 14 is_stmt 0 view .LVU983
ARM GAS  /tmp/cctR0i1S.s 			page 101


 2614 0740 E245     		cmp	r10, ip
 2615 0742 FFF49EAD 		bcc	.L35
 2616              	.LVL246:
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2617              		.loc 1 327 14 view .LVU984
 2618 0746 D446     		mov	ip, r10
 2619              	.LVL247:
 327:lwIP/src/core/ipv4/etharp.c ****             old_stable = i;
 2620              		.loc 1 327 14 view .LVU985
 2621              	.LBE164:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2622              		.loc 1 283 35 view .LVU986
 2623 0748 0125     		movs	r5, #1
 2624 074a 9AE5     		b	.L35
 2625              	.LVL248:
 2626              	.L190:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2627              		.loc 1 283 35 view .LVU987
 2628 074c 0120     		movs	r0, #1
 2629              	.LVL249:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2630              		.loc 1 283 35 view .LVU988
 2631 074e 34E6     		b	.L317
 2632              	.LVL250:
 2633              	.L337:
 2634              	.LBB165:
 286:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
 2635              		.loc 1 286 8 view .LVU989
 2636 0750 0A20     		movs	r0, #10
 2637              	.LVL251:
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 2638              		.loc 1 290 12 is_stmt 1 view .LVU990
 290:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
 2639              		.loc 1 290 15 is_stmt 0 view .LVU991
 2640 0752 0029     		cmp	r1, #0
 2641 0754 3FF4FAAC 		beq	.L85
 2642 0758 EAE4     		b	.L359
 2643              	.LVL252:
 2644              	.L37:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2645              		.loc 1 314 11 is_stmt 1 view .LVU992
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2646              		.loc 1 314 14 is_stmt 0 view .LVU993
 2647 075a 8A45     		cmp	r10, r1
 2648 075c FFF491AD 		bcc	.L35
 2649              	.LVL253:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2650              		.loc 1 314 14 view .LVU994
 2651 0760 5146     		mov	r1, r10
 2652              	.LVL254:
 314:lwIP/src/core/ipv4/etharp.c ****             old_pending = i;
 2653              		.loc 1 314 14 view .LVU995
 2654              	.LBE165:
 283:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2655              		.loc 1 283 35 view .LVU996
 2656 0762 3A46     		mov	r2, r7
 2657 0764 8DE5     		b	.L35
ARM GAS  /tmp/cctR0i1S.s 			page 102


 2658              		.cfi_endproc
 2659              	.LFE119:
 2661 0766 00BF     		.section	.text.etharp_tmr,"ax",%progbits
 2662              		.align	1
 2663              		.p2align 2,,3
 2664              		.global	etharp_tmr
 2665              		.syntax unified
 2666              		.thumb
 2667              		.thumb_func
 2668              		.fpu fpv4-sp-d16
 2670              	etharp_tmr:
 2671              	.LFB106:
 198:lwIP/src/core/ipv4/etharp.c ****   int i;
 2672              		.loc 1 198 1 is_stmt 1 view -0
 2673              		.cfi_startproc
 2674              		@ args = 0, pretend = 0, frame = 0
 2675              		@ frame_needed = 0, uses_anonymous_args = 0
 199:lwIP/src/core/ipv4/etharp.c **** 
 2676              		.loc 1 199 3 view .LVU998
 201:lwIP/src/core/ipv4/etharp.c ****   /* remove expired entries from the ARP table */
 2677              		.loc 1 201 48 view .LVU999
 203:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2678              		.loc 1 203 3 view .LVU1000
 2679              	.LVL255:
 203:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2680              		.loc 1 203 15 view .LVU1001
 198:lwIP/src/core/ipv4/etharp.c ****   int i;
 2681              		.loc 1 198 1 is_stmt 0 view .LVU1002
 2682 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 2683              	.LCFI9:
 2684              		.cfi_def_cfa_offset 24
 2685              		.cfi_offset 4, -24
 2686              		.cfi_offset 5, -20
 2687              		.cfi_offset 6, -16
 2688              		.cfi_offset 7, -12
 2689              		.cfi_offset 8, -8
 2690              		.cfi_offset 14, -4
 2691 0004 204C     		ldr	r4, .L388
 2692 0006 84B0     		sub	sp, sp, #16
 2693              	.LCFI10:
 2694              		.cfi_def_cfa_offset 40
 2695              	.LBB166:
 2696              	.LBB167:
 2697              	.LBB168:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 2698              		.loc 1 180 22 view .LVU1003
 2699 0008 0026     		movs	r6, #0
 2700              	.LBE168:
 2701              	.LBE167:
 2702              	.LBB170:
 2703              	.LBB171:
 2704              	.LBB172:
 2705              	.LBB173:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 2706              		.loc 1 1183 10 view .LVU1004
 2707 000a DFF88480 		ldr	r8, .L388+8
 2708 000e 04F1F005 		add	r5, r4, #240
ARM GAS  /tmp/cctR0i1S.s 			page 103


 2709 0012 1E4F     		ldr	r7, .L388+4
 2710 0014 0CE0     		b	.L371
 2711              	.LVL256:
 2712              	.L387:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 2713              		.loc 1 1183 10 view .LVU1005
 2714              	.LBE173:
 2715              	.LBE172:
 2716              	.LBE171:
 2717              	.LBE170:
 212:lwIP/src/core/ipv4/etharp.c ****            (arp_table[i].ctime >= ARP_MAXPENDING))) {
 2718              		.loc 1 212 58 view .LVU1006
 2719 0016 012A     		cmp	r2, #1
 2720 0018 01D1     		bne	.L366
 2721 001a 042B     		cmp	r3, #4
 2722 001c 12D8     		bhi	.L365
 2723              	.L366:
 219:lwIP/src/core/ipv4/etharp.c ****         /* Don't send more than one request every 2 seconds. */
 2724              		.loc 1 219 14 is_stmt 1 view .LVU1007
 219:lwIP/src/core/ipv4/etharp.c ****         /* Don't send more than one request every 2 seconds. */
 2725              		.loc 1 219 17 is_stmt 0 view .LVU1008
 2726 001e 032A     		cmp	r2, #3
 2727 0020 1CD0     		beq	.L383
 222:lwIP/src/core/ipv4/etharp.c ****         /* Reset state to stable, so that the next transmitted packet will
 2728              		.loc 1 222 14 is_stmt 1 view .LVU1009
 222:lwIP/src/core/ipv4/etharp.c ****         /* Reset state to stable, so that the next transmitted packet will
 2729              		.loc 1 222 17 is_stmt 0 view .LVU1010
 2730 0022 042A     		cmp	r2, #4
 2731 0024 1DD0     		beq	.L384
 226:lwIP/src/core/ipv4/etharp.c ****         /* still pending, resend an ARP query */
 2732              		.loc 1 226 14 is_stmt 1 view .LVU1011
 226:lwIP/src/core/ipv4/etharp.c ****         /* still pending, resend an ARP query */
 2733              		.loc 1 226 17 is_stmt 0 view .LVU1012
 2734 0026 012A     		cmp	r2, #1
 2735 0028 1ED0     		beq	.L385
 2736              	.LVL257:
 2737              	.L364:
 226:lwIP/src/core/ipv4/etharp.c ****         /* still pending, resend an ARP query */
 2738              		.loc 1 226 17 view .LVU1013
 2739              	.LBE166:
 203:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2740              		.loc 1 203 35 is_stmt 1 discriminator 2 view .LVU1014
 203:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2741              		.loc 1 203 15 discriminator 2 view .LVU1015
 2742 002a 1834     		adds	r4, r4, #24
 203:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2743              		.loc 1 203 3 is_stmt 0 discriminator 2 view .LVU1016
 2744 002c AC42     		cmp	r4, r5
 2745 002e 12D0     		beq	.L386
 2746              	.L371:
 2747              	.LBB179:
 204:lwIP/src/core/ipv4/etharp.c ****     if (state != ETHARP_STATE_EMPTY
 2748              		.loc 1 204 5 is_stmt 1 view .LVU1017
 204:lwIP/src/core/ipv4/etharp.c ****     if (state != ETHARP_STATE_EMPTY
 2749              		.loc 1 204 10 is_stmt 0 view .LVU1018
 2750 0030 227D     		ldrb	r2, [r4, #20]	@ zero_extendqisi2
 2751              	.LVL258:
ARM GAS  /tmp/cctR0i1S.s 			page 104


 205:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 2752              		.loc 1 205 5 is_stmt 1 view .LVU1019
 205:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_SUPPORT_STATIC_ENTRIES
 2753              		.loc 1 205 8 is_stmt 0 view .LVU1020
 2754 0032 002A     		cmp	r2, #0
 2755 0034 F9D0     		beq	.L364
 210:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 2756              		.loc 1 210 7 is_stmt 1 view .LVU1021
 210:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 2757              		.loc 1 210 25 is_stmt 0 view .LVU1022
 2758 0036 638A     		ldrh	r3, [r4, #18]
 2759 0038 0133     		adds	r3, r3, #1
 2760 003a 9BB2     		uxth	r3, r3
 211:lwIP/src/core/ipv4/etharp.c ****           ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 2761              		.loc 1 211 10 view .LVU1023
 2762 003c B3F5967F 		cmp	r3, #300
 210:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 2763              		.loc 1 210 25 view .LVU1024
 2764 0040 6382     		strh	r3, [r4, #18]	@ movhi
 211:lwIP/src/core/ipv4/etharp.c ****           ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 2765              		.loc 1 211 7 is_stmt 1 view .LVU1025
 211:lwIP/src/core/ipv4/etharp.c ****           ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 2766              		.loc 1 211 10 is_stmt 0 view .LVU1026
 2767 0042 E8D3     		bcc	.L387
 2768              	.L365:
 216:lwIP/src/core/ipv4/etharp.c ****         /* clean up entries that have just been expired */
 2769              		.loc 1 216 105 is_stmt 1 view .LVU1027
 218:lwIP/src/core/ipv4/etharp.c ****       } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
 2770              		.loc 1 218 9 view .LVU1028
 2771              	.LBB177:
 2772              	.LBI167:
 168:lwIP/src/core/ipv4/etharp.c **** {
 2773              		.loc 1 168 1 view .LVU1029
 2774              	.LBB169:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 2775              		.loc 1 171 66 view .LVU1030
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 2776              		.loc 1 173 3 view .LVU1031
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 2777              		.loc 1 173 19 is_stmt 0 view .LVU1032
 2778 0044 2068     		ldr	r0, [r4]
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 2779              		.loc 1 173 6 view .LVU1033
 2780 0046 10B1     		cbz	r0, .L367
 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 2781              		.loc 1 175 133 is_stmt 1 view .LVU1034
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 2782              		.loc 1 176 5 view .LVU1035
 2783 0048 FFF7FEFF 		bl	pbuf_free
 2784              	.LVL259:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 2785              		.loc 1 177 5 view .LVU1036
 177:lwIP/src/core/ipv4/etharp.c ****   }
 2786              		.loc 1 177 20 is_stmt 0 view .LVU1037
 2787 004c 2660     		str	r6, [r4]
 2788              	.L367:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
ARM GAS  /tmp/cctR0i1S.s 			page 105


 2789              		.loc 1 180 3 is_stmt 1 view .LVU1038
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 2790              		.loc 1 180 22 is_stmt 0 view .LVU1039
 2791 004e 2675     		strb	r6, [r4, #20]
 2792              	.LBE169:
 2793              	.LBE177:
 2794              	.LBE179:
 203:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2795              		.loc 1 203 35 is_stmt 1 view .LVU1040
 203:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2796              		.loc 1 203 15 view .LVU1041
 2797 0050 1834     		adds	r4, r4, #24
 203:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2798              		.loc 1 203 3 is_stmt 0 view .LVU1042
 2799 0052 AC42     		cmp	r4, r5
 2800 0054 ECD1     		bne	.L371
 2801              	.L386:
 232:lwIP/src/core/ipv4/etharp.c **** 
 2802              		.loc 1 232 1 view .LVU1043
 2803 0056 04B0     		add	sp, sp, #16
 2804              	.LCFI11:
 2805              		.cfi_remember_state
 2806              		.cfi_def_cfa_offset 24
 2807              		@ sp needed
 2808 0058 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2809              	.LVL260:
 2810              	.L383:
 2811              	.LCFI12:
 2812              		.cfi_restore_state
 2813              	.LBB180:
 221:lwIP/src/core/ipv4/etharp.c ****       } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
 2814              		.loc 1 221 9 is_stmt 1 view .LVU1044
 221:lwIP/src/core/ipv4/etharp.c ****       } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
 2815              		.loc 1 221 28 is_stmt 0 view .LVU1045
 2816 005c 0423     		movs	r3, #4
 2817 005e 2375     		strb	r3, [r4, #20]
 2818 0060 E3E7     		b	.L364
 2819              	.L384:
 225:lwIP/src/core/ipv4/etharp.c ****       } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 2820              		.loc 1 225 9 is_stmt 1 view .LVU1046
 225:lwIP/src/core/ipv4/etharp.c ****       } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 2821              		.loc 1 225 28 is_stmt 0 view .LVU1047
 2822 0062 0223     		movs	r3, #2
 2823 0064 2375     		strb	r3, [r4, #20]
 2824 0066 E0E7     		b	.L364
 2825              	.L385:
 228:lwIP/src/core/ipv4/etharp.c ****       }
 2826              		.loc 1 228 9 is_stmt 1 view .LVU1048
 2827 0068 A068     		ldr	r0, [r4, #8]
 2828              	.LVL261:
 2829              	.LBB178:
 2830              	.LBI170:
1198:lwIP/src/core/ipv4/etharp.c **** {
 2831              		.loc 1 1198 1 view .LVU1049
 2832              	.LBB176:
1200:lwIP/src/core/ipv4/etharp.c ****   return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 2833              		.loc 1 1200 89 view .LVU1050
ARM GAS  /tmp/cctR0i1S.s 			page 106


 2834              		.loc 1 1201 3 view .LVU1051
 2835              	.LBB175:
 2836              	.LBI172:
1181:lwIP/src/core/ipv4/etharp.c **** {
 2837              		.loc 1 1181 1 view .LVU1052
 2838              	.LBB174:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 2839              		.loc 1 1183 3 view .LVU1053
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 2840              		.loc 1 1183 10 is_stmt 0 view .LVU1054
 2841 006a 04F1040C 		add	ip, r4, #4
 2842              	.LVL262:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 2843              		.loc 1 1183 10 view .LVU1055
 2844 006e 0392     		str	r2, [sp, #12]
 2845 0070 3A46     		mov	r2, r7
 2846              	.LVL263:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 2847              		.loc 1 1183 47 view .LVU1056
 2848 0072 00F11E03 		add	r3, r0, #30
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 2849              		.loc 1 1183 10 view .LVU1057
 2850 0076 CDF808C0 		str	ip, [sp, #8]
 2851 007a 1946     		mov	r1, r3
 2852 007c CDE90008 		strd	r0, r8, [sp]
 2853 0080 FFF7FEFF 		bl	etharp_raw
 2854              	.LVL264:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 2855              		.loc 1 1183 10 view .LVU1058
 2856              	.LBE174:
 2857              	.LBE175:
 2858              		.loc 1 1201 10 view .LVU1059
 2859 0084 D1E7     		b	.L364
 2860              	.L389:
 2861 0086 00BF     		.align	2
 2862              	.L388:
 2863 0088 00000000 		.word	.LANCHOR0
 2864 008c 00000000 		.word	ethbroadcast
 2865 0090 00000000 		.word	ethzero
 2866              	.LBE176:
 2867              	.LBE178:
 2868              	.LBE180:
 2869              		.cfi_endproc
 2870              	.LFE106:
 2872              		.section	.text.etharp_cleanup_netif,"ax",%progbits
 2873              		.align	1
 2874              		.p2align 2,,3
 2875              		.global	etharp_cleanup_netif
 2876              		.syntax unified
 2877              		.thumb
 2878              		.thumb_func
 2879              		.fpu fpv4-sp-d16
 2881              	etharp_cleanup_netif:
 2882              	.LVL265:
 2883              	.LFB109:
 560:lwIP/src/core/ipv4/etharp.c ****   int i;
 2884              		.loc 1 560 1 is_stmt 1 view -0
ARM GAS  /tmp/cctR0i1S.s 			page 107


 2885              		.cfi_startproc
 2886              		@ args = 0, pretend = 0, frame = 0
 2887              		@ frame_needed = 0, uses_anonymous_args = 0
 561:lwIP/src/core/ipv4/etharp.c **** 
 2888              		.loc 1 561 3 view .LVU1061
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2889              		.loc 1 563 3 view .LVU1062
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2890              		.loc 1 563 15 view .LVU1063
 2891              	.LBB181:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 2892              		.loc 1 564 5 view .LVU1064
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2893              		.loc 1 565 5 view .LVU1065
 2894              	.LBE181:
 560:lwIP/src/core/ipv4/etharp.c ****   int i;
 2895              		.loc 1 560 1 is_stmt 0 view .LVU1066
 2896 0000 38B5     		push	{r3, r4, r5, lr}
 2897              	.LCFI13:
 2898              		.cfi_def_cfa_offset 16
 2899              		.cfi_offset 3, -16
 2900              		.cfi_offset 4, -12
 2901              		.cfi_offset 5, -8
 2902              		.cfi_offset 14, -4
 2903              	.LBB202:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 2904              		.loc 1 564 10 view .LVU1067
 2905 0002 6A4C     		ldr	r4, .L473
 2906              	.LBE202:
 560:lwIP/src/core/ipv4/etharp.c ****   int i;
 2907              		.loc 1 560 1 view .LVU1068
 2908 0004 0546     		mov	r5, r0
 2909              	.LBB203:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2910              		.loc 1 565 8 view .LVU1069
 2911 0006 237D     		ldrb	r3, [r4, #20]	@ zero_extendqisi2
 2912 0008 1BB1     		cbz	r3, .L391
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2913              		.loc 1 565 39 view .LVU1070
 2914 000a A368     		ldr	r3, [r4, #8]
 2915 000c 9842     		cmp	r0, r3
 2916 000e 00F0BE80 		beq	.L454
 2917              	.L391:
 2918              	.LBE203:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2919              		.loc 1 563 35 is_stmt 1 view .LVU1071
 2920              	.LVL266:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2921              		.loc 1 563 15 view .LVU1072
 2922              	.LBB204:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 2923              		.loc 1 564 5 view .LVU1073
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2924              		.loc 1 565 5 view .LVU1074
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2925              		.loc 1 565 8 is_stmt 0 view .LVU1075
 2926 0012 94F82C30 		ldrb	r3, [r4, #44]	@ zero_extendqisi2
ARM GAS  /tmp/cctR0i1S.s 			page 108


 2927 0016 13B1     		cbz	r3, .L394
 2928              	.LVL267:
 2929              	.L472:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2930              		.loc 1 565 39 view .LVU1076
 2931 0018 236A     		ldr	r3, [r4, #32]
 2932 001a 9D42     		cmp	r5, r3
 2933 001c 35D0     		beq	.L455
 2934              	.L394:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2935              		.loc 1 565 39 view .LVU1077
 2936              	.LBE204:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2937              		.loc 1 563 35 is_stmt 1 view .LVU1078
 2938              	.LVL268:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2939              		.loc 1 563 15 view .LVU1079
 2940              	.LBB205:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 2941              		.loc 1 564 5 view .LVU1080
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2942              		.loc 1 565 5 view .LVU1081
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2943              		.loc 1 565 8 is_stmt 0 view .LVU1082
 2944 001e 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 2945 0022 13B1     		cbz	r3, .L397
 2946              	.L464:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2947              		.loc 1 565 39 view .LVU1083
 2948 0024 A36B     		ldr	r3, [r4, #56]
 2949 0026 9D42     		cmp	r5, r3
 2950 0028 3DD0     		beq	.L456
 2951              	.L397:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2952              		.loc 1 565 39 view .LVU1084
 2953              	.LBE205:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2954              		.loc 1 563 35 is_stmt 1 view .LVU1085
 2955              	.LVL269:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2956              		.loc 1 563 15 view .LVU1086
 2957              	.LBB206:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 2958              		.loc 1 564 5 view .LVU1087
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2959              		.loc 1 565 5 view .LVU1088
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2960              		.loc 1 565 8 is_stmt 0 view .LVU1089
 2961 002a 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 2962 002e 13B1     		cbz	r3, .L400
 2963              	.L465:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2964              		.loc 1 565 39 view .LVU1090
 2965 0030 236D     		ldr	r3, [r4, #80]
 2966 0032 9D42     		cmp	r5, r3
 2967 0034 45D0     		beq	.L457
 2968              	.L400:
ARM GAS  /tmp/cctR0i1S.s 			page 109


 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2969              		.loc 1 565 39 view .LVU1091
 2970              	.LBE206:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2971              		.loc 1 563 35 is_stmt 1 view .LVU1092
 2972              	.LVL270:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2973              		.loc 1 563 15 view .LVU1093
 2974              	.LBB207:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 2975              		.loc 1 564 5 view .LVU1094
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2976              		.loc 1 565 5 view .LVU1095
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2977              		.loc 1 565 8 is_stmt 0 view .LVU1096
 2978 0036 94F87430 		ldrb	r3, [r4, #116]	@ zero_extendqisi2
 2979 003a 13B1     		cbz	r3, .L403
 2980              	.L466:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2981              		.loc 1 565 39 view .LVU1097
 2982 003c A36E     		ldr	r3, [r4, #104]
 2983 003e 9D42     		cmp	r5, r3
 2984 0040 4DD0     		beq	.L458
 2985              	.L403:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2986              		.loc 1 565 39 view .LVU1098
 2987              	.LBE207:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2988              		.loc 1 563 35 is_stmt 1 view .LVU1099
 2989              	.LVL271:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 2990              		.loc 1 563 15 view .LVU1100
 2991              	.LBB208:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 2992              		.loc 1 564 5 view .LVU1101
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2993              		.loc 1 565 5 view .LVU1102
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2994              		.loc 1 565 8 is_stmt 0 view .LVU1103
 2995 0042 94F88C30 		ldrb	r3, [r4, #140]	@ zero_extendqisi2
 2996 0046 1BB1     		cbz	r3, .L406
 2997              	.L467:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 2998              		.loc 1 565 39 view .LVU1104
 2999 0048 D4F88030 		ldr	r3, [r4, #128]
 3000 004c 9D42     		cmp	r5, r3
 3001 004e 54D0     		beq	.L459
 3002              	.L406:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3003              		.loc 1 565 39 view .LVU1105
 3004              	.LBE208:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3005              		.loc 1 563 35 is_stmt 1 view .LVU1106
 3006              	.LVL272:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3007              		.loc 1 563 15 view .LVU1107
 3008              	.LBB209:
ARM GAS  /tmp/cctR0i1S.s 			page 110


 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3009              		.loc 1 564 5 view .LVU1108
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3010              		.loc 1 565 5 view .LVU1109
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3011              		.loc 1 565 8 is_stmt 0 view .LVU1110
 3012 0050 94F8A430 		ldrb	r3, [r4, #164]	@ zero_extendqisi2
 3013 0054 1BB1     		cbz	r3, .L409
 3014              	.L468:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3015              		.loc 1 565 39 view .LVU1111
 3016 0056 D4F89830 		ldr	r3, [r4, #152]
 3017 005a 9D42     		cmp	r5, r3
 3018 005c 5BD0     		beq	.L460
 3019              	.L409:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3020              		.loc 1 565 39 view .LVU1112
 3021              	.LBE209:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3022              		.loc 1 563 35 is_stmt 1 view .LVU1113
 3023              	.LVL273:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3024              		.loc 1 563 15 view .LVU1114
 3025              	.LBB210:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3026              		.loc 1 564 5 view .LVU1115
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3027              		.loc 1 565 5 view .LVU1116
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3028              		.loc 1 565 8 is_stmt 0 view .LVU1117
 3029 005e 94F8BC30 		ldrb	r3, [r4, #188]	@ zero_extendqisi2
 3030 0062 1BB1     		cbz	r3, .L412
 3031              	.L469:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3032              		.loc 1 565 39 view .LVU1118
 3033 0064 D4F8B030 		ldr	r3, [r4, #176]
 3034 0068 9D42     		cmp	r5, r3
 3035 006a 64D0     		beq	.L461
 3036              	.L412:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3037              		.loc 1 565 39 view .LVU1119
 3038              	.LBE210:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3039              		.loc 1 563 35 is_stmt 1 view .LVU1120
 3040              	.LVL274:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3041              		.loc 1 563 15 view .LVU1121
 3042              	.LBB211:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3043              		.loc 1 564 5 view .LVU1122
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3044              		.loc 1 565 5 view .LVU1123
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3045              		.loc 1 565 8 is_stmt 0 view .LVU1124
 3046 006c 94F8D430 		ldrb	r3, [r4, #212]	@ zero_extendqisi2
 3047 0070 1BB1     		cbz	r3, .L415
 3048              	.L470:
ARM GAS  /tmp/cctR0i1S.s 			page 111


 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3049              		.loc 1 565 39 view .LVU1125
 3050 0072 D4F8C830 		ldr	r3, [r4, #200]
 3051 0076 9D42     		cmp	r5, r3
 3052 0078 6DD0     		beq	.L462
 3053              	.L415:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3054              		.loc 1 565 39 view .LVU1126
 3055              	.LBE211:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3056              		.loc 1 563 35 is_stmt 1 view .LVU1127
 3057              	.LVL275:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3058              		.loc 1 563 15 view .LVU1128
 3059              	.LBB212:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3060              		.loc 1 564 5 view .LVU1129
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3061              		.loc 1 565 5 view .LVU1130
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3062              		.loc 1 565 8 is_stmt 0 view .LVU1131
 3063 007a 94F8EC30 		ldrb	r3, [r4, #236]	@ zero_extendqisi2
 3064 007e 1BB1     		cbz	r3, .L390
 3065              	.L471:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3066              		.loc 1 565 39 discriminator 1 view .LVU1132
 3067 0080 D4F8E030 		ldr	r3, [r4, #224]
 3068 0084 AB42     		cmp	r3, r5
 3069 0086 76D0     		beq	.L463
 3070              	.L390:
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3071              		.loc 1 565 39 discriminator 1 view .LVU1133
 3072              	.LBE212:
 569:lwIP/src/core/ipv4/etharp.c **** 
 3073              		.loc 1 569 1 view .LVU1134
 3074 0088 38BD     		pop	{r3, r4, r5, pc}
 3075              	.LVL276:
 3076              	.L455:
 3077              	.LBB213:
 566:lwIP/src/core/ipv4/etharp.c ****     }
 3078              		.loc 1 566 7 is_stmt 1 view .LVU1135
 3079              	.LBB182:
 3080              	.LBI182:
 168:lwIP/src/core/ipv4/etharp.c **** {
 3081              		.loc 1 168 1 view .LVU1136
 3082              	.LBB183:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 3083              		.loc 1 171 66 view .LVU1137
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3084              		.loc 1 173 3 view .LVU1138
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3085              		.loc 1 173 19 is_stmt 0 view .LVU1139
 3086 008a A069     		ldr	r0, [r4, #24]
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3087              		.loc 1 173 6 view .LVU1140
 3088 008c 18B1     		cbz	r0, .L396
 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
ARM GAS  /tmp/cctR0i1S.s 			page 112


 3089              		.loc 1 175 133 is_stmt 1 view .LVU1141
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 3090              		.loc 1 176 5 view .LVU1142
 3091 008e FFF7FEFF 		bl	pbuf_free
 3092              	.LVL277:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3093              		.loc 1 177 5 view .LVU1143
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3094              		.loc 1 177 20 is_stmt 0 view .LVU1144
 3095 0092 0023     		movs	r3, #0
 3096 0094 A361     		str	r3, [r4, #24]
 3097              	.L396:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3098              		.loc 1 180 3 is_stmt 1 view .LVU1145
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3099              		.loc 1 180 22 is_stmt 0 view .LVU1146
 3100 0096 0023     		movs	r3, #0
 3101 0098 84F82C30 		strb	r3, [r4, #44]
 3102              	.LVL278:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3103              		.loc 1 180 22 view .LVU1147
 3104              	.LBE183:
 3105              	.LBE182:
 3106              	.LBE213:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3107              		.loc 1 563 35 is_stmt 1 view .LVU1148
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3108              		.loc 1 563 15 view .LVU1149
 3109              	.LBB214:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3110              		.loc 1 564 5 view .LVU1150
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3111              		.loc 1 565 5 view .LVU1151
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3112              		.loc 1 565 8 is_stmt 0 view .LVU1152
 3113 009c 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 3114 00a0 002B     		cmp	r3, #0
 3115 00a2 C2D0     		beq	.L397
 3116 00a4 BEE7     		b	.L464
 3117              	.L456:
 566:lwIP/src/core/ipv4/etharp.c ****     }
 3118              		.loc 1 566 7 is_stmt 1 view .LVU1153
 3119              	.LVL279:
 3120              	.LBB193:
 168:lwIP/src/core/ipv4/etharp.c **** {
 3121              		.loc 1 168 1 view .LVU1154
 3122              	.LBB184:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 3123              		.loc 1 171 66 view .LVU1155
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3124              		.loc 1 173 3 view .LVU1156
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3125              		.loc 1 173 19 is_stmt 0 view .LVU1157
 3126 00a6 206B     		ldr	r0, [r4, #48]
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3127              		.loc 1 173 6 view .LVU1158
 3128 00a8 18B1     		cbz	r0, .L399
ARM GAS  /tmp/cctR0i1S.s 			page 113


 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 3129              		.loc 1 175 133 is_stmt 1 view .LVU1159
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 3130              		.loc 1 176 5 view .LVU1160
 3131 00aa FFF7FEFF 		bl	pbuf_free
 3132              	.LVL280:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3133              		.loc 1 177 5 view .LVU1161
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3134              		.loc 1 177 20 is_stmt 0 view .LVU1162
 3135 00ae 0023     		movs	r3, #0
 3136 00b0 2363     		str	r3, [r4, #48]
 3137              	.L399:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3138              		.loc 1 180 3 is_stmt 1 view .LVU1163
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3139              		.loc 1 180 22 is_stmt 0 view .LVU1164
 3140 00b2 0023     		movs	r3, #0
 3141 00b4 84F84430 		strb	r3, [r4, #68]
 3142              	.LVL281:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3143              		.loc 1 180 22 view .LVU1165
 3144              	.LBE184:
 3145              	.LBE193:
 3146              	.LBE214:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3147              		.loc 1 563 35 is_stmt 1 view .LVU1166
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3148              		.loc 1 563 15 view .LVU1167
 3149              	.LBB215:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3150              		.loc 1 564 5 view .LVU1168
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3151              		.loc 1 565 5 view .LVU1169
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3152              		.loc 1 565 8 is_stmt 0 view .LVU1170
 3153 00b8 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 3154 00bc 002B     		cmp	r3, #0
 3155 00be BAD0     		beq	.L400
 3156 00c0 B6E7     		b	.L465
 3157              	.L457:
 566:lwIP/src/core/ipv4/etharp.c ****     }
 3158              		.loc 1 566 7 is_stmt 1 view .LVU1171
 3159              	.LVL282:
 3160              	.LBB194:
 168:lwIP/src/core/ipv4/etharp.c **** {
 3161              		.loc 1 168 1 view .LVU1172
 3162              	.LBB185:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 3163              		.loc 1 171 66 view .LVU1173
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3164              		.loc 1 173 3 view .LVU1174
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3165              		.loc 1 173 19 is_stmt 0 view .LVU1175
 3166 00c2 A06C     		ldr	r0, [r4, #72]
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3167              		.loc 1 173 6 view .LVU1176
ARM GAS  /tmp/cctR0i1S.s 			page 114


 3168 00c4 18B1     		cbz	r0, .L402
 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 3169              		.loc 1 175 133 is_stmt 1 view .LVU1177
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 3170              		.loc 1 176 5 view .LVU1178
 3171 00c6 FFF7FEFF 		bl	pbuf_free
 3172              	.LVL283:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3173              		.loc 1 177 5 view .LVU1179
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3174              		.loc 1 177 20 is_stmt 0 view .LVU1180
 3175 00ca 0023     		movs	r3, #0
 3176 00cc A364     		str	r3, [r4, #72]
 3177              	.L402:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3178              		.loc 1 180 3 is_stmt 1 view .LVU1181
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3179              		.loc 1 180 22 is_stmt 0 view .LVU1182
 3180 00ce 0023     		movs	r3, #0
 3181 00d0 84F85C30 		strb	r3, [r4, #92]
 3182              	.LVL284:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3183              		.loc 1 180 22 view .LVU1183
 3184              	.LBE185:
 3185              	.LBE194:
 3186              	.LBE215:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3187              		.loc 1 563 35 is_stmt 1 view .LVU1184
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3188              		.loc 1 563 15 view .LVU1185
 3189              	.LBB216:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3190              		.loc 1 564 5 view .LVU1186
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3191              		.loc 1 565 5 view .LVU1187
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3192              		.loc 1 565 8 is_stmt 0 view .LVU1188
 3193 00d4 94F87430 		ldrb	r3, [r4, #116]	@ zero_extendqisi2
 3194 00d8 002B     		cmp	r3, #0
 3195 00da B2D0     		beq	.L403
 3196 00dc AEE7     		b	.L466
 3197              	.L458:
 566:lwIP/src/core/ipv4/etharp.c ****     }
 3198              		.loc 1 566 7 is_stmt 1 view .LVU1189
 3199              	.LVL285:
 3200              	.LBB195:
 168:lwIP/src/core/ipv4/etharp.c **** {
 3201              		.loc 1 168 1 view .LVU1190
 3202              	.LBB186:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 3203              		.loc 1 171 66 view .LVU1191
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3204              		.loc 1 173 3 view .LVU1192
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3205              		.loc 1 173 19 is_stmt 0 view .LVU1193
 3206 00de 206E     		ldr	r0, [r4, #96]
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
ARM GAS  /tmp/cctR0i1S.s 			page 115


 3207              		.loc 1 173 6 view .LVU1194
 3208 00e0 18B1     		cbz	r0, .L405
 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 3209              		.loc 1 175 133 is_stmt 1 view .LVU1195
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 3210              		.loc 1 176 5 view .LVU1196
 3211 00e2 FFF7FEFF 		bl	pbuf_free
 3212              	.LVL286:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3213              		.loc 1 177 5 view .LVU1197
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3214              		.loc 1 177 20 is_stmt 0 view .LVU1198
 3215 00e6 0023     		movs	r3, #0
 3216 00e8 2366     		str	r3, [r4, #96]
 3217              	.L405:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3218              		.loc 1 180 3 is_stmt 1 view .LVU1199
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3219              		.loc 1 180 22 is_stmt 0 view .LVU1200
 3220 00ea 0023     		movs	r3, #0
 3221 00ec 84F87430 		strb	r3, [r4, #116]
 3222              	.LVL287:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3223              		.loc 1 180 22 view .LVU1201
 3224              	.LBE186:
 3225              	.LBE195:
 3226              	.LBE216:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3227              		.loc 1 563 35 is_stmt 1 view .LVU1202
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3228              		.loc 1 563 15 view .LVU1203
 3229              	.LBB217:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3230              		.loc 1 564 5 view .LVU1204
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3231              		.loc 1 565 5 view .LVU1205
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3232              		.loc 1 565 8 is_stmt 0 view .LVU1206
 3233 00f0 94F88C30 		ldrb	r3, [r4, #140]	@ zero_extendqisi2
 3234 00f4 002B     		cmp	r3, #0
 3235 00f6 ABD0     		beq	.L406
 3236 00f8 A6E7     		b	.L467
 3237              	.L459:
 566:lwIP/src/core/ipv4/etharp.c ****     }
 3238              		.loc 1 566 7 is_stmt 1 view .LVU1207
 3239              	.LVL288:
 3240              	.LBB196:
 168:lwIP/src/core/ipv4/etharp.c **** {
 3241              		.loc 1 168 1 view .LVU1208
 3242              	.LBB187:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 3243              		.loc 1 171 66 view .LVU1209
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3244              		.loc 1 173 3 view .LVU1210
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3245              		.loc 1 173 19 is_stmt 0 view .LVU1211
 3246 00fa A06F     		ldr	r0, [r4, #120]
ARM GAS  /tmp/cctR0i1S.s 			page 116


 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3247              		.loc 1 173 6 view .LVU1212
 3248 00fc 18B1     		cbz	r0, .L408
 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 3249              		.loc 1 175 133 is_stmt 1 view .LVU1213
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 3250              		.loc 1 176 5 view .LVU1214
 3251 00fe FFF7FEFF 		bl	pbuf_free
 3252              	.LVL289:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3253              		.loc 1 177 5 view .LVU1215
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3254              		.loc 1 177 20 is_stmt 0 view .LVU1216
 3255 0102 0023     		movs	r3, #0
 3256 0104 A367     		str	r3, [r4, #120]
 3257              	.L408:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3258              		.loc 1 180 3 is_stmt 1 view .LVU1217
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3259              		.loc 1 180 22 is_stmt 0 view .LVU1218
 3260 0106 0023     		movs	r3, #0
 3261 0108 84F88C30 		strb	r3, [r4, #140]
 3262              	.LVL290:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3263              		.loc 1 180 22 view .LVU1219
 3264              	.LBE187:
 3265              	.LBE196:
 3266              	.LBE217:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3267              		.loc 1 563 35 is_stmt 1 view .LVU1220
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3268              		.loc 1 563 15 view .LVU1221
 3269              	.LBB218:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3270              		.loc 1 564 5 view .LVU1222
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3271              		.loc 1 565 5 view .LVU1223
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3272              		.loc 1 565 8 is_stmt 0 view .LVU1224
 3273 010c 94F8A430 		ldrb	r3, [r4, #164]	@ zero_extendqisi2
 3274 0110 002B     		cmp	r3, #0
 3275 0112 A4D0     		beq	.L409
 3276 0114 9FE7     		b	.L468
 3277              	.L460:
 566:lwIP/src/core/ipv4/etharp.c ****     }
 3278              		.loc 1 566 7 is_stmt 1 view .LVU1225
 3279              	.LVL291:
 3280              	.LBB197:
 168:lwIP/src/core/ipv4/etharp.c **** {
 3281              		.loc 1 168 1 view .LVU1226
 3282              	.LBB188:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 3283              		.loc 1 171 66 view .LVU1227
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3284              		.loc 1 173 3 view .LVU1228
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3285              		.loc 1 173 19 is_stmt 0 view .LVU1229
ARM GAS  /tmp/cctR0i1S.s 			page 117


 3286 0116 D4F89000 		ldr	r0, [r4, #144]
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3287              		.loc 1 173 6 view .LVU1230
 3288 011a 20B1     		cbz	r0, .L411
 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 3289              		.loc 1 175 133 is_stmt 1 view .LVU1231
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 3290              		.loc 1 176 5 view .LVU1232
 3291 011c FFF7FEFF 		bl	pbuf_free
 3292              	.LVL292:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3293              		.loc 1 177 5 view .LVU1233
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3294              		.loc 1 177 20 is_stmt 0 view .LVU1234
 3295 0120 0023     		movs	r3, #0
 3296 0122 C4F89030 		str	r3, [r4, #144]
 3297              	.L411:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3298              		.loc 1 180 3 is_stmt 1 view .LVU1235
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3299              		.loc 1 180 22 is_stmt 0 view .LVU1236
 3300 0126 0023     		movs	r3, #0
 3301 0128 84F8A430 		strb	r3, [r4, #164]
 3302              	.LVL293:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3303              		.loc 1 180 22 view .LVU1237
 3304              	.LBE188:
 3305              	.LBE197:
 3306              	.LBE218:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3307              		.loc 1 563 35 is_stmt 1 view .LVU1238
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3308              		.loc 1 563 15 view .LVU1239
 3309              	.LBB219:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3310              		.loc 1 564 5 view .LVU1240
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3311              		.loc 1 565 5 view .LVU1241
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3312              		.loc 1 565 8 is_stmt 0 view .LVU1242
 3313 012c 94F8BC30 		ldrb	r3, [r4, #188]	@ zero_extendqisi2
 3314 0130 002B     		cmp	r3, #0
 3315 0132 9BD0     		beq	.L412
 3316 0134 96E7     		b	.L469
 3317              	.L461:
 566:lwIP/src/core/ipv4/etharp.c ****     }
 3318              		.loc 1 566 7 is_stmt 1 view .LVU1243
 3319              	.LVL294:
 3320              	.LBB198:
 168:lwIP/src/core/ipv4/etharp.c **** {
 3321              		.loc 1 168 1 view .LVU1244
 3322              	.LBB189:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 3323              		.loc 1 171 66 view .LVU1245
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3324              		.loc 1 173 3 view .LVU1246
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
ARM GAS  /tmp/cctR0i1S.s 			page 118


 3325              		.loc 1 173 19 is_stmt 0 view .LVU1247
 3326 0136 D4F8A800 		ldr	r0, [r4, #168]
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3327              		.loc 1 173 6 view .LVU1248
 3328 013a 20B1     		cbz	r0, .L414
 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 3329              		.loc 1 175 133 is_stmt 1 view .LVU1249
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 3330              		.loc 1 176 5 view .LVU1250
 3331 013c FFF7FEFF 		bl	pbuf_free
 3332              	.LVL295:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3333              		.loc 1 177 5 view .LVU1251
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3334              		.loc 1 177 20 is_stmt 0 view .LVU1252
 3335 0140 0023     		movs	r3, #0
 3336 0142 C4F8A830 		str	r3, [r4, #168]
 3337              	.L414:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3338              		.loc 1 180 3 is_stmt 1 view .LVU1253
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3339              		.loc 1 180 22 is_stmt 0 view .LVU1254
 3340 0146 0023     		movs	r3, #0
 3341 0148 84F8BC30 		strb	r3, [r4, #188]
 3342              	.LVL296:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3343              		.loc 1 180 22 view .LVU1255
 3344              	.LBE189:
 3345              	.LBE198:
 3346              	.LBE219:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3347              		.loc 1 563 35 is_stmt 1 view .LVU1256
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3348              		.loc 1 563 15 view .LVU1257
 3349              	.LBB220:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3350              		.loc 1 564 5 view .LVU1258
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3351              		.loc 1 565 5 view .LVU1259
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3352              		.loc 1 565 8 is_stmt 0 view .LVU1260
 3353 014c 94F8D430 		ldrb	r3, [r4, #212]	@ zero_extendqisi2
 3354 0150 002B     		cmp	r3, #0
 3355 0152 92D0     		beq	.L415
 3356 0154 8DE7     		b	.L470
 3357              	.L462:
 566:lwIP/src/core/ipv4/etharp.c ****     }
 3358              		.loc 1 566 7 is_stmt 1 view .LVU1261
 3359              	.LVL297:
 3360              	.LBB199:
 168:lwIP/src/core/ipv4/etharp.c **** {
 3361              		.loc 1 168 1 view .LVU1262
 3362              	.LBB190:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 3363              		.loc 1 171 66 view .LVU1263
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3364              		.loc 1 173 3 view .LVU1264
ARM GAS  /tmp/cctR0i1S.s 			page 119


 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3365              		.loc 1 173 19 is_stmt 0 view .LVU1265
 3366 0156 D4F8C000 		ldr	r0, [r4, #192]
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3367              		.loc 1 173 6 view .LVU1266
 3368 015a 20B1     		cbz	r0, .L417
 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 3369              		.loc 1 175 133 is_stmt 1 view .LVU1267
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 3370              		.loc 1 176 5 view .LVU1268
 3371 015c FFF7FEFF 		bl	pbuf_free
 3372              	.LVL298:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3373              		.loc 1 177 5 view .LVU1269
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3374              		.loc 1 177 20 is_stmt 0 view .LVU1270
 3375 0160 0023     		movs	r3, #0
 3376 0162 C4F8C030 		str	r3, [r4, #192]
 3377              	.L417:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3378              		.loc 1 180 3 is_stmt 1 view .LVU1271
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3379              		.loc 1 180 22 is_stmt 0 view .LVU1272
 3380 0166 0023     		movs	r3, #0
 3381 0168 84F8D430 		strb	r3, [r4, #212]
 3382              	.LVL299:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3383              		.loc 1 180 22 view .LVU1273
 3384              	.LBE190:
 3385              	.LBE199:
 3386              	.LBE220:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3387              		.loc 1 563 35 is_stmt 1 view .LVU1274
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3388              		.loc 1 563 15 view .LVU1275
 3389              	.LBB221:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3390              		.loc 1 564 5 view .LVU1276
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3391              		.loc 1 565 5 view .LVU1277
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3392              		.loc 1 565 8 is_stmt 0 view .LVU1278
 3393 016c 94F8EC30 		ldrb	r3, [r4, #236]	@ zero_extendqisi2
 3394 0170 002B     		cmp	r3, #0
 3395 0172 89D0     		beq	.L390
 3396 0174 84E7     		b	.L471
 3397              	.L463:
 566:lwIP/src/core/ipv4/etharp.c ****     }
 3398              		.loc 1 566 7 is_stmt 1 view .LVU1279
 3399              	.LVL300:
 3400              	.LBB200:
 168:lwIP/src/core/ipv4/etharp.c **** {
 3401              		.loc 1 168 1 view .LVU1280
 3402              	.LBB191:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 3403              		.loc 1 171 66 view .LVU1281
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
ARM GAS  /tmp/cctR0i1S.s 			page 120


 3404              		.loc 1 173 3 view .LVU1282
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3405              		.loc 1 173 19 is_stmt 0 view .LVU1283
 3406 0176 D4F8D800 		ldr	r0, [r4, #216]
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3407              		.loc 1 173 6 view .LVU1284
 3408 017a 20B1     		cbz	r0, .L419
 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 3409              		.loc 1 175 133 is_stmt 1 view .LVU1285
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 3410              		.loc 1 176 5 view .LVU1286
 3411 017c FFF7FEFF 		bl	pbuf_free
 3412              	.LVL301:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3413              		.loc 1 177 5 view .LVU1287
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3414              		.loc 1 177 20 is_stmt 0 view .LVU1288
 3415 0180 0023     		movs	r3, #0
 3416 0182 C4F8D830 		str	r3, [r4, #216]
 3417              	.L419:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3418              		.loc 1 180 3 is_stmt 1 view .LVU1289
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3419              		.loc 1 180 22 is_stmt 0 view .LVU1290
 3420 0186 0023     		movs	r3, #0
 3421 0188 84F8EC30 		strb	r3, [r4, #236]
 3422              	.LVL302:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3423              		.loc 1 180 22 view .LVU1291
 3424              	.LBE191:
 3425              	.LBE200:
 3426              	.LBE221:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3427              		.loc 1 563 35 is_stmt 1 view .LVU1292
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3428              		.loc 1 563 15 view .LVU1293
 569:lwIP/src/core/ipv4/etharp.c **** 
 3429              		.loc 1 569 1 is_stmt 0 view .LVU1294
 3430 018c 38BD     		pop	{r3, r4, r5, pc}
 3431              	.LVL303:
 3432              	.L454:
 3433              	.LBB222:
 566:lwIP/src/core/ipv4/etharp.c ****     }
 3434              		.loc 1 566 7 is_stmt 1 view .LVU1295
 3435              	.LBB201:
 168:lwIP/src/core/ipv4/etharp.c **** {
 3436              		.loc 1 168 1 view .LVU1296
 3437              	.LBB192:
 171:lwIP/src/core/ipv4/etharp.c ****   /* and empty packet queue */
 3438              		.loc 1 171 66 view .LVU1297
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3439              		.loc 1 173 3 view .LVU1298
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
 3440              		.loc 1 173 19 is_stmt 0 view .LVU1299
 3441 018e 2068     		ldr	r0, [r4]
 3442              	.LVL304:
 173:lwIP/src/core/ipv4/etharp.c ****     /* remove all queued packets */
ARM GAS  /tmp/cctR0i1S.s 			page 121


 3443              		.loc 1 173 6 view .LVU1300
 3444 0190 18B1     		cbz	r0, .L393
 175:lwIP/src/core/ipv4/etharp.c ****     free_etharp_q(arp_table[i].q);
 3445              		.loc 1 175 133 is_stmt 1 view .LVU1301
 176:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 3446              		.loc 1 176 5 view .LVU1302
 3447 0192 FFF7FEFF 		bl	pbuf_free
 3448              	.LVL305:
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3449              		.loc 1 177 5 view .LVU1303
 177:lwIP/src/core/ipv4/etharp.c ****   }
 3450              		.loc 1 177 20 is_stmt 0 view .LVU1304
 3451 0196 0023     		movs	r3, #0
 3452 0198 2360     		str	r3, [r4]
 3453              	.L393:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3454              		.loc 1 180 3 is_stmt 1 view .LVU1305
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3455              		.loc 1 180 22 is_stmt 0 view .LVU1306
 3456 019a 0023     		movs	r3, #0
 3457 019c 2375     		strb	r3, [r4, #20]
 3458              	.LVL306:
 180:lwIP/src/core/ipv4/etharp.c **** #ifdef LWIP_DEBUG
 3459              		.loc 1 180 22 view .LVU1307
 3460              	.LBE192:
 3461              	.LBE201:
 3462              	.LBE222:
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3463              		.loc 1 563 35 is_stmt 1 view .LVU1308
 563:lwIP/src/core/ipv4/etharp.c ****     u8_t state = arp_table[i].state;
 3464              		.loc 1 563 15 view .LVU1309
 3465              	.LBB223:
 564:lwIP/src/core/ipv4/etharp.c ****     if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 3466              		.loc 1 564 5 view .LVU1310
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3467              		.loc 1 565 5 view .LVU1311
 565:lwIP/src/core/ipv4/etharp.c ****       etharp_free_entry(i);
 3468              		.loc 1 565 8 is_stmt 0 view .LVU1312
 3469 019e 94F82C30 		ldrb	r3, [r4, #44]	@ zero_extendqisi2
 3470 01a2 002B     		cmp	r3, #0
 3471 01a4 3FF43BAF 		beq	.L394
 3472 01a8 36E7     		b	.L472
 3473              	.L474:
 3474 01aa 00BF     		.align	2
 3475              	.L473:
 3476 01ac 00000000 		.word	.LANCHOR0
 3477              	.LBE223:
 3478              		.cfi_endproc
 3479              	.LFE109:
 3481              		.section	.rodata.etharp_find_addr.str1.4,"aMS",%progbits,1
 3482              		.align	2
 3483              	.LC6:
 3484 0000 6574685F 		.ascii	"eth_ret != NULL && ip_ret != NULL\000"
 3484      72657420 
 3484      213D204E 
 3484      554C4C20 
 3484      26262069 
ARM GAS  /tmp/cctR0i1S.s 			page 122


 3485              		.section	.text.etharp_find_addr,"ax",%progbits
 3486              		.align	1
 3487              		.p2align 2,,3
 3488              		.global	etharp_find_addr
 3489              		.syntax unified
 3490              		.thumb
 3491              		.thumb_func
 3492              		.fpu fpv4-sp-d16
 3494              	etharp_find_addr:
 3495              	.LVL307:
 3496              	.LFB110:
 585:lwIP/src/core/ipv4/etharp.c ****   s16_t i;
 3497              		.loc 1 585 1 is_stmt 1 view -0
 3498              		.cfi_startproc
 3499              		@ args = 0, pretend = 0, frame = 0
 3500              		@ frame_needed = 0, uses_anonymous_args = 0
 586:lwIP/src/core/ipv4/etharp.c **** 
 3501              		.loc 1 586 3 view .LVU1314
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 3502              		.loc 1 588 3 view .LVU1315
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 3503              		.loc 1 588 3 view .LVU1316
 585:lwIP/src/core/ipv4/etharp.c ****   s16_t i;
 3504              		.loc 1 585 1 is_stmt 0 view .LVU1317
 3505 0000 70B5     		push	{r4, r5, r6, lr}
 3506              	.LCFI14:
 3507              		.cfi_def_cfa_offset 16
 3508              		.cfi_offset 4, -16
 3509              		.cfi_offset 5, -12
 3510              		.cfi_offset 6, -8
 3511              		.cfi_offset 14, -4
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 3512              		.loc 1 588 3 view .LVU1318
 3513 0002 CAB1     		cbz	r2, .L482
 3514 0004 1D46     		mov	r5, r3
 3515 0006 BBB1     		cbz	r3, .L482
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 3516              		.loc 1 588 3 is_stmt 1 discriminator 2 view .LVU1319
 591:lwIP/src/core/ipv4/etharp.c **** 
 3517              		.loc 1 591 3 discriminator 2 view .LVU1320
 593:lwIP/src/core/ipv4/etharp.c ****   if ((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 3518              		.loc 1 593 3 discriminator 2 view .LVU1321
 3519 0008 0846     		mov	r0, r1
 3520              	.LVL308:
 593:lwIP/src/core/ipv4/etharp.c ****   if ((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 3521              		.loc 1 593 7 is_stmt 0 discriminator 2 view .LVU1322
 3522 000a 0221     		movs	r1, #2
 3523              	.LVL309:
 593:lwIP/src/core/ipv4/etharp.c ****   if ((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 3524              		.loc 1 593 7 discriminator 2 view .LVU1323
 3525 000c 1646     		mov	r6, r2
 3526 000e FFF7FEFF 		bl	etharp_find_entry.isra.0
 3527              	.LVL310:
 594:lwIP/src/core/ipv4/etharp.c ****     *eth_ret = &arp_table[i].ethaddr;
 3528              		.loc 1 594 3 is_stmt 1 discriminator 2 view .LVU1324
 594:lwIP/src/core/ipv4/etharp.c ****     *eth_ret = &arp_table[i].ethaddr;
 3529              		.loc 1 594 6 is_stmt 0 discriminator 2 view .LVU1325
ARM GAS  /tmp/cctR0i1S.s 			page 123


 3530 0012 0028     		cmp	r0, #0
 3531              	.LVL311:
 594:lwIP/src/core/ipv4/etharp.c ****     *eth_ret = &arp_table[i].ethaddr;
 3532              		.loc 1 594 6 discriminator 2 view .LVU1326
 3533 0014 14DB     		blt	.L481
 594:lwIP/src/core/ipv4/etharp.c ****     *eth_ret = &arp_table[i].ethaddr;
 3534              		.loc 1 594 32 discriminator 1 view .LVU1327
 3535 0016 00EB4001 		add	r1, r0, r0, lsl #1
 3536 001a 0B4C     		ldr	r4, .L484
 3537 001c 04EBC103 		add	r3, r4, r1, lsl #3
 3538 0020 C900     		lsls	r1, r1, #3
 594:lwIP/src/core/ipv4/etharp.c ****     *eth_ret = &arp_table[i].ethaddr;
 3539              		.loc 1 594 16 discriminator 1 view .LVU1328
 3540 0022 1B7D     		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 3541 0024 012B     		cmp	r3, #1
 3542 0026 0BD9     		bls	.L481
 595:lwIP/src/core/ipv4/etharp.c ****     *ip_ret = &arp_table[i].ipaddr;
 3543              		.loc 1 595 5 is_stmt 1 view .LVU1329
 595:lwIP/src/core/ipv4/etharp.c ****     *ip_ret = &arp_table[i].ipaddr;
 3544              		.loc 1 595 16 is_stmt 0 view .LVU1330
 3545 0028 01F10C03 		add	r3, r1, #12
 596:lwIP/src/core/ipv4/etharp.c ****     return i;
 3546              		.loc 1 596 15 view .LVU1331
 3547 002c 0431     		adds	r1, r1, #4
 595:lwIP/src/core/ipv4/etharp.c ****     *ip_ret = &arp_table[i].ipaddr;
 3548              		.loc 1 595 16 view .LVU1332
 3549 002e 2344     		add	r3, r3, r4
 596:lwIP/src/core/ipv4/etharp.c ****     return i;
 3550              		.loc 1 596 15 view .LVU1333
 3551 0030 2144     		add	r1, r1, r4
 595:lwIP/src/core/ipv4/etharp.c ****     *ip_ret = &arp_table[i].ipaddr;
 3552              		.loc 1 595 14 view .LVU1334
 3553 0032 3360     		str	r3, [r6]
 596:lwIP/src/core/ipv4/etharp.c ****     return i;
 3554              		.loc 1 596 5 is_stmt 1 view .LVU1335
 596:lwIP/src/core/ipv4/etharp.c ****     return i;
 3555              		.loc 1 596 13 is_stmt 0 view .LVU1336
 3556 0034 2960     		str	r1, [r5]
 597:lwIP/src/core/ipv4/etharp.c ****   }
 3557              		.loc 1 597 5 is_stmt 1 view .LVU1337
 600:lwIP/src/core/ipv4/etharp.c **** 
 3558              		.loc 1 600 1 is_stmt 0 view .LVU1338
 3559 0036 70BD     		pop	{r4, r5, r6, pc}
 3560              	.LVL312:
 3561              	.L482:
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 3562              		.loc 1 588 3 is_stmt 1 discriminator 1 view .LVU1339
 3563 0038 0448     		ldr	r0, .L484+4
 3564              	.LVL313:
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 3565              		.loc 1 588 3 is_stmt 0 discriminator 1 view .LVU1340
 3566 003a FFF7FEFF 		bl	printf
 3567              	.LVL314:
 3568              	.L478:
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 3569              		.loc 1 588 3 is_stmt 1 discriminator 1 view .LVU1341
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
ARM GAS  /tmp/cctR0i1S.s 			page 124


 3570              		.loc 1 588 3 discriminator 1 view .LVU1342
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 3571              		.loc 1 588 3 discriminator 1 view .LVU1343
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 3572              		.loc 1 588 3 discriminator 1 view .LVU1344
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 3573              		.loc 1 588 3 discriminator 1 view .LVU1345
 588:lwIP/src/core/ipv4/etharp.c ****               eth_ret != NULL && ip_ret != NULL);
 3574              		.loc 1 588 3 discriminator 1 view .LVU1346
 3575 003e FEE7     		b	.L478
 3576              	.LVL315:
 3577              	.L481:
 599:lwIP/src/core/ipv4/etharp.c **** }
 3578              		.loc 1 599 10 is_stmt 0 view .LVU1347
 3579 0040 4FF0FF30 		mov	r0, #-1
 600:lwIP/src/core/ipv4/etharp.c **** 
 3580              		.loc 1 600 1 view .LVU1348
 3581 0044 70BD     		pop	{r4, r5, r6, pc}
 3582              	.LVL316:
 3583              	.L485:
 600:lwIP/src/core/ipv4/etharp.c **** 
 3584              		.loc 1 600 1 view .LVU1349
 3585 0046 00BF     		.align	2
 3586              	.L484:
 3587 0048 00000000 		.word	.LANCHOR0
 3588 004c 00000000 		.word	.LC6
 3589              		.cfi_endproc
 3590              	.LFE110:
 3592              		.section	.rodata.etharp_get_entry.str1.4,"aMS",%progbits,1
 3593              		.align	2
 3594              	.LC7:
 3595 0000 69706164 		.ascii	"ipaddr != NULL\000"
 3595      64722021 
 3595      3D204E55 
 3595      4C4C00
 3596 000f 00       		.align	2
 3597              	.LC8:
 3598 0010 6574685F 		.ascii	"eth_ret != NULL\000"
 3598      72657420 
 3598      213D204E 
 3598      554C4C00 
 3599              		.section	.text.etharp_get_entry,"ax",%progbits
 3600              		.align	1
 3601              		.p2align 2,,3
 3602              		.global	etharp_get_entry
 3603              		.syntax unified
 3604              		.thumb
 3605              		.thumb_func
 3606              		.fpu fpv4-sp-d16
 3608              	etharp_get_entry:
 3609              	.LVL317:
 3610              	.LFB111:
 613:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 3611              		.loc 1 613 1 is_stmt 1 view -0
 3612              		.cfi_startproc
 3613              		@ args = 0, pretend = 0, frame = 0
 3614              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cctR0i1S.s 			page 125


 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 3615              		.loc 1 614 3 view .LVU1351
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 3616              		.loc 1 614 3 view .LVU1352
 613:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 3617              		.loc 1 613 1 is_stmt 0 view .LVU1353
 3618 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3619              	.LCFI15:
 3620              		.cfi_def_cfa_offset 24
 3621              		.cfi_offset 3, -24
 3622              		.cfi_offset 4, -20
 3623              		.cfi_offset 5, -16
 3624              		.cfi_offset 6, -12
 3625              		.cfi_offset 7, -8
 3626              		.cfi_offset 14, -4
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 3627              		.loc 1 614 3 view .LVU1354
 3628 0002 C9B1     		cbz	r1, .L497
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 3629              		.loc 1 614 3 is_stmt 1 discriminator 2 view .LVU1355
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 3630              		.loc 1 615 3 discriminator 2 view .LVU1356
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 3631              		.loc 1 615 3 discriminator 2 view .LVU1357
 3632 0004 E2B1     		cbz	r2, .L498
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 3633              		.loc 1 615 3 discriminator 2 view .LVU1358
 616:lwIP/src/core/ipv4/etharp.c **** 
 3634              		.loc 1 616 3 discriminator 2 view .LVU1359
 616:lwIP/src/core/ipv4/etharp.c **** 
 3635              		.loc 1 616 3 discriminator 2 view .LVU1360
 3636 0006 FBB1     		cbz	r3, .L499
 616:lwIP/src/core/ipv4/etharp.c **** 
 3637              		.loc 1 616 3 discriminator 2 view .LVU1361
 618:lwIP/src/core/ipv4/etharp.c ****     *ipaddr  = &arp_table[i].ipaddr;
 3638              		.loc 1 618 3 discriminator 2 view .LVU1362
 618:lwIP/src/core/ipv4/etharp.c ****     *ipaddr  = &arp_table[i].ipaddr;
 3639              		.loc 1 618 6 is_stmt 0 discriminator 2 view .LVU1363
 3640 0008 0928     		cmp	r0, #9
 3641 000a 13D8     		bhi	.L495
 618:lwIP/src/core/ipv4/etharp.c ****     *ipaddr  = &arp_table[i].ipaddr;
 3642              		.loc 1 618 44 discriminator 1 view .LVU1364
 3643 000c 00EB4000 		add	r0, r0, r0, lsl #1
 3644              	.LVL318:
 618:lwIP/src/core/ipv4/etharp.c ****     *ipaddr  = &arp_table[i].ipaddr;
 3645              		.loc 1 618 44 discriminator 1 view .LVU1365
 3646 0010 0F4D     		ldr	r5, .L500
 3647 0012 05EBC007 		add	r7, r5, r0, lsl #3
 3648 0016 C000     		lsls	r0, r0, #3
 618:lwIP/src/core/ipv4/etharp.c ****     *ipaddr  = &arp_table[i].ipaddr;
 3649              		.loc 1 618 28 discriminator 1 view .LVU1366
 3650 0018 3C7D     		ldrb	r4, [r7, #20]	@ zero_extendqisi2
 3651 001a 012C     		cmp	r4, #1
 3652 001c 0AD9     		bls	.L495
 619:lwIP/src/core/ipv4/etharp.c ****     *netif   = arp_table[i].netif;
 3653              		.loc 1 619 5 is_stmt 1 view .LVU1367
 619:lwIP/src/core/ipv4/etharp.c ****     *netif   = arp_table[i].netif;
ARM GAS  /tmp/cctR0i1S.s 			page 126


 3654              		.loc 1 619 16 is_stmt 0 view .LVU1368
 3655 001e 061D     		adds	r6, r0, #4
 621:lwIP/src/core/ipv4/etharp.c ****     return 1;
 3656              		.loc 1 621 16 view .LVU1369
 3657 0020 00F10C04 		add	r4, r0, #12
 620:lwIP/src/core/ipv4/etharp.c ****     *eth_ret = &arp_table[i].ethaddr;
 3658              		.loc 1 620 28 view .LVU1370
 3659 0024 BF68     		ldr	r7, [r7, #8]
 622:lwIP/src/core/ipv4/etharp.c ****   } else {
 3660              		.loc 1 622 12 view .LVU1371
 3661 0026 0120     		movs	r0, #1
 619:lwIP/src/core/ipv4/etharp.c ****     *netif   = arp_table[i].netif;
 3662              		.loc 1 619 16 view .LVU1372
 3663 0028 2E44     		add	r6, r6, r5
 621:lwIP/src/core/ipv4/etharp.c ****     return 1;
 3664              		.loc 1 621 16 view .LVU1373
 3665 002a 2C44     		add	r4, r4, r5
 619:lwIP/src/core/ipv4/etharp.c ****     *netif   = arp_table[i].netif;
 3666              		.loc 1 619 14 view .LVU1374
 3667 002c 0E60     		str	r6, [r1]
 620:lwIP/src/core/ipv4/etharp.c ****     *eth_ret = &arp_table[i].ethaddr;
 3668              		.loc 1 620 5 is_stmt 1 view .LVU1375
 620:lwIP/src/core/ipv4/etharp.c ****     *eth_ret = &arp_table[i].ethaddr;
 3669              		.loc 1 620 14 is_stmt 0 view .LVU1376
 3670 002e 1760     		str	r7, [r2]
 621:lwIP/src/core/ipv4/etharp.c ****     return 1;
 3671              		.loc 1 621 5 is_stmt 1 view .LVU1377
 621:lwIP/src/core/ipv4/etharp.c ****     return 1;
 3672              		.loc 1 621 14 is_stmt 0 view .LVU1378
 3673 0030 1C60     		str	r4, [r3]
 622:lwIP/src/core/ipv4/etharp.c ****   } else {
 3674              		.loc 1 622 5 is_stmt 1 view .LVU1379
 626:lwIP/src/core/ipv4/etharp.c **** 
 3675              		.loc 1 626 1 is_stmt 0 view .LVU1380
 3676 0032 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3677              	.LVL319:
 3678              	.L495:
 624:lwIP/src/core/ipv4/etharp.c ****   }
 3679              		.loc 1 624 12 view .LVU1381
 3680 0034 0020     		movs	r0, #0
 626:lwIP/src/core/ipv4/etharp.c **** 
 3681              		.loc 1 626 1 view .LVU1382
 3682 0036 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3683              	.LVL320:
 3684              	.L497:
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 3685              		.loc 1 614 3 is_stmt 1 discriminator 1 view .LVU1383
 3686 0038 0648     		ldr	r0, .L500+4
 3687              	.LVL321:
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 3688              		.loc 1 614 3 is_stmt 0 discriminator 1 view .LVU1384
 3689 003a FFF7FEFF 		bl	printf
 3690              	.LVL322:
 3691              	.L488:
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 3692              		.loc 1 614 3 is_stmt 1 discriminator 1 view .LVU1385
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
ARM GAS  /tmp/cctR0i1S.s 			page 127


 3693              		.loc 1 614 3 discriminator 1 view .LVU1386
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 3694              		.loc 1 614 3 discriminator 1 view .LVU1387
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 3695              		.loc 1 614 3 discriminator 1 view .LVU1388
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 3696              		.loc 1 614 3 discriminator 1 view .LVU1389
 614:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 3697              		.loc 1 614 3 discriminator 1 view .LVU1390
 3698 003e FEE7     		b	.L488
 3699              	.LVL323:
 3700              	.L498:
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 3701              		.loc 1 615 3 discriminator 1 view .LVU1391
 3702 0040 0548     		ldr	r0, .L500+8
 3703              	.LVL324:
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 3704              		.loc 1 615 3 is_stmt 0 discriminator 1 view .LVU1392
 3705 0042 FFF7FEFF 		bl	printf
 3706              	.LVL325:
 3707              	.L490:
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 3708              		.loc 1 615 3 is_stmt 1 discriminator 2 view .LVU1393
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 3709              		.loc 1 615 3 discriminator 2 view .LVU1394
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 3710              		.loc 1 615 3 discriminator 2 view .LVU1395
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 3711              		.loc 1 615 3 discriminator 2 view .LVU1396
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 3712              		.loc 1 615 3 discriminator 2 view .LVU1397
 615:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("eth_ret != NULL", eth_ret != NULL);
 3713              		.loc 1 615 3 discriminator 2 view .LVU1398
 3714 0046 FEE7     		b	.L490
 3715              	.LVL326:
 3716              	.L499:
 616:lwIP/src/core/ipv4/etharp.c **** 
 3717              		.loc 1 616 3 discriminator 1 view .LVU1399
 3718 0048 0448     		ldr	r0, .L500+12
 3719              	.LVL327:
 616:lwIP/src/core/ipv4/etharp.c **** 
 3720              		.loc 1 616 3 is_stmt 0 discriminator 1 view .LVU1400
 3721 004a FFF7FEFF 		bl	printf
 3722              	.LVL328:
 3723              	.L492:
 616:lwIP/src/core/ipv4/etharp.c **** 
 3724              		.loc 1 616 3 is_stmt 1 discriminator 3 view .LVU1401
 616:lwIP/src/core/ipv4/etharp.c **** 
 3725              		.loc 1 616 3 discriminator 3 view .LVU1402
 616:lwIP/src/core/ipv4/etharp.c **** 
 3726              		.loc 1 616 3 discriminator 3 view .LVU1403
 616:lwIP/src/core/ipv4/etharp.c **** 
 3727              		.loc 1 616 3 discriminator 3 view .LVU1404
 616:lwIP/src/core/ipv4/etharp.c **** 
 3728              		.loc 1 616 3 discriminator 3 view .LVU1405
 616:lwIP/src/core/ipv4/etharp.c **** 
 3729              		.loc 1 616 3 discriminator 3 view .LVU1406
ARM GAS  /tmp/cctR0i1S.s 			page 128


 3730 004e FEE7     		b	.L492
 3731              	.L501:
 3732              		.align	2
 3733              	.L500:
 3734 0050 00000000 		.word	.LANCHOR0
 3735 0054 00000000 		.word	.LC7
 3736 0058 00000000 		.word	.LC0
 3737 005c 10000000 		.word	.LC8
 3738              		.cfi_endproc
 3739              	.LFE111:
 3741              		.section	.rodata.etharp_input.str1.4,"aMS",%progbits,1
 3742              		.align	2
 3743              	.LC9:
 3744 0000 6E657469 		.ascii	"netif->hwaddr_len == ETH_HWADDR_LEN\000"
 3744      662D3E68 
 3744      77616464 
 3744      725F6C65 
 3744      6E203D3D 
 3745              		.section	.text.etharp_input,"ax",%progbits
 3746              		.align	1
 3747              		.p2align 2,,3
 3748              		.global	etharp_input
 3749              		.syntax unified
 3750              		.thumb
 3751              		.thumb_func
 3752              		.fpu fpv4-sp-d16
 3754              	etharp_input:
 3755              	.LVL329:
 3756              	.LFB112:
 642:lwIP/src/core/ipv4/etharp.c ****   struct etharp_hdr *hdr;
 3757              		.loc 1 642 1 view -0
 3758              		.cfi_startproc
 3759              		@ args = 0, pretend = 0, frame = 16
 3760              		@ frame_needed = 0, uses_anonymous_args = 0
 643:lwIP/src/core/ipv4/etharp.c ****   /* these are aligned properly, whereas the ARP header fields might not be */
 3761              		.loc 1 643 3 view .LVU1408
 645:lwIP/src/core/ipv4/etharp.c ****   u8_t for_us;
 3762              		.loc 1 645 3 view .LVU1409
 646:lwIP/src/core/ipv4/etharp.c **** 
 3763              		.loc 1 646 3 view .LVU1410
 648:lwIP/src/core/ipv4/etharp.c **** 
 3764              		.loc 1 648 28 view .LVU1411
 650:lwIP/src/core/ipv4/etharp.c **** 
 3765              		.loc 1 650 3 view .LVU1412
 650:lwIP/src/core/ipv4/etharp.c **** 
 3766              		.loc 1 650 3 view .LVU1413
 642:lwIP/src/core/ipv4/etharp.c ****   struct etharp_hdr *hdr;
 3767              		.loc 1 642 1 is_stmt 0 view .LVU1414
 3768 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 3769              	.LCFI16:
 3770              		.cfi_def_cfa_offset 32
 3771              		.cfi_offset 4, -32
 3772              		.cfi_offset 5, -28
 3773              		.cfi_offset 6, -24
 3774              		.cfi_offset 7, -20
 3775              		.cfi_offset 8, -16
 3776              		.cfi_offset 9, -12
ARM GAS  /tmp/cctR0i1S.s 			page 129


 3777              		.cfi_offset 10, -8
 3778              		.cfi_offset 14, -4
 3779 0004 88B0     		sub	sp, sp, #32
 3780              	.LCFI17:
 3781              		.cfi_def_cfa_offset 64
 650:lwIP/src/core/ipv4/etharp.c **** 
 3782              		.loc 1 650 3 view .LVU1415
 3783 0006 31B3     		cbz	r1, .L529
 650:lwIP/src/core/ipv4/etharp.c **** 
 3784              		.loc 1 650 3 is_stmt 1 discriminator 2 view .LVU1416
 650:lwIP/src/core/ipv4/etharp.c **** 
 3785              		.loc 1 650 3 discriminator 2 view .LVU1417
 652:lwIP/src/core/ipv4/etharp.c **** 
 3786              		.loc 1 652 3 discriminator 2 view .LVU1418
 652:lwIP/src/core/ipv4/etharp.c **** 
 3787              		.loc 1 652 7 is_stmt 0 discriminator 2 view .LVU1419
 3788 0008 4568     		ldr	r5, [r0, #4]
 3789              	.LVL330:
 655:lwIP/src/core/ipv4/etharp.c ****       (hdr->hwlen != ETH_HWADDR_LEN) ||
 3790              		.loc 1 655 3 is_stmt 1 discriminator 2 view .LVU1420
 3791 000a 0746     		mov	r7, r0
 655:lwIP/src/core/ipv4/etharp.c ****       (hdr->hwlen != ETH_HWADDR_LEN) ||
 3792              		.loc 1 655 6 is_stmt 0 discriminator 2 view .LVU1421
 3793 000c 2B88     		ldrh	r3, [r5]	@ unaligned
 3794 000e B3F5807F 		cmp	r3, #256
 3795 0012 02D1     		bne	.L514
 655:lwIP/src/core/ipv4/etharp.c ****       (hdr->hwlen != ETH_HWADDR_LEN) ||
 3796              		.loc 1 655 60 discriminator 1 view .LVU1422
 3797 0014 2B79     		ldrb	r3, [r5, #4]	@ zero_extendqisi2
 3798 0016 062B     		cmp	r3, #6
 3799 0018 05D0     		beq	.L530
 3800              	.LVL331:
 3801              	.L514:
 741:lwIP/src/core/ipv4/etharp.c **** }
 3802              		.loc 1 741 3 is_stmt 1 discriminator 3 view .LVU1423
 3803 001a 3846     		mov	r0, r7
 3804 001c FFF7FEFF 		bl	pbuf_free
 3805              	.LVL332:
 742:lwIP/src/core/ipv4/etharp.c **** 
 3806              		.loc 1 742 1 is_stmt 0 discriminator 3 view .LVU1424
 3807 0020 08B0     		add	sp, sp, #32
 3808              	.LCFI18:
 3809              		.cfi_remember_state
 3810              		.cfi_def_cfa_offset 32
 3811              		@ sp needed
 3812 0022 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 3813              	.LVL333:
 3814              	.L530:
 3815              	.LCFI19:
 3816              		.cfi_restore_state
 656:lwIP/src/core/ipv4/etharp.c ****       (hdr->protolen != sizeof(ip4_addr_t)) ||
 3817              		.loc 1 656 38 view .LVU1425
 3818 0026 6B79     		ldrb	r3, [r5, #5]	@ zero_extendqisi2
 3819 0028 042B     		cmp	r3, #4
 3820 002a F6D1     		bne	.L514
 657:lwIP/src/core/ipv4/etharp.c ****       (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 3821              		.loc 1 657 45 view .LVU1426
ARM GAS  /tmp/cctR0i1S.s 			page 130


 3822 002c 6B88     		ldrh	r3, [r5, #2]	@ unaligned
 3823 002e 082B     		cmp	r3, #8
 3824 0030 F3D1     		bne	.L514
 667:lwIP/src/core/ipv4/etharp.c **** 
 3825              		.loc 1 667 32 is_stmt 1 view .LVU1427
 678:lwIP/src/core/ipv4/etharp.c ****   IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
 3826              		.loc 1 678 3 view .LVU1428
 3827 0032 D5F80E00 		ldr	r0, [r5, #14]	@ unaligned
 3828              	.LVL334:
 678:lwIP/src/core/ipv4/etharp.c ****   IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
 3829              		.loc 1 678 3 is_stmt 0 view .LVU1429
 3830 0036 0C46     		mov	r4, r1
 682:lwIP/src/core/ipv4/etharp.c ****     for_us = 0;
 3831              		.loc 1 682 7 view .LVU1430
 3832 0038 0E68     		ldr	r6, [r1]
 3833 003a AB69     		ldr	r3, [r5, #24]	@ unaligned
 678:lwIP/src/core/ipv4/etharp.c ****   IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
 3834              		.loc 1 678 3 view .LVU1431
 3835 003c 0790     		str	r0, [sp, #28]
 679:lwIP/src/core/ipv4/etharp.c **** 
 3836              		.loc 1 679 3 is_stmt 1 view .LVU1432
 3837              	.LVL335:
 682:lwIP/src/core/ipv4/etharp.c ****     for_us = 0;
 3838              		.loc 1 682 3 view .LVU1433
 682:lwIP/src/core/ipv4/etharp.c ****     for_us = 0;
 3839              		.loc 1 682 6 is_stmt 0 view .LVU1434
 3840 003e 002E     		cmp	r6, #0
 3841 0040 63D1     		bne	.L531
 694:lwIP/src/core/ipv4/etharp.c ****                           for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
 3842              		.loc 1 694 3 view .LVU1435
 3843 0042 4FF0020A 		mov	r10, #2
 3844              	.L508:
 3845              	.LVL336:
 3846              	.LBB227:
 3847              	.LBI227:
 422:lwIP/src/core/ipv4/etharp.c **** {
 3848              		.loc 1 422 1 is_stmt 1 discriminator 4 view .LVU1436
 3849              	.LBB228:
 424:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 3850              		.loc 1 424 3 discriminator 4 view .LVU1437
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 3851              		.loc 1 425 3 discriminator 4 view .LVU1438
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 3852              		.loc 1 425 3 discriminator 4 view .LVU1439
 3853 0046 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 3854              	.LVL337:
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 3855              		.loc 1 425 3 is_stmt 0 discriminator 4 view .LVU1440
 3856 004a 062B     		cmp	r3, #6
 3857 004c 07D0     		beq	.L509
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 3858              		.loc 1 425 3 is_stmt 1 view .LVU1441
 3859 004e 3348     		ldr	r0, .L532
 3860 0050 FFF7FEFF 		bl	printf
 3861              	.LVL338:
 3862              	.L510:
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
ARM GAS  /tmp/cctR0i1S.s 			page 131


 3863              		.loc 1 425 3 view .LVU1442
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 3864              		.loc 1 425 3 view .LVU1443
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 3865              		.loc 1 425 3 view .LVU1444
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 3866              		.loc 1 425 3 view .LVU1445
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 3867              		.loc 1 425 3 view .LVU1446
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 3868              		.loc 1 425 3 view .LVU1447
 3869 0054 FEE7     		b	.L510
 3870              	.LVL339:
 3871              	.L529:
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 3872              		.loc 1 425 3 is_stmt 0 view .LVU1448
 3873              	.LBE228:
 3874              	.LBE227:
 650:lwIP/src/core/ipv4/etharp.c **** 
 3875              		.loc 1 650 3 is_stmt 1 discriminator 1 view .LVU1449
 3876 0056 3248     		ldr	r0, .L532+4
 3877              	.LVL340:
 650:lwIP/src/core/ipv4/etharp.c **** 
 3878              		.loc 1 650 3 is_stmt 0 discriminator 1 view .LVU1450
 3879 0058 FFF7FEFF 		bl	printf
 3880              	.LVL341:
 3881              	.L504:
 650:lwIP/src/core/ipv4/etharp.c **** 
 3882              		.loc 1 650 3 is_stmt 1 discriminator 1 view .LVU1451
 650:lwIP/src/core/ipv4/etharp.c **** 
 3883              		.loc 1 650 3 discriminator 1 view .LVU1452
 650:lwIP/src/core/ipv4/etharp.c **** 
 3884              		.loc 1 650 3 discriminator 1 view .LVU1453
 650:lwIP/src/core/ipv4/etharp.c **** 
 3885              		.loc 1 650 3 discriminator 1 view .LVU1454
 650:lwIP/src/core/ipv4/etharp.c **** 
 3886              		.loc 1 650 3 discriminator 1 view .LVU1455
 650:lwIP/src/core/ipv4/etharp.c **** 
 3887              		.loc 1 650 3 discriminator 1 view .LVU1456
 3888 005c FEE7     		b	.L504
 3889              	.LVL342:
 3890              	.L509:
 650:lwIP/src/core/ipv4/etharp.c **** 
 3891              		.loc 1 650 3 is_stmt 0 discriminator 1 view .LVU1457
 3892 005e 05F10808 		add	r8, r5, #8
 3893              	.LBB231:
 3894              	.LBB230:
 425:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".
 3895              		.loc 1 425 3 is_stmt 1 view .LVU1458
 429:lwIP/src/core/ipv4/etharp.c ****   /* non-unicast address? */
 3896              		.loc 1 429 69 view .LVU1459
 431:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_isbroadcast(ipaddr, netif) ||
 3897              		.loc 1 431 3 view .LVU1460
 431:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_isbroadcast(ipaddr, netif) ||
 3898              		.loc 1 431 7 is_stmt 0 view .LVU1461
 3899 0062 0028     		cmp	r0, #0
 3900 0064 3DD0     		beq	.L512
ARM GAS  /tmp/cctR0i1S.s 			page 132


 432:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_ismulticast(ipaddr)) {
 3901              		.loc 1 432 7 view .LVU1462
 3902 0066 2146     		mov	r1, r4
 3903              	.LVL343:
 432:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_ismulticast(ipaddr)) {
 3904              		.loc 1 432 7 view .LVU1463
 3905 0068 FFF7FEFF 		bl	ip4_addr_isbroadcast_u32
 3906              	.LVL344:
 431:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_isbroadcast(ipaddr, netif) ||
 3907              		.loc 1 431 30 view .LVU1464
 3908 006c 8146     		mov	r9, r0
 3909 006e C0BB     		cbnz	r0, .L512
 433:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast 
 3910              		.loc 1 433 7 view .LVU1465
 3911 0070 079B     		ldr	r3, [sp, #28]
 3912 0072 03F0F003 		and	r3, r3, #240
 432:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_ismulticast(ipaddr)) {
 3913              		.loc 1 432 43 view .LVU1466
 3914 0076 E02B     		cmp	r3, #224
 3915 0078 33D0     		beq	.L512
 438:lwIP/src/core/ipv4/etharp.c ****   /* bail out if no entry could be found */
 3916              		.loc 1 438 3 is_stmt 1 view .LVU1467
 438:lwIP/src/core/ipv4/etharp.c ****   /* bail out if no entry could be found */
 3917              		.loc 1 438 7 is_stmt 0 view .LVU1468
 3918 007a 5146     		mov	r1, r10
 3919 007c 07A8     		add	r0, sp, #28
 3920              	.LVL345:
 438:lwIP/src/core/ipv4/etharp.c ****   /* bail out if no entry could be found */
 3921              		.loc 1 438 7 view .LVU1469
 3922 007e FFF7FEFF 		bl	etharp_find_entry.isra.0
 3923              	.LVL346:
 440:lwIP/src/core/ipv4/etharp.c ****     return (err_t)i;
 3924              		.loc 1 440 3 is_stmt 1 view .LVU1470
 440:lwIP/src/core/ipv4/etharp.c ****     return (err_t)i;
 3925              		.loc 1 440 6 is_stmt 0 view .LVU1471
 3926 0082 021E     		subs	r2, r0, #0
 3927 0084 2DDB     		blt	.L512
 455:lwIP/src/core/ipv4/etharp.c ****   }
 3928              		.loc 1 455 5 is_stmt 1 view .LVU1472
 455:lwIP/src/core/ipv4/etharp.c ****   }
 3929              		.loc 1 455 24 is_stmt 0 view .LVU1473
 3930 0086 DFF89CE0 		ldr	lr, .L532+8
 3931 008a 02EB420C 		add	ip, r2, r2, lsl #1
 3932 008e 0221     		movs	r1, #2
 465:lwIP/src/core/ipv4/etharp.c ****   /* reset time stamp */
 3933              		.loc 1 465 3 view .LVU1474
 3934 0090 0C20     		movs	r0, #12
 3935              	.LVL347:
 455:lwIP/src/core/ipv4/etharp.c ****   }
 3936              		.loc 1 455 24 view .LVU1475
 3937 0092 0EEBCC03 		add	r3, lr, ip, lsl #3
 465:lwIP/src/core/ipv4/etharp.c ****   /* reset time stamp */
 3938              		.loc 1 465 3 view .LVU1476
 3939 0096 4FF0180A 		mov	r10, #24
 3940              	.LVL348:
 455:lwIP/src/core/ipv4/etharp.c ****   }
 3941              		.loc 1 455 24 view .LVU1477
ARM GAS  /tmp/cctR0i1S.s 			page 133


 3942 009a 4FEACC0C 		lsl	ip, ip, #3
 3943 009e 1975     		strb	r1, [r3, #20]
 459:lwIP/src/core/ipv4/etharp.c ****   /* insert in SNMP ARP index tree */
 3944              		.loc 1 459 3 is_stmt 1 view .LVU1478
 461:lwIP/src/core/ipv4/etharp.c **** 
 3945              		.loc 1 461 50 view .LVU1479
 463:lwIP/src/core/ipv4/etharp.c ****   /* update address */
 3946              		.loc 1 463 111 view .LVU1480
 465:lwIP/src/core/ipv4/etharp.c ****   /* reset time stamp */
 3947              		.loc 1 465 3 view .LVU1481
 3948 00a0 12FB0A02 		smlabb	r2, r2, r10, r0
 459:lwIP/src/core/ipv4/etharp.c ****   /* insert in SNMP ARP index tree */
 3949              		.loc 1 459 22 is_stmt 0 view .LVU1482
 3950 00a4 9C60     		str	r4, [r3, #8]
 465:lwIP/src/core/ipv4/etharp.c ****   /* reset time stamp */
 3951              		.loc 1 465 3 view .LVU1483
 3952 00a6 D8F80000 		ldr	r0, [r8]	@ unaligned
 3953 00aa 0EEB0201 		add	r1, lr, r2
 3954 00ae 4EF80200 		str	r0, [lr, r2]
 3955 00b2 B8F80420 		ldrh	r2, [r8, #4]	@ unaligned
 3956 00b6 8A80     		strh	r2, [r1, #4]	@ unaligned
 467:lwIP/src/core/ipv4/etharp.c ****   /* this is where we will send out queued packets! */
 3957              		.loc 1 467 3 is_stmt 1 view .LVU1484
 481:lwIP/src/core/ipv4/etharp.c ****     struct pbuf *p = arp_table[i].q;
 3958              		.loc 1 481 19 is_stmt 0 view .LVU1485
 3959 00b8 5EF80C10 		ldr	r1, [lr, ip]
 467:lwIP/src/core/ipv4/etharp.c ****   /* this is where we will send out queued packets! */
 3960              		.loc 1 467 22 view .LVU1486
 3961 00bc A3F81290 		strh	r9, [r3, #18]	@ movhi
 481:lwIP/src/core/ipv4/etharp.c ****     struct pbuf *p = arp_table[i].q;
 3962              		.loc 1 481 3 is_stmt 1 view .LVU1487
 481:lwIP/src/core/ipv4/etharp.c ****     struct pbuf *p = arp_table[i].q;
 3963              		.loc 1 481 6 is_stmt 0 view .LVU1488
 3964 00c0 79B1     		cbz	r1, .L512
 3965              	.LBB229:
 482:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].q = NULL;
 3966              		.loc 1 482 5 is_stmt 1 view .LVU1489
 3967              	.LVL349:
 483:lwIP/src/core/ipv4/etharp.c **** #endif /* ARP_QUEUEING */
 3968              		.loc 1 483 5 view .LVU1490
 486:lwIP/src/core/ipv4/etharp.c ****     /* free the queued IP packet */
 3969              		.loc 1 486 5 is_stmt 0 view .LVU1491
 3970 00c2 4FF40060 		mov	r0, #2048
 483:lwIP/src/core/ipv4/etharp.c **** #endif /* ARP_QUEUEING */
 3971              		.loc 1 483 20 view .LVU1492
 3972 00c6 4EF80C90 		str	r9, [lr, ip]
 486:lwIP/src/core/ipv4/etharp.c ****     /* free the queued IP packet */
 3973              		.loc 1 486 5 is_stmt 1 view .LVU1493
 3974 00ca 4346     		mov	r3, r8
 3975 00cc 04F11E02 		add	r2, r4, #30
 3976 00d0 0090     		str	r0, [sp]
 3977 00d2 2046     		mov	r0, r4
 3978 00d4 0591     		str	r1, [sp, #20]
 3979 00d6 FFF7FEFF 		bl	ethernet_output
 3980              	.LVL350:
 488:lwIP/src/core/ipv4/etharp.c ****   }
 3981              		.loc 1 488 5 view .LVU1494
ARM GAS  /tmp/cctR0i1S.s 			page 134


 3982 00da 0599     		ldr	r1, [sp, #20]
 3983 00dc 0846     		mov	r0, r1
 3984 00de FFF7FEFF 		bl	pbuf_free
 3985              	.LVL351:
 3986              	.L512:
 488:lwIP/src/core/ipv4/etharp.c ****   }
 3987              		.loc 1 488 5 is_stmt 0 view .LVU1495
 3988              	.LBE229:
 3989              	.LBE230:
 3990              	.LBE231:
 698:lwIP/src/core/ipv4/etharp.c ****     /* ARP request? */
 3991              		.loc 1 698 3 is_stmt 1 view .LVU1496
 705:lwIP/src/core/ipv4/etharp.c ****       /* ARP request for our address? */
 3992              		.loc 1 705 92 view .LVU1497
 707:lwIP/src/core/ipv4/etharp.c ****         /* send ARP response */
 3993              		.loc 1 707 7 view .LVU1498
 698:lwIP/src/core/ipv4/etharp.c ****     /* ARP request? */
 3994              		.loc 1 698 3 is_stmt 0 view .LVU1499
 3995 00e2 EB88     		ldrh	r3, [r5, #6]	@ unaligned
 707:lwIP/src/core/ipv4/etharp.c ****         /* send ARP response */
 3996              		.loc 1 707 10 view .LVU1500
 3997 00e4 B3F5807F 		cmp	r3, #256
 3998 00e8 97D1     		bne	.L514
 3999 00ea 002E     		cmp	r6, #0
 4000 00ec 95D0     		beq	.L514
 709:lwIP/src/core/ipv4/etharp.c ****                    (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
 4001              		.loc 1 709 9 is_stmt 1 view .LVU1501
 710:lwIP/src/core/ipv4/etharp.c ****                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
 4002              		.loc 1 710 39 is_stmt 0 view .LVU1502
 4003 00ee 04F11E03 		add	r3, r4, #30
 709:lwIP/src/core/ipv4/etharp.c ****                    (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
 4004              		.loc 1 709 9 view .LVU1503
 4005 00f2 0226     		movs	r6, #2
 4006 00f4 07AD     		add	r5, sp, #28
 4007              	.LVL352:
 709:lwIP/src/core/ipv4/etharp.c ****                    (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
 4008              		.loc 1 709 9 view .LVU1504
 4009 00f6 4246     		mov	r2, r8
 4010 00f8 2046     		mov	r0, r4
 4011 00fa 1946     		mov	r1, r3
 4012 00fc CDE90048 		strd	r4, r8, [sp]
 4013 0100 CDE90256 		strd	r5, r6, [sp, #8]
 4014 0104 FFF7FEFF 		bl	etharp_raw
 4015              	.LVL353:
 4016 0108 87E7     		b	.L514
 4017              	.LVL354:
 4018              	.L531:
 686:lwIP/src/core/ipv4/etharp.c ****   }
 4019              		.loc 1 686 5 is_stmt 1 view .LVU1505
 686:lwIP/src/core/ipv4/etharp.c ****   }
 4020              		.loc 1 686 12 is_stmt 0 view .LVU1506
 4021 010a F61A     		subs	r6, r6, r3
 4022 010c B6FA86F6 		clz	r6, r6
 4023 0110 7609     		lsrs	r6, r6, #5
 4024              	.LVL355:
 694:lwIP/src/core/ipv4/etharp.c ****                           for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
 4025              		.loc 1 694 3 is_stmt 1 view .LVU1507
ARM GAS  /tmp/cctR0i1S.s 			page 135


 4026 0112 C6F1020A 		rsb	r10, r6, #2
 4027 0116 5FFA8AFA 		uxtb	r10, r10
 4028 011a 94E7     		b	.L508
 4029              	.L533:
 4030              		.align	2
 4031              	.L532:
 4032 011c 00000000 		.word	.LC9
 4033 0120 00000000 		.word	.LC0
 4034 0124 00000000 		.word	.LANCHOR0
 4035              		.cfi_endproc
 4036              	.LFE112:
 4038              		.section	.rodata.etharp_query.str1.4,"aMS",%progbits,1
 4039              		.align	2
 4040              	.LC10:
 4041 0000 74797065 		.ascii	"type overflow\000"
 4041      206F7665 
 4041      72666C6F 
 4041      7700
 4042 000e 0000     		.align	2
 4043              	.LC11:
 4044 0010 6E6F2070 		.ascii	"no packet queues allowed!\000"
 4044      61636B65 
 4044      74207175 
 4044      65756573 
 4044      20616C6C 
 4045              		.section	.text.etharp_query,"ax",%progbits
 4046              		.align	1
 4047              		.p2align 2,,3
 4048              		.global	etharp_query
 4049              		.syntax unified
 4050              		.thumb
 4051              		.thumb_func
 4052              		.fpu fpv4-sp-d16
 4054              	etharp_query:
 4055              	.LVL356:
 4056              	.LFB115:
 934:lwIP/src/core/ipv4/etharp.c ****   struct eth_addr *srcaddr = (struct eth_addr *)netif->hwaddr;
 4057              		.loc 1 934 1 view -0
 4058              		.cfi_startproc
 4059              		@ args = 0, pretend = 0, frame = 8
 4060              		@ frame_needed = 0, uses_anonymous_args = 0
 935:lwIP/src/core/ipv4/etharp.c ****   err_t result = ERR_MEM;
 4061              		.loc 1 935 3 view .LVU1509
 934:lwIP/src/core/ipv4/etharp.c ****   struct eth_addr *srcaddr = (struct eth_addr *)netif->hwaddr;
 4062              		.loc 1 934 1 is_stmt 0 view .LVU1510
 4063 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 4064              	.LCFI20:
 4065              		.cfi_def_cfa_offset 32
 4066              		.cfi_offset 4, -32
 4067              		.cfi_offset 5, -28
 4068              		.cfi_offset 6, -24
 4069              		.cfi_offset 7, -20
 4070              		.cfi_offset 8, -16
 4071              		.cfi_offset 9, -12
 4072              		.cfi_offset 10, -8
 4073              		.cfi_offset 14, -4
 4074 0004 8A46     		mov	r10, r1
ARM GAS  /tmp/cctR0i1S.s 			page 136


 4075 0006 86B0     		sub	sp, sp, #24
 4076              	.LCFI21:
 4077              		.cfi_def_cfa_offset 56
 934:lwIP/src/core/ipv4/etharp.c ****   struct eth_addr *srcaddr = (struct eth_addr *)netif->hwaddr;
 4078              		.loc 1 934 1 view .LVU1511
 4079 0008 0646     		mov	r6, r0
 4080              	.LVL357:
 936:lwIP/src/core/ipv4/etharp.c ****   int is_new_entry = 0;
 4081              		.loc 1 936 3 is_stmt 1 view .LVU1512
 937:lwIP/src/core/ipv4/etharp.c ****   s16_t i_err;
 4082              		.loc 1 937 3 view .LVU1513
 938:lwIP/src/core/ipv4/etharp.c ****   netif_addr_idx_t i;
 4083              		.loc 1 938 3 view .LVU1514
 939:lwIP/src/core/ipv4/etharp.c **** 
 4084              		.loc 1 939 3 view .LVU1515
 942:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_ismulticast(ipaddr) ||
 4085              		.loc 1 942 3 view .LVU1516
 942:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_ismulticast(ipaddr) ||
 4086              		.loc 1 942 7 is_stmt 0 view .LVU1517
 4087 000a 0146     		mov	r1, r0
 4088              	.LVL358:
 942:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_ismulticast(ipaddr) ||
 4089              		.loc 1 942 7 view .LVU1518
 4090 000c DAF80000 		ldr	r0, [r10]
 4091              	.LVL359:
 934:lwIP/src/core/ipv4/etharp.c ****   struct eth_addr *srcaddr = (struct eth_addr *)netif->hwaddr;
 4092              		.loc 1 934 1 view .LVU1519
 4093 0010 1546     		mov	r5, r2
 942:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_ismulticast(ipaddr) ||
 4094              		.loc 1 942 7 view .LVU1520
 4095 0012 FFF7FEFF 		bl	ip4_addr_isbroadcast_u32
 4096              	.LVL360:
 942:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_ismulticast(ipaddr) ||
 4097              		.loc 1 942 6 view .LVU1521
 4098 0016 0028     		cmp	r0, #0
 4099 0018 40F09780 		bne	.L554
 943:lwIP/src/core/ipv4/etharp.c ****       ip4_addr_isany(ipaddr)) {
 4100              		.loc 1 943 7 discriminator 1 view .LVU1522
 4101 001c DAF80030 		ldr	r3, [r10]
 4102 0020 03F0F002 		and	r2, r3, #240
 944:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address 
 4103              		.loc 1 944 7 discriminator 1 view .LVU1523
 4104 0024 E02A     		cmp	r2, #224
 4105 0026 00F09080 		beq	.L554
 4106 002a 002B     		cmp	r3, #0
 4107 002c 00F08D80 		beq	.L554
 950:lwIP/src/core/ipv4/etharp.c **** 
 4108              		.loc 1 950 3 is_stmt 1 view .LVU1524
 950:lwIP/src/core/ipv4/etharp.c **** 
 4109              		.loc 1 950 11 is_stmt 0 view .LVU1525
 4110 0030 0121     		movs	r1, #1
 4111 0032 5046     		mov	r0, r10
 4112 0034 FFF7FEFF 		bl	etharp_find_entry.isra.0
 4113              	.LVL361:
 953:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
 4114              		.loc 1 953 3 is_stmt 1 view .LVU1526
 953:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
ARM GAS  /tmp/cctR0i1S.s 			page 137


 4115              		.loc 1 953 6 is_stmt 0 view .LVU1527
 4116 0038 041E     		subs	r4, r0, #0
 4117 003a 46DB     		blt	.L566
 961:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 4118              		.loc 1 961 3 is_stmt 1 view .LVU1528
 961:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 4119              		.loc 1 961 3 view .LVU1529
 4120 003c 7E2C     		cmp	r4, #126
 4121 003e 28DC     		bgt	.L567
 965:lwIP/src/core/ipv4/etharp.c ****     is_new_entry = 1;
 4122              		.loc 1 965 19 is_stmt 0 discriminator 2 view .LVU1530
 4123 0040 434F     		ldr	r7, .L572
 4124 0042 04EB4409 		add	r9, r4, r4, lsl #1
 935:lwIP/src/core/ipv4/etharp.c ****   err_t result = ERR_MEM;
 4125              		.loc 1 935 20 discriminator 2 view .LVU1531
 4126 0046 06F11E03 		add	r3, r6, #30
 4127              	.LVL362:
 961:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 4128              		.loc 1 961 3 is_stmt 1 discriminator 2 view .LVU1532
 962:lwIP/src/core/ipv4/etharp.c **** 
 4129              		.loc 1 962 3 discriminator 2 view .LVU1533
 965:lwIP/src/core/ipv4/etharp.c ****     is_new_entry = 1;
 4130              		.loc 1 965 3 discriminator 2 view .LVU1534
 965:lwIP/src/core/ipv4/etharp.c ****     is_new_entry = 1;
 4131              		.loc 1 965 19 is_stmt 0 discriminator 2 view .LVU1535
 4132 004a 4FEA4408 		lsl	r8, r4, #1
 4133 004e 07EBC909 		add	r9, r7, r9, lsl #3
 4134 0052 99F81420 		ldrb	r2, [r9, #20]	@ zero_extendqisi2
 965:lwIP/src/core/ipv4/etharp.c ****     is_new_entry = 1;
 4135              		.loc 1 965 6 discriminator 2 view .LVU1536
 4136 0056 02BB     		cbnz	r2, .L539
 966:lwIP/src/core/ipv4/etharp.c ****     arp_table[i].state = ETHARP_STATE_PENDING;
 4137              		.loc 1 966 5 is_stmt 1 view .LVU1537
 4138              	.LVL363:
 967:lwIP/src/core/ipv4/etharp.c ****     /* record network interface for re-sending arp request in etharp_tmr */
 4139              		.loc 1 967 5 view .LVU1538
 967:lwIP/src/core/ipv4/etharp.c ****     /* record network interface for re-sending arp request in etharp_tmr */
 4140              		.loc 1 967 24 is_stmt 0 view .LVU1539
 4141 0058 4FF0010C 		mov	ip, #1
 4142              	.LBB232:
 4143              	.LBB233:
 4144              	.LBB234:
 4145              	.LBB235:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 4146              		.loc 1 1183 10 view .LVU1540
 4147 005c 3D4A     		ldr	r2, .L572+4
 4148 005e CDF808A0 		str	r10, [sp, #8]
 4149 0062 1946     		mov	r1, r3
 4150 0064 0192     		str	r2, [sp, #4]
 4151 0066 3046     		mov	r0, r6
 4152              	.LVL364:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 4153              		.loc 1 1183 10 view .LVU1541
 4154 0068 0096     		str	r6, [sp]
 4155 006a CDF80CC0 		str	ip, [sp, #12]
 4156 006e 3A4A     		ldr	r2, .L572+8
 4157              	.LBE235:
ARM GAS  /tmp/cctR0i1S.s 			page 138


 4158              	.LBE234:
 4159              	.LBE233:
 4160              	.LBE232:
 969:lwIP/src/core/ipv4/etharp.c ****   }
 4161              		.loc 1 969 24 view .LVU1542
 4162 0070 C9F80860 		str	r6, [r9, #8]
 967:lwIP/src/core/ipv4/etharp.c ****     /* record network interface for re-sending arp request in etharp_tmr */
 4163              		.loc 1 967 24 view .LVU1543
 4164 0074 89F814C0 		strb	ip, [r9, #20]
 969:lwIP/src/core/ipv4/etharp.c ****   }
 4165              		.loc 1 969 5 is_stmt 1 view .LVU1544
 973:lwIP/src/core/ipv4/etharp.c ****               ((arp_table[i].state == ETHARP_STATE_PENDING) ||
 4166              		.loc 1 973 3 view .LVU1545
 973:lwIP/src/core/ipv4/etharp.c ****               ((arp_table[i].state == ETHARP_STATE_PENDING) ||
 4167              		.loc 1 973 3 view .LVU1546
 980:lwIP/src/core/ipv4/etharp.c ****     if (result != ERR_OK) {
 4168              		.loc 1 980 5 view .LVU1547
 4169              	.LVL365:
 4170              	.LBB242:
 4171              	.LBI232:
1198:lwIP/src/core/ipv4/etharp.c **** {
 4172              		.loc 1 1198 1 view .LVU1548
 4173              	.LBB240:
1200:lwIP/src/core/ipv4/etharp.c ****   return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 4174              		.loc 1 1200 89 view .LVU1549
 4175              		.loc 1 1201 3 view .LVU1550
 4176              	.LBB238:
 4177              	.LBI234:
1181:lwIP/src/core/ipv4/etharp.c **** {
 4178              		.loc 1 1181 1 view .LVU1551
 4179              	.LBB236:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 4180              		.loc 1 1183 3 view .LVU1552
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 4181              		.loc 1 1183 10 is_stmt 0 view .LVU1553
 4182 0078 0593     		str	r3, [sp, #20]
 4183 007a FFF7FEFF 		bl	etharp_raw
 4184              	.LVL366:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 4185              		.loc 1 1183 10 view .LVU1554
 4186              	.LBE236:
 4187              	.LBE238:
 4188              	.LBE240:
 4189              	.LBE242:
 981:lwIP/src/core/ipv4/etharp.c ****       /* ARP request couldn't be sent */
 4190              		.loc 1 981 5 is_stmt 1 view .LVU1555
 986:lwIP/src/core/ipv4/etharp.c ****     if (q == NULL) {
 4191              		.loc 1 986 5 view .LVU1556
 987:lwIP/src/core/ipv4/etharp.c ****       return result;
 4192              		.loc 1 987 5 view .LVU1557
 987:lwIP/src/core/ipv4/etharp.c ****       return result;
 4193              		.loc 1 987 8 is_stmt 0 view .LVU1558
 4194 007e 059B     		ldr	r3, [sp, #20]
 4195 0080 25B1     		cbz	r5, .L555
 4196 0082 99F81420 		ldrb	r2, [r9, #20]	@ zero_extendqisi2
 993:lwIP/src/core/ipv4/etharp.c ****   /* stable entry? */
 4197              		.loc 1 993 3 is_stmt 1 view .LVU1559
ARM GAS  /tmp/cctR0i1S.s 			page 139


 993:lwIP/src/core/ipv4/etharp.c ****   /* stable entry? */
 4198              		.loc 1 993 3 view .LVU1560
 993:lwIP/src/core/ipv4/etharp.c ****   /* stable entry? */
 4199              		.loc 1 993 3 view .LVU1561
 995:lwIP/src/core/ipv4/etharp.c ****     /* we have a valid IP->Ethernet address mapping */
 4200              		.loc 1 995 3 view .LVU1562
 995:lwIP/src/core/ipv4/etharp.c ****     /* we have a valid IP->Ethernet address mapping */
 4201              		.loc 1 995 6 is_stmt 0 view .LVU1563
 4202 0086 012A     		cmp	r2, #1
 4203 0088 0DD8     		bhi	.L568
 4204              	.LVL367:
 4205              	.L564:
1001:lwIP/src/core/ipv4/etharp.c ****     /* entry is still pending, queue the given packet 'q' */
 4206              		.loc 1 1001 10 is_stmt 1 view .LVU1564
1001:lwIP/src/core/ipv4/etharp.c ****     /* entry is still pending, queue the given packet 'q' */
 4207              		.loc 1 1001 13 is_stmt 0 view .LVU1565
 4208 008a 22D0     		beq	.L569
 4209              	.LVL368:
 4210              	.L555:
1083:lwIP/src/core/ipv4/etharp.c **** 
 4211              		.loc 1 1083 1 view .LVU1566
 4212 008c 06B0     		add	sp, sp, #24
 4213              	.LCFI22:
 4214              		.cfi_remember_state
 4215              		.cfi_def_cfa_offset 32
 4216              		@ sp needed
 4217 008e BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 4218              	.LVL369:
 4219              	.L567:
 4220              	.LCFI23:
 4221              		.cfi_restore_state
 961:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 4222              		.loc 1 961 3 is_stmt 1 discriminator 1 view .LVU1567
 4223 0092 3248     		ldr	r0, .L572+12
 4224              	.LVL370:
 961:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 4225              		.loc 1 961 3 is_stmt 0 discriminator 1 view .LVU1568
 4226 0094 FFF7FEFF 		bl	printf
 4227              	.LVL371:
 4228              	.L538:
 961:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 4229              		.loc 1 961 3 is_stmt 1 discriminator 1 view .LVU1569
 961:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 4230              		.loc 1 961 3 discriminator 1 view .LVU1570
 961:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 4231              		.loc 1 961 3 discriminator 1 view .LVU1571
 961:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 4232              		.loc 1 961 3 discriminator 1 view .LVU1572
 961:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 4233              		.loc 1 961 3 discriminator 1 view .LVU1573
 961:lwIP/src/core/ipv4/etharp.c ****   i = (netif_addr_idx_t)i_err;
 4234              		.loc 1 961 3 discriminator 1 view .LVU1574
 4235 0098 FEE7     		b	.L538
 4236              	.LVL372:
 4237              	.L539:
 973:lwIP/src/core/ipv4/etharp.c ****               ((arp_table[i].state == ETHARP_STATE_PENDING) ||
 4238              		.loc 1 973 3 view .LVU1575
ARM GAS  /tmp/cctR0i1S.s 			page 140


 973:lwIP/src/core/ipv4/etharp.c ****               ((arp_table[i].state == ETHARP_STATE_PENDING) ||
 4239              		.loc 1 973 3 view .LVU1576
 973:lwIP/src/core/ipv4/etharp.c ****               ((arp_table[i].state == ETHARP_STATE_PENDING) ||
 4240              		.loc 1 973 3 view .LVU1577
 978:lwIP/src/core/ipv4/etharp.c ****     /* try to resolve it; send out ARP request */
 4241              		.loc 1 978 3 view .LVU1578
 978:lwIP/src/core/ipv4/etharp.c ****     /* try to resolve it; send out ARP request */
 4242              		.loc 1 978 6 is_stmt 0 view .LVU1579
 4243 009a 002D     		cmp	r5, #0
 4244 009c 44D0     		beq	.L541
 995:lwIP/src/core/ipv4/etharp.c ****     /* we have a valid IP->Ethernet address mapping */
 4245              		.loc 1 995 6 view .LVU1580
 4246 009e 012A     		cmp	r2, #1
 936:lwIP/src/core/ipv4/etharp.c ****   int is_new_entry = 0;
 4247              		.loc 1 936 9 view .LVU1581
 4248 00a0 4FF0FF30 		mov	r0, #-1
 4249              	.LVL373:
 993:lwIP/src/core/ipv4/etharp.c ****   /* stable entry? */
 4250              		.loc 1 993 3 is_stmt 1 view .LVU1582
 993:lwIP/src/core/ipv4/etharp.c ****   /* stable entry? */
 4251              		.loc 1 993 3 view .LVU1583
 993:lwIP/src/core/ipv4/etharp.c ****   /* stable entry? */
 4252              		.loc 1 993 3 view .LVU1584
 995:lwIP/src/core/ipv4/etharp.c ****     /* we have a valid IP->Ethernet address mapping */
 4253              		.loc 1 995 3 view .LVU1585
 995:lwIP/src/core/ipv4/etharp.c ****     /* we have a valid IP->Ethernet address mapping */
 4254              		.loc 1 995 6 is_stmt 0 view .LVU1586
 4255 00a4 F1D9     		bls	.L564
 4256              	.LVL374:
 4257              	.L568:
 997:lwIP/src/core/ipv4/etharp.c ****     /* send the packet */
 4258              		.loc 1 997 5 is_stmt 1 view .LVU1587
 999:lwIP/src/core/ipv4/etharp.c ****     /* pending entry? (either just created or already pending */
 4259              		.loc 1 999 49 is_stmt 0 view .LVU1588
 4260 00a6 1820     		movs	r0, #24
 4261              	.LVL375:
 999:lwIP/src/core/ipv4/etharp.c ****     /* pending entry? (either just created or already pending */
 4262              		.loc 1 999 14 view .LVU1589
 4263 00a8 1A46     		mov	r2, r3
 4264 00aa 4FF4006C 		mov	ip, #2048
 4265 00ae 2946     		mov	r1, r5
 999:lwIP/src/core/ipv4/etharp.c ****     /* pending entry? (either just created or already pending */
 4266              		.loc 1 999 49 view .LVU1590
 4267 00b0 04FB0073 		mla	r3, r4, r0, r7
 997:lwIP/src/core/ipv4/etharp.c ****     /* send the packet */
 4268              		.loc 1 997 5 view .LVU1591
 4269 00b4 2A4D     		ldr	r5, .L572+16
 4270              	.LVL376:
 999:lwIP/src/core/ipv4/etharp.c ****     /* pending entry? (either just created or already pending */
 4271              		.loc 1 999 14 view .LVU1592
 4272 00b6 CDF800C0 		str	ip, [sp]
 4273 00ba 3046     		mov	r0, r6
 4274 00bc 0C33     		adds	r3, r3, #12
 962:lwIP/src/core/ipv4/etharp.c **** 
 4275              		.loc 1 962 5 view .LVU1593
 4276 00be 2C70     		strb	r4, [r5]
 999:lwIP/src/core/ipv4/etharp.c ****     /* pending entry? (either just created or already pending */
ARM GAS  /tmp/cctR0i1S.s 			page 141


 4277              		.loc 1 999 5 is_stmt 1 view .LVU1594
 999:lwIP/src/core/ipv4/etharp.c ****     /* pending entry? (either just created or already pending */
 4278              		.loc 1 999 14 is_stmt 0 view .LVU1595
 4279 00c0 FFF7FEFF 		bl	ethernet_output
 4280              	.LVL377:
1083:lwIP/src/core/ipv4/etharp.c **** 
 4281              		.loc 1 1083 1 view .LVU1596
 4282 00c4 06B0     		add	sp, sp, #24
 4283              	.LCFI24:
 4284              		.cfi_remember_state
 4285              		.cfi_def_cfa_offset 32
 4286              		@ sp needed
 4287 00c6 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 4288              	.LVL378:
 4289              	.L566:
 4290              	.LCFI25:
 4291              		.cfi_restore_state
 954:lwIP/src/core/ipv4/etharp.c ****     if (q) {
 4292              		.loc 1 954 95 is_stmt 1 view .LVU1597
 955:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
 4293              		.loc 1 955 5 view .LVU1598
 956:lwIP/src/core/ipv4/etharp.c ****       ETHARP_STATS_INC(etharp.memerr);
 4294              		.loc 1 956 85 view .LVU1599
 957:lwIP/src/core/ipv4/etharp.c ****     }
 4295              		.loc 1 957 38 view .LVU1600
 959:lwIP/src/core/ipv4/etharp.c ****   }
 4296              		.loc 1 959 5 view .LVU1601
 959:lwIP/src/core/ipv4/etharp.c ****   }
 4297              		.loc 1 959 12 is_stmt 0 view .LVU1602
 4298 00ca 60B2     		sxtb	r0, r4
 4299              	.LVL379:
1083:lwIP/src/core/ipv4/etharp.c **** 
 4300              		.loc 1 1083 1 view .LVU1603
 4301 00cc 06B0     		add	sp, sp, #24
 4302              	.LCFI26:
 4303              		.cfi_remember_state
 4304              		.cfi_def_cfa_offset 32
 4305              		@ sp needed
 4306 00ce BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 4307              	.LVL380:
 4308              	.L569:
 4309              	.LCFI27:
 4310              		.cfi_restore_state
1083:lwIP/src/core/ipv4/etharp.c **** 
 4311              		.loc 1 1083 1 view .LVU1604
 4312 00d2 2B46     		mov	r3, r5
 4313 00d4 04E0     		b	.L547
 4314              	.LVL381:
 4315              	.L543:
 4316              	.LBB243:
1010:lwIP/src/core/ipv4/etharp.c ****         copy_needed = 1;
 4317              		.loc 1 1010 10 discriminator 4 view .LVU1605
 4318 00d6 1A7B     		ldrb	r2, [r3, #12]	@ zero_extendqisi2
 4319 00d8 5206     		lsls	r2, r2, #25
 4320 00da 0AD4     		bmi	.L546
1014:lwIP/src/core/ipv4/etharp.c ****     }
 4321              		.loc 1 1014 9 view .LVU1606
ARM GAS  /tmp/cctR0i1S.s 			page 142


 4322 00dc 1B68     		ldr	r3, [r3]
 4323              	.LVL382:
1008:lwIP/src/core/ipv4/etharp.c ****       LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 4324              		.loc 1 1008 11 is_stmt 1 view .LVU1607
 4325 00de 83B3     		cbz	r3, .L548
 4326              	.LVL383:
 4327              	.L547:
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4328              		.loc 1 1009 7 view .LVU1608
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4329              		.loc 1 1009 7 view .LVU1609
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4330              		.loc 1 1009 7 view .LVU1610
1010:lwIP/src/core/ipv4/etharp.c ****         copy_needed = 1;
 4331              		.loc 1 1010 7 view .LVU1611
1014:lwIP/src/core/ipv4/etharp.c ****     }
 4332              		.loc 1 1014 7 view .LVU1612
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4333              		.loc 1 1009 7 is_stmt 0 view .LVU1613
 4334 00e0 5989     		ldrh	r1, [r3, #10]
 4335 00e2 1A89     		ldrh	r2, [r3, #8]
 4336 00e4 9142     		cmp	r1, r2
 4337 00e6 F6D1     		bne	.L543
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4338              		.loc 1 1009 7 discriminator 1 view .LVU1614
 4339 00e8 1A68     		ldr	r2, [r3]
 4340 00ea CAB9     		cbnz	r2, .L570
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4341              		.loc 1 1009 7 is_stmt 1 view .LVU1615
1010:lwIP/src/core/ipv4/etharp.c ****         copy_needed = 1;
 4342              		.loc 1 1010 7 view .LVU1616
1010:lwIP/src/core/ipv4/etharp.c ****         copy_needed = 1;
 4343              		.loc 1 1010 10 is_stmt 0 view .LVU1617
 4344 00ec 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 4345              	.LVL384:
1010:lwIP/src/core/ipv4/etharp.c ****         copy_needed = 1;
 4346              		.loc 1 1010 10 view .LVU1618
 4347 00ee 5B06     		lsls	r3, r3, #25
 4348 00f0 27D5     		bpl	.L548
 4349              	.L546:
 4350              	.LVL385:
1016:lwIP/src/core/ipv4/etharp.c ****       /* copy the whole packet into new pbufs */
 4351              		.loc 1 1016 5 is_stmt 1 view .LVU1619
1018:lwIP/src/core/ipv4/etharp.c ****     } else {
 4352              		.loc 1 1018 7 view .LVU1620
1018:lwIP/src/core/ipv4/etharp.c ****     } else {
 4353              		.loc 1 1018 11 is_stmt 0 view .LVU1621
 4354 00f2 2A46     		mov	r2, r5
 4355 00f4 4FF42071 		mov	r1, #640
 4356 00f8 0E20     		movs	r0, #14
 4357              	.LVL386:
1018:lwIP/src/core/ipv4/etharp.c ****     } else {
 4358              		.loc 1 1018 11 view .LVU1622
 4359 00fa FFF7FEFF 		bl	pbuf_clone
 4360              	.LVL387:
1025:lwIP/src/core/ipv4/etharp.c ****       /* queue packet ... */
 4361              		.loc 1 1025 5 is_stmt 1 view .LVU1623
ARM GAS  /tmp/cctR0i1S.s 			page 143


1025:lwIP/src/core/ipv4/etharp.c ****       /* queue packet ... */
 4362              		.loc 1 1025 8 is_stmt 0 view .LVU1624
 4363 00fe 0546     		mov	r5, r0
 4364              	.LVL388:
1025:lwIP/src/core/ipv4/etharp.c ****       /* queue packet ... */
 4365              		.loc 1 1025 8 view .LVU1625
 4366 0100 58B1     		cbz	r0, .L571
 4367              	.LVL389:
 4368              	.L550:
1068:lwIP/src/core/ipv4/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet
 4369              		.loc 1 1068 7 is_stmt 1 view .LVU1626
1068:lwIP/src/core/ipv4/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet
 4370              		.loc 1 1068 23 is_stmt 0 view .LVU1627
 4371 0102 08EB0403 		add	r3, r8, r4
 4372 0106 57F83300 		ldr	r0, [r7, r3, lsl #3]
1068:lwIP/src/core/ipv4/etharp.c ****         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet
 4373              		.loc 1 1068 10 view .LVU1628
 4374 010a 08B1     		cbz	r0, .L549
1069:lwIP/src/core/ipv4/etharp.c ****         pbuf_free(arp_table[i].q);
 4375              		.loc 1 1069 152 is_stmt 1 view .LVU1629
1070:lwIP/src/core/ipv4/etharp.c ****       }
 4376              		.loc 1 1070 9 view .LVU1630
 4377 010c FFF7FEFF 		bl	pbuf_free
 4378              	.LVL390:
 4379              	.L549:
1072:lwIP/src/core/ipv4/etharp.c ****       result = ERR_OK;
 4380              		.loc 1 1072 7 view .LVU1631
1072:lwIP/src/core/ipv4/etharp.c ****       result = ERR_OK;
 4381              		.loc 1 1072 22 is_stmt 0 view .LVU1632
 4382 0110 4444     		add	r4, r4, r8
 4383              	.LVL391:
1073:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"U1
 4384              		.loc 1 1073 14 view .LVU1633
 4385 0112 0020     		movs	r0, #0
1072:lwIP/src/core/ipv4/etharp.c ****       result = ERR_OK;
 4386              		.loc 1 1072 22 view .LVU1634
 4387 0114 47F83450 		str	r5, [r7, r4, lsl #3]
1073:lwIP/src/core/ipv4/etharp.c ****       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"U1
 4388              		.loc 1 1073 7 is_stmt 1 view .LVU1635
 4389              	.LVL392:
1074:lwIP/src/core/ipv4/etharp.c **** #endif /* ARP_QUEUEING */
 4390              		.loc 1 1074 130 view .LVU1636
 4391 0118 B8E7     		b	.L555
 4392              	.LVL393:
 4393              	.L571:
1079:lwIP/src/core/ipv4/etharp.c ****     }
 4394              		.loc 1 1079 14 is_stmt 0 view .LVU1637
 4395 011a 4FF0FF30 		mov	r0, #-1
 4396              	.LVL394:
1079:lwIP/src/core/ipv4/etharp.c ****     }
 4397              		.loc 1 1079 14 view .LVU1638
 4398 011e B5E7     		b	.L555
 4399              	.LVL395:
 4400              	.L570:
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4401              		.loc 1 1009 7 is_stmt 1 discriminator 3 view .LVU1639
 4402 0120 1048     		ldr	r0, .L572+20
ARM GAS  /tmp/cctR0i1S.s 			page 144


 4403              	.LVL396:
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4404              		.loc 1 1009 7 is_stmt 0 discriminator 3 view .LVU1640
 4405 0122 FFF7FEFF 		bl	printf
 4406              	.LVL397:
 4407              	.L545:
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4408              		.loc 1 1009 7 is_stmt 1 discriminator 4 view .LVU1641
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4409              		.loc 1 1009 7 discriminator 4 view .LVU1642
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4410              		.loc 1 1009 7 discriminator 4 view .LVU1643
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4411              		.loc 1 1009 7 discriminator 4 view .LVU1644
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4412              		.loc 1 1009 7 discriminator 4 view .LVU1645
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4413              		.loc 1 1009 7 discriminator 4 view .LVU1646
 4414 0126 FEE7     		b	.L545
 4415              	.LVL398:
 4416              	.L541:
1009:lwIP/src/core/ipv4/etharp.c ****       if (PBUF_NEEDS_COPY(p)) {
 4417              		.loc 1 1009 7 is_stmt 0 discriminator 4 view .LVU1647
 4418              	.LBE243:
 980:lwIP/src/core/ipv4/etharp.c ****     if (result != ERR_OK) {
 4419              		.loc 1 980 5 is_stmt 1 view .LVU1648
 4420              	.LBB244:
1198:lwIP/src/core/ipv4/etharp.c **** {
 4421              		.loc 1 1198 1 view .LVU1649
 4422              	.LBB241:
1200:lwIP/src/core/ipv4/etharp.c ****   return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 4423              		.loc 1 1200 89 view .LVU1650
 4424              		.loc 1 1201 3 view .LVU1651
 4425              	.LBB239:
1181:lwIP/src/core/ipv4/etharp.c **** {
 4426              		.loc 1 1181 1 view .LVU1652
 4427              	.LBB237:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 4428              		.loc 1 1183 3 view .LVU1653
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 4429              		.loc 1 1183 10 is_stmt 0 view .LVU1654
 4430 0128 0121     		movs	r1, #1
 4431 012a 0A4A     		ldr	r2, .L572+4
 4432 012c 3046     		mov	r0, r6
 4433              	.LVL399:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 4434              		.loc 1 1183 10 view .LVU1655
 4435 012e CDF808A0 		str	r10, [sp, #8]
 4436 0132 0391     		str	r1, [sp, #12]
 4437 0134 1946     		mov	r1, r3
 4438 0136 0192     		str	r2, [sp, #4]
 4439 0138 0096     		str	r6, [sp]
 4440 013a 074A     		ldr	r2, .L572+8
 4441 013c FFF7FEFF 		bl	etharp_raw
 4442              	.LVL400:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 4443              		.loc 1 1183 10 view .LVU1656
ARM GAS  /tmp/cctR0i1S.s 			page 145


 4444              	.LBE237:
 4445              	.LBE239:
 4446              	.LBE241:
 4447              	.LBE244:
 981:lwIP/src/core/ipv4/etharp.c ****       /* ARP request couldn't be sent */
 4448              		.loc 1 981 5 is_stmt 1 view .LVU1657
 986:lwIP/src/core/ipv4/etharp.c ****     if (q == NULL) {
 4449              		.loc 1 986 5 view .LVU1658
 987:lwIP/src/core/ipv4/etharp.c ****       return result;
 4450              		.loc 1 987 5 view .LVU1659
 987:lwIP/src/core/ipv4/etharp.c ****       return result;
 4451              		.loc 1 987 5 is_stmt 0 view .LVU1660
 4452 0140 A4E7     		b	.L555
 4453              	.LVL401:
 4454              	.L548:
 4455              	.LBB245:
1016:lwIP/src/core/ipv4/etharp.c ****       /* copy the whole packet into new pbufs */
 4456              		.loc 1 1016 5 is_stmt 1 view .LVU1661
1021:lwIP/src/core/ipv4/etharp.c ****       pbuf_ref(p);
 4457              		.loc 1 1021 7 view .LVU1662
1022:lwIP/src/core/ipv4/etharp.c ****     }
 4458              		.loc 1 1022 7 view .LVU1663
 4459 0142 2846     		mov	r0, r5
 4460              	.LVL402:
1022:lwIP/src/core/ipv4/etharp.c ****     }
 4461              		.loc 1 1022 7 is_stmt 0 view .LVU1664
 4462 0144 FFF7FEFF 		bl	pbuf_ref
 4463              	.LVL403:
1025:lwIP/src/core/ipv4/etharp.c ****       /* queue packet ... */
 4464              		.loc 1 1025 5 is_stmt 1 view .LVU1665
 4465 0148 DBE7     		b	.L550
 4466              	.LVL404:
 4467              	.L554:
1025:lwIP/src/core/ipv4/etharp.c ****       /* queue packet ... */
 4468              		.loc 1 1025 5 is_stmt 0 view .LVU1666
 4469              	.LBE245:
 946:lwIP/src/core/ipv4/etharp.c ****   }
 4470              		.loc 1 946 12 view .LVU1667
 4471 014a 6FF00F00 		mvn	r0, #15
 4472 014e 9DE7     		b	.L555
 4473              	.L573:
 4474              		.align	2
 4475              	.L572:
 4476 0150 00000000 		.word	.LANCHOR0
 4477 0154 00000000 		.word	ethzero
 4478 0158 00000000 		.word	ethbroadcast
 4479 015c 00000000 		.word	.LC10
 4480 0160 00000000 		.word	.LANCHOR1
 4481 0164 10000000 		.word	.LC11
 4482              		.cfi_endproc
 4483              	.LFE115:
 4485              		.section	.rodata.etharp_output.str1.4,"aMS",%progbits,1
 4486              		.align	2
 4487              	.LC12:
 4488 0000 7120213D 		.ascii	"q != NULL\000"
 4488      204E554C 
 4488      4C00
ARM GAS  /tmp/cctR0i1S.s 			page 146


 4489              		.section	.text.etharp_output,"ax",%progbits
 4490              		.align	1
 4491              		.p2align 2,,3
 4492              		.global	etharp_output
 4493              		.syntax unified
 4494              		.thumb
 4495              		.thumb_func
 4496              		.fpu fpv4-sp-d16
 4498              	etharp_output:
 4499              	.LVL405:
 4500              	.LFB114:
 792:lwIP/src/core/ipv4/etharp.c ****   const struct eth_addr *dest;
 4501              		.loc 1 792 1 is_stmt 1 view -0
 4502              		.cfi_startproc
 4503              		@ args = 0, pretend = 0, frame = 8
 4504              		@ frame_needed = 0, uses_anonymous_args = 0
 793:lwIP/src/core/ipv4/etharp.c ****   struct eth_addr mcastaddr;
 4505              		.loc 1 793 3 view .LVU1669
 794:lwIP/src/core/ipv4/etharp.c ****   const ip4_addr_t *dst_addr = ipaddr;
 4506              		.loc 1 794 3 view .LVU1670
 795:lwIP/src/core/ipv4/etharp.c **** 
 4507              		.loc 1 795 3 view .LVU1671
 797:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("netif != NULL", netif != NULL);
 4508              		.loc 1 797 28 view .LVU1672
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4509              		.loc 1 798 3 view .LVU1673
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4510              		.loc 1 798 3 view .LVU1674
 792:lwIP/src/core/ipv4/etharp.c ****   const struct eth_addr *dest;
 4511              		.loc 1 792 1 is_stmt 0 view .LVU1675
 4512 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 4513              	.LCFI28:
 4514              		.cfi_def_cfa_offset 24
 4515              		.cfi_offset 4, -24
 4516              		.cfi_offset 5, -20
 4517              		.cfi_offset 6, -16
 4518              		.cfi_offset 7, -12
 4519              		.cfi_offset 8, -8
 4520              		.cfi_offset 14, -4
 4521 0004 84B0     		sub	sp, sp, #16
 4522              	.LCFI29:
 4523              		.cfi_def_cfa_offset 40
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4524              		.loc 1 798 3 view .LVU1676
 4525 0006 0028     		cmp	r0, #0
 4526 0008 00F0B180 		beq	.L611
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4527              		.loc 1 798 3 is_stmt 1 discriminator 2 view .LVU1677
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 4528              		.loc 1 799 3 discriminator 2 view .LVU1678
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 4529              		.loc 1 799 3 discriminator 2 view .LVU1679
 4530 000c 8846     		mov	r8, r1
 4531 000e 0029     		cmp	r1, #0
 4532 0010 00F0A980 		beq	.L612
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 4533              		.loc 1 799 3 discriminator 2 view .LVU1680
ARM GAS  /tmp/cctR0i1S.s 			page 147


 800:lwIP/src/core/ipv4/etharp.c **** 
 4534              		.loc 1 800 3 discriminator 2 view .LVU1681
 800:lwIP/src/core/ipv4/etharp.c **** 
 4535              		.loc 1 800 3 discriminator 2 view .LVU1682
 4536 0014 1746     		mov	r7, r2
 4537 0016 002A     		cmp	r2, #0
 4538 0018 00F08180 		beq	.L613
 800:lwIP/src/core/ipv4/etharp.c **** 
 4539              		.loc 1 800 3 discriminator 2 view .LVU1683
 806:lwIP/src/core/ipv4/etharp.c ****     /* broadcast on Ethernet also */
 4540              		.loc 1 806 3 discriminator 2 view .LVU1684
 806:lwIP/src/core/ipv4/etharp.c ****     /* broadcast on Ethernet also */
 4541              		.loc 1 806 7 is_stmt 0 discriminator 2 view .LVU1685
 4542 001c 0146     		mov	r1, r0
 4543              	.LVL406:
 806:lwIP/src/core/ipv4/etharp.c ****     /* broadcast on Ethernet also */
 4544              		.loc 1 806 7 discriminator 2 view .LVU1686
 4545 001e 0646     		mov	r6, r0
 4546 0020 1068     		ldr	r0, [r2]
 4547              	.LVL407:
 806:lwIP/src/core/ipv4/etharp.c ****     /* broadcast on Ethernet also */
 4548              		.loc 1 806 7 discriminator 2 view .LVU1687
 4549 0022 FFF7FEFF 		bl	ip4_addr_isbroadcast_u32
 4550              	.LVL408:
 806:lwIP/src/core/ipv4/etharp.c ****     /* broadcast on Ethernet also */
 4551              		.loc 1 806 6 discriminator 2 view .LVU1688
 4552 0026 0546     		mov	r5, r0
 4553 0028 0028     		cmp	r0, #0
 4554 002a 40F09A80 		bne	.L597
 810:lwIP/src/core/ipv4/etharp.c ****     /* Hash IP multicast address to MAC address.*/
 4555              		.loc 1 810 10 is_stmt 1 view .LVU1689
 810:lwIP/src/core/ipv4/etharp.c ****     /* Hash IP multicast address to MAC address.*/
 4556              		.loc 1 810 14 is_stmt 0 view .LVU1690
 4557 002e 3C68     		ldr	r4, [r7]
 4558 0030 04F0F003 		and	r3, r4, #240
 810:lwIP/src/core/ipv4/etharp.c ****     /* Hash IP multicast address to MAC address.*/
 4559              		.loc 1 810 13 view .LVU1691
 4560 0034 E02B     		cmp	r3, #224
 4561 0036 76D0     		beq	.L614
 4562              	.LBB246:
 822:lwIP/src/core/ipv4/etharp.c ****     /* outside local network? if so, this can neither be a global broadcast nor
 4563              		.loc 1 822 5 is_stmt 1 view .LVU1692
 825:lwIP/src/core/ipv4/etharp.c ****         !ip4_addr_islinklocal(ipaddr)) {
 4564              		.loc 1 825 5 view .LVU1693
 825:lwIP/src/core/ipv4/etharp.c ****         !ip4_addr_islinklocal(ipaddr)) {
 4565              		.loc 1 825 9 is_stmt 0 view .LVU1694
 4566 0038 D6E90032 		ldrd	r3, r2, [r6]
 4567 003c 6340     		eors	r3, r3, r4
 825:lwIP/src/core/ipv4/etharp.c ****         !ip4_addr_islinklocal(ipaddr)) {
 4568              		.loc 1 825 8 view .LVU1695
 4569 003e 1342     		tst	r3, r2
 4570 0040 0AD0     		beq	.L583
 826:lwIP/src/core/ipv4/etharp.c **** #if LWIP_AUTOIP
 4571              		.loc 1 826 10 discriminator 1 view .LVU1696
 4572 0042 A2B2     		uxth	r2, r4
 825:lwIP/src/core/ipv4/etharp.c ****         !ip4_addr_islinklocal(ipaddr)) {
 4573              		.loc 1 825 83 discriminator 1 view .LVU1697
ARM GAS  /tmp/cctR0i1S.s 			page 148


 4574 0044 4FF6A963 		movw	r3, #65193
 4575 0048 9A42     		cmp	r2, r3
 4576 004a 05D0     		beq	.L583
 844:lwIP/src/core/ipv4/etharp.c ****             /* send to hardware address of default gateway IP address */
 4577              		.loc 1 844 11 is_stmt 1 view .LVU1698
 844:lwIP/src/core/ipv4/etharp.c ****             /* send to hardware address of default gateway IP address */
 4578              		.loc 1 844 16 is_stmt 0 view .LVU1699
 4579 004c B468     		ldr	r4, [r6, #8]
 844:lwIP/src/core/ipv4/etharp.c ****             /* send to hardware address of default gateway IP address */
 4580              		.loc 1 844 14 view .LVU1700
 4581 004e 002C     		cmp	r4, #0
 4582 0050 00F09680 		beq	.L598
 846:lwIP/src/core/ipv4/etharp.c ****             /* no default gateway available */
 4583              		.loc 1 846 13 is_stmt 1 view .LVU1701
 846:lwIP/src/core/ipv4/etharp.c ****             /* no default gateway available */
 4584              		.loc 1 846 22 is_stmt 0 view .LVU1702
 4585 0054 06F10807 		add	r7, r6, #8
 4586              	.LVL409:
 4587              	.L583:
 861:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4588              		.loc 1 861 9 is_stmt 1 view .LVU1703
 861:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4589              		.loc 1 861 44 is_stmt 0 view .LVU1704
 4590 0058 DFF870C1 		ldr	ip, .L617+20
 4591 005c 564B     		ldr	r3, .L617
 4592 005e 9CF80020 		ldrb	r2, [ip]	@ zero_extendqisi2
 4593 0062 02EB4201 		add	r1, r2, r2, lsl #1
 4594 0066 03EBC101 		add	r1, r3, r1, lsl #3
 861:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4595              		.loc 1 861 12 view .LVU1705
 4596 006a 087D     		ldrb	r0, [r1, #20]	@ zero_extendqisi2
 4597 006c 0128     		cmp	r0, #1
 4598 006e 02D9     		bls	.L585
 861:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4599              		.loc 1 861 75 discriminator 1 view .LVU1706
 4600 0070 4968     		ldr	r1, [r1, #4]
 4601 0072 8C42     		cmp	r4, r1
 4602 0074 7FD0     		beq	.L615
 4603              	.L585:
 4604              	.LVL410:
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4605              		.loc 1 878 7 is_stmt 1 view .LVU1707
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4606              		.loc 1 878 10 is_stmt 0 view .LVU1708
 4607 0076 1A7D     		ldrb	r2, [r3, #20]	@ zero_extendqisi2
 4608 0078 012A     		cmp	r2, #1
 4609 007a 03D9     		bls	.L586
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4610              		.loc 1 878 55 view .LVU1709
 4611 007c 5A68     		ldr	r2, [r3, #4]
 4612 007e 9442     		cmp	r4, r2
 4613 0080 00F08280 		beq	.L587
 4614              	.L586:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4615              		.loc 1 877 37 is_stmt 1 view .LVU1710
 4616              	.LVL411:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
ARM GAS  /tmp/cctR0i1S.s 			page 149


 4617              		.loc 1 877 17 view .LVU1711
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4618              		.loc 1 878 7 view .LVU1712
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4619              		.loc 1 878 10 is_stmt 0 view .LVU1713
 4620 0084 93F82C20 		ldrb	r2, [r3, #44]	@ zero_extendqisi2
 4621 0088 012A     		cmp	r2, #1
 4622 008a 03D9     		bls	.L588
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4623              		.loc 1 878 55 view .LVU1714
 4624 008c DA69     		ldr	r2, [r3, #28]
 4625 008e 9442     		cmp	r4, r2
 4626 0090 00F08E80 		beq	.L599
 4627              	.L588:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4628              		.loc 1 877 37 is_stmt 1 view .LVU1715
 4629              	.LVL412:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4630              		.loc 1 877 17 view .LVU1716
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4631              		.loc 1 878 7 view .LVU1717
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4632              		.loc 1 878 10 is_stmt 0 view .LVU1718
 4633 0094 93F84420 		ldrb	r2, [r3, #68]	@ zero_extendqisi2
 4634 0098 012A     		cmp	r2, #1
 4635 009a 03D9     		bls	.L589
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4636              		.loc 1 878 55 view .LVU1719
 4637 009c 5A6B     		ldr	r2, [r3, #52]
 4638 009e 9442     		cmp	r4, r2
 4639 00a0 00F08880 		beq	.L600
 4640              	.L589:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4641              		.loc 1 877 37 is_stmt 1 view .LVU1720
 4642              	.LVL413:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4643              		.loc 1 877 17 view .LVU1721
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4644              		.loc 1 878 7 view .LVU1722
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4645              		.loc 1 878 10 is_stmt 0 view .LVU1723
 4646 00a4 93F85C20 		ldrb	r2, [r3, #92]	@ zero_extendqisi2
 4647 00a8 012A     		cmp	r2, #1
 4648 00aa 02D9     		bls	.L590
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4649              		.loc 1 878 55 view .LVU1724
 4650 00ac DA6C     		ldr	r2, [r3, #76]
 4651 00ae 9442     		cmp	r4, r2
 4652 00b0 7CD0     		beq	.L601
 4653              	.L590:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4654              		.loc 1 877 37 is_stmt 1 view .LVU1725
 4655              	.LVL414:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4656              		.loc 1 877 17 view .LVU1726
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4657              		.loc 1 878 7 view .LVU1727
ARM GAS  /tmp/cctR0i1S.s 			page 150


 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4658              		.loc 1 878 10 is_stmt 0 view .LVU1728
 4659 00b2 93F87420 		ldrb	r2, [r3, #116]	@ zero_extendqisi2
 4660 00b6 012A     		cmp	r2, #1
 4661 00b8 02D9     		bls	.L591
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4662              		.loc 1 878 55 view .LVU1729
 4663 00ba 5A6E     		ldr	r2, [r3, #100]
 4664 00bc 9442     		cmp	r4, r2
 4665 00be 73D0     		beq	.L602
 4666              	.L591:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4667              		.loc 1 877 37 is_stmt 1 view .LVU1730
 4668              	.LVL415:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4669              		.loc 1 877 17 view .LVU1731
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4670              		.loc 1 878 7 view .LVU1732
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4671              		.loc 1 878 10 is_stmt 0 view .LVU1733
 4672 00c0 93F88C20 		ldrb	r2, [r3, #140]	@ zero_extendqisi2
 4673 00c4 012A     		cmp	r2, #1
 4674 00c6 02D9     		bls	.L592
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4675              		.loc 1 878 55 view .LVU1734
 4676 00c8 DA6F     		ldr	r2, [r3, #124]
 4677 00ca 9442     		cmp	r4, r2
 4678 00cc 6AD0     		beq	.L603
 4679              	.L592:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4680              		.loc 1 877 37 is_stmt 1 view .LVU1735
 4681              	.LVL416:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4682              		.loc 1 877 17 view .LVU1736
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4683              		.loc 1 878 7 view .LVU1737
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4684              		.loc 1 878 10 is_stmt 0 view .LVU1738
 4685 00ce 93F8A420 		ldrb	r2, [r3, #164]	@ zero_extendqisi2
 4686 00d2 012A     		cmp	r2, #1
 4687 00d4 03D9     		bls	.L593
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4688              		.loc 1 878 55 view .LVU1739
 4689 00d6 D3F89420 		ldr	r2, [r3, #148]
 4690 00da 9442     		cmp	r4, r2
 4691 00dc 60D0     		beq	.L604
 4692              	.L593:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4693              		.loc 1 877 37 is_stmt 1 view .LVU1740
 4694              	.LVL417:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4695              		.loc 1 877 17 view .LVU1741
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4696              		.loc 1 878 7 view .LVU1742
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4697              		.loc 1 878 10 is_stmt 0 view .LVU1743
 4698 00de 93F8BC20 		ldrb	r2, [r3, #188]	@ zero_extendqisi2
ARM GAS  /tmp/cctR0i1S.s 			page 151


 4699 00e2 012A     		cmp	r2, #1
 4700 00e4 03D9     		bls	.L594
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4701              		.loc 1 878 55 view .LVU1744
 4702 00e6 D3F8AC20 		ldr	r2, [r3, #172]
 4703 00ea 9442     		cmp	r4, r2
 4704 00ec 56D0     		beq	.L605
 4705              	.L594:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4706              		.loc 1 877 37 is_stmt 1 view .LVU1745
 4707              	.LVL418:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4708              		.loc 1 877 17 view .LVU1746
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4709              		.loc 1 878 7 view .LVU1747
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4710              		.loc 1 878 10 is_stmt 0 view .LVU1748
 4711 00ee 93F8D420 		ldrb	r2, [r3, #212]	@ zero_extendqisi2
 4712 00f2 012A     		cmp	r2, #1
 4713 00f4 03D9     		bls	.L595
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4714              		.loc 1 878 55 view .LVU1749
 4715 00f6 D3F8C420 		ldr	r2, [r3, #196]
 4716 00fa 9442     		cmp	r4, r2
 4717 00fc 4CD0     		beq	.L606
 4718              	.L595:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4719              		.loc 1 877 37 is_stmt 1 view .LVU1750
 4720              	.LVL419:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4721              		.loc 1 877 17 view .LVU1751
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4722              		.loc 1 878 7 view .LVU1752
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4723              		.loc 1 878 10 is_stmt 0 view .LVU1753
 4724 00fe 93F8EC20 		ldrb	r2, [r3, #236]	@ zero_extendqisi2
 4725 0102 012A     		cmp	r2, #1
 4726 0104 03D9     		bls	.L596
 878:lwIP/src/core/ipv4/etharp.c **** #if ETHARP_TABLE_MATCH_NETIF
 4727              		.loc 1 878 55 discriminator 1 view .LVU1754
 4728 0106 D3F8DC30 		ldr	r3, [r3, #220]
 4729 010a 9C42     		cmp	r4, r3
 4730 010c 3BD0     		beq	.L616
 4731              	.L596:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4732              		.loc 1 877 37 is_stmt 1 discriminator 2 view .LVU1755
 4733              	.LVL420:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4734              		.loc 1 877 17 discriminator 2 view .LVU1756
 890:lwIP/src/core/ipv4/etharp.c ****   }
 4735              		.loc 1 890 5 discriminator 2 view .LVU1757
 890:lwIP/src/core/ipv4/etharp.c ****   }
 4736              		.loc 1 890 12 is_stmt 0 discriminator 2 view .LVU1758
 4737 010e 4246     		mov	r2, r8
 4738 0110 3946     		mov	r1, r7
 4739 0112 3046     		mov	r0, r6
 4740 0114 FFF7FEFF 		bl	etharp_query
ARM GAS  /tmp/cctR0i1S.s 			page 152


 4741              	.LVL421:
 4742              	.L584:
 890:lwIP/src/core/ipv4/etharp.c ****   }
 4743              		.loc 1 890 12 discriminator 2 view .LVU1759
 4744              	.LBE246:
 897:lwIP/src/core/ipv4/etharp.c **** 
 4745              		.loc 1 897 1 view .LVU1760
 4746 0118 04B0     		add	sp, sp, #16
 4747              	.LCFI30:
 4748              		.cfi_remember_state
 4749              		.cfi_def_cfa_offset 24
 4750              		@ sp needed
 4751 011a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 4752              	.LVL422:
 4753              	.L613:
 4754              	.LCFI31:
 4755              		.cfi_restore_state
 800:lwIP/src/core/ipv4/etharp.c **** 
 4756              		.loc 1 800 3 is_stmt 1 discriminator 1 view .LVU1761
 4757 011e 2748     		ldr	r0, .L617+4
 4758              	.LVL423:
 800:lwIP/src/core/ipv4/etharp.c **** 
 4759              		.loc 1 800 3 is_stmt 0 discriminator 1 view .LVU1762
 4760 0120 FFF7FEFF 		bl	printf
 4761              	.LVL424:
 4762              	.L580:
 800:lwIP/src/core/ipv4/etharp.c **** 
 4763              		.loc 1 800 3 is_stmt 1 discriminator 3 view .LVU1763
 800:lwIP/src/core/ipv4/etharp.c **** 
 4764              		.loc 1 800 3 discriminator 3 view .LVU1764
 800:lwIP/src/core/ipv4/etharp.c **** 
 4765              		.loc 1 800 3 discriminator 3 view .LVU1765
 800:lwIP/src/core/ipv4/etharp.c **** 
 4766              		.loc 1 800 3 discriminator 3 view .LVU1766
 800:lwIP/src/core/ipv4/etharp.c **** 
 4767              		.loc 1 800 3 discriminator 3 view .LVU1767
 800:lwIP/src/core/ipv4/etharp.c **** 
 4768              		.loc 1 800 3 discriminator 3 view .LVU1768
 4769 0124 FEE7     		b	.L580
 4770              	.LVL425:
 4771              	.L614:
 812:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
 4772              		.loc 1 812 5 view .LVU1769
 813:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
 4773              		.loc 1 813 5 view .LVU1770
 814:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 4774              		.loc 1 814 5 view .LVU1771
 815:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[4] = ip4_addr3(ipaddr);
 4775              		.loc 1 815 43 is_stmt 0 view .LVU1772
 4776 0126 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 812:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
 4777              		.loc 1 812 23 view .LVU1773
 4778 0128 0124     		movs	r4, #1
 814:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 4779              		.loc 1 814 23 view .LVU1774
 4780 012a 5E20     		movs	r0, #94
 816:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[5] = ip4_addr4(ipaddr);
ARM GAS  /tmp/cctR0i1S.s 			page 153


 4781              		.loc 1 816 23 view .LVU1775
 4782 012c B978     		ldrb	r1, [r7, #2]	@ zero_extendqisi2
 815:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[4] = ip4_addr3(ipaddr);
 4783              		.loc 1 815 43 view .LVU1776
 4784 012e 03F07F03 		and	r3, r3, #127
 817:lwIP/src/core/ipv4/etharp.c ****     /* destination Ethernet address is multicast */
 4785              		.loc 1 817 23 view .LVU1777
 4786 0132 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 812:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
 4787              		.loc 1 812 23 view .LVU1778
 4788 0134 ADF80840 		strh	r4, [sp, #8]	@ movhi
 815:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[4] = ip4_addr3(ipaddr);
 4789              		.loc 1 815 23 view .LVU1779
 4790 0138 8DF80B30 		strb	r3, [sp, #11]
 819:lwIP/src/core/ipv4/etharp.c ****     /* unicast destination IP address? */
 4791              		.loc 1 819 10 view .LVU1780
 4792 013c 02AB     		add	r3, sp, #8
 814:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 4793              		.loc 1 814 23 view .LVU1781
 4794 013e 8DF80A00 		strb	r0, [sp, #10]
 815:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[4] = ip4_addr3(ipaddr);
 4795              		.loc 1 815 5 is_stmt 1 view .LVU1782
 816:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[5] = ip4_addr4(ipaddr);
 4796              		.loc 1 816 5 view .LVU1783
 816:lwIP/src/core/ipv4/etharp.c ****     mcastaddr.addr[5] = ip4_addr4(ipaddr);
 4797              		.loc 1 816 23 is_stmt 0 view .LVU1784
 4798 0142 8DF80C10 		strb	r1, [sp, #12]
 817:lwIP/src/core/ipv4/etharp.c ****     /* destination Ethernet address is multicast */
 4799              		.loc 1 817 5 is_stmt 1 view .LVU1785
 817:lwIP/src/core/ipv4/etharp.c ****     /* destination Ethernet address is multicast */
 4800              		.loc 1 817 23 is_stmt 0 view .LVU1786
 4801 0146 8DF80D20 		strb	r2, [sp, #13]
 819:lwIP/src/core/ipv4/etharp.c ****     /* unicast destination IP address? */
 4802              		.loc 1 819 5 is_stmt 1 view .LVU1787
 4803              	.LVL426:
 4804              	.L581:
 896:lwIP/src/core/ipv4/etharp.c **** }
 4805              		.loc 1 896 3 view .LVU1788
 896:lwIP/src/core/ipv4/etharp.c **** }
 4806              		.loc 1 896 10 is_stmt 0 view .LVU1789
 4807 014a 4FF40060 		mov	r0, #2048
 4808 014e 4146     		mov	r1, r8
 4809 0150 06F11E02 		add	r2, r6, #30
 4810 0154 0090     		str	r0, [sp]
 4811 0156 3046     		mov	r0, r6
 4812 0158 FFF7FEFF 		bl	ethernet_output
 4813              	.LVL427:
 897:lwIP/src/core/ipv4/etharp.c **** 
 4814              		.loc 1 897 1 view .LVU1790
 4815 015c 04B0     		add	sp, sp, #16
 4816              	.LCFI32:
 4817              		.cfi_remember_state
 4818              		.cfi_def_cfa_offset 24
 4819              		@ sp needed
 4820 015e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 4821              	.LVL428:
 4822              	.L597:
ARM GAS  /tmp/cctR0i1S.s 			page 154


 4823              	.LCFI33:
 4824              		.cfi_restore_state
 808:lwIP/src/core/ipv4/etharp.c ****     /* multicast destination IP address? */
 4825              		.loc 1 808 10 view .LVU1791
 4826 0162 174B     		ldr	r3, .L617+8
 4827 0164 F1E7     		b	.L581
 4828              	.LVL429:
 4829              	.L612:
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 4830              		.loc 1 799 3 is_stmt 1 discriminator 1 view .LVU1792
 4831 0166 1748     		ldr	r0, .L617+12
 4832              	.LVL430:
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 4833              		.loc 1 799 3 is_stmt 0 discriminator 1 view .LVU1793
 4834 0168 FFF7FEFF 		bl	printf
 4835              	.LVL431:
 4836              	.L578:
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 4837              		.loc 1 799 3 is_stmt 1 discriminator 2 view .LVU1794
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 4838              		.loc 1 799 3 discriminator 2 view .LVU1795
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 4839              		.loc 1 799 3 discriminator 2 view .LVU1796
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 4840              		.loc 1 799 3 discriminator 2 view .LVU1797
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 4841              		.loc 1 799 3 discriminator 2 view .LVU1798
 799:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 4842              		.loc 1 799 3 discriminator 2 view .LVU1799
 4843 016c FEE7     		b	.L578
 4844              	.LVL432:
 4845              	.L611:
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4846              		.loc 1 798 3 discriminator 1 view .LVU1800
 4847 016e 1648     		ldr	r0, .L617+16
 4848              	.LVL433:
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4849              		.loc 1 798 3 is_stmt 0 discriminator 1 view .LVU1801
 4850 0170 FFF7FEFF 		bl	printf
 4851              	.LVL434:
 4852              	.L576:
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4853              		.loc 1 798 3 is_stmt 1 discriminator 1 view .LVU1802
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4854              		.loc 1 798 3 discriminator 1 view .LVU1803
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4855              		.loc 1 798 3 discriminator 1 view .LVU1804
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4856              		.loc 1 798 3 discriminator 1 view .LVU1805
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4857              		.loc 1 798 3 discriminator 1 view .LVU1806
 798:lwIP/src/core/ipv4/etharp.c ****   LWIP_ASSERT("q != NULL", q != NULL);
 4858              		.loc 1 798 3 discriminator 1 view .LVU1807
 4859 0174 FEE7     		b	.L576
 4860              	.LVL435:
 4861              	.L615:
 4862              	.LBB247:
ARM GAS  /tmp/cctR0i1S.s 			page 155


 867:lwIP/src/core/ipv4/etharp.c ****           return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 4863              		.loc 1 867 44 view .LVU1808
 868:lwIP/src/core/ipv4/etharp.c ****         }
 4864              		.loc 1 868 11 view .LVU1809
 868:lwIP/src/core/ipv4/etharp.c ****         }
 4865              		.loc 1 868 18 is_stmt 0 view .LVU1810
 4866 0176 4146     		mov	r1, r8
 4867 0178 3046     		mov	r0, r6
 4868 017a FFF7FEFF 		bl	etharp_output_to_arp_index
 4869              	.LVL436:
 4870 017e CBE7     		b	.L584
 4871              	.LVL437:
 4872              	.L598:
 850:lwIP/src/core/ipv4/etharp.c ****           }
 4873              		.loc 1 850 20 view .LVU1811
 4874 0180 6FF00300 		mvn	r0, #3
 4875 0184 C8E7     		b	.L584
 4876              	.LVL438:
 4877              	.L616:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4878              		.loc 1 877 38 view .LVU1812
 4879 0186 0925     		movs	r5, #9
 4880              	.LVL439:
 4881              	.L587:
 884:lwIP/src/core/ipv4/etharp.c ****         return etharp_output_to_arp_index(netif, q, i);
 4882              		.loc 1 884 9 is_stmt 1 view .LVU1813
 885:lwIP/src/core/ipv4/etharp.c ****       }
 4883              		.loc 1 885 16 is_stmt 0 view .LVU1814
 4884 0188 4146     		mov	r1, r8
 4885 018a 3046     		mov	r0, r6
 4886 018c 2A46     		mov	r2, r5
 884:lwIP/src/core/ipv4/etharp.c ****         return etharp_output_to_arp_index(netif, q, i);
 4887              		.loc 1 884 9 view .LVU1815
 4888 018e 8CF80050 		strb	r5, [ip]
 885:lwIP/src/core/ipv4/etharp.c ****       }
 4889              		.loc 1 885 9 is_stmt 1 view .LVU1816
 885:lwIP/src/core/ipv4/etharp.c ****       }
 4890              		.loc 1 885 16 is_stmt 0 view .LVU1817
 4891 0192 FFF7FEFF 		bl	etharp_output_to_arp_index
 4892              	.LVL440:
 4893 0196 BFE7     		b	.L584
 4894              	.LVL441:
 4895              	.L606:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4896              		.loc 1 877 38 view .LVU1818
 4897 0198 0825     		movs	r5, #8
 4898 019a F5E7     		b	.L587
 4899              	.LVL442:
 4900              	.L605:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4901              		.loc 1 877 38 view .LVU1819
 4902 019c 0725     		movs	r5, #7
 4903 019e F3E7     		b	.L587
 4904              	.LVL443:
 4905              	.L604:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4906              		.loc 1 877 38 view .LVU1820
ARM GAS  /tmp/cctR0i1S.s 			page 156


 4907 01a0 0625     		movs	r5, #6
 4908 01a2 F1E7     		b	.L587
 4909              	.LVL444:
 4910              	.L603:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4911              		.loc 1 877 38 view .LVU1821
 4912 01a4 0525     		movs	r5, #5
 4913 01a6 EFE7     		b	.L587
 4914              	.LVL445:
 4915              	.L602:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4916              		.loc 1 877 38 view .LVU1822
 4917 01a8 0425     		movs	r5, #4
 4918 01aa EDE7     		b	.L587
 4919              	.LVL446:
 4920              	.L601:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4921              		.loc 1 877 38 view .LVU1823
 4922 01ac 0325     		movs	r5, #3
 4923 01ae EBE7     		b	.L587
 4924              	.LVL447:
 4925              	.L599:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4926              		.loc 1 877 38 view .LVU1824
 4927 01b0 0125     		movs	r5, #1
 4928 01b2 E9E7     		b	.L587
 4929              	.LVL448:
 4930              	.L600:
 877:lwIP/src/core/ipv4/etharp.c ****       if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 4931              		.loc 1 877 38 view .LVU1825
 4932 01b4 0225     		movs	r5, #2
 4933 01b6 E7E7     		b	.L587
 4934              	.L618:
 4935              		.align	2
 4936              	.L617:
 4937 01b8 00000000 		.word	.LANCHOR0
 4938 01bc 00000000 		.word	.LC7
 4939 01c0 00000000 		.word	ethbroadcast
 4940 01c4 00000000 		.word	.LC12
 4941 01c8 00000000 		.word	.LC0
 4942 01cc 00000000 		.word	.LANCHOR1
 4943              	.LBE247:
 4944              		.cfi_endproc
 4945              	.LFE114:
 4947              		.section	.text.etharp_request,"ax",%progbits
 4948              		.align	1
 4949              		.p2align 2,,3
 4950              		.global	etharp_request
 4951              		.syntax unified
 4952              		.thumb
 4953              		.thumb_func
 4954              		.fpu fpv4-sp-d16
 4956              	etharp_request:
 4957              	.LVL449:
 4958              	.LFB118:
1199:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
 4959              		.loc 1 1199 1 is_stmt 1 view -0
ARM GAS  /tmp/cctR0i1S.s 			page 157


 4960              		.cfi_startproc
 4961              		@ args = 0, pretend = 0, frame = 0
 4962              		@ frame_needed = 0, uses_anonymous_args = 0
1200:lwIP/src/core/ipv4/etharp.c ****   return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 4963              		.loc 1 1200 89 view .LVU1827
 4964              		.loc 1 1201 3 view .LVU1828
 4965              	.LBB254:
 4966              	.LBI254:
1181:lwIP/src/core/ipv4/etharp.c **** {
 4967              		.loc 1 1181 1 view .LVU1829
 4968              	.LBB255:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 4969              		.loc 1 1183 3 view .LVU1830
 4970              	.LBB256:
 4971              	.LBI256:
1101:lwIP/src/core/ipv4/etharp.c ****            const struct eth_addr *ethdst_addr,
 4972              		.loc 1 1101 1 view .LVU1831
 4973              	.LBB257:
1107:lwIP/src/core/ipv4/etharp.c ****   err_t result = ERR_OK;
 4974              		.loc 1 1107 3 view .LVU1832
1108:lwIP/src/core/ipv4/etharp.c ****   struct etharp_hdr *hdr;
 4975              		.loc 1 1108 3 view .LVU1833
1109:lwIP/src/core/ipv4/etharp.c **** 
 4976              		.loc 1 1109 3 view .LVU1834
1111:lwIP/src/core/ipv4/etharp.c **** 
 4977              		.loc 1 1111 3 view .LVU1835
1111:lwIP/src/core/ipv4/etharp.c **** 
 4978              		.loc 1 1111 3 view .LVU1836
 4979              	.LBE257:
 4980              	.LBE256:
 4981              	.LBE255:
 4982              	.LBE254:
1199:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
 4983              		.loc 1 1199 1 is_stmt 0 view .LVU1837
 4984 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 4985              	.LCFI34:
 4986              		.cfi_def_cfa_offset 28
 4987              		.cfi_offset 4, -28
 4988              		.cfi_offset 5, -24
 4989              		.cfi_offset 6, -20
 4990              		.cfi_offset 7, -16
 4991              		.cfi_offset 8, -12
 4992              		.cfi_offset 9, -8
 4993              		.cfi_offset 14, -4
 4994 0004 83B0     		sub	sp, sp, #12
 4995              	.LCFI35:
 4996              		.cfi_def_cfa_offset 40
 4997              	.LBB269:
 4998              	.LBB266:
 4999              	.LBB262:
 5000              	.LBB258:
1111:lwIP/src/core/ipv4/etharp.c **** 
 5001              		.loc 1 1111 3 view .LVU1838
 5002 0006 F0B1     		cbz	r0, .L629
1111:lwIP/src/core/ipv4/etharp.c **** 
 5003              		.loc 1 1111 3 is_stmt 1 view .LVU1839
1114:lwIP/src/core/ipv4/etharp.c ****   /* could allocate a pbuf for an ARP request? */
ARM GAS  /tmp/cctR0i1S.s 			page 158


 5004              		.loc 1 1114 3 view .LVU1840
 5005 0008 0446     		mov	r4, r0
 5006 000a 0F46     		mov	r7, r1
1114:lwIP/src/core/ipv4/etharp.c ****   /* could allocate a pbuf for an ARP request? */
 5007              		.loc 1 1114 7 is_stmt 0 view .LVU1841
 5008 000c 4FF42072 		mov	r2, #640
 5009 0010 1C21     		movs	r1, #28
 5010              	.LVL450:
1114:lwIP/src/core/ipv4/etharp.c ****   /* could allocate a pbuf for an ARP request? */
 5011              		.loc 1 1114 7 view .LVU1842
 5012 0012 0E20     		movs	r0, #14
 5013              	.LVL451:
1114:lwIP/src/core/ipv4/etharp.c ****   /* could allocate a pbuf for an ARP request? */
 5014              		.loc 1 1114 7 view .LVU1843
 5015 0014 FFF7FEFF 		bl	pbuf_alloc
 5016              	.LVL452:
1116:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
 5017              		.loc 1 1116 3 is_stmt 1 view .LVU1844
1116:lwIP/src/core/ipv4/etharp.c ****     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
 5018              		.loc 1 1116 6 is_stmt 0 view .LVU1845
 5019 0018 0546     		mov	r5, r0
 5020 001a 0028     		cmp	r0, #0
 5021 001c 45D0     		beq	.L627
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 5022              		.loc 1 1122 3 is_stmt 1 view .LVU1846
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 5023              		.loc 1 1122 3 view .LVU1847
 5024 001e 4389     		ldrh	r3, [r0, #10]
 5025 0020 1B2B     		cmp	r3, #27
 5026 0022 0CD9     		bls	.L630
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 5027              		.loc 1 1122 3 view .LVU1848
1125:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
 5028              		.loc 1 1125 3 view .LVU1849
1125:lwIP/src/core/ipv4/etharp.c ****   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
 5029              		.loc 1 1125 7 is_stmt 0 view .LVU1850
 5030 0024 4368     		ldr	r3, [r0, #4]
 5031              	.LVL453:
1126:lwIP/src/core/ipv4/etharp.c ****   hdr->opcode = lwip_htons(opcode);
 5032              		.loc 1 1126 88 is_stmt 1 view .LVU1851
1127:lwIP/src/core/ipv4/etharp.c **** 
 5033              		.loc 1 1127 3 view .LVU1852
1127:lwIP/src/core/ipv4/etharp.c **** 
 5034              		.loc 1 1127 3 is_stmt 0 view .LVU1853
 5035              	.LBE258:
 5036              	.LBE262:
 5037              	.LBE266:
 5038              	.LBE269:
 5039              		.loc 2 937 3 is_stmt 1 view .LVU1854
 5040              	.LBB270:
 5041              	.LBB267:
 5042              	.LBB263:
 5043              	.LBB259:
1127:lwIP/src/core/ipv4/etharp.c **** 
 5044              		.loc 1 1127 15 is_stmt 0 view .LVU1855
 5045 0026 0122     		movs	r2, #1
 5046 0028 0026     		movs	r6, #0
ARM GAS  /tmp/cctR0i1S.s 			page 159


 5047 002a DA71     		strb	r2, [r3, #7]
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5048              		.loc 1 1129 3 is_stmt 1 view .LVU1856
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5049              		.loc 1 1129 3 view .LVU1857
1127:lwIP/src/core/ipv4/etharp.c **** 
 5050              		.loc 1 1127 15 is_stmt 0 view .LVU1858
 5051 002c 9E71     		strb	r6, [r3, #6]
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5052              		.loc 1 1129 3 view .LVU1859
 5053 002e 94F82410 		ldrb	r1, [r4, #36]	@ zero_extendqisi2
 5054 0032 0629     		cmp	r1, #6
 5055 0034 0BD0     		beq	.L625
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5056              		.loc 1 1129 3 is_stmt 1 view .LVU1860
 5057 0036 1E48     		ldr	r0, .L631
 5058              	.LVL454:
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5059              		.loc 1 1129 3 is_stmt 0 view .LVU1861
 5060 0038 FFF7FEFF 		bl	printf
 5061              	.LVL455:
 5062              	.L626:
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5063              		.loc 1 1129 3 is_stmt 1 view .LVU1862
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5064              		.loc 1 1129 3 view .LVU1863
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5065              		.loc 1 1129 3 view .LVU1864
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5066              		.loc 1 1129 3 view .LVU1865
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5067              		.loc 1 1129 3 view .LVU1866
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5068              		.loc 1 1129 3 view .LVU1867
 5069 003c FEE7     		b	.L626
 5070              	.LVL456:
 5071              	.L630:
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 5072              		.loc 1 1122 3 view .LVU1868
 5073 003e 1D48     		ldr	r0, .L631+4
 5074              	.LVL457:
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 5075              		.loc 1 1122 3 is_stmt 0 view .LVU1869
 5076 0040 FFF7FEFF 		bl	printf
 5077              	.LVL458:
 5078              	.L624:
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 5079              		.loc 1 1122 3 is_stmt 1 view .LVU1870
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 5080              		.loc 1 1122 3 view .LVU1871
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 5081              		.loc 1 1122 3 view .LVU1872
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 5082              		.loc 1 1122 3 view .LVU1873
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
 5083              		.loc 1 1122 3 view .LVU1874
1122:lwIP/src/core/ipv4/etharp.c ****               (p->len >= SIZEOF_ETHARP_HDR));
ARM GAS  /tmp/cctR0i1S.s 			page 160


 5084              		.loc 1 1122 3 view .LVU1875
 5085 0044 FEE7     		b	.L624
 5086              	.LVL459:
 5087              	.L629:
1111:lwIP/src/core/ipv4/etharp.c **** 
 5088              		.loc 1 1111 3 view .LVU1876
 5089 0046 1C48     		ldr	r0, .L631+8
 5090              	.LVL460:
1111:lwIP/src/core/ipv4/etharp.c **** 
 5091              		.loc 1 1111 3 is_stmt 0 view .LVU1877
 5092 0048 FFF7FEFF 		bl	printf
 5093              	.LVL461:
 5094              	.L621:
1111:lwIP/src/core/ipv4/etharp.c **** 
 5095              		.loc 1 1111 3 is_stmt 1 view .LVU1878
1111:lwIP/src/core/ipv4/etharp.c **** 
 5096              		.loc 1 1111 3 view .LVU1879
1111:lwIP/src/core/ipv4/etharp.c **** 
 5097              		.loc 1 1111 3 view .LVU1880
1111:lwIP/src/core/ipv4/etharp.c **** 
 5098              		.loc 1 1111 3 view .LVU1881
1111:lwIP/src/core/ipv4/etharp.c **** 
 5099              		.loc 1 1111 3 view .LVU1882
1111:lwIP/src/core/ipv4/etharp.c **** 
 5100              		.loc 1 1111 3 view .LVU1883
 5101 004c FEE7     		b	.L621
 5102              	.LVL462:
 5103              	.L625:
1111:lwIP/src/core/ipv4/etharp.c **** 
 5104              		.loc 1 1111 3 is_stmt 0 view .LVU1884
 5105              	.LBE259:
 5106              	.LBE263:
1183:lwIP/src/core/ipv4/etharp.c ****                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 5107              		.loc 1 1183 47 view .LVU1885
 5108 004e 2246     		mov	r2, r4
 5109              	.LBB264:
 5110              	.LBB260:
1129:lwIP/src/core/ipv4/etharp.c ****               (netif->hwaddr_len == ETH_HWADDR_LEN));
 5111              		.loc 1 1129 3 is_stmt 1 view .LVU1886
1133:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 5112              		.loc 1 1133 3 view .LVU1887
1134:lwIP/src/core/ipv4/etharp.c ****   /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
 5113              		.loc 1 1134 3 is_stmt 0 view .LVU1888
 5114 0050 1A48     		ldr	r0, .L631+12
 5115              	.LVL463:
1140:lwIP/src/core/ipv4/etharp.c ****   hdr->proto = PP_HTONS(ETHTYPE_IP);
 5116              		.loc 1 1140 15 view .LVU1889
 5117 0052 DFF870E0 		ldr	lr, .L631+20
1144:lwIP/src/core/ipv4/etharp.c **** 
 5118              		.loc 1 1144 17 view .LVU1890
 5119 0056 4FF0040C 		mov	ip, #4
1133:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 5120              		.loc 1 1133 3 view .LVU1891
 5121 005a 52F81E8F 		ldr	r8, [r2, #30]!	@ unaligned
 5122 005e C3F80880 		str	r8, [r3, #8]	@ unaligned
1134:lwIP/src/core/ipv4/etharp.c ****   /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
 5123              		.loc 1 1134 3 view .LVU1892
ARM GAS  /tmp/cctR0i1S.s 			page 161


 5124 0062 D0F80080 		ldr	r8, [r0]	@ unaligned
1133:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 5125              		.loc 1 1133 3 view .LVU1893
 5126 0066 B2F80490 		ldrh	r9, [r2, #4]	@ unaligned
1134:lwIP/src/core/ipv4/etharp.c ****   /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
 5127              		.loc 1 1134 3 view .LVU1894
 5128 006a 8088     		ldrh	r0, [r0, #4]	@ unaligned
1133:lwIP/src/core/ipv4/etharp.c ****   SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
 5129              		.loc 1 1133 3 view .LVU1895
 5130 006c A3F80C90 		strh	r9, [r3, #12]	@ unaligned
1134:lwIP/src/core/ipv4/etharp.c ****   /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
 5131              		.loc 1 1134 3 is_stmt 1 view .LVU1896
 5132 0070 D882     		strh	r0, [r3, #22]	@ unaligned
1137:lwIP/src/core/ipv4/etharp.c ****   IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->dipaddr, ipdst_addr);
 5133              		.loc 1 1137 3 view .LVU1897
1156:lwIP/src/core/ipv4/etharp.c ****   }
 5134              		.loc 1 1156 5 is_stmt 0 view .LVU1898
 5135 0072 2046     		mov	r0, r4
1134:lwIP/src/core/ipv4/etharp.c ****   /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
 5136              		.loc 1 1134 3 view .LVU1899
 5137 0074 C3F81280 		str	r8, [r3, #18]	@ unaligned
 5138 0078 D4F80080 		ldr	r8, [r4]	@ unaligned
1156:lwIP/src/core/ipv4/etharp.c ****   }
 5139              		.loc 1 1156 5 view .LVU1900
 5140 007c 40F60604 		movw	r4, #2054
 5141              	.LVL464:
1137:lwIP/src/core/ipv4/etharp.c ****   IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->dipaddr, ipdst_addr);
 5142              		.loc 1 1137 3 view .LVU1901
 5143 0080 C3F80E80 		str	r8, [r3, #14]	@ unaligned
1138:lwIP/src/core/ipv4/etharp.c **** 
 5144              		.loc 1 1138 3 is_stmt 1 view .LVU1902
 5145 0084 3F68     		ldr	r7, [r7]	@ unaligned
 5146              	.LVL465:
1143:lwIP/src/core/ipv4/etharp.c ****   hdr->protolen = sizeof(ip4_addr_t);
 5147              		.loc 1 1143 14 is_stmt 0 view .LVU1903
 5148 0086 1971     		strb	r1, [r3, #4]
1156:lwIP/src/core/ipv4/etharp.c ****   }
 5149              		.loc 1 1156 5 view .LVU1904
 5150 0088 2946     		mov	r1, r5
1140:lwIP/src/core/ipv4/etharp.c ****   hdr->proto = PP_HTONS(ETHTYPE_IP);
 5151              		.loc 1 1140 15 view .LVU1905
 5152 008a C3F800E0 		str	lr, [r3]	@ unaligned
1144:lwIP/src/core/ipv4/etharp.c **** 
 5153              		.loc 1 1144 17 view .LVU1906
 5154 008e 83F805C0 		strb	ip, [r3, #5]
1138:lwIP/src/core/ipv4/etharp.c **** 
 5155              		.loc 1 1138 3 view .LVU1907
 5156 0092 9F61     		str	r7, [r3, #24]	@ unaligned
1140:lwIP/src/core/ipv4/etharp.c ****   hdr->proto = PP_HTONS(ETHTYPE_IP);
 5157              		.loc 1 1140 3 is_stmt 1 view .LVU1908
1141:lwIP/src/core/ipv4/etharp.c ****   /* set hwlen and protolen */
 5158              		.loc 1 1141 3 view .LVU1909
1143:lwIP/src/core/ipv4/etharp.c ****   hdr->protolen = sizeof(ip4_addr_t);
 5159              		.loc 1 1143 3 view .LVU1910
1144:lwIP/src/core/ipv4/etharp.c **** 
 5160              		.loc 1 1144 3 view .LVU1911
1156:lwIP/src/core/ipv4/etharp.c ****   }
ARM GAS  /tmp/cctR0i1S.s 			page 162


 5161              		.loc 1 1156 5 view .LVU1912
 5162 0094 0A4B     		ldr	r3, .L631+16
 5163              	.LVL466:
1156:lwIP/src/core/ipv4/etharp.c ****   }
 5164              		.loc 1 1156 5 is_stmt 0 view .LVU1913
 5165 0096 0094     		str	r4, [sp]
 5166 0098 FFF7FEFF 		bl	ethernet_output
 5167              	.LVL467:
1159:lwIP/src/core/ipv4/etharp.c ****   /* free ARP query packet */
 5168              		.loc 1 1159 32 is_stmt 1 view .LVU1914
1161:lwIP/src/core/ipv4/etharp.c ****   p = NULL;
 5169              		.loc 1 1161 3 view .LVU1915
 5170 009c 2846     		mov	r0, r5
 5171 009e FFF7FEFF 		bl	pbuf_free
 5172              	.LVL468:
1162:lwIP/src/core/ipv4/etharp.c ****   /* could not allocate pbuf for ARP request */
 5173              		.loc 1 1162 3 view .LVU1916
1165:lwIP/src/core/ipv4/etharp.c **** }
 5174              		.loc 1 1165 3 view .LVU1917
1165:lwIP/src/core/ipv4/etharp.c **** }
 5175              		.loc 1 1165 10 is_stmt 0 view .LVU1918
 5176 00a2 3046     		mov	r0, r6
 5177              	.LVL469:
 5178              	.L622:
1165:lwIP/src/core/ipv4/etharp.c **** }
 5179              		.loc 1 1165 10 view .LVU1919
 5180              	.LBE260:
 5181              	.LBE264:
 5182              	.LBE267:
 5183              	.LBE270:
1202:lwIP/src/core/ipv4/etharp.c **** }
 5184              		.loc 1 1202 1 view .LVU1920
 5185 00a4 03B0     		add	sp, sp, #12
 5186              	.LCFI36:
 5187              		.cfi_remember_state
 5188              		.cfi_def_cfa_offset 28
 5189              		@ sp needed
 5190 00a6 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 5191              	.LVL470:
 5192              	.L627:
 5193              	.LCFI37:
 5194              		.cfi_restore_state
 5195              	.LBB271:
 5196              	.LBB268:
 5197              	.LBB265:
 5198              	.LBB261:
1120:lwIP/src/core/ipv4/etharp.c ****   }
 5199              		.loc 1 1120 12 view .LVU1921
 5200 00aa 4FF0FF30 		mov	r0, #-1
 5201              	.LVL471:
1120:lwIP/src/core/ipv4/etharp.c ****   }
 5202              		.loc 1 1120 12 view .LVU1922
 5203 00ae F9E7     		b	.L622
 5204              	.L632:
 5205              		.align	2
 5206              	.L631:
 5207 00b0 44000000 		.word	.LC2
ARM GAS  /tmp/cctR0i1S.s 			page 163


 5208 00b4 10000000 		.word	.LC1
 5209 00b8 00000000 		.word	.LC0
 5210 00bc 00000000 		.word	ethzero
 5211 00c0 00000000 		.word	ethbroadcast
 5212 00c4 00010800 		.word	524544
 5213              	.LBE261:
 5214              	.LBE265:
 5215              	.LBE268:
 5216              	.LBE271:
 5217              		.cfi_endproc
 5218              	.LFE118:
 5220              		.section	.bss.arp_table,"aw",%nobits
 5221              		.align	2
 5222              		.set	.LANCHOR0,. + 0
 5225              	arp_table:
 5226 0000 00000000 		.space	240
 5226      00000000 
 5226      00000000 
 5226      00000000 
 5226      00000000 
 5227              		.section	.bss.etharp_cached_entry,"aw",%nobits
 5228              		.set	.LANCHOR1,. + 0
 5231              	etharp_cached_entry:
 5232 0000 00       		.space	1
 5233              		.text
 5234              	.Letext0:
 5235              		.file 3 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h"
 5236              		.file 4 "/usr/arm-none-eabi/include/machine/_default_types.h"
 5237              		.file 5 "/usr/arm-none-eabi/include/sys/lock.h"
 5238              		.file 6 "/usr/arm-none-eabi/include/sys/_types.h"
 5239              		.file 7 "/usr/arm-none-eabi/include/sys/reent.h"
 5240              		.file 8 "/usr/arm-none-eabi/include/stdlib.h"
 5241              		.file 9 "/usr/arm-none-eabi/include/sys/_stdint.h"
 5242              		.file 10 "/usr/arm-none-eabi/include/sys/types.h"
 5243              		.file 11 "lwIP/src/include/lwip/arch.h"
 5244              		.file 12 "/usr/arm-none-eabi/include/ctype.h"
 5245              		.file 13 "lwIP/src/include/lwip/err.h"
 5246              		.file 14 "lwIP/src/include/lwip/pbuf.h"
 5247              		.file 15 "lwIP/src/include/lwip/ip4_addr.h"
 5248              		.file 16 "lwIP/src/include/lwip/ip_addr.h"
 5249              		.file 17 "lwIP/src/include/lwip/memp.h"
 5250              		.file 18 "lwIP/src/include/lwip/priv/memp_priv.h"
 5251              		.file 19 "lwIP/src/include/lwip/netif.h"
 5252              		.file 20 "lwIP/src/include/lwip/prot/ethernet.h"
 5253              		.file 21 "lwIP/src/include/lwip/prot/etharp.h"
 5254              		.file 22 "lwIP/src/include/lwip/prot/ieee.h"
 5255              		.file 23 "lwIP/src/include/lwip/prot/iana.h"
 5256              		.file 24 "lwIP/src/include/netif/ethernet.h"
 5257              		.file 25 "/usr/arm-none-eabi/include/stdio.h"
ARM GAS  /tmp/cctR0i1S.s 			page 164


DEFINED SYMBOLS
                            *ABS*:0000000000000000 etharp.c
     /tmp/cctR0i1S.s:18     .rodata.etharp_raw.str1.4:0000000000000000 $d
     /tmp/cctR0i1S.s:29     .text.etharp_raw:0000000000000000 $t
     /tmp/cctR0i1S.s:37     .text.etharp_raw:0000000000000000 etharp_raw
     /tmp/cctR0i1S.s:258    .text.etharp_raw:00000000000000bc $d
     /tmp/cctR0i1S.s:266    .rodata.etharp_output_to_arp_index.str1.4:0000000000000000 $d
     /tmp/cctR0i1S.s:270    .text.etharp_output_to_arp_index:0000000000000000 $t
     /tmp/cctR0i1S.s:277    .text.etharp_output_to_arp_index:0000000000000000 etharp_output_to_arp_index
     /tmp/cctR0i1S.s:480    .text.etharp_output_to_arp_index:00000000000000a4 $d
     /tmp/cctR0i1S.s:488    .rodata.etharp_find_entry.isra.0.str1.4:0000000000000000 $d
     /tmp/cctR0i1S.s:495    .text.etharp_find_entry.isra.0:0000000000000000 $t
     /tmp/cctR0i1S.s:502    .text.etharp_find_entry.isra.0:0000000000000000 etharp_find_entry.isra.0
     /tmp/cctR0i1S.s:1194   .text.etharp_find_entry.isra.0:0000000000000258 $d
     /tmp/cctR0i1S.s:1201   .text.etharp_find_entry.isra.0:0000000000000264 $t
     /tmp/cctR0i1S.s:2662   .text.etharp_tmr:0000000000000000 $t
     /tmp/cctR0i1S.s:2670   .text.etharp_tmr:0000000000000000 etharp_tmr
     /tmp/cctR0i1S.s:2863   .text.etharp_tmr:0000000000000088 $d
     /tmp/cctR0i1S.s:2873   .text.etharp_cleanup_netif:0000000000000000 $t
     /tmp/cctR0i1S.s:2881   .text.etharp_cleanup_netif:0000000000000000 etharp_cleanup_netif
     /tmp/cctR0i1S.s:3476   .text.etharp_cleanup_netif:00000000000001ac $d
     /tmp/cctR0i1S.s:3482   .rodata.etharp_find_addr.str1.4:0000000000000000 $d
     /tmp/cctR0i1S.s:3486   .text.etharp_find_addr:0000000000000000 $t
     /tmp/cctR0i1S.s:3494   .text.etharp_find_addr:0000000000000000 etharp_find_addr
     /tmp/cctR0i1S.s:3587   .text.etharp_find_addr:0000000000000048 $d
     /tmp/cctR0i1S.s:3593   .rodata.etharp_get_entry.str1.4:0000000000000000 $d
     /tmp/cctR0i1S.s:3600   .text.etharp_get_entry:0000000000000000 $t
     /tmp/cctR0i1S.s:3608   .text.etharp_get_entry:0000000000000000 etharp_get_entry
     /tmp/cctR0i1S.s:3734   .text.etharp_get_entry:0000000000000050 $d
     /tmp/cctR0i1S.s:3742   .rodata.etharp_input.str1.4:0000000000000000 $d
     /tmp/cctR0i1S.s:3746   .text.etharp_input:0000000000000000 $t
     /tmp/cctR0i1S.s:3754   .text.etharp_input:0000000000000000 etharp_input
     /tmp/cctR0i1S.s:4032   .text.etharp_input:000000000000011c $d
     /tmp/cctR0i1S.s:4039   .rodata.etharp_query.str1.4:0000000000000000 $d
     /tmp/cctR0i1S.s:4046   .text.etharp_query:0000000000000000 $t
     /tmp/cctR0i1S.s:4054   .text.etharp_query:0000000000000000 etharp_query
     /tmp/cctR0i1S.s:4476   .text.etharp_query:0000000000000150 $d
     /tmp/cctR0i1S.s:4486   .rodata.etharp_output.str1.4:0000000000000000 $d
     /tmp/cctR0i1S.s:4490   .text.etharp_output:0000000000000000 $t
     /tmp/cctR0i1S.s:4498   .text.etharp_output:0000000000000000 etharp_output
     /tmp/cctR0i1S.s:4937   .text.etharp_output:00000000000001b8 $d
     /tmp/cctR0i1S.s:4948   .text.etharp_request:0000000000000000 $t
     /tmp/cctR0i1S.s:4956   .text.etharp_request:0000000000000000 etharp_request
     /tmp/cctR0i1S.s:5207   .text.etharp_request:00000000000000b0 $d
     /tmp/cctR0i1S.s:5221   .bss.arp_table:0000000000000000 $d
     /tmp/cctR0i1S.s:5225   .bss.arp_table:0000000000000000 arp_table
     /tmp/cctR0i1S.s:5231   .bss.etharp_cached_entry:0000000000000000 etharp_cached_entry
     /tmp/cctR0i1S.s:5232   .bss.etharp_cached_entry:0000000000000000 $d

UNDEFINED SYMBOLS
pbuf_alloc
printf
ethernet_output
pbuf_free
ethzero
ethbroadcast
ip4_addr_isbroadcast_u32
ARM GAS  /tmp/cctR0i1S.s 			page 165


pbuf_clone
pbuf_ref
