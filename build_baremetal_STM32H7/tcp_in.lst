ARM GAS  /tmp/ccFjUByx.s 			page 1


   1              		.cpu cortex-m7
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"tcp_in.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.tcp_parseopt.str1.4,"aMS",%progbits,1
  18              		.align	2
  19              	.LC0:
  20 0000 7463705F 		.ascii	"tcp_parseopt: invalid pcb\000"
  20      70617273 
  20      656F7074 
  20      3A20696E 
  20      76616C69 
  21              		.section	.text.tcp_parseopt,"ax",%progbits
  22              		.align	1
  23              		.p2align 2,,3
  24              		.arch armv7e-m
  25              		.syntax unified
  26              		.thumb
  27              		.thumb_func
  28              		.fpu fpv4-sp-d16
  30              	tcp_parseopt:
  31              	.LVL0:
  32              	.LFB113:
  33              		.file 1 "lwIP/src/core/tcp_in.c"
   1:lwIP/src/core/tcp_in.c **** /**
   2:lwIP/src/core/tcp_in.c ****  * @file
   3:lwIP/src/core/tcp_in.c ****  * Transmission Control Protocol, incoming traffic
   4:lwIP/src/core/tcp_in.c ****  *
   5:lwIP/src/core/tcp_in.c ****  * The input processing functions of the TCP layer.
   6:lwIP/src/core/tcp_in.c ****  *
   7:lwIP/src/core/tcp_in.c ****  * These functions are generally called in the order (ip_input() ->)
   8:lwIP/src/core/tcp_in.c ****  * tcp_input() -> * tcp_process() -> tcp_receive() (-> application).
   9:lwIP/src/core/tcp_in.c ****  *
  10:lwIP/src/core/tcp_in.c ****  */
  11:lwIP/src/core/tcp_in.c **** 
  12:lwIP/src/core/tcp_in.c **** /*
  13:lwIP/src/core/tcp_in.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  14:lwIP/src/core/tcp_in.c ****  * All rights reserved.
  15:lwIP/src/core/tcp_in.c ****  *
  16:lwIP/src/core/tcp_in.c ****  * Redistribution and use in source and binary forms, with or without modification,
  17:lwIP/src/core/tcp_in.c ****  * are permitted provided that the following conditions are met:
  18:lwIP/src/core/tcp_in.c ****  *
  19:lwIP/src/core/tcp_in.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  20:lwIP/src/core/tcp_in.c ****  *    this list of conditions and the following disclaimer.
  21:lwIP/src/core/tcp_in.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
ARM GAS  /tmp/ccFjUByx.s 			page 2


  22:lwIP/src/core/tcp_in.c ****  *    this list of conditions and the following disclaimer in the documentation
  23:lwIP/src/core/tcp_in.c ****  *    and/or other materials provided with the distribution.
  24:lwIP/src/core/tcp_in.c ****  * 3. The name of the author may not be used to endorse or promote products
  25:lwIP/src/core/tcp_in.c ****  *    derived from this software without specific prior written permission.
  26:lwIP/src/core/tcp_in.c ****  *
  27:lwIP/src/core/tcp_in.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  28:lwIP/src/core/tcp_in.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  29:lwIP/src/core/tcp_in.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  30:lwIP/src/core/tcp_in.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  31:lwIP/src/core/tcp_in.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  32:lwIP/src/core/tcp_in.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  33:lwIP/src/core/tcp_in.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  34:lwIP/src/core/tcp_in.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  35:lwIP/src/core/tcp_in.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  36:lwIP/src/core/tcp_in.c ****  * OF SUCH DAMAGE.
  37:lwIP/src/core/tcp_in.c ****  *
  38:lwIP/src/core/tcp_in.c ****  * This file is part of the lwIP TCP/IP stack.
  39:lwIP/src/core/tcp_in.c ****  *
  40:lwIP/src/core/tcp_in.c ****  * Author: Adam Dunkels <adam@sics.se>
  41:lwIP/src/core/tcp_in.c ****  *
  42:lwIP/src/core/tcp_in.c ****  */
  43:lwIP/src/core/tcp_in.c **** 
  44:lwIP/src/core/tcp_in.c **** #include "lwip/opt.h"
  45:lwIP/src/core/tcp_in.c **** 
  46:lwIP/src/core/tcp_in.c **** #if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
  47:lwIP/src/core/tcp_in.c **** 
  48:lwIP/src/core/tcp_in.c **** #include "lwip/priv/tcp_priv.h"
  49:lwIP/src/core/tcp_in.c **** #include "lwip/def.h"
  50:lwIP/src/core/tcp_in.c **** #include "lwip/ip_addr.h"
  51:lwIP/src/core/tcp_in.c **** #include "lwip/netif.h"
  52:lwIP/src/core/tcp_in.c **** #include "lwip/mem.h"
  53:lwIP/src/core/tcp_in.c **** #include "lwip/memp.h"
  54:lwIP/src/core/tcp_in.c **** #include "lwip/inet_chksum.h"
  55:lwIP/src/core/tcp_in.c **** #include "lwip/stats.h"
  56:lwIP/src/core/tcp_in.c **** #include "lwip/ip6.h"
  57:lwIP/src/core/tcp_in.c **** #include "lwip/ip6_addr.h"
  58:lwIP/src/core/tcp_in.c **** #if LWIP_ND6_TCP_REACHABILITY_HINTS
  59:lwIP/src/core/tcp_in.c **** #include "lwip/nd6.h"
  60:lwIP/src/core/tcp_in.c **** #endif /* LWIP_ND6_TCP_REACHABILITY_HINTS */
  61:lwIP/src/core/tcp_in.c **** 
  62:lwIP/src/core/tcp_in.c **** #include <string.h>
  63:lwIP/src/core/tcp_in.c **** 
  64:lwIP/src/core/tcp_in.c **** #ifdef LWIP_HOOK_FILENAME
  65:lwIP/src/core/tcp_in.c **** #include LWIP_HOOK_FILENAME
  66:lwIP/src/core/tcp_in.c **** #endif
  67:lwIP/src/core/tcp_in.c **** 
  68:lwIP/src/core/tcp_in.c **** /** Initial CWND calculation as defined RFC 2581 */
  69:lwIP/src/core/tcp_in.c **** #define LWIP_TCP_CALC_INITIAL_CWND(mss) ((tcpwnd_size_t)LWIP_MIN((4U * (mss)), LWIP_MAX((2U * (mss)
  70:lwIP/src/core/tcp_in.c **** 
  71:lwIP/src/core/tcp_in.c **** /* These variables are global to all functions involved in the input
  72:lwIP/src/core/tcp_in.c ****    processing of TCP segments. They are set by the tcp_input()
  73:lwIP/src/core/tcp_in.c ****    function. */
  74:lwIP/src/core/tcp_in.c **** static struct tcp_seg inseg;
  75:lwIP/src/core/tcp_in.c **** static struct tcp_hdr *tcphdr;
  76:lwIP/src/core/tcp_in.c **** static u16_t tcphdr_optlen;
  77:lwIP/src/core/tcp_in.c **** static u16_t tcphdr_opt1len;
  78:lwIP/src/core/tcp_in.c **** static u8_t *tcphdr_opt2;
ARM GAS  /tmp/ccFjUByx.s 			page 3


  79:lwIP/src/core/tcp_in.c **** static u16_t tcp_optidx;
  80:lwIP/src/core/tcp_in.c **** static u32_t seqno, ackno;
  81:lwIP/src/core/tcp_in.c **** static tcpwnd_size_t recv_acked;
  82:lwIP/src/core/tcp_in.c **** static u16_t tcplen;
  83:lwIP/src/core/tcp_in.c **** static u8_t flags;
  84:lwIP/src/core/tcp_in.c **** 
  85:lwIP/src/core/tcp_in.c **** static u8_t recv_flags;
  86:lwIP/src/core/tcp_in.c **** static struct pbuf *recv_data;
  87:lwIP/src/core/tcp_in.c **** 
  88:lwIP/src/core/tcp_in.c **** struct tcp_pcb *tcp_input_pcb;
  89:lwIP/src/core/tcp_in.c **** 
  90:lwIP/src/core/tcp_in.c **** /* Forward declarations. */
  91:lwIP/src/core/tcp_in.c **** static err_t tcp_process(struct tcp_pcb *pcb);
  92:lwIP/src/core/tcp_in.c **** static void tcp_receive(struct tcp_pcb *pcb);
  93:lwIP/src/core/tcp_in.c **** static void tcp_parseopt(struct tcp_pcb *pcb);
  94:lwIP/src/core/tcp_in.c **** 
  95:lwIP/src/core/tcp_in.c **** static void tcp_listen_input(struct tcp_pcb_listen *pcb);
  96:lwIP/src/core/tcp_in.c **** static void tcp_timewait_input(struct tcp_pcb *pcb);
  97:lwIP/src/core/tcp_in.c **** 
  98:lwIP/src/core/tcp_in.c **** static int tcp_input_delayed_close(struct tcp_pcb *pcb);
  99:lwIP/src/core/tcp_in.c **** 
 100:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_SACK_OUT
 101:lwIP/src/core/tcp_in.c **** static void tcp_add_sack(struct tcp_pcb *pcb, u32_t left, u32_t right);
 102:lwIP/src/core/tcp_in.c **** static void tcp_remove_sacks_lt(struct tcp_pcb *pcb, u32_t seq);
 103:lwIP/src/core/tcp_in.c **** #if defined(TCP_OOSEQ_BYTES_LIMIT) || defined(TCP_OOSEQ_PBUFS_LIMIT)
 104:lwIP/src/core/tcp_in.c **** static void tcp_remove_sacks_gt(struct tcp_pcb *pcb, u32_t seq);
 105:lwIP/src/core/tcp_in.c **** #endif /* TCP_OOSEQ_BYTES_LIMIT || TCP_OOSEQ_PBUFS_LIMIT */
 106:lwIP/src/core/tcp_in.c **** #endif /* LWIP_TCP_SACK_OUT */
 107:lwIP/src/core/tcp_in.c **** 
 108:lwIP/src/core/tcp_in.c **** /**
 109:lwIP/src/core/tcp_in.c ****  * The initial input processing of TCP. It verifies the TCP header, demultiplexes
 110:lwIP/src/core/tcp_in.c ****  * the segment between the PCBs and passes it on to tcp_process(), which implements
 111:lwIP/src/core/tcp_in.c ****  * the TCP finite state machine. This function is called by the IP layer (in
 112:lwIP/src/core/tcp_in.c ****  * ip_input()).
 113:lwIP/src/core/tcp_in.c ****  *
 114:lwIP/src/core/tcp_in.c ****  * @param p received TCP segment to process (p->payload pointing to the TCP header)
 115:lwIP/src/core/tcp_in.c ****  * @param inp network interface on which this segment was received
 116:lwIP/src/core/tcp_in.c ****  */
 117:lwIP/src/core/tcp_in.c **** void
 118:lwIP/src/core/tcp_in.c **** tcp_input(struct pbuf *p, struct netif *inp)
 119:lwIP/src/core/tcp_in.c **** {
 120:lwIP/src/core/tcp_in.c ****   struct tcp_pcb *pcb, *prev;
 121:lwIP/src/core/tcp_in.c ****   struct tcp_pcb_listen *lpcb;
 122:lwIP/src/core/tcp_in.c **** #if SO_REUSE
 123:lwIP/src/core/tcp_in.c ****   struct tcp_pcb *lpcb_prev = NULL;
 124:lwIP/src/core/tcp_in.c ****   struct tcp_pcb_listen *lpcb_any = NULL;
 125:lwIP/src/core/tcp_in.c **** #endif /* SO_REUSE */
 126:lwIP/src/core/tcp_in.c ****   u8_t hdrlen_bytes;
 127:lwIP/src/core/tcp_in.c ****   err_t err;
 128:lwIP/src/core/tcp_in.c **** 
 129:lwIP/src/core/tcp_in.c ****   LWIP_UNUSED_ARG(inp);
 130:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT_CORE_LOCKED();
 131:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
 132:lwIP/src/core/tcp_in.c **** 
 133:lwIP/src/core/tcp_in.c ****   PERF_START;
 134:lwIP/src/core/tcp_in.c **** 
 135:lwIP/src/core/tcp_in.c ****   TCP_STATS_INC(tcp.recv);
ARM GAS  /tmp/ccFjUByx.s 			page 4


 136:lwIP/src/core/tcp_in.c ****   MIB2_STATS_INC(mib2.tcpinsegs);
 137:lwIP/src/core/tcp_in.c **** 
 138:lwIP/src/core/tcp_in.c ****   tcphdr = (struct tcp_hdr *)p->payload;
 139:lwIP/src/core/tcp_in.c **** 
 140:lwIP/src/core/tcp_in.c **** #if TCP_INPUT_DEBUG
 141:lwIP/src/core/tcp_in.c ****   tcp_debug_print(tcphdr);
 142:lwIP/src/core/tcp_in.c **** #endif
 143:lwIP/src/core/tcp_in.c **** 
 144:lwIP/src/core/tcp_in.c ****   /* Check that TCP header fits in payload */
 145:lwIP/src/core/tcp_in.c ****   if (p->len < TCP_HLEN) {
 146:lwIP/src/core/tcp_in.c ****     /* drop short packets */
 147:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_le
 148:lwIP/src/core/tcp_in.c ****     TCP_STATS_INC(tcp.lenerr);
 149:lwIP/src/core/tcp_in.c ****     goto dropped;
 150:lwIP/src/core/tcp_in.c ****   }
 151:lwIP/src/core/tcp_in.c **** 
 152:lwIP/src/core/tcp_in.c ****   /* Don't even process incoming broadcasts/multicasts. */
 153:lwIP/src/core/tcp_in.c ****   if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 154:lwIP/src/core/tcp_in.c ****       ip_addr_ismulticast(ip_current_dest_addr())) {
 155:lwIP/src/core/tcp_in.c ****     TCP_STATS_INC(tcp.proterr);
 156:lwIP/src/core/tcp_in.c ****     goto dropped;
 157:lwIP/src/core/tcp_in.c ****   }
 158:lwIP/src/core/tcp_in.c **** 
 159:lwIP/src/core/tcp_in.c **** #if CHECKSUM_CHECK_TCP
 160:lwIP/src/core/tcp_in.c ****   IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) {
 161:lwIP/src/core/tcp_in.c ****     /* Verify TCP checksum. */
 162:lwIP/src/core/tcp_in.c ****     u16_t chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
 163:lwIP/src/core/tcp_in.c ****                                     ip_current_src_addr(), ip_current_dest_addr());
 164:lwIP/src/core/tcp_in.c ****     if (chksum != 0) {
 165:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_
 166:lwIP/src/core/tcp_in.c ****                                     chksum));
 167:lwIP/src/core/tcp_in.c ****       tcp_debug_print(tcphdr);
 168:lwIP/src/core/tcp_in.c ****       TCP_STATS_INC(tcp.chkerr);
 169:lwIP/src/core/tcp_in.c ****       goto dropped;
 170:lwIP/src/core/tcp_in.c ****     }
 171:lwIP/src/core/tcp_in.c ****   }
 172:lwIP/src/core/tcp_in.c **** #endif /* CHECKSUM_CHECK_TCP */
 173:lwIP/src/core/tcp_in.c **** 
 174:lwIP/src/core/tcp_in.c ****   /* sanity-check header length */
 175:lwIP/src/core/tcp_in.c ****   hdrlen_bytes = TCPH_HDRLEN_BYTES(tcphdr);
 176:lwIP/src/core/tcp_in.c ****   if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 177:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: invalid header length (%"U16_F")\n", (u16_t)hdrlen_by
 178:lwIP/src/core/tcp_in.c ****     TCP_STATS_INC(tcp.lenerr);
 179:lwIP/src/core/tcp_in.c ****     goto dropped;
 180:lwIP/src/core/tcp_in.c ****   }
 181:lwIP/src/core/tcp_in.c **** 
 182:lwIP/src/core/tcp_in.c ****   /* Move the payload pointer in the pbuf so that it points to the
 183:lwIP/src/core/tcp_in.c ****      TCP data instead of the TCP header. */
 184:lwIP/src/core/tcp_in.c ****   tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
 185:lwIP/src/core/tcp_in.c ****   tcphdr_opt2 = NULL;
 186:lwIP/src/core/tcp_in.c ****   if (p->len >= hdrlen_bytes) {
 187:lwIP/src/core/tcp_in.c ****     /* all options are in the first pbuf */
 188:lwIP/src/core/tcp_in.c ****     tcphdr_opt1len = tcphdr_optlen;
 189:lwIP/src/core/tcp_in.c ****     pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
 190:lwIP/src/core/tcp_in.c ****   } else {
 191:lwIP/src/core/tcp_in.c ****     u16_t opt2len;
 192:lwIP/src/core/tcp_in.c ****     /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
ARM GAS  /tmp/ccFjUByx.s 			page 5


 193:lwIP/src/core/tcp_in.c ****     /* there must be a next pbuf, due to hdrlen_bytes sanity check above */
 194:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->next != NULL", p->next != NULL);
 195:lwIP/src/core/tcp_in.c **** 
 196:lwIP/src/core/tcp_in.c ****     /* advance over the TCP header (cannot fail) */
 197:lwIP/src/core/tcp_in.c ****     pbuf_remove_header(p, TCP_HLEN);
 198:lwIP/src/core/tcp_in.c **** 
 199:lwIP/src/core/tcp_in.c ****     /* determine how long the first and second parts of the options are */
 200:lwIP/src/core/tcp_in.c ****     tcphdr_opt1len = p->len;
 201:lwIP/src/core/tcp_in.c ****     opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 202:lwIP/src/core/tcp_in.c **** 
 203:lwIP/src/core/tcp_in.c ****     /* options continue in the next pbuf: set p to zero length and hide the
 204:lwIP/src/core/tcp_in.c ****         options in the next pbuf (adjusting p->tot_len) */
 205:lwIP/src/core/tcp_in.c ****     pbuf_remove_header(p, tcphdr_opt1len);
 206:lwIP/src/core/tcp_in.c **** 
 207:lwIP/src/core/tcp_in.c ****     /* check that the options fit in the second pbuf */
 208:lwIP/src/core/tcp_in.c ****     if (opt2len > p->next->len) {
 209:lwIP/src/core/tcp_in.c ****       /* drop short packets */
 210:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: options overflow second pbuf (%"U16_F" bytes)\n", p
 211:lwIP/src/core/tcp_in.c ****       TCP_STATS_INC(tcp.lenerr);
 212:lwIP/src/core/tcp_in.c ****       goto dropped;
 213:lwIP/src/core/tcp_in.c ****     }
 214:lwIP/src/core/tcp_in.c **** 
 215:lwIP/src/core/tcp_in.c ****     /* remember the pointer to the second part of the options */
 216:lwIP/src/core/tcp_in.c ****     tcphdr_opt2 = (u8_t *)p->next->payload;
 217:lwIP/src/core/tcp_in.c **** 
 218:lwIP/src/core/tcp_in.c ****     /* advance p->next to point after the options, and manually
 219:lwIP/src/core/tcp_in.c ****         adjust p->tot_len to keep it consistent with the changed p->next */
 220:lwIP/src/core/tcp_in.c ****     pbuf_remove_header(p->next, opt2len);
 221:lwIP/src/core/tcp_in.c ****     p->tot_len = (u16_t)(p->tot_len - opt2len);
 222:lwIP/src/core/tcp_in.c **** 
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->len == 0", p->len == 0);
 224:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 225:lwIP/src/core/tcp_in.c ****   }
 226:lwIP/src/core/tcp_in.c **** 
 227:lwIP/src/core/tcp_in.c ****   /* Convert fields in TCP header to host byte order. */
 228:lwIP/src/core/tcp_in.c ****   tcphdr->src = lwip_ntohs(tcphdr->src);
 229:lwIP/src/core/tcp_in.c ****   tcphdr->dest = lwip_ntohs(tcphdr->dest);
 230:lwIP/src/core/tcp_in.c ****   seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 231:lwIP/src/core/tcp_in.c ****   ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 232:lwIP/src/core/tcp_in.c ****   tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 233:lwIP/src/core/tcp_in.c **** 
 234:lwIP/src/core/tcp_in.c ****   flags = TCPH_FLAGS(tcphdr);
 235:lwIP/src/core/tcp_in.c ****   tcplen = p->tot_len;
 236:lwIP/src/core/tcp_in.c ****   if (flags & (TCP_FIN | TCP_SYN)) {
 237:lwIP/src/core/tcp_in.c ****     tcplen++;
 238:lwIP/src/core/tcp_in.c ****     if (tcplen < p->tot_len) {
 239:lwIP/src/core/tcp_in.c ****       /* u16_t overflow, cannot handle this */
 240:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: length u16_t overflow, cannot handle this\n"));
 241:lwIP/src/core/tcp_in.c ****       TCP_STATS_INC(tcp.lenerr);
 242:lwIP/src/core/tcp_in.c ****       goto dropped;
 243:lwIP/src/core/tcp_in.c ****     }
 244:lwIP/src/core/tcp_in.c ****   }
 245:lwIP/src/core/tcp_in.c **** 
 246:lwIP/src/core/tcp_in.c ****   /* Demultiplex an incoming segment. First, we check if it is destined
 247:lwIP/src/core/tcp_in.c ****      for an active connection. */
 248:lwIP/src/core/tcp_in.c ****   prev = NULL;
 249:lwIP/src/core/tcp_in.c **** 
ARM GAS  /tmp/ccFjUByx.s 			page 6


 250:lwIP/src/core/tcp_in.c ****   for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 251:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 252:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 253:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 254:lwIP/src/core/tcp_in.c **** 
 255:lwIP/src/core/tcp_in.c ****     /* check if PCB is bound to specific netif */
 256:lwIP/src/core/tcp_in.c ****     if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 257:lwIP/src/core/tcp_in.c ****         (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 258:lwIP/src/core/tcp_in.c ****       prev = pcb;
 259:lwIP/src/core/tcp_in.c ****       continue;
 260:lwIP/src/core/tcp_in.c ****     }
 261:lwIP/src/core/tcp_in.c **** 
 262:lwIP/src/core/tcp_in.c ****     if (pcb->remote_port == tcphdr->src &&
 263:lwIP/src/core/tcp_in.c ****         pcb->local_port == tcphdr->dest &&
 264:lwIP/src/core/tcp_in.c ****         ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 265:lwIP/src/core/tcp_in.c ****         ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 266:lwIP/src/core/tcp_in.c ****       /* Move this PCB to the front of the list so that subsequent
 267:lwIP/src/core/tcp_in.c ****          lookups will be faster (we exploit locality in TCP segment
 268:lwIP/src/core/tcp_in.c ****          arrivals). */
 269:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 270:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 271:lwIP/src/core/tcp_in.c ****         prev->next = pcb->next;
 272:lwIP/src/core/tcp_in.c ****         pcb->next = tcp_active_pcbs;
 273:lwIP/src/core/tcp_in.c ****         tcp_active_pcbs = pcb;
 274:lwIP/src/core/tcp_in.c ****       } else {
 275:lwIP/src/core/tcp_in.c ****         TCP_STATS_INC(tcp.cachehit);
 276:lwIP/src/core/tcp_in.c ****       }
 277:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 278:lwIP/src/core/tcp_in.c ****       break;
 279:lwIP/src/core/tcp_in.c ****     }
 280:lwIP/src/core/tcp_in.c ****     prev = pcb;
 281:lwIP/src/core/tcp_in.c ****   }
 282:lwIP/src/core/tcp_in.c **** 
 283:lwIP/src/core/tcp_in.c ****   if (pcb == NULL) {
 284:lwIP/src/core/tcp_in.c ****     /* If it did not go to an active connection, we check the connections
 285:lwIP/src/core/tcp_in.c ****        in the TIME-WAIT state. */
 286:lwIP/src/core/tcp_in.c ****     for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 287:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 288:lwIP/src/core/tcp_in.c **** 
 289:lwIP/src/core/tcp_in.c ****       /* check if PCB is bound to specific netif */
 290:lwIP/src/core/tcp_in.c ****       if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 291:lwIP/src/core/tcp_in.c ****           (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 292:lwIP/src/core/tcp_in.c ****         continue;
 293:lwIP/src/core/tcp_in.c ****       }
 294:lwIP/src/core/tcp_in.c **** 
 295:lwIP/src/core/tcp_in.c ****       if (pcb->remote_port == tcphdr->src &&
 296:lwIP/src/core/tcp_in.c ****           pcb->local_port == tcphdr->dest &&
 297:lwIP/src/core/tcp_in.c ****           ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 298:lwIP/src/core/tcp_in.c ****           ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 299:lwIP/src/core/tcp_in.c ****         /* We don't really care enough to move this PCB to the front
 300:lwIP/src/core/tcp_in.c ****            of the list since we are not very likely to receive that
 301:lwIP/src/core/tcp_in.c ****            many segments for connections in TIME-WAIT. */
 302:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
 303:lwIP/src/core/tcp_in.c **** #ifdef LWIP_HOOK_TCP_INPACKET_PCB
 304:lwIP/src/core/tcp_in.c ****         if (LWIP_HOOK_TCP_INPACKET_PCB(pcb, tcphdr, tcphdr_optlen, tcphdr_opt1len,
 305:lwIP/src/core/tcp_in.c ****                                        tcphdr_opt2, p) == ERR_OK)
 306:lwIP/src/core/tcp_in.c **** #endif
ARM GAS  /tmp/ccFjUByx.s 			page 7


 307:lwIP/src/core/tcp_in.c ****         {
 308:lwIP/src/core/tcp_in.c ****           tcp_timewait_input(pcb);
 309:lwIP/src/core/tcp_in.c ****         }
 310:lwIP/src/core/tcp_in.c ****         pbuf_free(p);
 311:lwIP/src/core/tcp_in.c ****         return;
 312:lwIP/src/core/tcp_in.c ****       }
 313:lwIP/src/core/tcp_in.c ****     }
 314:lwIP/src/core/tcp_in.c **** 
 315:lwIP/src/core/tcp_in.c ****     /* Finally, if we still did not get a match, we check all PCBs that
 316:lwIP/src/core/tcp_in.c ****        are LISTENing for incoming connections. */
 317:lwIP/src/core/tcp_in.c ****     prev = NULL;
 318:lwIP/src/core/tcp_in.c ****     for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 319:lwIP/src/core/tcp_in.c ****       /* check if PCB is bound to specific netif */
 320:lwIP/src/core/tcp_in.c ****       if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 321:lwIP/src/core/tcp_in.c ****           (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 322:lwIP/src/core/tcp_in.c ****         prev = (struct tcp_pcb *)lpcb;
 323:lwIP/src/core/tcp_in.c ****         continue;
 324:lwIP/src/core/tcp_in.c ****       }
 325:lwIP/src/core/tcp_in.c **** 
 326:lwIP/src/core/tcp_in.c ****       if (lpcb->local_port == tcphdr->dest) {
 327:lwIP/src/core/tcp_in.c ****         if (IP_IS_ANY_TYPE_VAL(lpcb->local_ip)) {
 328:lwIP/src/core/tcp_in.c ****           /* found an ANY TYPE (IPv4/IPv6) match */
 329:lwIP/src/core/tcp_in.c **** #if SO_REUSE
 330:lwIP/src/core/tcp_in.c ****           lpcb_any = lpcb;
 331:lwIP/src/core/tcp_in.c ****           lpcb_prev = prev;
 332:lwIP/src/core/tcp_in.c **** #else /* SO_REUSE */
 333:lwIP/src/core/tcp_in.c ****           break;
 334:lwIP/src/core/tcp_in.c **** #endif /* SO_REUSE */
 335:lwIP/src/core/tcp_in.c ****         } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
 336:lwIP/src/core/tcp_in.c ****           if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 337:lwIP/src/core/tcp_in.c ****             /* found an exact match */
 338:lwIP/src/core/tcp_in.c ****             break;
 339:lwIP/src/core/tcp_in.c ****           } else if (ip_addr_isany(&lpcb->local_ip)) {
 340:lwIP/src/core/tcp_in.c ****             /* found an ANY-match */
 341:lwIP/src/core/tcp_in.c **** #if SO_REUSE
 342:lwIP/src/core/tcp_in.c ****             lpcb_any = lpcb;
 343:lwIP/src/core/tcp_in.c ****             lpcb_prev = prev;
 344:lwIP/src/core/tcp_in.c **** #else /* SO_REUSE */
 345:lwIP/src/core/tcp_in.c ****             break;
 346:lwIP/src/core/tcp_in.c **** #endif /* SO_REUSE */
 347:lwIP/src/core/tcp_in.c ****           }
 348:lwIP/src/core/tcp_in.c ****         }
 349:lwIP/src/core/tcp_in.c ****       }
 350:lwIP/src/core/tcp_in.c ****       prev = (struct tcp_pcb *)lpcb;
 351:lwIP/src/core/tcp_in.c ****     }
 352:lwIP/src/core/tcp_in.c **** #if SO_REUSE
 353:lwIP/src/core/tcp_in.c ****     /* first try specific local IP */
 354:lwIP/src/core/tcp_in.c ****     if (lpcb == NULL) {
 355:lwIP/src/core/tcp_in.c ****       /* only pass to ANY if no specific local IP has been found */
 356:lwIP/src/core/tcp_in.c ****       lpcb = lpcb_any;
 357:lwIP/src/core/tcp_in.c ****       prev = lpcb_prev;
 358:lwIP/src/core/tcp_in.c ****     }
 359:lwIP/src/core/tcp_in.c **** #endif /* SO_REUSE */
 360:lwIP/src/core/tcp_in.c ****     if (lpcb != NULL) {
 361:lwIP/src/core/tcp_in.c ****       /* Move this PCB to the front of the list so that subsequent
 362:lwIP/src/core/tcp_in.c ****          lookups will be faster (we exploit locality in TCP segment
 363:lwIP/src/core/tcp_in.c ****          arrivals). */
ARM GAS  /tmp/ccFjUByx.s 			page 8


 364:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 365:lwIP/src/core/tcp_in.c ****         ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 366:lwIP/src/core/tcp_in.c ****         /* our successor is the remainder of the listening list */
 367:lwIP/src/core/tcp_in.c ****         lpcb->next = tcp_listen_pcbs.listen_pcbs;
 368:lwIP/src/core/tcp_in.c ****         /* put this listening pcb at the head of the listening list */
 369:lwIP/src/core/tcp_in.c ****         tcp_listen_pcbs.listen_pcbs = lpcb;
 370:lwIP/src/core/tcp_in.c ****       } else {
 371:lwIP/src/core/tcp_in.c ****         TCP_STATS_INC(tcp.cachehit);
 372:lwIP/src/core/tcp_in.c ****       }
 373:lwIP/src/core/tcp_in.c **** 
 374:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
 375:lwIP/src/core/tcp_in.c **** #ifdef LWIP_HOOK_TCP_INPACKET_PCB
 376:lwIP/src/core/tcp_in.c ****       if (LWIP_HOOK_TCP_INPACKET_PCB((struct tcp_pcb *)lpcb, tcphdr, tcphdr_optlen,
 377:lwIP/src/core/tcp_in.c ****                                      tcphdr_opt1len, tcphdr_opt2, p) == ERR_OK)
 378:lwIP/src/core/tcp_in.c **** #endif
 379:lwIP/src/core/tcp_in.c ****       {
 380:lwIP/src/core/tcp_in.c ****         tcp_listen_input(lpcb);
 381:lwIP/src/core/tcp_in.c ****       }
 382:lwIP/src/core/tcp_in.c ****       pbuf_free(p);
 383:lwIP/src/core/tcp_in.c ****       return;
 384:lwIP/src/core/tcp_in.c ****     }
 385:lwIP/src/core/tcp_in.c ****   }
 386:lwIP/src/core/tcp_in.c **** 
 387:lwIP/src/core/tcp_in.c **** #if TCP_INPUT_DEBUG
 388:lwIP/src/core/tcp_in.c ****   LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
 389:lwIP/src/core/tcp_in.c ****   tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
 390:lwIP/src/core/tcp_in.c ****   LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
 391:lwIP/src/core/tcp_in.c **** #endif /* TCP_INPUT_DEBUG */
 392:lwIP/src/core/tcp_in.c **** 
 393:lwIP/src/core/tcp_in.c **** 
 394:lwIP/src/core/tcp_in.c **** #ifdef LWIP_HOOK_TCP_INPACKET_PCB
 395:lwIP/src/core/tcp_in.c ****   if ((pcb != NULL) && LWIP_HOOK_TCP_INPACKET_PCB(pcb, tcphdr, tcphdr_optlen,
 396:lwIP/src/core/tcp_in.c ****       tcphdr_opt1len, tcphdr_opt2, p) != ERR_OK) {
 397:lwIP/src/core/tcp_in.c ****     pbuf_free(p);
 398:lwIP/src/core/tcp_in.c ****     return;
 399:lwIP/src/core/tcp_in.c ****   }
 400:lwIP/src/core/tcp_in.c **** #endif
 401:lwIP/src/core/tcp_in.c ****   if (pcb != NULL) {
 402:lwIP/src/core/tcp_in.c ****     /* The incoming segment belongs to a connection. */
 403:lwIP/src/core/tcp_in.c **** #if TCP_INPUT_DEBUG
 404:lwIP/src/core/tcp_in.c ****     tcp_debug_print_state(pcb->state);
 405:lwIP/src/core/tcp_in.c **** #endif /* TCP_INPUT_DEBUG */
 406:lwIP/src/core/tcp_in.c **** 
 407:lwIP/src/core/tcp_in.c ****     /* Set up a tcp_seg structure. */
 408:lwIP/src/core/tcp_in.c ****     inseg.next = NULL;
 409:lwIP/src/core/tcp_in.c ****     inseg.len = p->tot_len;
 410:lwIP/src/core/tcp_in.c ****     inseg.p = p;
 411:lwIP/src/core/tcp_in.c ****     inseg.tcphdr = tcphdr;
 412:lwIP/src/core/tcp_in.c **** 
 413:lwIP/src/core/tcp_in.c ****     recv_data = NULL;
 414:lwIP/src/core/tcp_in.c ****     recv_flags = 0;
 415:lwIP/src/core/tcp_in.c ****     recv_acked = 0;
 416:lwIP/src/core/tcp_in.c **** 
 417:lwIP/src/core/tcp_in.c ****     if (flags & TCP_PSH) {
 418:lwIP/src/core/tcp_in.c ****       p->flags |= PBUF_FLAG_PUSH;
 419:lwIP/src/core/tcp_in.c ****     }
 420:lwIP/src/core/tcp_in.c **** 
ARM GAS  /tmp/ccFjUByx.s 			page 9


 421:lwIP/src/core/tcp_in.c ****     /* If there is data which was previously "refused" by upper layer */
 422:lwIP/src/core/tcp_in.c ****     if (pcb->refused_data != NULL) {
 423:lwIP/src/core/tcp_in.c ****       if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 424:lwIP/src/core/tcp_in.c ****           ((pcb->refused_data != NULL) && (tcplen > 0))) {
 425:lwIP/src/core/tcp_in.c ****         /* pcb has been aborted or refused data is still refused and the new
 426:lwIP/src/core/tcp_in.c ****            segment contains data */
 427:lwIP/src/core/tcp_in.c ****         if (pcb->rcv_ann_wnd == 0) {
 428:lwIP/src/core/tcp_in.c ****           /* this is a zero-window probe, we respond to it with current RCV.NXT
 429:lwIP/src/core/tcp_in.c ****           and drop the data segment */
 430:lwIP/src/core/tcp_in.c ****           tcp_send_empty_ack(pcb);
 431:lwIP/src/core/tcp_in.c ****         }
 432:lwIP/src/core/tcp_in.c ****         TCP_STATS_INC(tcp.drop);
 433:lwIP/src/core/tcp_in.c ****         MIB2_STATS_INC(mib2.tcpinerrs);
 434:lwIP/src/core/tcp_in.c ****         goto aborted;
 435:lwIP/src/core/tcp_in.c ****       }
 436:lwIP/src/core/tcp_in.c ****     }
 437:lwIP/src/core/tcp_in.c ****     tcp_input_pcb = pcb;
 438:lwIP/src/core/tcp_in.c ****     err = tcp_process(pcb);
 439:lwIP/src/core/tcp_in.c ****     /* A return value of ERR_ABRT means that tcp_abort() was called
 440:lwIP/src/core/tcp_in.c ****        and that the pcb has been freed. If so, we don't do anything. */
 441:lwIP/src/core/tcp_in.c ****     if (err != ERR_ABRT) {
 442:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 443:lwIP/src/core/tcp_in.c ****         /* TF_RESET means that the connection was reset by the other
 444:lwIP/src/core/tcp_in.c ****            end. We then call the error callback to inform the
 445:lwIP/src/core/tcp_in.c ****            application that the connection is dead before we
 446:lwIP/src/core/tcp_in.c ****            deallocate the PCB. */
 447:lwIP/src/core/tcp_in.c ****         TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
 448:lwIP/src/core/tcp_in.c ****         tcp_pcb_remove(&tcp_active_pcbs, pcb);
 449:lwIP/src/core/tcp_in.c ****         tcp_free(pcb);
 450:lwIP/src/core/tcp_in.c ****       } else {
 451:lwIP/src/core/tcp_in.c ****         err = ERR_OK;
 452:lwIP/src/core/tcp_in.c ****         /* If the application has registered a "sent" function to be
 453:lwIP/src/core/tcp_in.c ****            called when new send buffer space is available, we call it
 454:lwIP/src/core/tcp_in.c ****            now. */
 455:lwIP/src/core/tcp_in.c ****         if (recv_acked > 0) {
 456:lwIP/src/core/tcp_in.c ****           u16_t acked16;
 457:lwIP/src/core/tcp_in.c **** #if LWIP_WND_SCALE
 458:lwIP/src/core/tcp_in.c ****           /* recv_acked is u32_t but the sent callback only takes a u16_t,
 459:lwIP/src/core/tcp_in.c ****              so we might have to call it multiple times. */
 460:lwIP/src/core/tcp_in.c ****           u32_t acked = recv_acked;
 461:lwIP/src/core/tcp_in.c ****           while (acked > 0) {
 462:lwIP/src/core/tcp_in.c ****             acked16 = (u16_t)LWIP_MIN(acked, 0xffffu);
 463:lwIP/src/core/tcp_in.c ****             acked -= acked16;
 464:lwIP/src/core/tcp_in.c **** #else
 465:lwIP/src/core/tcp_in.c ****           {
 466:lwIP/src/core/tcp_in.c ****             acked16 = recv_acked;
 467:lwIP/src/core/tcp_in.c **** #endif
 468:lwIP/src/core/tcp_in.c ****             TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 469:lwIP/src/core/tcp_in.c ****             if (err == ERR_ABRT) {
 470:lwIP/src/core/tcp_in.c ****               goto aborted;
 471:lwIP/src/core/tcp_in.c ****             }
 472:lwIP/src/core/tcp_in.c ****           }
 473:lwIP/src/core/tcp_in.c ****           recv_acked = 0;
 474:lwIP/src/core/tcp_in.c ****         }
 475:lwIP/src/core/tcp_in.c ****         if (tcp_input_delayed_close(pcb)) {
 476:lwIP/src/core/tcp_in.c ****           goto aborted;
 477:lwIP/src/core/tcp_in.c ****         }
ARM GAS  /tmp/ccFjUByx.s 			page 10


 478:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
 479:lwIP/src/core/tcp_in.c ****         while (recv_data != NULL) {
 480:lwIP/src/core/tcp_in.c ****           struct pbuf *rest = NULL;
 481:lwIP/src/core/tcp_in.c ****           pbuf_split_64k(recv_data, &rest);
 482:lwIP/src/core/tcp_in.c **** #else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
 483:lwIP/src/core/tcp_in.c ****         if (recv_data != NULL) {
 484:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
 485:lwIP/src/core/tcp_in.c **** 
 486:lwIP/src/core/tcp_in.c ****           LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 487:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_RXCLOSED) {
 488:lwIP/src/core/tcp_in.c ****             /* received data although already closed -> abort (send RST) to
 489:lwIP/src/core/tcp_in.c ****                notify the remote host that not all data has been processed */
 490:lwIP/src/core/tcp_in.c ****             pbuf_free(recv_data);
 491:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
 492:lwIP/src/core/tcp_in.c ****             if (rest != NULL) {
 493:lwIP/src/core/tcp_in.c ****               pbuf_free(rest);
 494:lwIP/src/core/tcp_in.c ****             }
 495:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
 496:lwIP/src/core/tcp_in.c ****             tcp_abort(pcb);
 497:lwIP/src/core/tcp_in.c ****             goto aborted;
 498:lwIP/src/core/tcp_in.c ****           }
 499:lwIP/src/core/tcp_in.c **** 
 500:lwIP/src/core/tcp_in.c ****           /* Notify application that data has been received. */
 501:lwIP/src/core/tcp_in.c ****           TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 502:lwIP/src/core/tcp_in.c ****           if (err == ERR_ABRT) {
 503:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
 504:lwIP/src/core/tcp_in.c ****             if (rest != NULL) {
 505:lwIP/src/core/tcp_in.c ****               pbuf_free(rest);
 506:lwIP/src/core/tcp_in.c ****             }
 507:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
 508:lwIP/src/core/tcp_in.c ****             goto aborted;
 509:lwIP/src/core/tcp_in.c ****           }
 510:lwIP/src/core/tcp_in.c **** 
 511:lwIP/src/core/tcp_in.c ****           /* If the upper layer can't receive this data, store it */
 512:lwIP/src/core/tcp_in.c ****           if (err != ERR_OK) {
 513:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
 514:lwIP/src/core/tcp_in.c ****             if (rest != NULL) {
 515:lwIP/src/core/tcp_in.c ****               pbuf_cat(recv_data, rest);
 516:lwIP/src/core/tcp_in.c ****             }
 517:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
 518:lwIP/src/core/tcp_in.c ****             pcb->refused_data = recv_data;
 519:lwIP/src/core/tcp_in.c ****             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"
 520:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
 521:lwIP/src/core/tcp_in.c ****             break;
 522:lwIP/src/core/tcp_in.c ****           } else {
 523:lwIP/src/core/tcp_in.c ****             /* Upper layer received the data, go on with the rest if > 64K */
 524:lwIP/src/core/tcp_in.c ****             recv_data = rest;
 525:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
 526:lwIP/src/core/tcp_in.c ****           }
 527:lwIP/src/core/tcp_in.c ****         }
 528:lwIP/src/core/tcp_in.c **** 
 529:lwIP/src/core/tcp_in.c ****         /* If a FIN segment was received, we call the callback
 530:lwIP/src/core/tcp_in.c ****            function with a NULL buffer to indicate EOF. */
 531:lwIP/src/core/tcp_in.c ****         if (recv_flags & TF_GOT_FIN) {
 532:lwIP/src/core/tcp_in.c ****           if (pcb->refused_data != NULL) {
 533:lwIP/src/core/tcp_in.c ****             /* Delay this if we have refused data. */
 534:lwIP/src/core/tcp_in.c ****             pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
ARM GAS  /tmp/ccFjUByx.s 			page 11


 535:lwIP/src/core/tcp_in.c ****           } else {
 536:lwIP/src/core/tcp_in.c ****             /* correct rcv_wnd as the application won't call tcp_recved()
 537:lwIP/src/core/tcp_in.c ****                for the FIN's seqno */
 538:lwIP/src/core/tcp_in.c ****             if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 539:lwIP/src/core/tcp_in.c ****               pcb->rcv_wnd++;
 540:lwIP/src/core/tcp_in.c ****             }
 541:lwIP/src/core/tcp_in.c ****             TCP_EVENT_CLOSED(pcb, err);
 542:lwIP/src/core/tcp_in.c ****             if (err == ERR_ABRT) {
 543:lwIP/src/core/tcp_in.c ****               goto aborted;
 544:lwIP/src/core/tcp_in.c ****             }
 545:lwIP/src/core/tcp_in.c ****           }
 546:lwIP/src/core/tcp_in.c ****         }
 547:lwIP/src/core/tcp_in.c **** 
 548:lwIP/src/core/tcp_in.c ****         tcp_input_pcb = NULL;
 549:lwIP/src/core/tcp_in.c ****         if (tcp_input_delayed_close(pcb)) {
 550:lwIP/src/core/tcp_in.c ****           goto aborted;
 551:lwIP/src/core/tcp_in.c ****         }
 552:lwIP/src/core/tcp_in.c ****         /* Try to send something out. */
 553:lwIP/src/core/tcp_in.c ****         tcp_output(pcb);
 554:lwIP/src/core/tcp_in.c **** #if TCP_INPUT_DEBUG
 555:lwIP/src/core/tcp_in.c **** #if TCP_DEBUG
 556:lwIP/src/core/tcp_in.c ****         tcp_debug_print_state(pcb->state);
 557:lwIP/src/core/tcp_in.c **** #endif /* TCP_DEBUG */
 558:lwIP/src/core/tcp_in.c **** #endif /* TCP_INPUT_DEBUG */
 559:lwIP/src/core/tcp_in.c ****       }
 560:lwIP/src/core/tcp_in.c ****     }
 561:lwIP/src/core/tcp_in.c ****     /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
 562:lwIP/src/core/tcp_in.c ****        Below this line, 'pcb' may not be dereferenced! */
 563:lwIP/src/core/tcp_in.c **** aborted:
 564:lwIP/src/core/tcp_in.c ****     tcp_input_pcb = NULL;
 565:lwIP/src/core/tcp_in.c ****     recv_data = NULL;
 566:lwIP/src/core/tcp_in.c **** 
 567:lwIP/src/core/tcp_in.c ****     /* give up our reference to inseg.p */
 568:lwIP/src/core/tcp_in.c ****     if (inseg.p != NULL) {
 569:lwIP/src/core/tcp_in.c ****       pbuf_free(inseg.p);
 570:lwIP/src/core/tcp_in.c ****       inseg.p = NULL;
 571:lwIP/src/core/tcp_in.c ****     }
 572:lwIP/src/core/tcp_in.c ****   } else {
 573:lwIP/src/core/tcp_in.c ****     /* If no matching PCB was found, send a TCP RST (reset) to the
 574:lwIP/src/core/tcp_in.c ****        sender. */
 575:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
 576:lwIP/src/core/tcp_in.c ****     if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 577:lwIP/src/core/tcp_in.c ****       TCP_STATS_INC(tcp.proterr);
 578:lwIP/src/core/tcp_in.c ****       TCP_STATS_INC(tcp.drop);
 579:lwIP/src/core/tcp_in.c ****       tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 580:lwIP/src/core/tcp_in.c ****               ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 581:lwIP/src/core/tcp_in.c ****     }
 582:lwIP/src/core/tcp_in.c ****     pbuf_free(p);
 583:lwIP/src/core/tcp_in.c ****   }
 584:lwIP/src/core/tcp_in.c **** 
 585:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
 586:lwIP/src/core/tcp_in.c ****   PERF_STOP("tcp_input");
 587:lwIP/src/core/tcp_in.c ****   return;
 588:lwIP/src/core/tcp_in.c **** dropped:
 589:lwIP/src/core/tcp_in.c ****   TCP_STATS_INC(tcp.drop);
 590:lwIP/src/core/tcp_in.c ****   MIB2_STATS_INC(mib2.tcpinerrs);
 591:lwIP/src/core/tcp_in.c ****   pbuf_free(p);
ARM GAS  /tmp/ccFjUByx.s 			page 12


 592:lwIP/src/core/tcp_in.c **** }
 593:lwIP/src/core/tcp_in.c **** 
 594:lwIP/src/core/tcp_in.c **** /** Called from tcp_input to check for TF_CLOSED flag. This results in closing
 595:lwIP/src/core/tcp_in.c ****  * and deallocating a pcb at the correct place to ensure noone references it
 596:lwIP/src/core/tcp_in.c ****  * any more.
 597:lwIP/src/core/tcp_in.c ****  * @returns 1 if the pcb has been closed and deallocated, 0 otherwise
 598:lwIP/src/core/tcp_in.c ****  */
 599:lwIP/src/core/tcp_in.c **** static int
 600:lwIP/src/core/tcp_in.c **** tcp_input_delayed_close(struct tcp_pcb *pcb)
 601:lwIP/src/core/tcp_in.c **** {
 602:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
 603:lwIP/src/core/tcp_in.c **** 
 604:lwIP/src/core/tcp_in.c ****   if (recv_flags & TF_CLOSED) {
 605:lwIP/src/core/tcp_in.c ****     /* The connection has been closed and we will deallocate the
 606:lwIP/src/core/tcp_in.c ****         PCB. */
 607:lwIP/src/core/tcp_in.c ****     if (!(pcb->flags & TF_RXCLOSED)) {
 608:lwIP/src/core/tcp_in.c ****       /* Connection closed although the application has only shut down the
 609:lwIP/src/core/tcp_in.c ****           tx side: call the PCB's err callback and indicate the closure to
 610:lwIP/src/core/tcp_in.c ****           ensure the application doesn't continue using the PCB. */
 611:lwIP/src/core/tcp_in.c ****       TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
 612:lwIP/src/core/tcp_in.c ****     }
 613:lwIP/src/core/tcp_in.c ****     tcp_pcb_remove(&tcp_active_pcbs, pcb);
 614:lwIP/src/core/tcp_in.c ****     tcp_free(pcb);
 615:lwIP/src/core/tcp_in.c ****     return 1;
 616:lwIP/src/core/tcp_in.c ****   }
 617:lwIP/src/core/tcp_in.c ****   return 0;
 618:lwIP/src/core/tcp_in.c **** }
 619:lwIP/src/core/tcp_in.c **** 
 620:lwIP/src/core/tcp_in.c **** /**
 621:lwIP/src/core/tcp_in.c ****  * Called by tcp_input() when a segment arrives for a listening
 622:lwIP/src/core/tcp_in.c ****  * connection (from tcp_input()).
 623:lwIP/src/core/tcp_in.c ****  *
 624:lwIP/src/core/tcp_in.c ****  * @param pcb the tcp_pcb_listen for which a segment arrived
 625:lwIP/src/core/tcp_in.c ****  *
 626:lwIP/src/core/tcp_in.c ****  * @note the segment which arrived is saved in global variables, therefore only the pcb
 627:lwIP/src/core/tcp_in.c ****  *       involved is passed as a parameter to this function
 628:lwIP/src/core/tcp_in.c ****  */
 629:lwIP/src/core/tcp_in.c **** static void
 630:lwIP/src/core/tcp_in.c **** tcp_listen_input(struct tcp_pcb_listen *pcb)
 631:lwIP/src/core/tcp_in.c **** {
 632:lwIP/src/core/tcp_in.c ****   struct tcp_pcb *npcb;
 633:lwIP/src/core/tcp_in.c ****   u32_t iss;
 634:lwIP/src/core/tcp_in.c ****   err_t rc;
 635:lwIP/src/core/tcp_in.c **** 
 636:lwIP/src/core/tcp_in.c ****   if (flags & TCP_RST) {
 637:lwIP/src/core/tcp_in.c ****     /* An incoming RST should be ignored. Return. */
 638:lwIP/src/core/tcp_in.c ****     return;
 639:lwIP/src/core/tcp_in.c ****   }
 640:lwIP/src/core/tcp_in.c **** 
 641:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);
 642:lwIP/src/core/tcp_in.c **** 
 643:lwIP/src/core/tcp_in.c ****   /* In the LISTEN state, we check for incoming SYN segments,
 644:lwIP/src/core/tcp_in.c ****      creates a new PCB, and responds with a SYN|ACK. */
 645:lwIP/src/core/tcp_in.c ****   if (flags & TCP_ACK) {
 646:lwIP/src/core/tcp_in.c ****     /* For incoming segments with the ACK flag set, respond with a
 647:lwIP/src/core/tcp_in.c ****        RST. */
 648:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
ARM GAS  /tmp/ccFjUByx.s 			page 13


 649:lwIP/src/core/tcp_in.c ****     tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 650:lwIP/src/core/tcp_in.c ****             ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 651:lwIP/src/core/tcp_in.c ****   } else if (flags & TCP_SYN) {
 652:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->
 653:lwIP/src/core/tcp_in.c **** #if TCP_LISTEN_BACKLOG
 654:lwIP/src/core/tcp_in.c ****     if (pcb->accepts_pending >= pcb->backlog) {
 655:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcph
 656:lwIP/src/core/tcp_in.c ****       return;
 657:lwIP/src/core/tcp_in.c ****     }
 658:lwIP/src/core/tcp_in.c **** #endif /* TCP_LISTEN_BACKLOG */
 659:lwIP/src/core/tcp_in.c ****     npcb = tcp_alloc(pcb->prio);
 660:lwIP/src/core/tcp_in.c ****     /* If a new PCB could not be created (probably due to lack of memory),
 661:lwIP/src/core/tcp_in.c ****        we don't do anything, but rely on the sender will retransmit the
 662:lwIP/src/core/tcp_in.c ****        SYN at a time when we have more memory available. */
 663:lwIP/src/core/tcp_in.c ****     if (npcb == NULL) {
 664:lwIP/src/core/tcp_in.c ****       err_t err;
 665:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
 666:lwIP/src/core/tcp_in.c ****       TCP_STATS_INC(tcp.memerr);
 667:lwIP/src/core/tcp_in.c ****       TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 668:lwIP/src/core/tcp_in.c ****       LWIP_UNUSED_ARG(err); /* err not useful here */
 669:lwIP/src/core/tcp_in.c ****       return;
 670:lwIP/src/core/tcp_in.c ****     }
 671:lwIP/src/core/tcp_in.c **** #if TCP_LISTEN_BACKLOG
 672:lwIP/src/core/tcp_in.c ****     pcb->accepts_pending++;
 673:lwIP/src/core/tcp_in.c ****     tcp_set_flags(npcb, TF_BACKLOGPEND);
 674:lwIP/src/core/tcp_in.c **** #endif /* TCP_LISTEN_BACKLOG */
 675:lwIP/src/core/tcp_in.c ****     /* Set up the new PCB. */
 676:lwIP/src/core/tcp_in.c ****     ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 677:lwIP/src/core/tcp_in.c ****     ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 678:lwIP/src/core/tcp_in.c ****     npcb->local_port = pcb->local_port;
 679:lwIP/src/core/tcp_in.c ****     npcb->remote_port = tcphdr->src;
 680:lwIP/src/core/tcp_in.c ****     npcb->state = SYN_RCVD;
 681:lwIP/src/core/tcp_in.c ****     npcb->rcv_nxt = seqno + 1;
 682:lwIP/src/core/tcp_in.c ****     npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 683:lwIP/src/core/tcp_in.c ****     iss = tcp_next_iss(npcb);
 684:lwIP/src/core/tcp_in.c ****     npcb->snd_wl2 = iss;
 685:lwIP/src/core/tcp_in.c ****     npcb->snd_nxt = iss;
 686:lwIP/src/core/tcp_in.c ****     npcb->lastack = iss;
 687:lwIP/src/core/tcp_in.c ****     npcb->snd_lbb = iss;
 688:lwIP/src/core/tcp_in.c ****     npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 689:lwIP/src/core/tcp_in.c ****     npcb->callback_arg = pcb->callback_arg;
 690:lwIP/src/core/tcp_in.c **** #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
 691:lwIP/src/core/tcp_in.c ****     npcb->listener = pcb;
 692:lwIP/src/core/tcp_in.c **** #endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
 693:lwIP/src/core/tcp_in.c ****     /* inherit socket options */
 694:lwIP/src/core/tcp_in.c ****     npcb->so_options = pcb->so_options & SOF_INHERITED;
 695:lwIP/src/core/tcp_in.c ****     npcb->netif_idx = pcb->netif_idx;
 696:lwIP/src/core/tcp_in.c ****     /* Register the new PCB so that we can begin receiving segments
 697:lwIP/src/core/tcp_in.c ****        for it. */
 698:lwIP/src/core/tcp_in.c ****     TCP_REG_ACTIVE(npcb);
 699:lwIP/src/core/tcp_in.c **** 
 700:lwIP/src/core/tcp_in.c ****     /* Parse any options in the SYN. */
 701:lwIP/src/core/tcp_in.c ****     tcp_parseopt(npcb);
 702:lwIP/src/core/tcp_in.c ****     npcb->snd_wnd = tcphdr->wnd;
 703:lwIP/src/core/tcp_in.c ****     npcb->snd_wnd_max = npcb->snd_wnd;
 704:lwIP/src/core/tcp_in.c **** 
 705:lwIP/src/core/tcp_in.c **** #if TCP_CALCULATE_EFF_SEND_MSS
ARM GAS  /tmp/ccFjUByx.s 			page 14


 706:lwIP/src/core/tcp_in.c ****     npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 707:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 708:lwIP/src/core/tcp_in.c **** 
 709:lwIP/src/core/tcp_in.c ****     MIB2_STATS_INC(mib2.tcppassiveopens);
 710:lwIP/src/core/tcp_in.c **** 
 711:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_PCB_NUM_EXT_ARGS
 712:lwIP/src/core/tcp_in.c ****     if (tcp_ext_arg_invoke_callbacks_passive_open(pcb, npcb) != ERR_OK) {
 713:lwIP/src/core/tcp_in.c ****       tcp_abandon(npcb, 0);
 714:lwIP/src/core/tcp_in.c ****       return;
 715:lwIP/src/core/tcp_in.c ****     }
 716:lwIP/src/core/tcp_in.c **** #endif
 717:lwIP/src/core/tcp_in.c **** 
 718:lwIP/src/core/tcp_in.c ****     /* Send a SYN|ACK together with the MSS option. */
 719:lwIP/src/core/tcp_in.c ****     rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 720:lwIP/src/core/tcp_in.c ****     if (rc != ERR_OK) {
 721:lwIP/src/core/tcp_in.c ****       tcp_abandon(npcb, 0);
 722:lwIP/src/core/tcp_in.c ****       return;
 723:lwIP/src/core/tcp_in.c ****     }
 724:lwIP/src/core/tcp_in.c ****     tcp_output(npcb);
 725:lwIP/src/core/tcp_in.c ****   }
 726:lwIP/src/core/tcp_in.c ****   return;
 727:lwIP/src/core/tcp_in.c **** }
 728:lwIP/src/core/tcp_in.c **** 
 729:lwIP/src/core/tcp_in.c **** /**
 730:lwIP/src/core/tcp_in.c ****  * Called by tcp_input() when a segment arrives for a connection in
 731:lwIP/src/core/tcp_in.c ****  * TIME_WAIT.
 732:lwIP/src/core/tcp_in.c ****  *
 733:lwIP/src/core/tcp_in.c ****  * @param pcb the tcp_pcb for which a segment arrived
 734:lwIP/src/core/tcp_in.c ****  *
 735:lwIP/src/core/tcp_in.c ****  * @note the segment which arrived is saved in global variables, therefore only the pcb
 736:lwIP/src/core/tcp_in.c ****  *       involved is passed as a parameter to this function
 737:lwIP/src/core/tcp_in.c ****  */
 738:lwIP/src/core/tcp_in.c **** static void
 739:lwIP/src/core/tcp_in.c **** tcp_timewait_input(struct tcp_pcb *pcb)
 740:lwIP/src/core/tcp_in.c **** {
 741:lwIP/src/core/tcp_in.c ****   /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
 742:lwIP/src/core/tcp_in.c ****   /* RFC 793 3.9 Event Processing - Segment Arrives:
 743:lwIP/src/core/tcp_in.c ****    * - first check sequence number - we skip that one in TIME_WAIT (always
 744:lwIP/src/core/tcp_in.c ****    *   acceptable since we only send ACKs)
 745:lwIP/src/core/tcp_in.c ****    * - second check the RST bit (... return) */
 746:lwIP/src/core/tcp_in.c ****   if (flags & TCP_RST) {
 747:lwIP/src/core/tcp_in.c ****     return;
 748:lwIP/src/core/tcp_in.c ****   }
 749:lwIP/src/core/tcp_in.c **** 
 750:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_timewait_input: invalid pcb", pcb != NULL);
 751:lwIP/src/core/tcp_in.c **** 
 752:lwIP/src/core/tcp_in.c ****   /* - fourth, check the SYN bit, */
 753:lwIP/src/core/tcp_in.c ****   if (flags & TCP_SYN) {
 754:lwIP/src/core/tcp_in.c ****     /* If an incoming segment is not acceptable, an acknowledgment
 755:lwIP/src/core/tcp_in.c ****        should be sent in reply */
 756:lwIP/src/core/tcp_in.c ****     if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 757:lwIP/src/core/tcp_in.c ****       /* If the SYN is in the window it is an error, send a reset */
 758:lwIP/src/core/tcp_in.c ****       tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 759:lwIP/src/core/tcp_in.c ****               ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 760:lwIP/src/core/tcp_in.c ****       return;
 761:lwIP/src/core/tcp_in.c ****     }
 762:lwIP/src/core/tcp_in.c ****   } else if (flags & TCP_FIN) {
ARM GAS  /tmp/ccFjUByx.s 			page 15


 763:lwIP/src/core/tcp_in.c ****     /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
 764:lwIP/src/core/tcp_in.c ****          Restart the 2 MSL time-wait timeout.*/
 765:lwIP/src/core/tcp_in.c ****     pcb->tmr = tcp_ticks;
 766:lwIP/src/core/tcp_in.c ****   }
 767:lwIP/src/core/tcp_in.c **** 
 768:lwIP/src/core/tcp_in.c ****   if ((tcplen > 0)) {
 769:lwIP/src/core/tcp_in.c ****     /* Acknowledge data, FIN or out-of-window SYN */
 770:lwIP/src/core/tcp_in.c ****     tcp_ack_now(pcb);
 771:lwIP/src/core/tcp_in.c ****     tcp_output(pcb);
 772:lwIP/src/core/tcp_in.c ****   }
 773:lwIP/src/core/tcp_in.c ****   return;
 774:lwIP/src/core/tcp_in.c **** }
 775:lwIP/src/core/tcp_in.c **** 
 776:lwIP/src/core/tcp_in.c **** /**
 777:lwIP/src/core/tcp_in.c ****  * Implements the TCP state machine. Called by tcp_input. In some
 778:lwIP/src/core/tcp_in.c ****  * states tcp_receive() is called to receive data. The tcp_seg
 779:lwIP/src/core/tcp_in.c ****  * argument will be freed by the caller (tcp_input()) unless the
 780:lwIP/src/core/tcp_in.c ****  * recv_data pointer in the pcb is set.
 781:lwIP/src/core/tcp_in.c ****  *
 782:lwIP/src/core/tcp_in.c ****  * @param pcb the tcp_pcb for which a segment arrived
 783:lwIP/src/core/tcp_in.c ****  *
 784:lwIP/src/core/tcp_in.c ****  * @note the segment which arrived is saved in global variables, therefore only the pcb
 785:lwIP/src/core/tcp_in.c ****  *       involved is passed as a parameter to this function
 786:lwIP/src/core/tcp_in.c ****  */
 787:lwIP/src/core/tcp_in.c **** static err_t
 788:lwIP/src/core/tcp_in.c **** tcp_process(struct tcp_pcb *pcb)
 789:lwIP/src/core/tcp_in.c **** {
 790:lwIP/src/core/tcp_in.c ****   struct tcp_seg *rseg;
 791:lwIP/src/core/tcp_in.c ****   u8_t acceptable = 0;
 792:lwIP/src/core/tcp_in.c ****   err_t err;
 793:lwIP/src/core/tcp_in.c **** 
 794:lwIP/src/core/tcp_in.c ****   err = ERR_OK;
 795:lwIP/src/core/tcp_in.c **** 
 796:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);
 797:lwIP/src/core/tcp_in.c **** 
 798:lwIP/src/core/tcp_in.c ****   /* Process incoming RST segments. */
 799:lwIP/src/core/tcp_in.c ****   if (flags & TCP_RST) {
 800:lwIP/src/core/tcp_in.c ****     /* First, determine if the reset is acceptable. */
 801:lwIP/src/core/tcp_in.c ****     if (pcb->state == SYN_SENT) {
 802:lwIP/src/core/tcp_in.c ****       /* "In the SYN-SENT state (a RST received in response to an initial SYN),
 803:lwIP/src/core/tcp_in.c ****           the RST is acceptable if the ACK field acknowledges the SYN." */
 804:lwIP/src/core/tcp_in.c ****       if (ackno == pcb->snd_nxt) {
 805:lwIP/src/core/tcp_in.c ****         acceptable = 1;
 806:lwIP/src/core/tcp_in.c ****       }
 807:lwIP/src/core/tcp_in.c ****     } else {
 808:lwIP/src/core/tcp_in.c ****       /* "In all states except SYN-SENT, all reset (RST) segments are validated
 809:lwIP/src/core/tcp_in.c ****           by checking their SEQ-fields." */
 810:lwIP/src/core/tcp_in.c ****       if (seqno == pcb->rcv_nxt) {
 811:lwIP/src/core/tcp_in.c ****         acceptable = 1;
 812:lwIP/src/core/tcp_in.c ****       } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 813:lwIP/src/core/tcp_in.c ****                                   pcb->rcv_nxt + pcb->rcv_wnd)) {
 814:lwIP/src/core/tcp_in.c ****         /* If the sequence number is inside the window, we send a challenge ACK
 815:lwIP/src/core/tcp_in.c ****            and wait for a re-send with matching sequence number.
 816:lwIP/src/core/tcp_in.c ****            This follows RFC 5961 section 3.2 and addresses CVE-2004-0230
 817:lwIP/src/core/tcp_in.c ****            (RST spoofing attack), which is present in RFC 793 RST handling. */
 818:lwIP/src/core/tcp_in.c ****         tcp_ack_now(pcb);
 819:lwIP/src/core/tcp_in.c ****       }
ARM GAS  /tmp/ccFjUByx.s 			page 16


 820:lwIP/src/core/tcp_in.c ****     }
 821:lwIP/src/core/tcp_in.c **** 
 822:lwIP/src/core/tcp_in.c ****     if (acceptable) {
 823:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
 824:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 825:lwIP/src/core/tcp_in.c ****       recv_flags |= TF_RESET;
 826:lwIP/src/core/tcp_in.c ****       tcp_clear_flags(pcb, TF_ACK_DELAY);
 827:lwIP/src/core/tcp_in.c ****       return ERR_RST;
 828:lwIP/src/core/tcp_in.c ****     } else {
 829:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F
 830:lwIP/src/core/tcp_in.c ****                                     seqno, pcb->rcv_nxt));
 831:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
 832:lwIP/src/core/tcp_in.c ****                               seqno, pcb->rcv_nxt));
 833:lwIP/src/core/tcp_in.c ****       return ERR_OK;
 834:lwIP/src/core/tcp_in.c ****     }
 835:lwIP/src/core/tcp_in.c ****   }
 836:lwIP/src/core/tcp_in.c **** 
 837:lwIP/src/core/tcp_in.c ****   if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 838:lwIP/src/core/tcp_in.c ****     /* Cope with new connection attempt after remote end crashed */
 839:lwIP/src/core/tcp_in.c ****     tcp_ack_now(pcb);
 840:lwIP/src/core/tcp_in.c ****     return ERR_OK;
 841:lwIP/src/core/tcp_in.c ****   }
 842:lwIP/src/core/tcp_in.c **** 
 843:lwIP/src/core/tcp_in.c ****   if ((pcb->flags & TF_RXCLOSED) == 0) {
 844:lwIP/src/core/tcp_in.c ****     /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
 845:lwIP/src/core/tcp_in.c ****     pcb->tmr = tcp_ticks;
 846:lwIP/src/core/tcp_in.c ****   }
 847:lwIP/src/core/tcp_in.c ****   pcb->keep_cnt_sent = 0;
 848:lwIP/src/core/tcp_in.c ****   pcb->persist_probe = 0;
 849:lwIP/src/core/tcp_in.c **** 
 850:lwIP/src/core/tcp_in.c ****   tcp_parseopt(pcb);
 851:lwIP/src/core/tcp_in.c **** 
 852:lwIP/src/core/tcp_in.c ****   /* Do different things depending on the TCP state. */
 853:lwIP/src/core/tcp_in.c ****   switch (pcb->state) {
 854:lwIP/src/core/tcp_in.c ****     case SYN_SENT:
 855:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F
 856:lwIP/src/core/tcp_in.c ****                                     pcb->snd_nxt, lwip_ntohl(pcb->unacked->tcphdr->seqno)));
 857:lwIP/src/core/tcp_in.c ****       /* received SYN ACK with expected sequence number? */
 858:lwIP/src/core/tcp_in.c ****       if ((flags & TCP_ACK) && (flags & TCP_SYN)
 859:lwIP/src/core/tcp_in.c ****           && (ackno == pcb->lastack + 1)) {
 860:lwIP/src/core/tcp_in.c ****         pcb->rcv_nxt = seqno + 1;
 861:lwIP/src/core/tcp_in.c ****         pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 862:lwIP/src/core/tcp_in.c ****         pcb->lastack = ackno;
 863:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd = tcphdr->wnd;
 864:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd_max = pcb->snd_wnd;
 865:lwIP/src/core/tcp_in.c ****         pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 866:lwIP/src/core/tcp_in.c ****         pcb->state = ESTABLISHED;
 867:lwIP/src/core/tcp_in.c **** 
 868:lwIP/src/core/tcp_in.c **** #if TCP_CALCULATE_EFF_SEND_MSS
 869:lwIP/src/core/tcp_in.c ****         pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 870:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 871:lwIP/src/core/tcp_in.c **** 
 872:lwIP/src/core/tcp_in.c ****         pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 873:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
 874:lwIP/src/core/tcp_in.c ****                                      " ssthresh %"TCPWNDSIZE_F"\n",
 875:lwIP/src/core/tcp_in.c ****                                      pcb->cwnd, pcb->ssthresh));
 876:lwIP/src/core/tcp_in.c ****         LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
ARM GAS  /tmp/ccFjUByx.s 			page 17


 877:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 878:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_
 879:lwIP/src/core/tcp_in.c ****         rseg = pcb->unacked;
 880:lwIP/src/core/tcp_in.c ****         if (rseg == NULL) {
 881:lwIP/src/core/tcp_in.c ****           /* might happen if tcp_output fails in tcp_rexmit_rto()
 882:lwIP/src/core/tcp_in.c ****              in which case the segment is on the unsent list */
 883:lwIP/src/core/tcp_in.c ****           rseg = pcb->unsent;
 884:lwIP/src/core/tcp_in.c ****           LWIP_ASSERT("no segment to free", rseg != NULL);
 885:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 886:lwIP/src/core/tcp_in.c ****         } else {
 887:lwIP/src/core/tcp_in.c ****           pcb->unacked = rseg->next;
 888:lwIP/src/core/tcp_in.c ****         }
 889:lwIP/src/core/tcp_in.c ****         tcp_seg_free(rseg);
 890:lwIP/src/core/tcp_in.c **** 
 891:lwIP/src/core/tcp_in.c ****         /* If there's nothing left to acknowledge, stop the retransmit
 892:lwIP/src/core/tcp_in.c ****            timer, otherwise reset it to start again */
 893:lwIP/src/core/tcp_in.c ****         if (pcb->unacked == NULL) {
 894:lwIP/src/core/tcp_in.c ****           pcb->rtime = -1;
 895:lwIP/src/core/tcp_in.c ****         } else {
 896:lwIP/src/core/tcp_in.c ****           pcb->rtime = 0;
 897:lwIP/src/core/tcp_in.c ****           pcb->nrtx = 0;
 898:lwIP/src/core/tcp_in.c ****         }
 899:lwIP/src/core/tcp_in.c **** 
 900:lwIP/src/core/tcp_in.c ****         /* Call the user specified function to call when successfully
 901:lwIP/src/core/tcp_in.c ****          * connected. */
 902:lwIP/src/core/tcp_in.c ****         TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 903:lwIP/src/core/tcp_in.c ****         if (err == ERR_ABRT) {
 904:lwIP/src/core/tcp_in.c ****           return ERR_ABRT;
 905:lwIP/src/core/tcp_in.c ****         }
 906:lwIP/src/core/tcp_in.c ****         tcp_ack_now(pcb);
 907:lwIP/src/core/tcp_in.c ****       }
 908:lwIP/src/core/tcp_in.c ****       /* received ACK? possibly a half-open connection */
 909:lwIP/src/core/tcp_in.c ****       else if (flags & TCP_ACK) {
 910:lwIP/src/core/tcp_in.c ****         /* send a RST to bring the other side in a non-synchronized state. */
 911:lwIP/src/core/tcp_in.c ****         tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 912:lwIP/src/core/tcp_in.c ****                 ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 913:lwIP/src/core/tcp_in.c ****         /* Resend SYN immediately (don't wait for rto timeout) to establish
 914:lwIP/src/core/tcp_in.c ****           connection faster, but do not send more SYNs than we otherwise would
 915:lwIP/src/core/tcp_in.c ****           have, or we might get caught in a loop on loopback interfaces. */
 916:lwIP/src/core/tcp_in.c ****         if (pcb->nrtx < TCP_SYNMAXRTX) {
 917:lwIP/src/core/tcp_in.c ****           pcb->rtime = 0;
 918:lwIP/src/core/tcp_in.c ****           tcp_rexmit_rto(pcb);
 919:lwIP/src/core/tcp_in.c ****         }
 920:lwIP/src/core/tcp_in.c ****       }
 921:lwIP/src/core/tcp_in.c ****       break;
 922:lwIP/src/core/tcp_in.c ****     case SYN_RCVD:
 923:lwIP/src/core/tcp_in.c ****       if (flags & TCP_ACK) {
 924:lwIP/src/core/tcp_in.c ****         /* expected ACK number? */
 925:lwIP/src/core/tcp_in.c ****         if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 926:lwIP/src/core/tcp_in.c ****           pcb->state = ESTABLISHED;
 927:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphd
 928:lwIP/src/core/tcp_in.c **** #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
 929:lwIP/src/core/tcp_in.c ****           if (pcb->listener == NULL) {
 930:lwIP/src/core/tcp_in.c ****             /* listen pcb might be closed by now */
 931:lwIP/src/core/tcp_in.c ****             err = ERR_VAL;
 932:lwIP/src/core/tcp_in.c ****           } else
 933:lwIP/src/core/tcp_in.c **** #endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
ARM GAS  /tmp/ccFjUByx.s 			page 18


 934:lwIP/src/core/tcp_in.c ****           {
 935:lwIP/src/core/tcp_in.c **** #if LWIP_CALLBACK_API
 936:lwIP/src/core/tcp_in.c ****             LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
 937:lwIP/src/core/tcp_in.c **** #endif
 938:lwIP/src/core/tcp_in.c ****             tcp_backlog_accepted(pcb);
 939:lwIP/src/core/tcp_in.c ****             /* Call the accept function. */
 940:lwIP/src/core/tcp_in.c ****             TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 941:lwIP/src/core/tcp_in.c ****           }
 942:lwIP/src/core/tcp_in.c ****           if (err != ERR_OK) {
 943:lwIP/src/core/tcp_in.c ****             /* If the accept function returns with an error, we abort
 944:lwIP/src/core/tcp_in.c ****              * the connection. */
 945:lwIP/src/core/tcp_in.c ****             /* Already aborted? */
 946:lwIP/src/core/tcp_in.c ****             if (err != ERR_ABRT) {
 947:lwIP/src/core/tcp_in.c ****               tcp_abort(pcb);
 948:lwIP/src/core/tcp_in.c ****             }
 949:lwIP/src/core/tcp_in.c ****             return ERR_ABRT;
 950:lwIP/src/core/tcp_in.c ****           }
 951:lwIP/src/core/tcp_in.c ****           /* If there was any data contained within this ACK,
 952:lwIP/src/core/tcp_in.c ****            * we'd better pass it on to the application as well. */
 953:lwIP/src/core/tcp_in.c ****           tcp_receive(pcb);
 954:lwIP/src/core/tcp_in.c **** 
 955:lwIP/src/core/tcp_in.c ****           /* Prevent ACK for SYN to generate a sent event */
 956:lwIP/src/core/tcp_in.c ****           if (recv_acked != 0) {
 957:lwIP/src/core/tcp_in.c ****             recv_acked--;
 958:lwIP/src/core/tcp_in.c ****           }
 959:lwIP/src/core/tcp_in.c **** 
 960:lwIP/src/core/tcp_in.c ****           pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 961:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
 962:lwIP/src/core/tcp_in.c ****                                        " ssthresh %"TCPWNDSIZE_F"\n",
 963:lwIP/src/core/tcp_in.c ****                                        pcb->cwnd, pcb->ssthresh));
 964:lwIP/src/core/tcp_in.c **** 
 965:lwIP/src/core/tcp_in.c ****           if (recv_flags & TF_GOT_FIN) {
 966:lwIP/src/core/tcp_in.c ****             tcp_ack_now(pcb);
 967:lwIP/src/core/tcp_in.c ****             pcb->state = CLOSE_WAIT;
 968:lwIP/src/core/tcp_in.c ****           }
 969:lwIP/src/core/tcp_in.c ****         } else {
 970:lwIP/src/core/tcp_in.c ****           /* incorrect ACK number, send RST */
 971:lwIP/src/core/tcp_in.c ****           tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 972:lwIP/src/core/tcp_in.c ****                   ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 973:lwIP/src/core/tcp_in.c ****         }
 974:lwIP/src/core/tcp_in.c ****       } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 975:lwIP/src/core/tcp_in.c ****         /* Looks like another copy of the SYN - retransmit our SYN-ACK */
 976:lwIP/src/core/tcp_in.c ****         tcp_rexmit(pcb);
 977:lwIP/src/core/tcp_in.c ****       }
 978:lwIP/src/core/tcp_in.c ****       break;
 979:lwIP/src/core/tcp_in.c ****     case CLOSE_WAIT:
 980:lwIP/src/core/tcp_in.c ****     /* FALLTHROUGH */
 981:lwIP/src/core/tcp_in.c ****     case ESTABLISHED:
 982:lwIP/src/core/tcp_in.c ****       tcp_receive(pcb);
 983:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_GOT_FIN) { /* passive close */
 984:lwIP/src/core/tcp_in.c ****         tcp_ack_now(pcb);
 985:lwIP/src/core/tcp_in.c ****         pcb->state = CLOSE_WAIT;
 986:lwIP/src/core/tcp_in.c ****       }
 987:lwIP/src/core/tcp_in.c ****       break;
 988:lwIP/src/core/tcp_in.c ****     case FIN_WAIT_1:
 989:lwIP/src/core/tcp_in.c ****       tcp_receive(pcb);
 990:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_GOT_FIN) {
ARM GAS  /tmp/ccFjUByx.s 			page 19


 991:lwIP/src/core/tcp_in.c ****         if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 992:lwIP/src/core/tcp_in.c ****             pcb->unsent == NULL) {
 993:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_DEBUG,
 994:lwIP/src/core/tcp_in.c ****                       ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->s
 995:lwIP/src/core/tcp_in.c ****           tcp_ack_now(pcb);
 996:lwIP/src/core/tcp_in.c ****           tcp_pcb_purge(pcb);
 997:lwIP/src/core/tcp_in.c ****           TCP_RMV_ACTIVE(pcb);
 998:lwIP/src/core/tcp_in.c ****           pcb->state = TIME_WAIT;
 999:lwIP/src/core/tcp_in.c ****           TCP_REG(&tcp_tw_pcbs, pcb);
1000:lwIP/src/core/tcp_in.c ****         } else {
1001:lwIP/src/core/tcp_in.c ****           tcp_ack_now(pcb);
1002:lwIP/src/core/tcp_in.c ****           pcb->state = CLOSING;
1003:lwIP/src/core/tcp_in.c ****         }
1004:lwIP/src/core/tcp_in.c ****       } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
1005:lwIP/src/core/tcp_in.c ****                  pcb->unsent == NULL) {
1006:lwIP/src/core/tcp_in.c ****         pcb->state = FIN_WAIT_2;
1007:lwIP/src/core/tcp_in.c ****       }
1008:lwIP/src/core/tcp_in.c ****       break;
1009:lwIP/src/core/tcp_in.c ****     case FIN_WAIT_2:
1010:lwIP/src/core/tcp_in.c ****       tcp_receive(pcb);
1011:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_GOT_FIN) {
1012:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.
1013:lwIP/src/core/tcp_in.c ****         tcp_ack_now(pcb);
1014:lwIP/src/core/tcp_in.c ****         tcp_pcb_purge(pcb);
1015:lwIP/src/core/tcp_in.c ****         TCP_RMV_ACTIVE(pcb);
1016:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
1017:lwIP/src/core/tcp_in.c ****         TCP_REG(&tcp_tw_pcbs, pcb);
1018:lwIP/src/core/tcp_in.c ****       }
1019:lwIP/src/core/tcp_in.c ****       break;
1020:lwIP/src/core/tcp_in.c ****     case CLOSING:
1021:lwIP/src/core/tcp_in.c ****       tcp_receive(pcb);
1022:lwIP/src/core/tcp_in.c ****       if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
1023:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcp
1024:lwIP/src/core/tcp_in.c ****         tcp_pcb_purge(pcb);
1025:lwIP/src/core/tcp_in.c ****         TCP_RMV_ACTIVE(pcb);
1026:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
1027:lwIP/src/core/tcp_in.c ****         TCP_REG(&tcp_tw_pcbs, pcb);
1028:lwIP/src/core/tcp_in.c ****       }
1029:lwIP/src/core/tcp_in.c ****       break;
1030:lwIP/src/core/tcp_in.c ****     case LAST_ACK:
1031:lwIP/src/core/tcp_in.c ****       tcp_receive(pcb);
1032:lwIP/src/core/tcp_in.c ****       if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
1033:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tc
1034:lwIP/src/core/tcp_in.c ****         /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
1035:lwIP/src/core/tcp_in.c ****         recv_flags |= TF_CLOSED;
1036:lwIP/src/core/tcp_in.c ****       }
1037:lwIP/src/core/tcp_in.c ****       break;
1038:lwIP/src/core/tcp_in.c ****     default:
1039:lwIP/src/core/tcp_in.c ****       break;
1040:lwIP/src/core/tcp_in.c ****   }
1041:lwIP/src/core/tcp_in.c ****   return ERR_OK;
1042:lwIP/src/core/tcp_in.c **** }
1043:lwIP/src/core/tcp_in.c **** 
1044:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ
1045:lwIP/src/core/tcp_in.c **** /**
1046:lwIP/src/core/tcp_in.c ****  * Insert segment into the list (segments covered with new one will be deleted)
1047:lwIP/src/core/tcp_in.c ****  *
ARM GAS  /tmp/ccFjUByx.s 			page 20


1048:lwIP/src/core/tcp_in.c ****  * Called from tcp_receive()
1049:lwIP/src/core/tcp_in.c ****  */
1050:lwIP/src/core/tcp_in.c **** static void
1051:lwIP/src/core/tcp_in.c **** tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
1052:lwIP/src/core/tcp_in.c **** {
1053:lwIP/src/core/tcp_in.c ****   struct tcp_seg *old_seg;
1054:lwIP/src/core/tcp_in.c **** 
1055:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);
1056:lwIP/src/core/tcp_in.c **** 
1057:lwIP/src/core/tcp_in.c ****   if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
1058:lwIP/src/core/tcp_in.c ****     /* received segment overlaps all following segments */
1059:lwIP/src/core/tcp_in.c ****     tcp_segs_free(next);
1060:lwIP/src/core/tcp_in.c ****     next = NULL;
1061:lwIP/src/core/tcp_in.c ****   } else {
1062:lwIP/src/core/tcp_in.c ****     /* delete some following segments
1063:lwIP/src/core/tcp_in.c ****        oos queue may have segments with FIN flag */
1064:lwIP/src/core/tcp_in.c ****     while (next &&
1065:lwIP/src/core/tcp_in.c ****            TCP_SEQ_GEQ((seqno + cseg->len),
1066:lwIP/src/core/tcp_in.c ****                        (next->tcphdr->seqno + next->len))) {
1067:lwIP/src/core/tcp_in.c ****       /* cseg with FIN already processed */
1068:lwIP/src/core/tcp_in.c ****       if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
1069:lwIP/src/core/tcp_in.c ****         TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
1070:lwIP/src/core/tcp_in.c ****       }
1071:lwIP/src/core/tcp_in.c ****       old_seg = next;
1072:lwIP/src/core/tcp_in.c ****       next = next->next;
1073:lwIP/src/core/tcp_in.c ****       tcp_seg_free(old_seg);
1074:lwIP/src/core/tcp_in.c ****     }
1075:lwIP/src/core/tcp_in.c ****     if (next &&
1076:lwIP/src/core/tcp_in.c ****         TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
1077:lwIP/src/core/tcp_in.c ****       /* We need to trim the incoming segment. */
1078:lwIP/src/core/tcp_in.c ****       cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
1079:lwIP/src/core/tcp_in.c ****       pbuf_realloc(cseg->p, cseg->len);
1080:lwIP/src/core/tcp_in.c ****     }
1081:lwIP/src/core/tcp_in.c ****   }
1082:lwIP/src/core/tcp_in.c ****   cseg->next = next;
1083:lwIP/src/core/tcp_in.c **** }
1084:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ */
1085:lwIP/src/core/tcp_in.c **** 
1086:lwIP/src/core/tcp_in.c **** /** Remove segments from a list if the incoming ACK acknowledges them */
1087:lwIP/src/core/tcp_in.c **** static struct tcp_seg *
1088:lwIP/src/core/tcp_in.c **** tcp_free_acked_segments(struct tcp_pcb *pcb, struct tcp_seg *seg_list, const char *dbg_list_name,
1089:lwIP/src/core/tcp_in.c ****                         struct tcp_seg *dbg_other_seg_list)
1090:lwIP/src/core/tcp_in.c **** {
1091:lwIP/src/core/tcp_in.c ****   struct tcp_seg *next;
1092:lwIP/src/core/tcp_in.c ****   u16_t clen;
1093:lwIP/src/core/tcp_in.c **** 
1094:lwIP/src/core/tcp_in.c ****   LWIP_UNUSED_ARG(dbg_list_name);
1095:lwIP/src/core/tcp_in.c ****   LWIP_UNUSED_ARG(dbg_other_seg_list);
1096:lwIP/src/core/tcp_in.c **** 
1097:lwIP/src/core/tcp_in.c ****   while (seg_list != NULL &&
1098:lwIP/src/core/tcp_in.c ****          TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
1099:lwIP/src/core/tcp_in.c ****                      TCP_TCPLEN(seg_list), ackno)) {
1100:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->%s\n",
1101:lwIP/src/core/tcp_in.c ****                                   lwip_ntohl(seg_list->tcphdr->seqno),
1102:lwIP/src/core/tcp_in.c ****                                   lwip_ntohl(seg_list->tcphdr->seqno) + TCP_TCPLEN(seg_list),
1103:lwIP/src/core/tcp_in.c ****                                   dbg_list_name));
1104:lwIP/src/core/tcp_in.c **** 
ARM GAS  /tmp/ccFjUByx.s 			page 21


1105:lwIP/src/core/tcp_in.c ****     next = seg_list;
1106:lwIP/src/core/tcp_in.c ****     seg_list = seg_list->next;
1107:lwIP/src/core/tcp_in.c **** 
1108:lwIP/src/core/tcp_in.c ****     clen = pbuf_clen(next->p);
1109:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
1110:lwIP/src/core/tcp_in.c ****                                  (tcpwnd_size_t)pcb->snd_queuelen));
1111:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
1112:lwIP/src/core/tcp_in.c **** 
1113:lwIP/src/core/tcp_in.c ****     pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
1114:lwIP/src/core/tcp_in.c ****     recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
1115:lwIP/src/core/tcp_in.c ****     tcp_seg_free(next);
1116:lwIP/src/core/tcp_in.c **** 
1117:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing %s)\n",
1118:lwIP/src/core/tcp_in.c ****                                  (tcpwnd_size_t)pcb->snd_queuelen,
1119:lwIP/src/core/tcp_in.c ****                                  dbg_list_name));
1120:lwIP/src/core/tcp_in.c ****     if (pcb->snd_queuelen != 0) {
1121:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_receive: valid queue length",
1122:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
1123:lwIP/src/core/tcp_in.c ****     }
1124:lwIP/src/core/tcp_in.c ****   }
1125:lwIP/src/core/tcp_in.c ****   return seg_list;
1126:lwIP/src/core/tcp_in.c **** }
1127:lwIP/src/core/tcp_in.c **** 
1128:lwIP/src/core/tcp_in.c **** /**
1129:lwIP/src/core/tcp_in.c ****  * Called by tcp_process. Checks if the given segment is an ACK for outstanding
1130:lwIP/src/core/tcp_in.c ****  * data, and if so frees the memory of the buffered data. Next, it places the
1131:lwIP/src/core/tcp_in.c ****  * segment on any of the receive queues (pcb->recved or pcb->ooseq). If the segment
1132:lwIP/src/core/tcp_in.c ****  * is buffered, the pbuf is referenced by pbuf_ref so that it will not be freed until
1133:lwIP/src/core/tcp_in.c ****  * it has been removed from the buffer.
1134:lwIP/src/core/tcp_in.c ****  *
1135:lwIP/src/core/tcp_in.c ****  * If the incoming segment constitutes an ACK for a segment that was used for RTT
1136:lwIP/src/core/tcp_in.c ****  * estimation, the RTT is estimated here as well.
1137:lwIP/src/core/tcp_in.c ****  *
1138:lwIP/src/core/tcp_in.c ****  * Called from tcp_process().
1139:lwIP/src/core/tcp_in.c ****  */
1140:lwIP/src/core/tcp_in.c **** static void
1141:lwIP/src/core/tcp_in.c **** tcp_receive(struct tcp_pcb *pcb)
1142:lwIP/src/core/tcp_in.c **** {
1143:lwIP/src/core/tcp_in.c ****   s16_t m;
1144:lwIP/src/core/tcp_in.c ****   u32_t right_wnd_edge;
1145:lwIP/src/core/tcp_in.c ****   int found_dupack = 0;
1146:lwIP/src/core/tcp_in.c **** 
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
1148:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
1149:lwIP/src/core/tcp_in.c **** 
1150:lwIP/src/core/tcp_in.c ****   if (flags & TCP_ACK) {
1151:lwIP/src/core/tcp_in.c ****     right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
1152:lwIP/src/core/tcp_in.c **** 
1153:lwIP/src/core/tcp_in.c ****     /* Update window. */
1154:lwIP/src/core/tcp_in.c ****     if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
1155:lwIP/src/core/tcp_in.c ****         (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
1156:lwIP/src/core/tcp_in.c ****         (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
1157:lwIP/src/core/tcp_in.c ****       pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
1158:lwIP/src/core/tcp_in.c ****       /* keep track of the biggest window announced by the remote host to calculate
1159:lwIP/src/core/tcp_in.c ****          the maximum segment size */
1160:lwIP/src/core/tcp_in.c ****       if (pcb->snd_wnd_max < pcb->snd_wnd) {
1161:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd_max = pcb->snd_wnd;
ARM GAS  /tmp/ccFjUByx.s 			page 22


1162:lwIP/src/core/tcp_in.c ****       }
1163:lwIP/src/core/tcp_in.c ****       pcb->snd_wl1 = seqno;
1164:lwIP/src/core/tcp_in.c ****       pcb->snd_wl2 = ackno;
1165:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"TCPWNDSIZE_F"\n", pcb->snd_wnd));
1166:lwIP/src/core/tcp_in.c **** #if TCP_WND_DEBUG
1167:lwIP/src/core/tcp_in.c ****     } else {
1168:lwIP/src/core/tcp_in.c ****       if (pcb->snd_wnd != (tcpwnd_size_t)SND_WND_SCALE(pcb, tcphdr->wnd)) {
1169:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_WND_DEBUG,
1170:lwIP/src/core/tcp_in.c ****                     ("tcp_receive: no window update lastack %"U32_F" ackno %"
1171:lwIP/src/core/tcp_in.c ****                      U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
1172:lwIP/src/core/tcp_in.c ****                      pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
1173:lwIP/src/core/tcp_in.c ****       }
1174:lwIP/src/core/tcp_in.c **** #endif /* TCP_WND_DEBUG */
1175:lwIP/src/core/tcp_in.c ****     }
1176:lwIP/src/core/tcp_in.c **** 
1177:lwIP/src/core/tcp_in.c ****     /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
1178:lwIP/src/core/tcp_in.c ****      * duplicate ack if:
1179:lwIP/src/core/tcp_in.c ****      * 1) It doesn't ACK new data
1180:lwIP/src/core/tcp_in.c ****      * 2) length of received packet is zero (i.e. no payload)
1181:lwIP/src/core/tcp_in.c ****      * 3) the advertised window hasn't changed
1182:lwIP/src/core/tcp_in.c ****      * 4) There is outstanding unacknowledged data (retransmission timer running)
1183:lwIP/src/core/tcp_in.c ****      * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
1184:lwIP/src/core/tcp_in.c ****      *
1185:lwIP/src/core/tcp_in.c ****      * If it passes all five, should process as a dupack:
1186:lwIP/src/core/tcp_in.c ****      * a) dupacks < 3: do nothing
1187:lwIP/src/core/tcp_in.c ****      * b) dupacks == 3: fast retransmit
1188:lwIP/src/core/tcp_in.c ****      * c) dupacks > 3: increase cwnd
1189:lwIP/src/core/tcp_in.c ****      *
1190:lwIP/src/core/tcp_in.c ****      * If it only passes 1-3, should reset dupack counter (and add to
1191:lwIP/src/core/tcp_in.c ****      * stats, which we don't do in lwIP)
1192:lwIP/src/core/tcp_in.c ****      *
1193:lwIP/src/core/tcp_in.c ****      * If it only passes 1, should reset dupack counter
1194:lwIP/src/core/tcp_in.c ****      *
1195:lwIP/src/core/tcp_in.c ****      */
1196:lwIP/src/core/tcp_in.c **** 
1197:lwIP/src/core/tcp_in.c ****     /* Clause 1 */
1198:lwIP/src/core/tcp_in.c ****     if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
1199:lwIP/src/core/tcp_in.c ****       /* Clause 2 */
1200:lwIP/src/core/tcp_in.c ****       if (tcplen == 0) {
1201:lwIP/src/core/tcp_in.c ****         /* Clause 3 */
1202:lwIP/src/core/tcp_in.c ****         if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
1203:lwIP/src/core/tcp_in.c ****           /* Clause 4 */
1204:lwIP/src/core/tcp_in.c ****           if (pcb->rtime >= 0) {
1205:lwIP/src/core/tcp_in.c ****             /* Clause 5 */
1206:lwIP/src/core/tcp_in.c ****             if (pcb->lastack == ackno) {
1207:lwIP/src/core/tcp_in.c ****               found_dupack = 1;
1208:lwIP/src/core/tcp_in.c ****               if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
1209:lwIP/src/core/tcp_in.c ****                 ++pcb->dupacks;
1210:lwIP/src/core/tcp_in.c ****               }
1211:lwIP/src/core/tcp_in.c ****               if (pcb->dupacks > 3) {
1212:lwIP/src/core/tcp_in.c ****                 /* Inflate the congestion window */
1213:lwIP/src/core/tcp_in.c ****                 TCP_WND_INC(pcb->cwnd, pcb->mss);
1214:lwIP/src/core/tcp_in.c ****               }
1215:lwIP/src/core/tcp_in.c ****               if (pcb->dupacks >= 3) {
1216:lwIP/src/core/tcp_in.c ****                 /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
1217:lwIP/src/core/tcp_in.c ****                 tcp_rexmit_fast(pcb);
1218:lwIP/src/core/tcp_in.c ****               }
ARM GAS  /tmp/ccFjUByx.s 			page 23


1219:lwIP/src/core/tcp_in.c ****             }
1220:lwIP/src/core/tcp_in.c ****           }
1221:lwIP/src/core/tcp_in.c ****         }
1222:lwIP/src/core/tcp_in.c ****       }
1223:lwIP/src/core/tcp_in.c ****       /* If Clause (1) or more is true, but not a duplicate ack, reset
1224:lwIP/src/core/tcp_in.c ****        * count of consecutive duplicate acks */
1225:lwIP/src/core/tcp_in.c ****       if (!found_dupack) {
1226:lwIP/src/core/tcp_in.c ****         pcb->dupacks = 0;
1227:lwIP/src/core/tcp_in.c ****       }
1228:lwIP/src/core/tcp_in.c ****     } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
1229:lwIP/src/core/tcp_in.c ****       /* We come here when the ACK acknowledges new data. */
1230:lwIP/src/core/tcp_in.c ****       tcpwnd_size_t acked;
1231:lwIP/src/core/tcp_in.c **** 
1232:lwIP/src/core/tcp_in.c ****       /* Reset the "IN Fast Retransmit" flag, since we are no longer
1233:lwIP/src/core/tcp_in.c ****          in fast retransmit. Also reset the congestion window to the
1234:lwIP/src/core/tcp_in.c ****          slow start threshold. */
1235:lwIP/src/core/tcp_in.c ****       if (pcb->flags & TF_INFR) {
1236:lwIP/src/core/tcp_in.c ****         tcp_clear_flags(pcb, TF_INFR);
1237:lwIP/src/core/tcp_in.c ****         pcb->cwnd = pcb->ssthresh;
1238:lwIP/src/core/tcp_in.c ****         pcb->bytes_acked = 0;
1239:lwIP/src/core/tcp_in.c ****       }
1240:lwIP/src/core/tcp_in.c **** 
1241:lwIP/src/core/tcp_in.c ****       /* Reset the number of retransmissions. */
1242:lwIP/src/core/tcp_in.c ****       pcb->nrtx = 0;
1243:lwIP/src/core/tcp_in.c **** 
1244:lwIP/src/core/tcp_in.c ****       /* Reset the retransmission time-out. */
1245:lwIP/src/core/tcp_in.c ****       pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
1246:lwIP/src/core/tcp_in.c **** 
1247:lwIP/src/core/tcp_in.c ****       /* Record how much data this ACK acks */
1248:lwIP/src/core/tcp_in.c ****       acked = (tcpwnd_size_t)(ackno - pcb->lastack);
1249:lwIP/src/core/tcp_in.c **** 
1250:lwIP/src/core/tcp_in.c ****       /* Reset the fast retransmit variables. */
1251:lwIP/src/core/tcp_in.c ****       pcb->dupacks = 0;
1252:lwIP/src/core/tcp_in.c ****       pcb->lastack = ackno;
1253:lwIP/src/core/tcp_in.c **** 
1254:lwIP/src/core/tcp_in.c ****       /* Update the congestion control variables (cwnd and
1255:lwIP/src/core/tcp_in.c ****          ssthresh). */
1256:lwIP/src/core/tcp_in.c ****       if (pcb->state >= ESTABLISHED) {
1257:lwIP/src/core/tcp_in.c ****         if (pcb->cwnd < pcb->ssthresh) {
1258:lwIP/src/core/tcp_in.c ****           tcpwnd_size_t increase;
1259:lwIP/src/core/tcp_in.c ****           /* limit to 1 SMSS segment during period following RTO */
1260:lwIP/src/core/tcp_in.c ****           u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
1261:lwIP/src/core/tcp_in.c ****           /* RFC 3465, section 2.2 Slow Start */
1262:lwIP/src/core/tcp_in.c ****           increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
1263:lwIP/src/core/tcp_in.c ****           TCP_WND_INC(pcb->cwnd, increase);
1264:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd)
1265:lwIP/src/core/tcp_in.c ****         } else {
1266:lwIP/src/core/tcp_in.c ****           /* RFC 3465, section 2.1 Congestion Avoidance */
1267:lwIP/src/core/tcp_in.c ****           TCP_WND_INC(pcb->bytes_acked, acked);
1268:lwIP/src/core/tcp_in.c ****           if (pcb->bytes_acked >= pcb->cwnd) {
1269:lwIP/src/core/tcp_in.c ****             pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
1270:lwIP/src/core/tcp_in.c ****             TCP_WND_INC(pcb->cwnd, pcb->mss);
1271:lwIP/src/core/tcp_in.c ****           }
1272:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"TCPWNDSIZE_F"\n", 
1273:lwIP/src/core/tcp_in.c ****         }
1274:lwIP/src/core/tcp_in.c ****       }
1275:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F
ARM GAS  /tmp/ccFjUByx.s 			page 24


1276:lwIP/src/core/tcp_in.c ****                                     ackno,
1277:lwIP/src/core/tcp_in.c ****                                     pcb->unacked != NULL ?
1278:lwIP/src/core/tcp_in.c ****                                     lwip_ntohl(pcb->unacked->tcphdr->seqno) : 0,
1279:lwIP/src/core/tcp_in.c ****                                     pcb->unacked != NULL ?
1280:lwIP/src/core/tcp_in.c ****                                     lwip_ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unack
1281:lwIP/src/core/tcp_in.c **** 
1282:lwIP/src/core/tcp_in.c ****       /* Remove segment from the unacknowledged list if the incoming
1283:lwIP/src/core/tcp_in.c ****          ACK acknowledges them. */
1284:lwIP/src/core/tcp_in.c ****       pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
1285:lwIP/src/core/tcp_in.c ****       /* We go through the ->unsent list to see if any of the segments
1286:lwIP/src/core/tcp_in.c ****          on the list are acknowledged by the ACK. This may seem
1287:lwIP/src/core/tcp_in.c ****          strange since an "unsent" segment shouldn't be acked. The
1288:lwIP/src/core/tcp_in.c ****          rationale is that lwIP puts all outstanding segments on the
1289:lwIP/src/core/tcp_in.c ****          ->unsent list after a retransmission, so these segments may
1290:lwIP/src/core/tcp_in.c ****          in fact have been sent once. */
1291:lwIP/src/core/tcp_in.c ****       pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
1292:lwIP/src/core/tcp_in.c **** 
1293:lwIP/src/core/tcp_in.c ****       /* If there's nothing left to acknowledge, stop the retransmit
1294:lwIP/src/core/tcp_in.c ****          timer, otherwise reset it to start again */
1295:lwIP/src/core/tcp_in.c ****       if (pcb->unacked == NULL) {
1296:lwIP/src/core/tcp_in.c ****         pcb->rtime = -1;
1297:lwIP/src/core/tcp_in.c ****       } else {
1298:lwIP/src/core/tcp_in.c ****         pcb->rtime = 0;
1299:lwIP/src/core/tcp_in.c ****       }
1300:lwIP/src/core/tcp_in.c **** 
1301:lwIP/src/core/tcp_in.c ****       pcb->polltmr = 0;
1302:lwIP/src/core/tcp_in.c **** 
1303:lwIP/src/core/tcp_in.c **** #if TCP_OVERSIZE
1304:lwIP/src/core/tcp_in.c ****       if (pcb->unsent == NULL) {
1305:lwIP/src/core/tcp_in.c ****         pcb->unsent_oversize = 0;
1306:lwIP/src/core/tcp_in.c ****       }
1307:lwIP/src/core/tcp_in.c **** #endif /* TCP_OVERSIZE */
1308:lwIP/src/core/tcp_in.c **** 
1309:lwIP/src/core/tcp_in.c **** #if LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS
1310:lwIP/src/core/tcp_in.c ****       if (ip_current_is_v6()) {
1311:lwIP/src/core/tcp_in.c ****         /* Inform neighbor reachability of forward progress. */
1312:lwIP/src/core/tcp_in.c ****         nd6_reachability_hint(ip6_current_src_addr());
1313:lwIP/src/core/tcp_in.c ****       }
1314:lwIP/src/core/tcp_in.c **** #endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/
1315:lwIP/src/core/tcp_in.c **** 
1316:lwIP/src/core/tcp_in.c ****       pcb->snd_buf = (tcpwnd_size_t)(pcb->snd_buf + recv_acked);
1317:lwIP/src/core/tcp_in.c ****       /* check if this ACK ends our retransmission of in-flight data */
1318:lwIP/src/core/tcp_in.c ****       if (pcb->flags & TF_RTO) {
1319:lwIP/src/core/tcp_in.c ****         /* RTO is done if
1320:lwIP/src/core/tcp_in.c ****             1) both queues are empty or
1321:lwIP/src/core/tcp_in.c ****             2) unacked is empty and unsent head contains data not part of RTO or
1322:lwIP/src/core/tcp_in.c ****             3) unacked head contains data not part of RTO */
1323:lwIP/src/core/tcp_in.c ****         if (pcb->unacked == NULL) {
1324:lwIP/src/core/tcp_in.c ****           if ((pcb->unsent == NULL) ||
1325:lwIP/src/core/tcp_in.c ****               (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
1326:lwIP/src/core/tcp_in.c ****             tcp_clear_flags(pcb, TF_RTO);
1327:lwIP/src/core/tcp_in.c ****           }
1328:lwIP/src/core/tcp_in.c ****         } else if (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unacked->tcphdr->seqno))) {
1329:lwIP/src/core/tcp_in.c ****           tcp_clear_flags(pcb, TF_RTO);
1330:lwIP/src/core/tcp_in.c ****         }
1331:lwIP/src/core/tcp_in.c ****       }
1332:lwIP/src/core/tcp_in.c ****       /* End of ACK for new data processing. */
ARM GAS  /tmp/ccFjUByx.s 			page 25


1333:lwIP/src/core/tcp_in.c ****     } else {
1334:lwIP/src/core/tcp_in.c ****       /* Out of sequence ACK, didn't really ack anything */
1335:lwIP/src/core/tcp_in.c ****       tcp_send_empty_ack(pcb);
1336:lwIP/src/core/tcp_in.c ****     }
1337:lwIP/src/core/tcp_in.c **** 
1338:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n"
1339:lwIP/src/core/tcp_in.c ****                                 pcb->rttest, pcb->rtseq, ackno));
1340:lwIP/src/core/tcp_in.c **** 
1341:lwIP/src/core/tcp_in.c ****     /* RTT estimation calculations. This is done by checking if the
1342:lwIP/src/core/tcp_in.c ****        incoming segment acknowledges the segment we use to take a
1343:lwIP/src/core/tcp_in.c ****        round-trip time measurement. */
1344:lwIP/src/core/tcp_in.c ****     if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
1345:lwIP/src/core/tcp_in.c ****       /* diff between this shouldn't exceed 32K since this are tcp timer ticks
1346:lwIP/src/core/tcp_in.c ****          and a round-trip shouldn't be that long... */
1347:lwIP/src/core/tcp_in.c ****       m = (s16_t)(tcp_ticks - pcb->rttest);
1348:lwIP/src/core/tcp_in.c **** 
1349:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
1350:lwIP/src/core/tcp_in.c ****                                   m, (u16_t)(m * TCP_SLOW_INTERVAL)));
1351:lwIP/src/core/tcp_in.c **** 
1352:lwIP/src/core/tcp_in.c ****       /* This is taken directly from VJs original code in his paper */
1353:lwIP/src/core/tcp_in.c ****       m = (s16_t)(m - (pcb->sa >> 3));
1354:lwIP/src/core/tcp_in.c ****       pcb->sa = (s16_t)(pcb->sa + m);
1355:lwIP/src/core/tcp_in.c ****       if (m < 0) {
1356:lwIP/src/core/tcp_in.c ****         m = (s16_t) - m;
1357:lwIP/src/core/tcp_in.c ****       }
1358:lwIP/src/core/tcp_in.c ****       m = (s16_t)(m - (pcb->sv >> 2));
1359:lwIP/src/core/tcp_in.c ****       pcb->sv = (s16_t)(pcb->sv + m);
1360:lwIP/src/core/tcp_in.c ****       pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
1361:lwIP/src/core/tcp_in.c **** 
1362:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
1363:lwIP/src/core/tcp_in.c ****                                   pcb->rto, (u16_t)(pcb->rto * TCP_SLOW_INTERVAL)));
1364:lwIP/src/core/tcp_in.c **** 
1365:lwIP/src/core/tcp_in.c ****       pcb->rttest = 0;
1366:lwIP/src/core/tcp_in.c ****     }
1367:lwIP/src/core/tcp_in.c ****   }
1368:lwIP/src/core/tcp_in.c **** 
1369:lwIP/src/core/tcp_in.c ****   /* If the incoming segment contains data, we must process it
1370:lwIP/src/core/tcp_in.c ****      further unless the pcb already received a FIN.
1371:lwIP/src/core/tcp_in.c ****      (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
1372:lwIP/src/core/tcp_in.c ****      LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
1373:lwIP/src/core/tcp_in.c ****   if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
1374:lwIP/src/core/tcp_in.c ****     /* This code basically does three things:
1375:lwIP/src/core/tcp_in.c **** 
1376:lwIP/src/core/tcp_in.c ****     +) If the incoming segment contains data that is the next
1377:lwIP/src/core/tcp_in.c ****     in-sequence data, this data is passed to the application. This
1378:lwIP/src/core/tcp_in.c ****     might involve trimming the first edge of the data. The rcv_nxt
1379:lwIP/src/core/tcp_in.c ****     variable and the advertised window are adjusted.
1380:lwIP/src/core/tcp_in.c **** 
1381:lwIP/src/core/tcp_in.c ****     +) If the incoming segment has data that is above the next
1382:lwIP/src/core/tcp_in.c ****     sequence number expected (->rcv_nxt), the segment is placed on
1383:lwIP/src/core/tcp_in.c ****     the ->ooseq queue. This is done by finding the appropriate
1384:lwIP/src/core/tcp_in.c ****     place in the ->ooseq queue (which is ordered by sequence
1385:lwIP/src/core/tcp_in.c ****     number) and trim the segment in both ends if needed. An
1386:lwIP/src/core/tcp_in.c ****     immediate ACK is sent to indicate that we received an
1387:lwIP/src/core/tcp_in.c ****     out-of-sequence segment.
1388:lwIP/src/core/tcp_in.c **** 
1389:lwIP/src/core/tcp_in.c ****     +) Finally, we check if the first segment on the ->ooseq queue
ARM GAS  /tmp/ccFjUByx.s 			page 26


1390:lwIP/src/core/tcp_in.c ****     now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
1391:lwIP/src/core/tcp_in.c ****     rcv_nxt > ooseq->seqno, we must trim the first edge of the
1392:lwIP/src/core/tcp_in.c ****     segment on ->ooseq before we adjust rcv_nxt. The data in the
1393:lwIP/src/core/tcp_in.c ****     segments that are now on sequence are chained onto the
1394:lwIP/src/core/tcp_in.c ****     incoming segment so that we only need to call the application
1395:lwIP/src/core/tcp_in.c ****     once.
1396:lwIP/src/core/tcp_in.c ****     */
1397:lwIP/src/core/tcp_in.c **** 
1398:lwIP/src/core/tcp_in.c ****     /* First, we check if we must trim the first edge. We have to do
1399:lwIP/src/core/tcp_in.c ****        this if the sequence number of the incoming segment is less
1400:lwIP/src/core/tcp_in.c ****        than rcv_nxt, and the sequence number plus the length of the
1401:lwIP/src/core/tcp_in.c ****        segment is larger than rcv_nxt. */
1402:lwIP/src/core/tcp_in.c ****     /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
1403:lwIP/src/core/tcp_in.c ****           if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
1404:lwIP/src/core/tcp_in.c ****     if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
1405:lwIP/src/core/tcp_in.c ****       /* Trimming the first edge is done by pushing the payload
1406:lwIP/src/core/tcp_in.c ****          pointer in the pbuf downwards. This is somewhat tricky since
1407:lwIP/src/core/tcp_in.c ****          we do not want to discard the full contents of the pbuf up to
1408:lwIP/src/core/tcp_in.c ****          the new starting point of the data since we have to keep the
1409:lwIP/src/core/tcp_in.c ****          TCP header which is present in the first pbuf in the chain.
1410:lwIP/src/core/tcp_in.c **** 
1411:lwIP/src/core/tcp_in.c ****          What is done is really quite a nasty hack: the first pbuf in
1412:lwIP/src/core/tcp_in.c ****          the pbuf chain is pointed to by inseg.p. Since we need to be
1413:lwIP/src/core/tcp_in.c ****          able to deallocate the whole pbuf, we cannot change this
1414:lwIP/src/core/tcp_in.c ****          inseg.p pointer to point to any of the later pbufs in the
1415:lwIP/src/core/tcp_in.c ****          chain. Instead, we point the ->payload pointer in the first
1416:lwIP/src/core/tcp_in.c ****          pbuf to data in one of the later pbufs. We also set the
1417:lwIP/src/core/tcp_in.c ****          inseg.data pointer to point to the right place. This way, the
1418:lwIP/src/core/tcp_in.c ****          ->p pointer will still point to the first pbuf, but the
1419:lwIP/src/core/tcp_in.c ****          ->p->payload pointer will point to data in another pbuf.
1420:lwIP/src/core/tcp_in.c **** 
1421:lwIP/src/core/tcp_in.c ****          After we are done with adjusting the pbuf pointers we must
1422:lwIP/src/core/tcp_in.c ****          adjust the ->data pointer in the seg and the segment
1423:lwIP/src/core/tcp_in.c ****          length.*/
1424:lwIP/src/core/tcp_in.c **** 
1425:lwIP/src/core/tcp_in.c ****       struct pbuf *p = inseg.p;
1426:lwIP/src/core/tcp_in.c ****       u32_t off32 = pcb->rcv_nxt - seqno;
1427:lwIP/src/core/tcp_in.c ****       u16_t new_tot_len, off;
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("inseg.p != NULL", inseg.p);
1429:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
1430:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
1431:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
1432:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
1433:lwIP/src/core/tcp_in.c ****       new_tot_len = (u16_t)(inseg.p->tot_len - off);
1434:lwIP/src/core/tcp_in.c ****       while (p->len < off) {
1435:lwIP/src/core/tcp_in.c ****         off -= p->len;
1436:lwIP/src/core/tcp_in.c ****         /* all pbufs up to and including this one have len==0, so tot_len is equal */
1437:lwIP/src/core/tcp_in.c ****         p->tot_len = new_tot_len;
1438:lwIP/src/core/tcp_in.c ****         p->len = 0;
1439:lwIP/src/core/tcp_in.c ****         p = p->next;
1440:lwIP/src/core/tcp_in.c ****       }
1441:lwIP/src/core/tcp_in.c ****       /* cannot fail... */
1442:lwIP/src/core/tcp_in.c ****       pbuf_remove_header(p, off);
1443:lwIP/src/core/tcp_in.c ****       inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
1444:lwIP/src/core/tcp_in.c ****     } else {
1445:lwIP/src/core/tcp_in.c ****       if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
1446:lwIP/src/core/tcp_in.c ****         /* the whole segment is < rcv_nxt */
ARM GAS  /tmp/ccFjUByx.s 			page 27


1447:lwIP/src/core/tcp_in.c ****         /* must be a duplicate of a packet that has already been correctly handled */
1448:lwIP/src/core/tcp_in.c **** 
1449:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
1450:lwIP/src/core/tcp_in.c ****         tcp_ack_now(pcb);
1451:lwIP/src/core/tcp_in.c ****       }
1452:lwIP/src/core/tcp_in.c ****     }
1453:lwIP/src/core/tcp_in.c **** 
1454:lwIP/src/core/tcp_in.c ****     /* The sequence number must be within the window (above rcv_nxt
1455:lwIP/src/core/tcp_in.c ****        and below rcv_nxt + rcv_wnd) in order to be further
1456:lwIP/src/core/tcp_in.c ****        processed. */
1457:lwIP/src/core/tcp_in.c ****     if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
1458:lwIP/src/core/tcp_in.c ****                         pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
1459:lwIP/src/core/tcp_in.c ****       if (pcb->rcv_nxt == seqno) {
1460:lwIP/src/core/tcp_in.c ****         /* The incoming segment is the next in sequence. We check if
1461:lwIP/src/core/tcp_in.c ****            we have to trim the end of the segment and update rcv_nxt
1462:lwIP/src/core/tcp_in.c ****            and pass the data to the application. */
1463:lwIP/src/core/tcp_in.c ****         tcplen = TCP_TCPLEN(&inseg);
1464:lwIP/src/core/tcp_in.c **** 
1465:lwIP/src/core/tcp_in.c ****         if (tcplen > pcb->rcv_wnd) {
1466:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG,
1467:lwIP/src/core/tcp_in.c ****                       ("tcp_receive: other end overran receive window"
1468:lwIP/src/core/tcp_in.c ****                        "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
1469:lwIP/src/core/tcp_in.c ****                        seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
1470:lwIP/src/core/tcp_in.c ****           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
1471:lwIP/src/core/tcp_in.c ****             /* Must remove the FIN from the header as we're trimming
1472:lwIP/src/core/tcp_in.c ****              * that byte of sequence-space from the packet */
1473:lwIP/src/core/tcp_in.c ****             TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
1474:lwIP/src/core/tcp_in.c ****           }
1475:lwIP/src/core/tcp_in.c ****           /* Adjust length of segment to fit in the window. */
1476:lwIP/src/core/tcp_in.c ****           TCPWND_CHECK16(pcb->rcv_wnd);
1477:lwIP/src/core/tcp_in.c ****           inseg.len = (u16_t)pcb->rcv_wnd;
1478:lwIP/src/core/tcp_in.c ****           if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
1479:lwIP/src/core/tcp_in.c ****             inseg.len -= 1;
1480:lwIP/src/core/tcp_in.c ****           }
1481:lwIP/src/core/tcp_in.c ****           pbuf_realloc(inseg.p, inseg.len);
1482:lwIP/src/core/tcp_in.c ****           tcplen = TCP_TCPLEN(&inseg);
1483:lwIP/src/core/tcp_in.c ****           LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
1484:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
1485:lwIP/src/core/tcp_in.c ****         }
1486:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ
1487:lwIP/src/core/tcp_in.c ****         /* Received in-sequence data, adjust ooseq data if:
1488:lwIP/src/core/tcp_in.c ****            - FIN has been received or
1489:lwIP/src/core/tcp_in.c ****            - inseq overlaps with ooseq */
1490:lwIP/src/core/tcp_in.c ****         if (pcb->ooseq != NULL) {
1491:lwIP/src/core/tcp_in.c ****           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
1492:lwIP/src/core/tcp_in.c ****             LWIP_DEBUGF(TCP_INPUT_DEBUG,
1493:lwIP/src/core/tcp_in.c ****                         ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
1494:lwIP/src/core/tcp_in.c ****             /* Received in-order FIN means anything that was received
1495:lwIP/src/core/tcp_in.c ****              * out of order must now have been received in-order, so
1496:lwIP/src/core/tcp_in.c ****              * bin the ooseq queue */
1497:lwIP/src/core/tcp_in.c ****             while (pcb->ooseq != NULL) {
1498:lwIP/src/core/tcp_in.c ****               struct tcp_seg *old_ooseq = pcb->ooseq;
1499:lwIP/src/core/tcp_in.c ****               pcb->ooseq = pcb->ooseq->next;
1500:lwIP/src/core/tcp_in.c ****               tcp_seg_free(old_ooseq);
1501:lwIP/src/core/tcp_in.c ****             }
1502:lwIP/src/core/tcp_in.c ****           } else {
1503:lwIP/src/core/tcp_in.c ****             struct tcp_seg *next = pcb->ooseq;
ARM GAS  /tmp/ccFjUByx.s 			page 28


1504:lwIP/src/core/tcp_in.c ****             /* Remove all segments on ooseq that are covered by inseg already.
1505:lwIP/src/core/tcp_in.c ****              * FIN is copied from ooseq to inseg if present. */
1506:lwIP/src/core/tcp_in.c ****             while (next &&
1507:lwIP/src/core/tcp_in.c ****                    TCP_SEQ_GEQ(seqno + tcplen,
1508:lwIP/src/core/tcp_in.c ****                                next->tcphdr->seqno + next->len)) {
1509:lwIP/src/core/tcp_in.c ****               struct tcp_seg *tmp;
1510:lwIP/src/core/tcp_in.c ****               /* inseg cannot have FIN here (already processed above) */
1511:lwIP/src/core/tcp_in.c ****               if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
1512:lwIP/src/core/tcp_in.c ****                   (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
1513:lwIP/src/core/tcp_in.c ****                 TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
1514:lwIP/src/core/tcp_in.c ****                 tcplen = TCP_TCPLEN(&inseg);
1515:lwIP/src/core/tcp_in.c ****               }
1516:lwIP/src/core/tcp_in.c ****               tmp = next;
1517:lwIP/src/core/tcp_in.c ****               next = next->next;
1518:lwIP/src/core/tcp_in.c ****               tcp_seg_free(tmp);
1519:lwIP/src/core/tcp_in.c ****             }
1520:lwIP/src/core/tcp_in.c ****             /* Now trim right side of inseg if it overlaps with the first
1521:lwIP/src/core/tcp_in.c ****              * segment on ooseq */
1522:lwIP/src/core/tcp_in.c ****             if (next &&
1523:lwIP/src/core/tcp_in.c ****                 TCP_SEQ_GT(seqno + tcplen,
1524:lwIP/src/core/tcp_in.c ****                            next->tcphdr->seqno)) {
1525:lwIP/src/core/tcp_in.c ****               /* inseg cannot have FIN here (already processed above) */
1526:lwIP/src/core/tcp_in.c ****               inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
1527:lwIP/src/core/tcp_in.c ****               if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
1528:lwIP/src/core/tcp_in.c ****                 inseg.len -= 1;
1529:lwIP/src/core/tcp_in.c ****               }
1530:lwIP/src/core/tcp_in.c ****               pbuf_realloc(inseg.p, inseg.len);
1531:lwIP/src/core/tcp_in.c ****               tcplen = TCP_TCPLEN(&inseg);
1532:lwIP/src/core/tcp_in.c ****               LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
1533:lwIP/src/core/tcp_in.c ****                           (seqno + tcplen) == next->tcphdr->seqno);
1534:lwIP/src/core/tcp_in.c ****             }
1535:lwIP/src/core/tcp_in.c ****             pcb->ooseq = next;
1536:lwIP/src/core/tcp_in.c ****           }
1537:lwIP/src/core/tcp_in.c ****         }
1538:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ */
1539:lwIP/src/core/tcp_in.c **** 
1540:lwIP/src/core/tcp_in.c ****         pcb->rcv_nxt = seqno + tcplen;
1541:lwIP/src/core/tcp_in.c **** 
1542:lwIP/src/core/tcp_in.c ****         /* Update the receiver's (our) window. */
1543:lwIP/src/core/tcp_in.c ****         LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
1544:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
1545:lwIP/src/core/tcp_in.c **** 
1546:lwIP/src/core/tcp_in.c ****         tcp_update_rcv_ann_wnd(pcb);
1547:lwIP/src/core/tcp_in.c **** 
1548:lwIP/src/core/tcp_in.c ****         /* If there is data in the segment, we make preparations to
1549:lwIP/src/core/tcp_in.c ****            pass this up to the application. The ->recv_data variable
1550:lwIP/src/core/tcp_in.c ****            is used for holding the pbuf that goes to the
1551:lwIP/src/core/tcp_in.c ****            application. The code for reassembling out-of-sequence data
1552:lwIP/src/core/tcp_in.c ****            chains its data on this pbuf as well.
1553:lwIP/src/core/tcp_in.c **** 
1554:lwIP/src/core/tcp_in.c ****            If the segment was a FIN, we set the TF_GOT_FIN flag that will
1555:lwIP/src/core/tcp_in.c ****            be used to indicate to the application that the remote side has
1556:lwIP/src/core/tcp_in.c ****            closed its end of the connection. */
1557:lwIP/src/core/tcp_in.c ****         if (inseg.p->tot_len > 0) {
1558:lwIP/src/core/tcp_in.c ****           recv_data = inseg.p;
1559:lwIP/src/core/tcp_in.c ****           /* Since this pbuf now is the responsibility of the
1560:lwIP/src/core/tcp_in.c ****              application, we delete our reference to it so that we won't
ARM GAS  /tmp/ccFjUByx.s 			page 29


1561:lwIP/src/core/tcp_in.c ****              (mistakingly) deallocate it. */
1562:lwIP/src/core/tcp_in.c ****           inseg.p = NULL;
1563:lwIP/src/core/tcp_in.c ****         }
1564:lwIP/src/core/tcp_in.c ****         if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
1565:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
1566:lwIP/src/core/tcp_in.c ****           recv_flags |= TF_GOT_FIN;
1567:lwIP/src/core/tcp_in.c ****         }
1568:lwIP/src/core/tcp_in.c **** 
1569:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ
1570:lwIP/src/core/tcp_in.c ****         /* We now check if we have segments on the ->ooseq queue that
1571:lwIP/src/core/tcp_in.c ****            are now in sequence. */
1572:lwIP/src/core/tcp_in.c ****         while (pcb->ooseq != NULL &&
1573:lwIP/src/core/tcp_in.c ****                pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
1574:lwIP/src/core/tcp_in.c **** 
1575:lwIP/src/core/tcp_in.c ****           struct tcp_seg *cseg = pcb->ooseq;
1576:lwIP/src/core/tcp_in.c ****           seqno = pcb->ooseq->tcphdr->seqno;
1577:lwIP/src/core/tcp_in.c **** 
1578:lwIP/src/core/tcp_in.c ****           pcb->rcv_nxt += TCP_TCPLEN(cseg);
1579:lwIP/src/core/tcp_in.c ****           LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
1580:lwIP/src/core/tcp_in.c ****                       pcb->rcv_wnd >= TCP_TCPLEN(cseg));
1581:lwIP/src/core/tcp_in.c ****           pcb->rcv_wnd -= TCP_TCPLEN(cseg);
1582:lwIP/src/core/tcp_in.c **** 
1583:lwIP/src/core/tcp_in.c ****           tcp_update_rcv_ann_wnd(pcb);
1584:lwIP/src/core/tcp_in.c **** 
1585:lwIP/src/core/tcp_in.c ****           if (cseg->p->tot_len > 0) {
1586:lwIP/src/core/tcp_in.c ****             /* Chain this pbuf onto the pbuf that we will pass to
1587:lwIP/src/core/tcp_in.c ****                the application. */
1588:lwIP/src/core/tcp_in.c ****             /* With window scaling, this can overflow recv_data->tot_len, but
1589:lwIP/src/core/tcp_in.c ****                that's not a problem since we explicitly fix that before passing
1590:lwIP/src/core/tcp_in.c ****                recv_data to the application. */
1591:lwIP/src/core/tcp_in.c ****             if (recv_data) {
1592:lwIP/src/core/tcp_in.c ****               pbuf_cat(recv_data, cseg->p);
1593:lwIP/src/core/tcp_in.c ****             } else {
1594:lwIP/src/core/tcp_in.c ****               recv_data = cseg->p;
1595:lwIP/src/core/tcp_in.c ****             }
1596:lwIP/src/core/tcp_in.c ****             cseg->p = NULL;
1597:lwIP/src/core/tcp_in.c ****           }
1598:lwIP/src/core/tcp_in.c ****           if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
1599:lwIP/src/core/tcp_in.c ****             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
1600:lwIP/src/core/tcp_in.c ****             recv_flags |= TF_GOT_FIN;
1601:lwIP/src/core/tcp_in.c ****             if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close 
1602:lwIP/src/core/tcp_in.c ****               pcb->state = CLOSE_WAIT;
1603:lwIP/src/core/tcp_in.c ****             }
1604:lwIP/src/core/tcp_in.c ****           }
1605:lwIP/src/core/tcp_in.c **** 
1606:lwIP/src/core/tcp_in.c ****           pcb->ooseq = cseg->next;
1607:lwIP/src/core/tcp_in.c ****           tcp_seg_free(cseg);
1608:lwIP/src/core/tcp_in.c ****         }
1609:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_SACK_OUT
1610:lwIP/src/core/tcp_in.c ****         if (pcb->flags & TF_SACK) {
1611:lwIP/src/core/tcp_in.c ****           if (pcb->ooseq != NULL) {
1612:lwIP/src/core/tcp_in.c ****             /* Some segments may have been removed from ooseq, let's remove all SACKs that
1613:lwIP/src/core/tcp_in.c ****                describe anything before the new beginning of that list. */
1614:lwIP/src/core/tcp_in.c ****             tcp_remove_sacks_lt(pcb, pcb->ooseq->tcphdr->seqno);
1615:lwIP/src/core/tcp_in.c ****           } else if (LWIP_TCP_SACK_VALID(pcb, 0)) {
1616:lwIP/src/core/tcp_in.c ****             /* ooseq has been cleared. Nothing to SACK */
1617:lwIP/src/core/tcp_in.c ****             memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
ARM GAS  /tmp/ccFjUByx.s 			page 30


1618:lwIP/src/core/tcp_in.c ****           }
1619:lwIP/src/core/tcp_in.c ****         }
1620:lwIP/src/core/tcp_in.c **** #endif /* LWIP_TCP_SACK_OUT */
1621:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ */
1622:lwIP/src/core/tcp_in.c **** 
1623:lwIP/src/core/tcp_in.c **** 
1624:lwIP/src/core/tcp_in.c ****         /* Acknowledge the segment(s). */
1625:lwIP/src/core/tcp_in.c ****         tcp_ack(pcb);
1626:lwIP/src/core/tcp_in.c **** 
1627:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_SACK_OUT
1628:lwIP/src/core/tcp_in.c ****         if (LWIP_TCP_SACK_VALID(pcb, 0)) {
1629:lwIP/src/core/tcp_in.c ****           /* Normally the ACK for the data received could be piggy-backed on a data packet,
1630:lwIP/src/core/tcp_in.c ****              but lwIP currently does not support including SACKs in data packets. So we force
1631:lwIP/src/core/tcp_in.c ****              it to respond with an empty ACK packet (only if there is at least one SACK to be sent)
1632:lwIP/src/core/tcp_in.c ****              NOTE: tcp_send_empty_ack() on success clears the ACK flags (set by tcp_ack()) */
1633:lwIP/src/core/tcp_in.c ****           tcp_send_empty_ack(pcb);
1634:lwIP/src/core/tcp_in.c ****         }
1635:lwIP/src/core/tcp_in.c **** #endif /* LWIP_TCP_SACK_OUT */
1636:lwIP/src/core/tcp_in.c **** 
1637:lwIP/src/core/tcp_in.c **** #if LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS
1638:lwIP/src/core/tcp_in.c ****         if (ip_current_is_v6()) {
1639:lwIP/src/core/tcp_in.c ****           /* Inform neighbor reachability of forward progress. */
1640:lwIP/src/core/tcp_in.c ****           nd6_reachability_hint(ip6_current_src_addr());
1641:lwIP/src/core/tcp_in.c ****         }
1642:lwIP/src/core/tcp_in.c **** #endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/
1643:lwIP/src/core/tcp_in.c **** 
1644:lwIP/src/core/tcp_in.c ****       } else {
1645:lwIP/src/core/tcp_in.c ****         /* We get here if the incoming segment is out-of-sequence. */
1646:lwIP/src/core/tcp_in.c **** 
1647:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ
1648:lwIP/src/core/tcp_in.c ****         /* We queue the segment on the ->ooseq queue. */
1649:lwIP/src/core/tcp_in.c ****         if (pcb->ooseq == NULL) {
1650:lwIP/src/core/tcp_in.c ****           pcb->ooseq = tcp_seg_copy(&inseg);
1651:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_SACK_OUT
1652:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_SACK) {
1653:lwIP/src/core/tcp_in.c ****             /* All the SACKs should be invalid, so we can simply store the most recent one: */
1654:lwIP/src/core/tcp_in.c ****             pcb->rcv_sacks[0].left = seqno;
1655:lwIP/src/core/tcp_in.c ****             pcb->rcv_sacks[0].right = seqno + inseg.len;
1656:lwIP/src/core/tcp_in.c ****           }
1657:lwIP/src/core/tcp_in.c **** #endif /* LWIP_TCP_SACK_OUT */
1658:lwIP/src/core/tcp_in.c ****         } else {
1659:lwIP/src/core/tcp_in.c ****           /* If the queue is not empty, we walk through the queue and
1660:lwIP/src/core/tcp_in.c ****              try to find a place where the sequence number of the
1661:lwIP/src/core/tcp_in.c ****              incoming segment is between the sequence numbers of the
1662:lwIP/src/core/tcp_in.c ****              previous and the next segment on the ->ooseq queue. That is
1663:lwIP/src/core/tcp_in.c ****              the place where we put the incoming segment. If needed, we
1664:lwIP/src/core/tcp_in.c ****              trim the second edges of the previous and the incoming
1665:lwIP/src/core/tcp_in.c ****              segment so that it will fit into the sequence.
1666:lwIP/src/core/tcp_in.c **** 
1667:lwIP/src/core/tcp_in.c ****              If the incoming segment has the same sequence number as a
1668:lwIP/src/core/tcp_in.c ****              segment on the ->ooseq queue, we discard the segment that
1669:lwIP/src/core/tcp_in.c ****              contains less data. */
1670:lwIP/src/core/tcp_in.c **** 
1671:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_SACK_OUT
1672:lwIP/src/core/tcp_in.c ****           /* This is the left edge of the lowest possible SACK range.
1673:lwIP/src/core/tcp_in.c ****              It may start before the newly received segment (possibly adjusted below). */
1674:lwIP/src/core/tcp_in.c ****           u32_t sackbeg = TCP_SEQ_LT(seqno, pcb->ooseq->tcphdr->seqno) ? seqno : pcb->ooseq->tcphdr
ARM GAS  /tmp/ccFjUByx.s 			page 31


1675:lwIP/src/core/tcp_in.c **** #endif /* LWIP_TCP_SACK_OUT */
1676:lwIP/src/core/tcp_in.c ****           struct tcp_seg *next, *prev = NULL;
1677:lwIP/src/core/tcp_in.c ****           for (next = pcb->ooseq; next != NULL; next = next->next) {
1678:lwIP/src/core/tcp_in.c ****             if (seqno == next->tcphdr->seqno) {
1679:lwIP/src/core/tcp_in.c ****               /* The sequence number of the incoming segment is the
1680:lwIP/src/core/tcp_in.c ****                  same as the sequence number of the segment on
1681:lwIP/src/core/tcp_in.c ****                  ->ooseq. We check the lengths to see which one to
1682:lwIP/src/core/tcp_in.c ****                  discard. */
1683:lwIP/src/core/tcp_in.c ****               if (inseg.len > next->len) {
1684:lwIP/src/core/tcp_in.c ****                 /* The incoming segment is larger than the old
1685:lwIP/src/core/tcp_in.c ****                    segment. We replace some segments with the new
1686:lwIP/src/core/tcp_in.c ****                    one. */
1687:lwIP/src/core/tcp_in.c ****                 struct tcp_seg *cseg = tcp_seg_copy(&inseg);
1688:lwIP/src/core/tcp_in.c ****                 if (cseg != NULL) {
1689:lwIP/src/core/tcp_in.c ****                   if (prev != NULL) {
1690:lwIP/src/core/tcp_in.c ****                     prev->next = cseg;
1691:lwIP/src/core/tcp_in.c ****                   } else {
1692:lwIP/src/core/tcp_in.c ****                     pcb->ooseq = cseg;
1693:lwIP/src/core/tcp_in.c ****                   }
1694:lwIP/src/core/tcp_in.c ****                   tcp_oos_insert_segment(cseg, next);
1695:lwIP/src/core/tcp_in.c ****                 }
1696:lwIP/src/core/tcp_in.c ****                 break;
1697:lwIP/src/core/tcp_in.c ****               } else {
1698:lwIP/src/core/tcp_in.c ****                 /* Either the lengths are the same or the incoming
1699:lwIP/src/core/tcp_in.c ****                    segment was smaller than the old one; in either
1700:lwIP/src/core/tcp_in.c ****                    case, we ditch the incoming segment. */
1701:lwIP/src/core/tcp_in.c ****                 break;
1702:lwIP/src/core/tcp_in.c ****               }
1703:lwIP/src/core/tcp_in.c ****             } else {
1704:lwIP/src/core/tcp_in.c ****               if (prev == NULL) {
1705:lwIP/src/core/tcp_in.c ****                 if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
1706:lwIP/src/core/tcp_in.c ****                   /* The sequence number of the incoming segment is lower
1707:lwIP/src/core/tcp_in.c ****                      than the sequence number of the first segment on the
1708:lwIP/src/core/tcp_in.c ****                      queue. We put the incoming segment first on the
1709:lwIP/src/core/tcp_in.c ****                      queue. */
1710:lwIP/src/core/tcp_in.c ****                   struct tcp_seg *cseg = tcp_seg_copy(&inseg);
1711:lwIP/src/core/tcp_in.c ****                   if (cseg != NULL) {
1712:lwIP/src/core/tcp_in.c ****                     pcb->ooseq = cseg;
1713:lwIP/src/core/tcp_in.c ****                     tcp_oos_insert_segment(cseg, next);
1714:lwIP/src/core/tcp_in.c ****                   }
1715:lwIP/src/core/tcp_in.c ****                   break;
1716:lwIP/src/core/tcp_in.c ****                 }
1717:lwIP/src/core/tcp_in.c ****               } else {
1718:lwIP/src/core/tcp_in.c ****                 /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
1719:lwIP/src/core/tcp_in.c ****                   TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
1720:lwIP/src/core/tcp_in.c ****                 if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
1721:lwIP/src/core/tcp_in.c ****                   /* The sequence number of the incoming segment is in
1722:lwIP/src/core/tcp_in.c ****                      between the sequence numbers of the previous and
1723:lwIP/src/core/tcp_in.c ****                      the next segment on ->ooseq. We trim trim the previous
1724:lwIP/src/core/tcp_in.c ****                      segment, delete next segments that included in received segment
1725:lwIP/src/core/tcp_in.c ****                      and trim received, if needed. */
1726:lwIP/src/core/tcp_in.c ****                   struct tcp_seg *cseg = tcp_seg_copy(&inseg);
1727:lwIP/src/core/tcp_in.c ****                   if (cseg != NULL) {
1728:lwIP/src/core/tcp_in.c ****                     if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
1729:lwIP/src/core/tcp_in.c ****                       /* We need to trim the prev segment. */
1730:lwIP/src/core/tcp_in.c ****                       prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
1731:lwIP/src/core/tcp_in.c ****                       pbuf_realloc(prev->p, prev->len);
ARM GAS  /tmp/ccFjUByx.s 			page 32


1732:lwIP/src/core/tcp_in.c ****                     }
1733:lwIP/src/core/tcp_in.c ****                     prev->next = cseg;
1734:lwIP/src/core/tcp_in.c ****                     tcp_oos_insert_segment(cseg, next);
1735:lwIP/src/core/tcp_in.c ****                   }
1736:lwIP/src/core/tcp_in.c ****                   break;
1737:lwIP/src/core/tcp_in.c ****                 }
1738:lwIP/src/core/tcp_in.c ****               }
1739:lwIP/src/core/tcp_in.c **** 
1740:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_SACK_OUT
1741:lwIP/src/core/tcp_in.c ****               /* The new segment goes after the 'next' one. If there is a "hole" in sequence number
1742:lwIP/src/core/tcp_in.c ****                  between 'prev' and the beginning of 'next', we want to move sackbeg. */
1743:lwIP/src/core/tcp_in.c ****               if (prev != NULL && prev->tcphdr->seqno + prev->len != next->tcphdr->seqno) {
1744:lwIP/src/core/tcp_in.c ****                 sackbeg = next->tcphdr->seqno;
1745:lwIP/src/core/tcp_in.c ****               }
1746:lwIP/src/core/tcp_in.c **** #endif /* LWIP_TCP_SACK_OUT */
1747:lwIP/src/core/tcp_in.c **** 
1748:lwIP/src/core/tcp_in.c ****               /* We don't use 'prev' below, so let's set it to current 'next'.
1749:lwIP/src/core/tcp_in.c ****                  This way even if we break the loop below, 'prev' will be pointing
1750:lwIP/src/core/tcp_in.c ****                  at the segment right in front of the newly added one. */
1751:lwIP/src/core/tcp_in.c ****               prev = next;
1752:lwIP/src/core/tcp_in.c **** 
1753:lwIP/src/core/tcp_in.c ****               /* If the "next" segment is the last segment on the
1754:lwIP/src/core/tcp_in.c ****                  ooseq queue, we add the incoming segment to the end
1755:lwIP/src/core/tcp_in.c ****                  of the list. */
1756:lwIP/src/core/tcp_in.c ****               if (next->next == NULL &&
1757:lwIP/src/core/tcp_in.c ****                   TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
1758:lwIP/src/core/tcp_in.c ****                 if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
1759:lwIP/src/core/tcp_in.c ****                   /* segment "next" already contains all data */
1760:lwIP/src/core/tcp_in.c ****                   break;
1761:lwIP/src/core/tcp_in.c ****                 }
1762:lwIP/src/core/tcp_in.c ****                 next->next = tcp_seg_copy(&inseg);
1763:lwIP/src/core/tcp_in.c ****                 if (next->next != NULL) {
1764:lwIP/src/core/tcp_in.c ****                   if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
1765:lwIP/src/core/tcp_in.c ****                     /* We need to trim the last segment. */
1766:lwIP/src/core/tcp_in.c ****                     next->len = (u16_t)(seqno - next->tcphdr->seqno);
1767:lwIP/src/core/tcp_in.c ****                     pbuf_realloc(next->p, next->len);
1768:lwIP/src/core/tcp_in.c ****                   }
1769:lwIP/src/core/tcp_in.c ****                   /* check if the remote side overruns our receive window */
1770:lwIP/src/core/tcp_in.c ****                   if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
1771:lwIP/src/core/tcp_in.c ****                     LWIP_DEBUGF(TCP_INPUT_DEBUG,
1772:lwIP/src/core/tcp_in.c ****                                 ("tcp_receive: other end overran receive window"
1773:lwIP/src/core/tcp_in.c ****                                  "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
1774:lwIP/src/core/tcp_in.c ****                                  seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
1775:lwIP/src/core/tcp_in.c ****                     if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
1776:lwIP/src/core/tcp_in.c ****                       /* Must remove the FIN from the header as we're trimming
1777:lwIP/src/core/tcp_in.c ****                        * that byte of sequence-space from the packet */
1778:lwIP/src/core/tcp_in.c ****                       TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN)
1779:lwIP/src/core/tcp_in.c ****                     }
1780:lwIP/src/core/tcp_in.c ****                     /* Adjust length of segment to fit in the window. */
1781:lwIP/src/core/tcp_in.c ****                     next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
1782:lwIP/src/core/tcp_in.c ****                     pbuf_realloc(next->next->p, next->next->len);
1783:lwIP/src/core/tcp_in.c ****                     tcplen = TCP_TCPLEN(next->next);
1784:lwIP/src/core/tcp_in.c ****                     LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
1785:lwIP/src/core/tcp_in.c ****                                 (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
1786:lwIP/src/core/tcp_in.c ****                   }
1787:lwIP/src/core/tcp_in.c ****                 }
1788:lwIP/src/core/tcp_in.c ****                 break;
ARM GAS  /tmp/ccFjUByx.s 			page 33


1789:lwIP/src/core/tcp_in.c ****               }
1790:lwIP/src/core/tcp_in.c ****             }
1791:lwIP/src/core/tcp_in.c ****           }
1792:lwIP/src/core/tcp_in.c **** 
1793:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_SACK_OUT
1794:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_SACK) {
1795:lwIP/src/core/tcp_in.c ****             if (prev == NULL) {
1796:lwIP/src/core/tcp_in.c ****               /* The new segment is at the beginning. sackbeg should already be set properly.
1797:lwIP/src/core/tcp_in.c ****                  We need to find the right edge. */
1798:lwIP/src/core/tcp_in.c ****               next = pcb->ooseq;
1799:lwIP/src/core/tcp_in.c ****             } else if (prev->next != NULL) {
1800:lwIP/src/core/tcp_in.c ****               /* The new segment was added after 'prev'. If there is a "hole" between 'prev' and 'p
1801:lwIP/src/core/tcp_in.c ****                  we need to move sackbeg. After that we should find the right edge. */
1802:lwIP/src/core/tcp_in.c ****               next = prev->next;
1803:lwIP/src/core/tcp_in.c ****               if (prev->tcphdr->seqno + prev->len != next->tcphdr->seqno) {
1804:lwIP/src/core/tcp_in.c ****                 sackbeg = next->tcphdr->seqno;
1805:lwIP/src/core/tcp_in.c ****               }
1806:lwIP/src/core/tcp_in.c ****             } else {
1807:lwIP/src/core/tcp_in.c ****               next = NULL;
1808:lwIP/src/core/tcp_in.c ****             }
1809:lwIP/src/core/tcp_in.c ****             if (next != NULL) {
1810:lwIP/src/core/tcp_in.c ****               u32_t sackend = next->tcphdr->seqno;
1811:lwIP/src/core/tcp_in.c ****               for ( ; (next != NULL) && (sackend == next->tcphdr->seqno); next = next->next) {
1812:lwIP/src/core/tcp_in.c ****                 sackend += next->len;
1813:lwIP/src/core/tcp_in.c ****               }
1814:lwIP/src/core/tcp_in.c ****               tcp_add_sack(pcb, sackbeg, sackend);
1815:lwIP/src/core/tcp_in.c ****             }
1816:lwIP/src/core/tcp_in.c ****           }
1817:lwIP/src/core/tcp_in.c **** #endif /* LWIP_TCP_SACK_OUT */
1818:lwIP/src/core/tcp_in.c ****         }
1819:lwIP/src/core/tcp_in.c **** #if defined(TCP_OOSEQ_BYTES_LIMIT) || defined(TCP_OOSEQ_PBUFS_LIMIT)
1820:lwIP/src/core/tcp_in.c ****         {
1821:lwIP/src/core/tcp_in.c ****           /* Check that the data on ooseq doesn't exceed one of the limits
1822:lwIP/src/core/tcp_in.c ****              and throw away everything above that limit. */
1823:lwIP/src/core/tcp_in.c **** #ifdef TCP_OOSEQ_BYTES_LIMIT
1824:lwIP/src/core/tcp_in.c ****           const u32_t ooseq_max_blen = TCP_OOSEQ_BYTES_LIMIT(pcb);
1825:lwIP/src/core/tcp_in.c ****           u32_t ooseq_blen = 0;
1826:lwIP/src/core/tcp_in.c **** #endif
1827:lwIP/src/core/tcp_in.c **** #ifdef TCP_OOSEQ_PBUFS_LIMIT
1828:lwIP/src/core/tcp_in.c ****           const u16_t ooseq_max_qlen = TCP_OOSEQ_PBUFS_LIMIT(pcb);
1829:lwIP/src/core/tcp_in.c ****           u16_t ooseq_qlen = 0;
1830:lwIP/src/core/tcp_in.c **** #endif
1831:lwIP/src/core/tcp_in.c ****           struct tcp_seg *next, *prev = NULL;
1832:lwIP/src/core/tcp_in.c ****           for (next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
1833:lwIP/src/core/tcp_in.c ****             struct pbuf *p = next->p;
1834:lwIP/src/core/tcp_in.c ****             int stop_here = 0;
1835:lwIP/src/core/tcp_in.c **** #ifdef TCP_OOSEQ_BYTES_LIMIT
1836:lwIP/src/core/tcp_in.c ****             ooseq_blen += p->tot_len;
1837:lwIP/src/core/tcp_in.c ****             if (ooseq_blen > ooseq_max_blen) {
1838:lwIP/src/core/tcp_in.c ****               stop_here = 1;
1839:lwIP/src/core/tcp_in.c ****             }
1840:lwIP/src/core/tcp_in.c **** #endif
1841:lwIP/src/core/tcp_in.c **** #ifdef TCP_OOSEQ_PBUFS_LIMIT
1842:lwIP/src/core/tcp_in.c ****             ooseq_qlen += pbuf_clen(p);
1843:lwIP/src/core/tcp_in.c ****             if (ooseq_qlen > ooseq_max_qlen) {
1844:lwIP/src/core/tcp_in.c ****               stop_here = 1;
1845:lwIP/src/core/tcp_in.c ****             }
ARM GAS  /tmp/ccFjUByx.s 			page 34


1846:lwIP/src/core/tcp_in.c **** #endif
1847:lwIP/src/core/tcp_in.c ****             if (stop_here) {
1848:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_SACK_OUT
1849:lwIP/src/core/tcp_in.c ****               if (pcb->flags & TF_SACK) {
1850:lwIP/src/core/tcp_in.c ****                 /* Let's remove all SACKs from next's seqno up. */
1851:lwIP/src/core/tcp_in.c ****                 tcp_remove_sacks_gt(pcb, next->tcphdr->seqno);
1852:lwIP/src/core/tcp_in.c ****               }
1853:lwIP/src/core/tcp_in.c **** #endif /* LWIP_TCP_SACK_OUT */
1854:lwIP/src/core/tcp_in.c ****               /* too much ooseq data, dump this and everything after it */
1855:lwIP/src/core/tcp_in.c ****               tcp_segs_free(next);
1856:lwIP/src/core/tcp_in.c ****               if (prev == NULL) {
1857:lwIP/src/core/tcp_in.c ****                 /* first ooseq segment is too much, dump the whole queue */
1858:lwIP/src/core/tcp_in.c ****                 pcb->ooseq = NULL;
1859:lwIP/src/core/tcp_in.c ****               } else {
1860:lwIP/src/core/tcp_in.c ****                 /* just dump 'next' and everything after it */
1861:lwIP/src/core/tcp_in.c ****                 prev->next = NULL;
1862:lwIP/src/core/tcp_in.c ****               }
1863:lwIP/src/core/tcp_in.c ****               break;
1864:lwIP/src/core/tcp_in.c ****             }
1865:lwIP/src/core/tcp_in.c ****           }
1866:lwIP/src/core/tcp_in.c ****         }
1867:lwIP/src/core/tcp_in.c **** #endif /* TCP_OOSEQ_BYTES_LIMIT || TCP_OOSEQ_PBUFS_LIMIT */
1868:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ */
1869:lwIP/src/core/tcp_in.c **** 
1870:lwIP/src/core/tcp_in.c ****         /* We send the ACK packet after we've (potentially) dealt with SACKs,
1871:lwIP/src/core/tcp_in.c ****            so they can be included in the acknowledgment. */
1872:lwIP/src/core/tcp_in.c ****         tcp_send_empty_ack(pcb);
1873:lwIP/src/core/tcp_in.c ****       }
1874:lwIP/src/core/tcp_in.c ****     } else {
1875:lwIP/src/core/tcp_in.c ****       /* The incoming segment is not within the window. */
1876:lwIP/src/core/tcp_in.c ****       tcp_send_empty_ack(pcb);
1877:lwIP/src/core/tcp_in.c ****     }
1878:lwIP/src/core/tcp_in.c ****   } else {
1879:lwIP/src/core/tcp_in.c ****     /* Segments with length 0 is taken care of here. Segments that
1880:lwIP/src/core/tcp_in.c ****        fall out of the window are ACKed. */
1881:lwIP/src/core/tcp_in.c ****     if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
1882:lwIP/src/core/tcp_in.c ****       tcp_ack_now(pcb);
1883:lwIP/src/core/tcp_in.c ****     }
1884:lwIP/src/core/tcp_in.c ****   }
1885:lwIP/src/core/tcp_in.c **** }
1886:lwIP/src/core/tcp_in.c **** 
1887:lwIP/src/core/tcp_in.c **** static u8_t
1888:lwIP/src/core/tcp_in.c **** tcp_get_next_optbyte(void)
1889:lwIP/src/core/tcp_in.c **** {
1890:lwIP/src/core/tcp_in.c ****   u16_t optidx = tcp_optidx++;
1891:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
1892:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
1893:lwIP/src/core/tcp_in.c ****     return opts[optidx];
1894:lwIP/src/core/tcp_in.c ****   } else {
1895:lwIP/src/core/tcp_in.c ****     u8_t idx = (u8_t)(optidx - tcphdr_opt1len);
1896:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
1897:lwIP/src/core/tcp_in.c ****   }
1898:lwIP/src/core/tcp_in.c **** }
1899:lwIP/src/core/tcp_in.c **** 
1900:lwIP/src/core/tcp_in.c **** /**
1901:lwIP/src/core/tcp_in.c ****  * Parses the options contained in the incoming segment.
1902:lwIP/src/core/tcp_in.c ****  *
ARM GAS  /tmp/ccFjUByx.s 			page 35


1903:lwIP/src/core/tcp_in.c ****  * Called from tcp_listen_input() and tcp_process().
1904:lwIP/src/core/tcp_in.c ****  * Currently, only the MSS option is supported!
1905:lwIP/src/core/tcp_in.c ****  *
1906:lwIP/src/core/tcp_in.c ****  * @param pcb the tcp_pcb for which a segment arrived
1907:lwIP/src/core/tcp_in.c ****  */
1908:lwIP/src/core/tcp_in.c **** static void
1909:lwIP/src/core/tcp_in.c **** tcp_parseopt(struct tcp_pcb *pcb)
1910:lwIP/src/core/tcp_in.c **** {
  34              		.loc 1 1910 1 view -0
  35              		.cfi_startproc
  36              		@ args = 0, pretend = 0, frame = 8
  37              		@ frame_needed = 0, uses_anonymous_args = 0
1911:lwIP/src/core/tcp_in.c ****   u8_t data;
  38              		.loc 1 1911 3 view .LVU1
1912:lwIP/src/core/tcp_in.c ****   u16_t mss;
  39              		.loc 1 1912 3 view .LVU2
1913:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_TIMESTAMPS
1914:lwIP/src/core/tcp_in.c ****   u32_t tsval;
1915:lwIP/src/core/tcp_in.c **** #endif
1916:lwIP/src/core/tcp_in.c **** 
1917:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);
  40              		.loc 1 1917 3 view .LVU3
  41              		.loc 1 1917 3 view .LVU4
1910:lwIP/src/core/tcp_in.c ****   u8_t data;
  42              		.loc 1 1910 1 is_stmt 0 view .LVU5
  43 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
  44              	.LCFI0:
  45              		.cfi_def_cfa_offset 36
  46              		.cfi_offset 4, -36
  47              		.cfi_offset 5, -32
  48              		.cfi_offset 6, -28
  49              		.cfi_offset 7, -24
  50              		.cfi_offset 8, -20
  51              		.cfi_offset 9, -16
  52              		.cfi_offset 10, -12
  53              		.cfi_offset 11, -8
  54              		.cfi_offset 14, -4
  55 0004 83B0     		sub	sp, sp, #12
  56              	.LCFI1:
  57              		.cfi_def_cfa_offset 48
  58              		.loc 1 1917 3 view .LVU6
  59 0006 0028     		cmp	r0, #0
  60 0008 00F09380 		beq	.L57
  61              		.loc 1 1917 3 is_stmt 1 discriminator 2 view .LVU7
1918:lwIP/src/core/tcp_in.c **** 
1919:lwIP/src/core/tcp_in.c ****   /* Parse the TCP MSS option, if present. */
1920:lwIP/src/core/tcp_in.c ****   if (tcphdr_optlen != 0) {
  62              		.loc 1 1920 3 discriminator 2 view .LVU8
  63              		.loc 1 1920 21 is_stmt 0 discriminator 2 view .LVU9
  64 000c 544B     		ldr	r3, .L63
  65 000e B3F800E0 		ldrh	lr, [r3]
  66              		.loc 1 1920 6 discriminator 2 view .LVU10
  67 0012 BEF1000F 		cmp	lr, #0
  68 0016 44D0     		beq	.L1
1921:lwIP/src/core/tcp_in.c ****     for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
  69              		.loc 1 1921 5 is_stmt 1 view .LVU11
  70              	.LBB92:
ARM GAS  /tmp/ccFjUByx.s 			page 36


  71              	.LBB93:
  72              	.LBB94:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
  73              		.loc 1 1891 40 is_stmt 0 view .LVU12
  74 0018 524A     		ldr	r2, .L63+4
  75              	.LBE94:
  76              	.LBE93:
  77              	.LBE92:
  78              		.loc 1 1921 21 view .LVU13
  79 001a 0023     		movs	r3, #0
  80 001c 524D     		ldr	r5, .L63+8
  81              	.LBB176:
1922:lwIP/src/core/tcp_in.c ****       u8_t opt = tcp_get_next_optbyte();
1923:lwIP/src/core/tcp_in.c ****       switch (opt) {
1924:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_EOL:
1925:lwIP/src/core/tcp_in.c ****           /* End of options. */
1926:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
1927:lwIP/src/core/tcp_in.c ****           return;
1928:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_NOP:
1929:lwIP/src/core/tcp_in.c ****           /* NOP option. */
1930:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
1931:lwIP/src/core/tcp_in.c ****           break;
1932:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_MSS:
1933:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
1934:lwIP/src/core/tcp_in.c ****           if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_
1935:lwIP/src/core/tcp_in.c ****             /* Bad length */
1936:lwIP/src/core/tcp_in.c ****             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
1937:lwIP/src/core/tcp_in.c ****             return;
1938:lwIP/src/core/tcp_in.c ****           }
1939:lwIP/src/core/tcp_in.c ****           /* An MSS option with the right option length. */
1940:lwIP/src/core/tcp_in.c ****           mss = (u16_t)(tcp_get_next_optbyte() << 8);
1941:lwIP/src/core/tcp_in.c ****           mss |= tcp_get_next_optbyte();
1942:lwIP/src/core/tcp_in.c ****           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
1943:lwIP/src/core/tcp_in.c ****           pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  82              		.loc 1 1943 20 view .LVU14
  83 001e 40F2B35B 		movw	fp, #1459
  84              	.LBB122:
  85              	.LBB108:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
  86              		.loc 1 1891 40 view .LVU15
  87 0022 1688     		ldrh	r6, [r2]
  88              	.LBE108:
  89              	.LBE122:
  90              	.LBE176:
1921:lwIP/src/core/tcp_in.c ****       u8_t opt = tcp_get_next_optbyte();
  91              		.loc 1 1921 5 view .LVU16
  92 0024 1F46     		mov	r7, r3
  93              	.LBB177:
  94              	.LBB123:
  95              	.LBB109:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
  96              		.loc 1 1891 20 view .LVU17
  97 0026 514C     		ldr	r4, .L63+12
  98              	.LBE109:
  99              	.LBE123:
 100              	.LBE177:
1921:lwIP/src/core/tcp_in.c ****       u8_t opt = tcp_get_next_optbyte();
ARM GAS  /tmp/ccFjUByx.s 			page 37


 101              		.loc 1 1921 5 view .LVU18
 102 0028 1A46     		mov	r2, r3
 103              	.LBB178:
 104              	.LBB124:
 105              	.LBB110:
 106              	.LBB95:
1895:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
 107              		.loc 1 1895 16 view .LVU19
 108 002a 5FFA86FC 		uxtb	ip, r6
 109              	.LBE95:
 110              	.LBB96:
1892:lwIP/src/core/tcp_in.c ****     return opts[optidx];
 111              		.loc 1 1892 18 view .LVU20
 112 002e 5049     		ldr	r1, .L63+16
 113              	.LBE96:
 114              	.LBE110:
 115              	.LBE124:
 116              	.LBE178:
1921:lwIP/src/core/tcp_in.c ****       u8_t opt = tcp_get_next_optbyte();
 117              		.loc 1 1921 21 view .LVU21
 118 0030 2B80     		strh	r3, [r5]	@ movhi
 119              	.LBB179:
 120              		.loc 1 1943 20 view .LVU22
 121 0032 40F2B45A 		movw	r10, #1460
 122              	.LBB125:
 123              	.LBB111:
 124              	.LBB97:
1896:lwIP/src/core/tcp_in.c ****   }
 125              		.loc 1 1896 23 view .LVU23
 126 0036 6FEA0C03 		mvn	r3, ip
 127              	.LBE97:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 128              		.loc 1 1891 20 view .LVU24
 129 003a 2468     		ldr	r4, [r4]
 130              	.LBB98:
1892:lwIP/src/core/tcp_in.c ****     return opts[optidx];
 131              		.loc 1 1892 18 view .LVU25
 132 003c 0968     		ldr	r1, [r1]
 133              	.LBE98:
 134              	.LBB99:
1896:lwIP/src/core/tcp_in.c ****   }
 135              		.loc 1 1896 23 view .LVU26
 136 003e 0193     		str	r3, [sp, #4]
 137 0040 E4B1     		cbz	r4, .L21
 138              	.L61:
 139 0042 02F11408 		add	r8, r2, #20
 140 0046 8844     		add	r8, r8, r1
 141              	.L29:
 142              	.LBE99:
 143              	.LBE111:
 144              	.LBE125:
 145              	.LBE179:
1921:lwIP/src/core/tcp_in.c ****       u8_t opt = tcp_get_next_optbyte();
 146              		.loc 1 1921 26 is_stmt 1 view .LVU27
 147              	.LBB180:
1922:lwIP/src/core/tcp_in.c ****       switch (opt) {
 148              		.loc 1 1922 7 view .LVU28
ARM GAS  /tmp/ccFjUByx.s 			page 38


 149              	.LBB126:
 150              	.LBI93:
1888:lwIP/src/core/tcp_in.c **** {
 151              		.loc 1 1888 1 view .LVU29
 152              	.LBB112:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 153              		.loc 1 1890 3 view .LVU30
 154              	.LBB100:
1892:lwIP/src/core/tcp_in.c ****     return opts[optidx];
 155              		.loc 1 1892 5 view .LVU31
 156              	.LVL1:
1893:lwIP/src/core/tcp_in.c ****   } else {
 157              		.loc 1 1893 5 view .LVU32
 158              	.LBE100:
 159              	.LBB101:
1895:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
 160              		.loc 1 1895 5 view .LVU33
1896:lwIP/src/core/tcp_in.c ****   }
 161              		.loc 1 1896 5 view .LVU34
 162              	.LBE101:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 163              		.loc 1 1890 28 is_stmt 0 view .LVU35
 164 0048 531C     		adds	r3, r2, #1
 165              	.LBE112:
 166              	.LBE126:
 167              	.LBE180:
1921:lwIP/src/core/tcp_in.c ****       u8_t opt = tcp_get_next_optbyte();
 168              		.loc 1 1921 5 view .LVU36
 169 004a 9645     		cmp	lr, r2
 170              	.LBB181:
 171              	.LBB127:
 172              	.LBB113:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 173              		.loc 1 1890 28 view .LVU37
 174 004c 9BB2     		uxth	r3, r3
 175              	.LVL2:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 176              		.loc 1 1891 3 is_stmt 1 view .LVU38
 177              	.LBE113:
 178              	.LBE127:
 179              	.LBE181:
1921:lwIP/src/core/tcp_in.c ****       u8_t opt = tcp_get_next_optbyte();
 180              		.loc 1 1921 5 is_stmt 0 view .LVU39
 181 004e 7DD9     		bls	.L22
 182              	.LBB182:
 183              	.LBB128:
 184              	.LBB114:
 185              	.LBB102:
1896:lwIP/src/core/tcp_in.c ****   }
 186              		.loc 1 1896 23 view .LVU40
 187 0050 019F     		ldr	r7, [sp, #4]
 188              	.LBE102:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 189              		.loc 1 1891 29 view .LVU41
 190 0052 9642     		cmp	r6, r2
 191              	.LBB103:
1896:lwIP/src/core/tcp_in.c ****   }
ARM GAS  /tmp/ccFjUByx.s 			page 39


 192              		.loc 1 1896 23 view .LVU42
 193 0054 1F44     		add	r7, r7, r3
 194 0056 FFB2     		uxtb	r7, r7
 195              	.LBE103:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 196              		.loc 1 1891 29 view .LVU43
 197 0058 26D8     		bhi	.L58
 198              	.LBB104:
1896:lwIP/src/core/tcp_in.c ****   }
 199              		.loc 1 1896 23 view .LVU44
 200 005a E75D     		ldrb	r7, [r4, r7]	@ zero_extendqisi2
 201              	.LVL3:
1896:lwIP/src/core/tcp_in.c ****   }
 202              		.loc 1 1896 23 view .LVU45
 203              	.LBE104:
 204              	.LBE114:
 205              	.LBE128:
1923:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_EOL:
 206              		.loc 1 1923 7 is_stmt 1 view .LVU46
 207 005c 012F     		cmp	r7, #1
 208 005e 27D0     		beq	.L24
 209              	.L25:
1923:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_EOL:
 210              		.loc 1 1923 7 is_stmt 0 view .LVU47
 211 0060 022F     		cmp	r7, #2
 212 0062 2AD0     		beq	.L26
 213 0064 E7B1     		cbz	r7, .L27
1944:lwIP/src/core/tcp_in.c ****           break;
1945:lwIP/src/core/tcp_in.c **** #if LWIP_WND_SCALE
1946:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_WS:
1947:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: WND_SCALE\n"));
1948:lwIP/src/core/tcp_in.c ****           if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_WS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_W
1949:lwIP/src/core/tcp_in.c ****             /* Bad length */
1950:lwIP/src/core/tcp_in.c ****             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
1951:lwIP/src/core/tcp_in.c ****             return;
1952:lwIP/src/core/tcp_in.c ****           }
1953:lwIP/src/core/tcp_in.c ****           /* An WND_SCALE option with the right option length. */
1954:lwIP/src/core/tcp_in.c ****           data = tcp_get_next_optbyte();
1955:lwIP/src/core/tcp_in.c ****           /* If syn was received with wnd scale option,
1956:lwIP/src/core/tcp_in.c ****              activate wnd scale opt, but only if this is not a retransmission */
1957:lwIP/src/core/tcp_in.c ****           if ((flags & TCP_SYN) && !(pcb->flags & TF_WND_SCALE)) {
1958:lwIP/src/core/tcp_in.c ****             pcb->snd_scale = data;
1959:lwIP/src/core/tcp_in.c ****             if (pcb->snd_scale > 14U) {
1960:lwIP/src/core/tcp_in.c ****               pcb->snd_scale = 14U;
1961:lwIP/src/core/tcp_in.c ****             }
1962:lwIP/src/core/tcp_in.c ****             pcb->rcv_scale = TCP_RCV_SCALE;
1963:lwIP/src/core/tcp_in.c ****             tcp_set_flags(pcb, TF_WND_SCALE);
1964:lwIP/src/core/tcp_in.c ****             /* window scaling is enabled, we can use the full receive window */
1965:lwIP/src/core/tcp_in.c ****             LWIP_ASSERT("window not at default value", pcb->rcv_wnd == TCPWND_MIN16(TCP_WND));
1966:lwIP/src/core/tcp_in.c ****             LWIP_ASSERT("window not at default value", pcb->rcv_ann_wnd == TCPWND_MIN16(TCP_WND));
1967:lwIP/src/core/tcp_in.c ****             pcb->rcv_wnd = pcb->rcv_ann_wnd = TCP_WND;
1968:lwIP/src/core/tcp_in.c ****           }
1969:lwIP/src/core/tcp_in.c ****           break;
1970:lwIP/src/core/tcp_in.c **** #endif /* LWIP_WND_SCALE */
1971:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_TIMESTAMPS
1972:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_TS:
1973:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
ARM GAS  /tmp/ccFjUByx.s 			page 40


1974:lwIP/src/core/tcp_in.c ****           if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_TS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_T
1975:lwIP/src/core/tcp_in.c ****             /* Bad length */
1976:lwIP/src/core/tcp_in.c ****             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
1977:lwIP/src/core/tcp_in.c ****             return;
1978:lwIP/src/core/tcp_in.c ****           }
1979:lwIP/src/core/tcp_in.c ****           /* TCP timestamp option with valid length */
1980:lwIP/src/core/tcp_in.c ****           tsval = tcp_get_next_optbyte();
1981:lwIP/src/core/tcp_in.c ****           tsval |= (tcp_get_next_optbyte() << 8);
1982:lwIP/src/core/tcp_in.c ****           tsval |= (tcp_get_next_optbyte() << 16);
1983:lwIP/src/core/tcp_in.c ****           tsval |= (tcp_get_next_optbyte() << 24);
1984:lwIP/src/core/tcp_in.c ****           if (flags & TCP_SYN) {
1985:lwIP/src/core/tcp_in.c ****             pcb->ts_recent = lwip_ntohl(tsval);
1986:lwIP/src/core/tcp_in.c ****             /* Enable sending timestamps in every segment now that we know
1987:lwIP/src/core/tcp_in.c ****                the remote host supports it. */
1988:lwIP/src/core/tcp_in.c ****             tcp_set_flags(pcb, TF_TIMESTAMP);
1989:lwIP/src/core/tcp_in.c ****           } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno + tcplen)) {
1990:lwIP/src/core/tcp_in.c ****             pcb->ts_recent = lwip_ntohl(tsval);
1991:lwIP/src/core/tcp_in.c ****           }
1992:lwIP/src/core/tcp_in.c ****           /* Advance to next option (6 bytes already read) */
1993:lwIP/src/core/tcp_in.c ****           tcp_optidx += LWIP_TCP_OPT_LEN_TS - 6;
1994:lwIP/src/core/tcp_in.c ****           break;
1995:lwIP/src/core/tcp_in.c **** #endif /* LWIP_TCP_TIMESTAMPS */
1996:lwIP/src/core/tcp_in.c **** #if LWIP_TCP_SACK_OUT
1997:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_SACK_PERM:
1998:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: SACK_PERM\n"));
1999:lwIP/src/core/tcp_in.c ****           if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_SACK_PERM || (tcp_optidx - 2 + LWIP_TCP_OP
2000:lwIP/src/core/tcp_in.c ****             /* Bad length */
2001:lwIP/src/core/tcp_in.c ****             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
2002:lwIP/src/core/tcp_in.c ****             return;
2003:lwIP/src/core/tcp_in.c ****           }
2004:lwIP/src/core/tcp_in.c ****           /* TCP SACK_PERM option with valid length */
2005:lwIP/src/core/tcp_in.c ****           if (flags & TCP_SYN) {
2006:lwIP/src/core/tcp_in.c ****             /* We only set it if we receive it in a SYN (or SYN+ACK) packet */
2007:lwIP/src/core/tcp_in.c ****             tcp_set_flags(pcb, TF_SACK);
2008:lwIP/src/core/tcp_in.c ****           }
2009:lwIP/src/core/tcp_in.c ****           break;
2010:lwIP/src/core/tcp_in.c **** #endif /* LWIP_TCP_SACK_OUT */
2011:lwIP/src/core/tcp_in.c ****         default:
2012:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
 214              		.loc 1 2012 66 is_stmt 1 view .LVU48
2013:lwIP/src/core/tcp_in.c ****           data = tcp_get_next_optbyte();
 215              		.loc 1 2013 11 view .LVU49
 216              	.LBB129:
 217              	.LBI129:
1888:lwIP/src/core/tcp_in.c **** {
 218              		.loc 1 1888 1 view .LVU50
 219              	.LBB130:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 220              		.loc 1 1890 3 view .LVU51
 221              	.LVL4:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 222              		.loc 1 1891 3 view .LVU52
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 223              		.loc 1 1891 29 is_stmt 0 view .LVU53
 224 0066 9E42     		cmp	r6, r3
 225 0068 5ED9     		bls	.L59
 226              	.LVL5:
ARM GAS  /tmp/ccFjUByx.s 			page 41


 227              	.L9:
 228              	.LBB131:
1892:lwIP/src/core/tcp_in.c ****     return opts[optidx];
 229              		.loc 1 1892 5 is_stmt 1 view .LVU54
1893:lwIP/src/core/tcp_in.c ****   } else {
 230              		.loc 1 1893 5 view .LVU55
1893:lwIP/src/core/tcp_in.c ****   } else {
 231              		.loc 1 1893 16 is_stmt 0 view .LVU56
 232 006a 0B44     		add	r3, r3, r1
 233 006c 1B7D     		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 234              	.LVL6:
 235              	.L19:
1893:lwIP/src/core/tcp_in.c ****   } else {
 236              		.loc 1 1893 16 view .LVU57
 237              	.LBE131:
 238              	.LBE130:
 239              	.LBE129:
2014:lwIP/src/core/tcp_in.c ****           if (data < 2) {
 240              		.loc 1 2014 11 is_stmt 1 view .LVU58
 241              		.loc 1 2014 14 is_stmt 0 view .LVU59
 242 006e 012B     		cmp	r3, #1
 243 0070 72D9     		bls	.L60
2015:lwIP/src/core/tcp_in.c ****             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
2016:lwIP/src/core/tcp_in.c ****             /* If the length field is zero, the options are malformed
2017:lwIP/src/core/tcp_in.c ****                and we don't process them further. */
2018:lwIP/src/core/tcp_in.c ****             return;
2019:lwIP/src/core/tcp_in.c ****           }
2020:lwIP/src/core/tcp_in.c ****           /* All other options have a length field, so that we easily
2021:lwIP/src/core/tcp_in.c ****              can skip past them. */
2022:lwIP/src/core/tcp_in.c ****           tcp_optidx += data - 2;
 244              		.loc 1 2022 11 is_stmt 1 view .LVU60
 245              		.loc 1 2022 22 is_stmt 0 view .LVU61
 246 0072 1A44     		add	r2, r2, r3
 247 0074 92B2     		uxth	r2, r2
 248              	.LVL7:
 249              	.L18:
1943:lwIP/src/core/tcp_in.c ****           break;
 250              		.loc 1 1943 20 discriminator 1 view .LVU62
 251 0076 0127     		movs	r7, #1
 252 0078 002C     		cmp	r4, #0
 253 007a E2D1     		bne	.L61
 254              	.L21:
 255 007c 02F11308 		add	r8, r2, #19
 256 0080 8844     		add	r8, r8, r1
 257              	.L7:
1922:lwIP/src/core/tcp_in.c ****       switch (opt) {
 258              		.loc 1 1922 7 is_stmt 1 discriminator 1 view .LVU63
 259              	.LBB135:
1888:lwIP/src/core/tcp_in.c **** {
 260              		.loc 1 1888 1 discriminator 1 view .LVU64
 261              	.LBB115:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 262              		.loc 1 1890 3 discriminator 1 view .LVU65
 263              	.LBE115:
 264              	.LBE135:
 265              	.LBE182:
1921:lwIP/src/core/tcp_in.c ****       u8_t opt = tcp_get_next_optbyte();
ARM GAS  /tmp/ccFjUByx.s 			page 42


 266              		.loc 1 1921 26 discriminator 1 view .LVU66
 267              	.LBB183:
 268              	.LBB136:
 269              	.LBB116:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 270              		.loc 1 1890 28 is_stmt 0 discriminator 1 view .LVU67
 271 0082 531C     		adds	r3, r2, #1
 272              	.LBE116:
 273              	.LBE136:
 274              	.LBE183:
1921:lwIP/src/core/tcp_in.c ****       u8_t opt = tcp_get_next_optbyte();
 275              		.loc 1 1921 5 discriminator 1 view .LVU68
 276 0084 9645     		cmp	lr, r2
 277              	.LBB184:
 278              	.LBB137:
 279              	.LBB117:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 280              		.loc 1 1890 28 discriminator 1 view .LVU69
 281 0086 9BB2     		uxth	r3, r3
 282              	.LVL8:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 283              		.loc 1 1891 3 is_stmt 1 discriminator 1 view .LVU70
 284              	.LBB105:
1892:lwIP/src/core/tcp_in.c ****     return opts[optidx];
 285              		.loc 1 1892 5 discriminator 1 view .LVU71
1893:lwIP/src/core/tcp_in.c ****   } else {
 286              		.loc 1 1893 5 discriminator 1 view .LVU72
 287              	.LBE105:
 288              	.LBE117:
 289              	.LBE137:
 290              	.LBE184:
1921:lwIP/src/core/tcp_in.c ****       u8_t opt = tcp_get_next_optbyte();
 291              		.loc 1 1921 5 is_stmt 0 discriminator 1 view .LVU73
 292 0088 60D9     		bls	.L22
 293              	.LBB185:
 294              	.LBB138:
 295              	.LBB118:
 296              	.LBB106:
1893:lwIP/src/core/tcp_in.c ****   } else {
 297              		.loc 1 1893 16 view .LVU74
 298 008a 18F8019F 		ldrb	r9, [r8, #1]!	@ zero_extendqisi2
 299              	.LVL9:
1893:lwIP/src/core/tcp_in.c ****   } else {
 300              		.loc 1 1893 16 view .LVU75
 301              	.LBE106:
 302              	.LBE118:
 303              	.LBE138:
1923:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_EOL:
 304              		.loc 1 1923 7 is_stmt 1 view .LVU76
 305 008e 0127     		movs	r7, #1
 306 0090 B945     		cmp	r9, r7
 307 0092 55D0     		beq	.L37
 308 0094 B9F1020F 		cmp	r9, #2
 309 0098 4FD0     		beq	.L8
 310 009a B9F1000F 		cmp	r9, #0
 311 009e E4D1     		bne	.L9
 312              	.LVL10:
ARM GAS  /tmp/ccFjUByx.s 			page 43


 313              	.L27:
1923:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_EOL:
 314              		.loc 1 1923 7 is_stmt 0 view .LVU77
 315 00a0 2B80     		strh	r3, [r5]	@ movhi
 316              	.L1:
 317              	.LBE185:
2023:lwIP/src/core/tcp_in.c ****       }
2024:lwIP/src/core/tcp_in.c ****     }
2025:lwIP/src/core/tcp_in.c ****   }
2026:lwIP/src/core/tcp_in.c **** }
 318              		.loc 1 2026 1 view .LVU78
 319 00a2 03B0     		add	sp, sp, #12
 320              	.LCFI2:
 321              		.cfi_remember_state
 322              		.cfi_def_cfa_offset 36
 323              		@ sp needed
 324 00a4 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 325              	.LVL11:
 326              	.L58:
 327              	.LCFI3:
 328              		.cfi_restore_state
 329              	.LBB186:
 330              	.LBB139:
 331              	.LBB119:
 332              	.LBB107:
1893:lwIP/src/core/tcp_in.c ****   } else {
 333              		.loc 1 1893 16 view .LVU79
 334 00a8 98F80070 		ldrb	r7, [r8]	@ zero_extendqisi2
 335              	.LVL12:
1893:lwIP/src/core/tcp_in.c ****   } else {
 336              		.loc 1 1893 16 view .LVU80
 337              	.LBE107:
 338              	.LBE119:
 339              	.LBE139:
1923:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_EOL:
 340              		.loc 1 1923 7 is_stmt 1 view .LVU81
 341 00ac 012F     		cmp	r7, #1
 342 00ae D7D1     		bne	.L25
 343              	.L24:
1923:lwIP/src/core/tcp_in.c ****         case LWIP_TCP_OPT_EOL:
 344              		.loc 1 1923 7 is_stmt 0 view .LVU82
 345 00b0 08F10108 		add	r8, r8, #1
 346              	.LBB140:
 347              	.LBB120:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 348              		.loc 1 1890 28 view .LVU83
 349 00b4 1A46     		mov	r2, r3
 350              	.LVL13:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 351              		.loc 1 1890 28 view .LVU84
 352 00b6 0127     		movs	r7, #1
 353              	.LVL14:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 354              		.loc 1 1890 28 view .LVU85
 355 00b8 C6E7     		b	.L29
 356              	.LVL15:
 357              	.L26:
ARM GAS  /tmp/ccFjUByx.s 			page 44


1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 358              		.loc 1 1890 28 view .LVU86
 359              	.LBE120:
 360              	.LBE140:
1933:lwIP/src/core/tcp_in.c ****           if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_
 361              		.loc 1 1933 64 is_stmt 1 view .LVU87
1934:lwIP/src/core/tcp_in.c ****             /* Bad length */
 362              		.loc 1 1934 11 view .LVU88
 363              	.LBB141:
 364              	.LBI141:
1888:lwIP/src/core/tcp_in.c **** {
 365              		.loc 1 1888 1 view .LVU89
 366              	.LBB142:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 367              		.loc 1 1890 3 view .LVU90
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 368              		.loc 1 1890 28 is_stmt 0 view .LVU91
 369 00ba 971C     		adds	r7, r2, #2
 370              	.LVL16:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 371              		.loc 1 1891 29 view .LVU92
 372 00bc 9E42     		cmp	r6, r3
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 373              		.loc 1 1890 28 view .LVU93
 374 00be BFB2     		uxth	r7, r7
 375              	.LVL17:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 376              		.loc 1 1891 3 is_stmt 1 view .LVU94
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 377              		.loc 1 1891 29 is_stmt 0 view .LVU95
 378 00c0 2DD9     		bls	.L62
 379              	.LVL18:
 380              	.L35:
 381              	.LBB143:
1892:lwIP/src/core/tcp_in.c ****     return opts[optidx];
 382              		.loc 1 1892 5 is_stmt 1 view .LVU96
1893:lwIP/src/core/tcp_in.c ****   } else {
 383              		.loc 1 1893 5 view .LVU97
1893:lwIP/src/core/tcp_in.c ****   } else {
 384              		.loc 1 1893 16 is_stmt 0 view .LVU98
 385 00c2 0B44     		add	r3, r3, r1
 386              	.LVL19:
1893:lwIP/src/core/tcp_in.c ****   } else {
 387              		.loc 1 1893 16 view .LVU99
 388 00c4 1B7D     		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 389              	.LVL20:
 390              	.L10:
1893:lwIP/src/core/tcp_in.c ****   } else {
 391              		.loc 1 1893 16 view .LVU100
 392              	.LBE143:
 393              	.LBE142:
 394              	.LBE141:
1934:lwIP/src/core/tcp_in.c ****             /* Bad length */
 395              		.loc 1 1934 14 view .LVU101
 396 00c6 042B     		cmp	r3, #4
 397 00c8 44D1     		bne	.L55
1934:lwIP/src/core/tcp_in.c ****             /* Bad length */
ARM GAS  /tmp/ccFjUByx.s 			page 45


 398              		.loc 1 1934 105 discriminator 1 view .LVU102
 399 00ca 7B1C     		adds	r3, r7, #1
1934:lwIP/src/core/tcp_in.c ****             /* Bad length */
 400              		.loc 1 1934 62 discriminator 1 view .LVU103
 401 00cc 7345     		cmp	r3, lr
 402 00ce 41DA     		bge	.L55
1940:lwIP/src/core/tcp_in.c ****           mss |= tcp_get_next_optbyte();
 403              		.loc 1 1940 11 is_stmt 1 view .LVU104
 404              	.LBB147:
 405              	.LBI147:
1888:lwIP/src/core/tcp_in.c **** {
 406              		.loc 1 1888 1 view .LVU105
 407              	.LBB148:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 408              		.loc 1 1890 3 view .LVU106
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 409              		.loc 1 1890 28 is_stmt 0 view .LVU107
 410 00d0 D31C     		adds	r3, r2, #3
 411 00d2 0432     		adds	r2, r2, #4
 412 00d4 1FFA83F8 		uxth	r8, r3
 413              	.LVL21:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 414              		.loc 1 1891 3 is_stmt 1 view .LVU108
 415 00d8 92B2     		uxth	r2, r2
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 416              		.loc 1 1891 6 is_stmt 0 view .LVU109
 417 00da 002C     		cmp	r4, #0
 418 00dc 32D0     		beq	.L13
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 419              		.loc 1 1891 29 view .LVU110
 420 00de BE42     		cmp	r6, r7
 421 00e0 13D8     		bhi	.L14
 422              	.LBB149:
1895:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
 423              		.loc 1 1895 5 is_stmt 1 view .LVU111
 424              	.LVL22:
1896:lwIP/src/core/tcp_in.c ****   }
 425              		.loc 1 1896 5 view .LVU112
1895:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
 426              		.loc 1 1895 10 is_stmt 0 view .LVU113
 427 00e2 A7EB0C07 		sub	r7, r7, ip
 428              	.LVL23:
1895:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
 429              		.loc 1 1895 10 view .LVU114
 430              	.LBE149:
 431              	.LBE148:
 432              	.LBE147:
 433              	.LBB156:
 434              	.LBB157:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 435              		.loc 1 1891 29 view .LVU115
 436 00e6 4645     		cmp	r6, r8
 437              	.LBE157:
 438              	.LBE156:
 439              	.LBB164:
 440              	.LBB153:
 441              	.LBB150:
ARM GAS  /tmp/ccFjUByx.s 			page 46


1896:lwIP/src/core/tcp_in.c ****   }
 442              		.loc 1 1896 23 view .LVU116
 443 00e8 FFB2     		uxtb	r7, r7
 444              	.LBE150:
 445              	.LBE153:
 446              	.LBE164:
1940:lwIP/src/core/tcp_in.c ****           mss |= tcp_get_next_optbyte();
 447              		.loc 1 1940 25 view .LVU117
 448 00ea E35D     		ldrb	r3, [r4, r7]	@ zero_extendqisi2
1940:lwIP/src/core/tcp_in.c ****           mss |= tcp_get_next_optbyte();
 449              		.loc 1 1940 15 view .LVU118
 450 00ec 4FEA0327 		lsl	r7, r3, #8
 451              	.LVL24:
1941:lwIP/src/core/tcp_in.c ****           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
 452              		.loc 1 1941 11 is_stmt 1 view .LVU119
 453              	.LBB165:
 454              	.LBI156:
1888:lwIP/src/core/tcp_in.c **** {
 455              		.loc 1 1888 1 view .LVU120
 456              	.LBB160:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 457              		.loc 1 1890 3 view .LVU121
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 458              		.loc 1 1891 3 view .LVU122
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 459              		.loc 1 1891 29 is_stmt 0 view .LVU123
 460 00f0 11D8     		bhi	.L33
 461              	.L15:
 462              	.LBB158:
1895:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
 463              		.loc 1 1895 5 is_stmt 1 view .LVU124
 464              	.LVL25:
1896:lwIP/src/core/tcp_in.c ****   }
 465              		.loc 1 1896 5 view .LVU125
1895:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
 466              		.loc 1 1895 10 is_stmt 0 view .LVU126
 467 00f2 A8EB0C03 		sub	r3, r8, ip
1896:lwIP/src/core/tcp_in.c ****   }
 468              		.loc 1 1896 23 view .LVU127
 469 00f6 DBB2     		uxtb	r3, r3
 470 00f8 E35C     		ldrb	r3, [r4, r3]	@ zero_extendqisi2
 471              	.LVL26:
 472              	.L16:
1896:lwIP/src/core/tcp_in.c ****   }
 473              		.loc 1 1896 23 view .LVU128
 474              	.LBE158:
 475              	.LBE160:
 476              	.LBE165:
1941:lwIP/src/core/tcp_in.c ****           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
 477              		.loc 1 1941 15 view .LVU129
 478 00fa 3B43     		orrs	r3, r3, r7
 479              	.LVL27:
1943:lwIP/src/core/tcp_in.c ****           break;
 480              		.loc 1 1943 11 is_stmt 1 view .LVU130
1943:lwIP/src/core/tcp_in.c ****           break;
 481              		.loc 1 1943 39 is_stmt 0 view .LVU131
 482 00fc 5F1E     		subs	r7, r3, #1
ARM GAS  /tmp/ccFjUByx.s 			page 47


1943:lwIP/src/core/tcp_in.c ****           break;
 483              		.loc 1 1943 20 view .LVU132
 484 00fe BFB2     		uxth	r7, r7
 485 0100 5F45     		cmp	r7, fp
 486 0102 88BF     		it	hi
 487 0104 5346     		movhi	r3, r10
 488              	.LVL28:
1943:lwIP/src/core/tcp_in.c ****           break;
 489              		.loc 1 1943 20 view .LVU133
 490 0106 4386     		strh	r3, [r0, #50]	@ movhi
1944:lwIP/src/core/tcp_in.c **** #if LWIP_WND_SCALE
 491              		.loc 1 1944 11 is_stmt 1 view .LVU134
 492 0108 B5E7     		b	.L18
 493              	.LVL29:
 494              	.L14:
 495              	.LBB166:
 496              	.LBB154:
 497              	.LBB151:
1892:lwIP/src/core/tcp_in.c ****     return opts[optidx];
 498              		.loc 1 1892 5 view .LVU135
1893:lwIP/src/core/tcp_in.c ****   } else {
 499              		.loc 1 1893 5 view .LVU136
1893:lwIP/src/core/tcp_in.c ****   } else {
 500              		.loc 1 1893 16 is_stmt 0 view .LVU137
 501 010a 0F44     		add	r7, r7, r1
 502              	.LVL30:
1893:lwIP/src/core/tcp_in.c ****   } else {
 503              		.loc 1 1893 16 view .LVU138
 504              	.LBE151:
 505              	.LBE154:
 506              	.LBE166:
 507              	.LBB167:
 508              	.LBB161:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 509              		.loc 1 1891 29 view .LVU139
 510 010c 4645     		cmp	r6, r8
 511              	.LBE161:
 512              	.LBE167:
1940:lwIP/src/core/tcp_in.c ****           mss |= tcp_get_next_optbyte();
 513              		.loc 1 1940 25 view .LVU140
 514 010e 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
1940:lwIP/src/core/tcp_in.c ****           mss |= tcp_get_next_optbyte();
 515              		.loc 1 1940 15 view .LVU141
 516 0110 4FEA0327 		lsl	r7, r3, #8
 517              	.LVL31:
1941:lwIP/src/core/tcp_in.c ****           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
 518              		.loc 1 1941 11 is_stmt 1 view .LVU142
 519              	.LBB168:
1888:lwIP/src/core/tcp_in.c **** {
 520              		.loc 1 1888 1 view .LVU143
 521              	.LBB162:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 522              		.loc 1 1890 3 view .LVU144
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 523              		.loc 1 1891 3 view .LVU145
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 524              		.loc 1 1891 29 is_stmt 0 view .LVU146
ARM GAS  /tmp/ccFjUByx.s 			page 48


 525 0114 EDD9     		bls	.L15
 526              	.LVL32:
 527              	.L33:
 528              	.LBB159:
1892:lwIP/src/core/tcp_in.c ****     return opts[optidx];
 529              		.loc 1 1892 5 is_stmt 1 view .LVU147
1893:lwIP/src/core/tcp_in.c ****   } else {
 530              		.loc 1 1893 5 view .LVU148
1893:lwIP/src/core/tcp_in.c ****   } else {
 531              		.loc 1 1893 16 is_stmt 0 view .LVU149
 532 0116 01EB0803 		add	r3, r1, r8
 533 011a 1B7D     		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 534 011c EDE7     		b	.L16
 535              	.LVL33:
 536              	.L62:
1893:lwIP/src/core/tcp_in.c ****   } else {
 537              		.loc 1 1893 16 view .LVU150
 538              	.LBE159:
 539              	.LBE162:
 540              	.LBE168:
 541              	.LBB169:
 542              	.LBB145:
 543              	.LBB144:
1895:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
 544              		.loc 1 1895 5 is_stmt 1 view .LVU151
1896:lwIP/src/core/tcp_in.c ****   }
 545              		.loc 1 1896 5 view .LVU152
1895:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
 546              		.loc 1 1895 10 is_stmt 0 view .LVU153
 547 011e A3EB0C03 		sub	r3, r3, ip
 548              	.LVL34:
1896:lwIP/src/core/tcp_in.c ****   }
 549              		.loc 1 1896 23 view .LVU154
 550 0122 DBB2     		uxtb	r3, r3
 551 0124 E35C     		ldrb	r3, [r4, r3]	@ zero_extendqisi2
 552 0126 CEE7     		b	.L10
 553              	.LVL35:
 554              	.L59:
1896:lwIP/src/core/tcp_in.c ****   }
 555              		.loc 1 1896 23 view .LVU155
 556              	.LBE144:
 557              	.LBE145:
 558              	.LBE169:
 559              	.LBB170:
 560              	.LBB133:
 561              	.LBB132:
1895:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
 562              		.loc 1 1895 5 is_stmt 1 view .LVU156
1896:lwIP/src/core/tcp_in.c ****   }
 563              		.loc 1 1896 5 view .LVU157
1895:lwIP/src/core/tcp_in.c ****     return tcphdr_opt2[idx];
 564              		.loc 1 1895 10 is_stmt 0 view .LVU158
 565 0128 A3EB0C03 		sub	r3, r3, ip
 566              	.LVL36:
1896:lwIP/src/core/tcp_in.c ****   }
 567              		.loc 1 1896 23 view .LVU159
 568 012c DBB2     		uxtb	r3, r3
ARM GAS  /tmp/ccFjUByx.s 			page 49


 569 012e E35C     		ldrb	r3, [r4, r3]	@ zero_extendqisi2
 570 0130 9DE7     		b	.L19
 571              	.LVL37:
 572              	.L57:
1896:lwIP/src/core/tcp_in.c ****   }
 573              		.loc 1 1896 23 view .LVU160
 574              	.LBE132:
 575              	.LBE133:
 576              	.LBE170:
 577              	.LBE186:
1917:lwIP/src/core/tcp_in.c **** 
 578              		.loc 1 1917 3 is_stmt 1 discriminator 1 view .LVU161
 579 0132 1048     		ldr	r0, .L63+20
 580              	.LVL38:
1917:lwIP/src/core/tcp_in.c **** 
 581              		.loc 1 1917 3 is_stmt 0 discriminator 1 view .LVU162
 582 0134 FFF7FEFF 		bl	printf
 583              	.LVL39:
 584              	.L3:
1917:lwIP/src/core/tcp_in.c **** 
 585              		.loc 1 1917 3 is_stmt 1 discriminator 1 view .LVU163
1917:lwIP/src/core/tcp_in.c **** 
 586              		.loc 1 1917 3 discriminator 1 view .LVU164
1917:lwIP/src/core/tcp_in.c **** 
 587              		.loc 1 1917 3 discriminator 1 view .LVU165
1917:lwIP/src/core/tcp_in.c **** 
 588              		.loc 1 1917 3 discriminator 1 view .LVU166
1917:lwIP/src/core/tcp_in.c **** 
 589              		.loc 1 1917 3 discriminator 1 view .LVU167
1917:lwIP/src/core/tcp_in.c **** 
 590              		.loc 1 1917 3 discriminator 1 view .LVU168
 591 0138 FEE7     		b	.L3
 592              	.LVL40:
 593              	.L8:
 594              	.LBB187:
1933:lwIP/src/core/tcp_in.c ****           if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_
 595              		.loc 1 1933 64 view .LVU169
1934:lwIP/src/core/tcp_in.c ****             /* Bad length */
 596              		.loc 1 1934 11 view .LVU170
 597              	.LBB171:
1888:lwIP/src/core/tcp_in.c **** {
 598              		.loc 1 1888 1 view .LVU171
 599              	.LBB146:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 600              		.loc 1 1890 3 view .LVU172
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 601              		.loc 1 1890 28 is_stmt 0 view .LVU173
 602 013a 971C     		adds	r7, r2, #2
 603 013c BFB2     		uxth	r7, r7
 604              	.LVL41:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 605              		.loc 1 1891 3 is_stmt 1 view .LVU174
 606 013e C0E7     		b	.L35
 607              	.LVL42:
 608              	.L37:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 609              		.loc 1 1891 3 is_stmt 0 view .LVU175
ARM GAS  /tmp/ccFjUByx.s 			page 50


 610              	.LBE146:
 611              	.LBE171:
 612              	.LBB172:
 613              	.LBB121:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 614              		.loc 1 1890 28 view .LVU176
 615 0140 1A46     		mov	r2, r3
 616              	.LVL43:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 617              		.loc 1 1890 28 view .LVU177
 618 0142 9EE7     		b	.L7
 619              	.LVL44:
 620              	.L13:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 621              		.loc 1 1890 28 view .LVU178
 622              	.LBE121:
 623              	.LBE172:
 624              	.LBB173:
 625              	.LBB155:
 626              	.LBB152:
1892:lwIP/src/core/tcp_in.c ****     return opts[optidx];
 627              		.loc 1 1892 5 is_stmt 1 view .LVU179
1893:lwIP/src/core/tcp_in.c ****   } else {
 628              		.loc 1 1893 5 view .LVU180
1893:lwIP/src/core/tcp_in.c ****   } else {
 629              		.loc 1 1893 16 is_stmt 0 view .LVU181
 630 0144 0F44     		add	r7, r7, r1
 631              	.LVL45:
1893:lwIP/src/core/tcp_in.c ****   } else {
 632              		.loc 1 1893 16 view .LVU182
 633              	.LBE152:
 634              	.LBE155:
 635              	.LBE173:
1940:lwIP/src/core/tcp_in.c ****           mss |= tcp_get_next_optbyte();
 636              		.loc 1 1940 25 view .LVU183
 637 0146 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
1940:lwIP/src/core/tcp_in.c ****           mss |= tcp_get_next_optbyte();
 638              		.loc 1 1940 15 view .LVU184
 639 0148 1F02     		lsls	r7, r3, #8
 640              	.LVL46:
1941:lwIP/src/core/tcp_in.c ****           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
 641              		.loc 1 1941 11 is_stmt 1 view .LVU185
 642              	.LBB174:
1888:lwIP/src/core/tcp_in.c **** {
 643              		.loc 1 1888 1 view .LVU186
 644              	.LBB163:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 645              		.loc 1 1890 3 view .LVU187
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 646              		.loc 1 1891 3 view .LVU188
 647 014a E4E7     		b	.L33
 648              	.LVL47:
 649              	.L22:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 650              		.loc 1 1891 3 is_stmt 0 view .LVU189
 651 014c 002F     		cmp	r7, #0
 652 014e A8D0     		beq	.L1
ARM GAS  /tmp/ccFjUByx.s 			page 51


 653 0150 2A80     		strh	r2, [r5]	@ movhi
 654 0152 A6E7     		b	.L1
 655              	.L55:
 656 0154 2F80     		strh	r7, [r5]	@ movhi
 657 0156 A4E7     		b	.L1
 658              	.LVL48:
 659              	.L60:
1891:lwIP/src/core/tcp_in.c ****     u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 660              		.loc 1 1891 3 view .LVU190
 661              	.LBE163:
 662              	.LBE174:
 663              	.LBB175:
 664              	.LBB134:
1890:lwIP/src/core/tcp_in.c ****   if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 665              		.loc 1 1890 28 view .LVU191
 666 0158 0232     		adds	r2, r2, #2
 667 015a 2A80     		strh	r2, [r5]	@ movhi
 668 015c A1E7     		b	.L1
 669              	.L64:
 670 015e 00BF     		.align	2
 671              	.L63:
 672 0160 00000000 		.word	.LANCHOR0
 673 0164 00000000 		.word	.LANCHOR3
 674 0168 00000000 		.word	.LANCHOR1
 675 016c 00000000 		.word	.LANCHOR2
 676 0170 00000000 		.word	.LANCHOR4
 677 0174 00000000 		.word	.LC0
 678              	.LBE134:
 679              	.LBE175:
 680              	.LBE187:
 681              		.cfi_endproc
 682              	.LFE113:
 684              		.section	.rodata.tcp_input_delayed_close.str1.4,"aMS",%progbits,1
 685              		.align	2
 686              	.LC1:
 687 0000 7463705F 		.ascii	"tcp_input_delayed_close: invalid pcb\000"
 687      696E7075 
 687      745F6465 
 687      6C617965 
 687      645F636C 
 688              		.section	.text.tcp_input_delayed_close,"ax",%progbits
 689              		.align	1
 690              		.p2align 2,,3
 691              		.syntax unified
 692              		.thumb
 693              		.thumb_func
 694              		.fpu fpv4-sp-d16
 696              	tcp_input_delayed_close:
 697              	.LVL49:
 698              	.LFB106:
 601:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
 699              		.loc 1 601 1 is_stmt 1 view -0
 700              		.cfi_startproc
 701              		@ args = 0, pretend = 0, frame = 0
 702              		@ frame_needed = 0, uses_anonymous_args = 0
 602:lwIP/src/core/tcp_in.c **** 
 703              		.loc 1 602 3 view .LVU193
ARM GAS  /tmp/ccFjUByx.s 			page 52


 602:lwIP/src/core/tcp_in.c **** 
 704              		.loc 1 602 3 view .LVU194
 601:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
 705              		.loc 1 601 1 is_stmt 0 view .LVU195
 706 0000 10B5     		push	{r4, lr}
 707              	.LCFI4:
 708              		.cfi_def_cfa_offset 8
 709              		.cfi_offset 4, -8
 710              		.cfi_offset 14, -4
 602:lwIP/src/core/tcp_in.c **** 
 711              		.loc 1 602 3 view .LVU196
 712 0002 D0B1     		cbz	r0, .L75
 602:lwIP/src/core/tcp_in.c **** 
 713              		.loc 1 602 3 is_stmt 1 discriminator 2 view .LVU197
 604:lwIP/src/core/tcp_in.c ****     /* The connection has been closed and we will deallocate the
 714              		.loc 1 604 3 discriminator 2 view .LVU198
 604:lwIP/src/core/tcp_in.c ****     /* The connection has been closed and we will deallocate the
 715              		.loc 1 604 18 is_stmt 0 discriminator 2 view .LVU199
 716 0004 0F4B     		ldr	r3, .L77
 604:lwIP/src/core/tcp_in.c ****     /* The connection has been closed and we will deallocate the
 717              		.loc 1 604 6 discriminator 2 view .LVU200
 718 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 719 0008 13F01003 		ands	r3, r3, #16
 720 000c 01D1     		bne	.L76
 617:lwIP/src/core/tcp_in.c **** }
 721              		.loc 1 617 10 view .LVU201
 722 000e 1846     		mov	r0, r3
 723              	.LVL50:
 618:lwIP/src/core/tcp_in.c **** 
 724              		.loc 1 618 1 view .LVU202
 725 0010 10BD     		pop	{r4, pc}
 726              	.LVL51:
 727              	.L76:
 728              	.LBB190:
 729              	.LBI190:
 600:lwIP/src/core/tcp_in.c **** {
 730              		.loc 1 600 1 is_stmt 1 view .LVU203
 731              	.LBB191:
 607:lwIP/src/core/tcp_in.c ****       /* Connection closed although the application has only shut down the
 732              		.loc 1 607 5 view .LVU204
 607:lwIP/src/core/tcp_in.c ****       /* Connection closed although the application has only shut down the
 733              		.loc 1 607 8 is_stmt 0 view .LVU205
 734 0012 438B     		ldrh	r3, [r0, #26]
 735 0014 0446     		mov	r4, r0
 736 0016 DB06     		lsls	r3, r3, #27
 737 0018 06D4     		bmi	.L69
 611:lwIP/src/core/tcp_in.c ****     }
 738              		.loc 1 611 7 is_stmt 1 view .LVU206
 611:lwIP/src/core/tcp_in.c ****     }
 739              		.loc 1 611 7 view .LVU207
 611:lwIP/src/core/tcp_in.c ****     }
 740              		.loc 1 611 7 view .LVU208
 741 001a D0F88C30 		ldr	r3, [r0, #140]
 742 001e 1BB1     		cbz	r3, .L69
 611:lwIP/src/core/tcp_in.c ****     }
 743              		.loc 1 611 7 view .LVU209
 744 0020 6FF00E01 		mvn	r1, #14
ARM GAS  /tmp/ccFjUByx.s 			page 53


 745 0024 0069     		ldr	r0, [r0, #16]
 746              	.LVL52:
 611:lwIP/src/core/tcp_in.c ****     }
 747              		.loc 1 611 7 is_stmt 0 view .LVU210
 748 0026 9847     		blx	r3
 749              	.LVL53:
 750              	.L69:
 611:lwIP/src/core/tcp_in.c ****     }
 751              		.loc 1 611 7 is_stmt 1 view .LVU211
 613:lwIP/src/core/tcp_in.c ****     tcp_free(pcb);
 752              		.loc 1 613 5 view .LVU212
 753 0028 2146     		mov	r1, r4
 754 002a 0748     		ldr	r0, .L77+4
 755 002c FFF7FEFF 		bl	tcp_pcb_remove
 756              	.LVL54:
 614:lwIP/src/core/tcp_in.c ****     return 1;
 757              		.loc 1 614 5 view .LVU213
 758 0030 2046     		mov	r0, r4
 759 0032 FFF7FEFF 		bl	tcp_free
 760              	.LVL55:
 615:lwIP/src/core/tcp_in.c ****   }
 761              		.loc 1 615 5 view .LVU214
 614:lwIP/src/core/tcp_in.c ****     return 1;
 762              		.loc 1 614 5 is_stmt 0 view .LVU215
 763 0036 0120     		movs	r0, #1
 764              	.LBE191:
 765              	.LBE190:
 618:lwIP/src/core/tcp_in.c **** 
 766              		.loc 1 618 1 view .LVU216
 767 0038 10BD     		pop	{r4, pc}
 768              	.LVL56:
 769              	.L75:
 602:lwIP/src/core/tcp_in.c **** 
 770              		.loc 1 602 3 is_stmt 1 discriminator 1 view .LVU217
 771 003a 0448     		ldr	r0, .L77+8
 772              	.LVL57:
 602:lwIP/src/core/tcp_in.c **** 
 773              		.loc 1 602 3 is_stmt 0 discriminator 1 view .LVU218
 774 003c FFF7FEFF 		bl	printf
 775              	.LVL58:
 776              	.L67:
 602:lwIP/src/core/tcp_in.c **** 
 777              		.loc 1 602 3 is_stmt 1 discriminator 1 view .LVU219
 602:lwIP/src/core/tcp_in.c **** 
 778              		.loc 1 602 3 discriminator 1 view .LVU220
 602:lwIP/src/core/tcp_in.c **** 
 779              		.loc 1 602 3 discriminator 1 view .LVU221
 602:lwIP/src/core/tcp_in.c **** 
 780              		.loc 1 602 3 discriminator 1 view .LVU222
 602:lwIP/src/core/tcp_in.c **** 
 781              		.loc 1 602 3 discriminator 1 view .LVU223
 602:lwIP/src/core/tcp_in.c **** 
 782              		.loc 1 602 3 discriminator 1 view .LVU224
 783 0040 FEE7     		b	.L67
 784              	.L78:
 785 0042 00BF     		.align	2
 786              	.L77:
ARM GAS  /tmp/ccFjUByx.s 			page 54


 787 0044 00000000 		.word	.LANCHOR5
 788 0048 00000000 		.word	tcp_active_pcbs
 789 004c 00000000 		.word	.LC1
 790              		.cfi_endproc
 791              	.LFE106:
 793              		.section	.rodata.tcp_free_acked_segments.isra.0.str1.4,"aMS",%progbits,1
 794              		.align	2
 795              	.LC2:
 796 0000 7063622D 		.ascii	"pcb->snd_queuelen >= pbuf_clen(next->p)\000"
 796      3E736E64 
 796      5F717565 
 796      75656C65 
 796      6E203E3D 
 797              		.align	2
 798              	.LC3:
 799 0028 7463705F 		.ascii	"tcp_receive: valid queue length\000"
 799      72656365 
 799      6976653A 
 799      2076616C 
 799      69642071 
 800              		.section	.text.tcp_free_acked_segments.isra.0,"ax",%progbits
 801              		.align	1
 802              		.p2align 2,,3
 803              		.syntax unified
 804              		.thumb
 805              		.thumb_func
 806              		.fpu fpv4-sp-d16
 808              	tcp_free_acked_segments.isra.0:
 809              	.LVL59:
 810              	.LFB116:
1088:lwIP/src/core/tcp_in.c ****                         struct tcp_seg *dbg_other_seg_list)
 811              		.loc 1 1088 1 view -0
 812              		.cfi_startproc
 813              		@ args = 0, pretend = 0, frame = 0
 814              		@ frame_needed = 0, uses_anonymous_args = 0
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
 815              		.loc 1 1121 7 view .LVU226
1097:lwIP/src/core/tcp_in.c ****          TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 816              		.loc 1 1097 9 view .LVU227
1088:lwIP/src/core/tcp_in.c ****                         struct tcp_seg *dbg_other_seg_list)
 817              		.loc 1 1088 1 is_stmt 0 view .LVU228
 818 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 819              	.LCFI5:
 820              		.cfi_def_cfa_offset 32
 821              		.cfi_offset 3, -32
 822              		.cfi_offset 4, -28
 823              		.cfi_offset 5, -24
 824              		.cfi_offset 6, -20
 825              		.cfi_offset 7, -16
 826              		.cfi_offset 8, -12
 827              		.cfi_offset 9, -8
 828              		.cfi_offset 14, -4
1097:lwIP/src/core/tcp_in.c ****          TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 829              		.loc 1 1097 9 view .LVU229
 830 0004 91B3     		cbz	r1, .L86
 831 0006 0446     		mov	r4, r0
 832 0008 8846     		mov	r8, r1
ARM GAS  /tmp/ccFjUByx.s 			page 55


 833 000a 1746     		mov	r7, r2
 834 000c 1E4E     		ldr	r6, .L98
1114:lwIP/src/core/tcp_in.c ****     tcp_seg_free(next);
 835              		.loc 1 1114 16 view .LVU230
 836 000e 1F4D     		ldr	r5, .L98+4
 837              	.LVL60:
 838              	.L80:
1103:lwIP/src/core/tcp_in.c **** 
 839              		.loc 1 1103 50 is_stmt 1 view .LVU231
1105:lwIP/src/core/tcp_in.c ****     seg_list = seg_list->next;
 840              		.loc 1 1105 5 view .LVU232
1106:lwIP/src/core/tcp_in.c **** 
 841              		.loc 1 1106 5 view .LVU233
1098:lwIP/src/core/tcp_in.c ****                      TCP_TCPLEN(seg_list), ackno)) {
 842              		.loc 1 1098 10 is_stmt 0 view .LVU234
 843 0010 D8F80C20 		ldr	r2, [r8, #12]
 844              	.LVL61:
 845              	.LBB192:
 846              	.LBI192:
 847              		.file 2 "STM32_XPD/CMSIS/Include/cmsis_gcc.h"
   1:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /*
   8:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  10:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  12:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  16:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  18:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
  24:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  25:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  28:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  34:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/ccFjUByx.s 			page 56


  38:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  39:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  43:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  46:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  49:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  55:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  58:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  61:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  64:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  67:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  70:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  78:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  86:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  94:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
ARM GAS  /tmp/ccFjUByx.s 			page 57


  95:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 102:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 110:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 113:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 116:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 117:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 118:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   @{
 122:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 123:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 124:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 125:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 129:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 131:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 133:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 134:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 135:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 136:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 140:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 142:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 144:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 145:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 146:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 147:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 151:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
ARM GAS  /tmp/ccFjUByx.s 			page 58


 152:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 153:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 155:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 158:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 159:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 160:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 162:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 166:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 168:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 170:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 173:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 174:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 175:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 176:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 177:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 181:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 183:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 185:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 186:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 187:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 189:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 193:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 195:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 197:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 198:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 199:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 200:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 201:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 205:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 207:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccFjUByx.s 			page 59


 209:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 212:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 213:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 214:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 215:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 219:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 221:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 223:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 226:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 227:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 228:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 229:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 233:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 235:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 237:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 240:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 241:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 242:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 243:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 247:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 249:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 251:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 254:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 255:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 256:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 258:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 262:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 264:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccFjUByx.s 			page 60


 266:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 269:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 270:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 271:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 272:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 273:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 277:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 279:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 281:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 282:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 283:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 285:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 289:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 291:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 293:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 294:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 295:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 296:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 297:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 301:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 303:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 305:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 308:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 309:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 310:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 312:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 316:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 318:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 320:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/ccFjUByx.s 			page 61


 323:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 324:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 325:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 326:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 327:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 331:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 333:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 335:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 336:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 337:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 339:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 343:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 345:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 347:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 348:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 349:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 350:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 352:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 356:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 358:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 360:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 363:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 364:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 365:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 366:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 370:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 372:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 374:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 375:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 376:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 377:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 378:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
ARM GAS  /tmp/ccFjUByx.s 			page 62


 380:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 382:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 384:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 386:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 389:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 390:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 391:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 393:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 397:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 399:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 401:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 404:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 405:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 406:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 407:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 408:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 412:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 414:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 416:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 417:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 418:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 420:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 424:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 426:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 428:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 429:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 430:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 431:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 435:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
ARM GAS  /tmp/ccFjUByx.s 			page 63


 437:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 439:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 441:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 443:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 444:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 445:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 446:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 450:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 452:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 454:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 455:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 456:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 457:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 461:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 463:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 465:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 468:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 469:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 470:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 472:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 476:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 478:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 480:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 483:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 484:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 485:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 486:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 487:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 491:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 493:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
ARM GAS  /tmp/ccFjUByx.s 			page 64


 494:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 495:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 496:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 497:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 499:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 503:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 505:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 507:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 508:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 509:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 510:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 511:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 516:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 518:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 520:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 521:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 522:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 523:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 527:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 529:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 531:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 534:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 535:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 536:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 538:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 542:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 544:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 546:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 549:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 550:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccFjUByx.s 			page 65


 551:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 552:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 553:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 557:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 559:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 561:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 562:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 563:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 565:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 569:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 571:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 573:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 574:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 575:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 579:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 580:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 583:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 584:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   
 589:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 592:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 594:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 599:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 603:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 604:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 605:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 607:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
ARM GAS  /tmp/ccFjUByx.s 			page 66


 608:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 611:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 614:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 616:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 620:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 624:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 625:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 626:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 627:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 628:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 629:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   
 634:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 637:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 639:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 644:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 646:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 647:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 648:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 649:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 651:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 655:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 658:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 660:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 664:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
ARM GAS  /tmp/ccFjUByx.s 			page 67


 665:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 666:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 667:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 668:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 669:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 670:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 671:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 676:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 679:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 681:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 686:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 690:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 691:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 692:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 693:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 695:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 699:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 702:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 704:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 708:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 712:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 713:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 714:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 715:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 716:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 717:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccFjUByx.s 			page 68


 722:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 725:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 727:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 732:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 734:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 735:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 736:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 737:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 739:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 743:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 746:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 748:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 752:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 754:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 755:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 756:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 757:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 760:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 761:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 762:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 766:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 768:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 776:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 778:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
ARM GAS  /tmp/ccFjUByx.s 			page 69


 779:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 781:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 782:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 784:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 785:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 786:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 787:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 788:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 792:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 794:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 802:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 804:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 805:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 807:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 808:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 809:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 810:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 812:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 813:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   @{
 817:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** */
 818:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 819:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 827:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 831:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 832:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 833:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccFjUByx.s 			page 70


 836:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 838:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 839:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 842:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 844:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 845:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 846:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 850:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 852:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 853:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 854:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 857:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 859:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 860:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 861:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 866:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 868:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 870:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 871:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 872:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 873:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 877:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 879:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 881:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 882:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 883:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 884:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 885:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 886:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 887:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 888:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 890:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 892:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccFjUByx.s 			page 71


 893:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 894:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 895:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 899:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 900:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 848              		.loc 2 900 31 is_stmt 1 view .LVU235
 849              	.LBB193:
 901:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 902:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 903:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 850              		.loc 2 903 3 view .LVU236
 851              	.LBE193:
 852              	.LBE192:
1098:lwIP/src/core/tcp_in.c ****                      TCP_TCPLEN(seg_list), ackno)) {
 853              		.loc 1 1098 10 is_stmt 0 view .LVU237
 854 0014 3168     		ldr	r1, [r6]
 855 0016 5368     		ldr	r3, [r2, #4]	@ unaligned
 856 0018 9289     		ldrh	r2, [r2, #12]	@ unaligned
 857              	.LVL62:
 858              	.LBB195:
 859              	.LBB194:
 860              		.loc 2 903 10 view .LVU238
 861 001a 1BBA     		rev	r3, r3
 862              	.LVL63:
 863              		.loc 2 903 10 view .LVU239
 864              	.LBE194:
 865              	.LBE195:
 866              	.LBB196:
 867              	.LBI196:
 904:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 905:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 906:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 907:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 909:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 910:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 911:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 912:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 913:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 914:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 917:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 918:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 919:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 921:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 922:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 923:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 924:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 925:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 926:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 927:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 928:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/ccFjUByx.s 			page 72


 929:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 933:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 868              		.loc 2 934 30 is_stmt 1 view .LVU240
 869              	.LBB197:
 935:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 936:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 870              		.loc 2 937 3 view .LVU241
 871              		.loc 2 937 3 is_stmt 0 view .LVU242
 872              	.LBE197:
 873              	.LBE196:
1098:lwIP/src/core/tcp_in.c ****                      TCP_TCPLEN(seg_list), ackno)) {
 874              		.loc 1 1098 10 view .LVU243
 875 001c B8F80800 		ldrh	r0, [r8, #8]
 876              	.LBB199:
 877              	.LBB198:
 878              		.loc 2 937 19 view .LVU244
 879 0020 52BA     		rev16	r2, r2
 880              	.LBE198:
 881              	.LBE199:
1098:lwIP/src/core/tcp_in.c ****                      TCP_TCPLEN(seg_list), ackno)) {
 882              		.loc 1 1098 10 view .LVU245
 883 0022 5B1A     		subs	r3, r3, r1
 884 0024 12F00302 		ands	r2, r2, #3
 885 0028 0344     		add	r3, r3, r0
 886 002a 18BF     		it	ne
 887 002c 0122     		movne	r2, #1
 888 002e 1344     		add	r3, r3, r2
1097:lwIP/src/core/tcp_in.c ****          TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 889              		.loc 1 1097 27 view .LVU246
 890 0030 002B     		cmp	r3, #0
 891 0032 1DDC     		bgt	.L81
1106:lwIP/src/core/tcp_in.c **** 
 892              		.loc 1 1106 14 view .LVU247
 893 0034 D8E90090 		ldrd	r9, r0, [r8]
 894              	.LVL64:
1108:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
 895              		.loc 1 1108 5 is_stmt 1 view .LVU248
1108:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
 896              		.loc 1 1108 12 is_stmt 0 view .LVU249
 897 0038 FFF7FEFF 		bl	pbuf_clen
 898              	.LVL65:
1111:lwIP/src/core/tcp_in.c **** 
 899              		.loc 1 1111 5 is_stmt 1 view .LVU250
1113:lwIP/src/core/tcp_in.c ****     recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
 900              		.loc 1 1113 5 view .LVU251
1111:lwIP/src/core/tcp_in.c **** 
 901              		.loc 1 1111 5 is_stmt 0 view .LVU252
 902 003c 2288     		ldrh	r2, [r4]
1108:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
 903              		.loc 1 1108 12 view .LVU253
 904 003e 0346     		mov	r3, r0
1115:lwIP/src/core/tcp_in.c **** 
ARM GAS  /tmp/ccFjUByx.s 			page 73


 905              		.loc 1 1115 5 view .LVU254
 906 0040 4046     		mov	r0, r8
 907              	.LVL66:
1110:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
 908              		.loc 1 1110 68 is_stmt 1 view .LVU255
1111:lwIP/src/core/tcp_in.c **** 
 909              		.loc 1 1111 5 view .LVU256
1111:lwIP/src/core/tcp_in.c **** 
 910              		.loc 1 1111 5 view .LVU257
 911 0042 9342     		cmp	r3, r2
1113:lwIP/src/core/tcp_in.c ****     recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
 912              		.loc 1 1113 25 is_stmt 0 view .LVU258
 913 0044 A2EB0301 		sub	r1, r2, r3
1111:lwIP/src/core/tcp_in.c **** 
 914              		.loc 1 1111 5 view .LVU259
 915 0048 15D8     		bhi	.L96
1114:lwIP/src/core/tcp_in.c ****     tcp_seg_free(next);
 916              		.loc 1 1114 18 view .LVU260
 917 004a 2A88     		ldrh	r2, [r5]
1113:lwIP/src/core/tcp_in.c ****     recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
 918              		.loc 1 1113 23 view .LVU261
 919 004c 2180     		strh	r1, [r4]	@ movhi
1114:lwIP/src/core/tcp_in.c ****     tcp_seg_free(next);
 920              		.loc 1 1114 5 is_stmt 1 view .LVU262
1114:lwIP/src/core/tcp_in.c ****     tcp_seg_free(next);
 921              		.loc 1 1114 18 is_stmt 0 view .LVU263
 922 004e B8F80830 		ldrh	r3, [r8, #8]
 923              	.LVL67:
1114:lwIP/src/core/tcp_in.c ****     tcp_seg_free(next);
 924              		.loc 1 1114 18 view .LVU264
 925 0052 C846     		mov	r8, r9
 926              	.LVL68:
1114:lwIP/src/core/tcp_in.c ****     tcp_seg_free(next);
 927              		.loc 1 1114 18 view .LVU265
 928 0054 1344     		add	r3, r3, r2
1114:lwIP/src/core/tcp_in.c ****     tcp_seg_free(next);
 929              		.loc 1 1114 16 view .LVU266
 930 0056 2B80     		strh	r3, [r5]	@ movhi
1115:lwIP/src/core/tcp_in.c **** 
 931              		.loc 1 1115 5 is_stmt 1 view .LVU267
 932 0058 FFF7FEFF 		bl	tcp_seg_free
 933              	.LVL69:
1119:lwIP/src/core/tcp_in.c ****     if (pcb->snd_queuelen != 0) {
 934              		.loc 1 1119 49 view .LVU268
1120:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_receive: valid queue length",
 935              		.loc 1 1120 5 view .LVU269
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
 936              		.loc 1 1121 7 view .LVU270
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
 937              		.loc 1 1121 7 view .LVU271
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
 938              		.loc 1 1121 7 view .LVU272
1097:lwIP/src/core/tcp_in.c ****          TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 939              		.loc 1 1097 9 view .LVU273
1120:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_receive: valid queue length",
 940              		.loc 1 1120 8 is_stmt 0 view .LVU274
 941 005c 2388     		ldrh	r3, [r4]
ARM GAS  /tmp/ccFjUByx.s 			page 74


 942 005e 13B1     		cbz	r3, .L84
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
 943              		.loc 1 1121 7 view .LVU275
 944 0060 59EA0703 		orrs	r3, r9, r7
 945 0064 0BD0     		beq	.L97
 946              	.L84:
1097:lwIP/src/core/tcp_in.c ****          TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 947              		.loc 1 1097 9 view .LVU276
 948 0066 B9F1000F 		cmp	r9, #0
 949 006a D1D1     		bne	.L80
 950              	.LVL70:
 951              	.L86:
1097:lwIP/src/core/tcp_in.c ****          TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 952              		.loc 1 1097 9 view .LVU277
 953 006c 4FF00008 		mov	r8, #0
 954              	.L81:
1125:lwIP/src/core/tcp_in.c **** }
 955              		.loc 1 1125 3 is_stmt 1 view .LVU278
1126:lwIP/src/core/tcp_in.c **** 
 956              		.loc 1 1126 1 is_stmt 0 view .LVU279
 957 0070 4046     		mov	r0, r8
 958 0072 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 959              	.LVL71:
 960              	.L96:
1111:lwIP/src/core/tcp_in.c **** 
 961              		.loc 1 1111 5 is_stmt 1 view .LVU280
 962 0076 0648     		ldr	r0, .L98+8
 963              	.LVL72:
1111:lwIP/src/core/tcp_in.c **** 
 964              		.loc 1 1111 5 is_stmt 0 view .LVU281
 965 0078 FFF7FEFF 		bl	printf
 966              	.LVL73:
 967              	.L83:
1111:lwIP/src/core/tcp_in.c **** 
 968              		.loc 1 1111 5 is_stmt 1 view .LVU282
1111:lwIP/src/core/tcp_in.c **** 
 969              		.loc 1 1111 5 view .LVU283
1111:lwIP/src/core/tcp_in.c **** 
 970              		.loc 1 1111 5 view .LVU284
1111:lwIP/src/core/tcp_in.c **** 
 971              		.loc 1 1111 5 view .LVU285
1111:lwIP/src/core/tcp_in.c **** 
 972              		.loc 1 1111 5 view .LVU286
1111:lwIP/src/core/tcp_in.c **** 
 973              		.loc 1 1111 5 view .LVU287
 974 007c FEE7     		b	.L83
 975              	.LVL74:
 976              	.L97:
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
 977              		.loc 1 1121 7 view .LVU288
 978 007e 0548     		ldr	r0, .L98+12
 979 0080 FFF7FEFF 		bl	printf
 980              	.LVL75:
 981              	.L85:
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
 982              		.loc 1 1121 7 view .LVU289
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
ARM GAS  /tmp/ccFjUByx.s 			page 75


 983              		.loc 1 1121 7 view .LVU290
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
 984              		.loc 1 1121 7 view .LVU291
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
 985              		.loc 1 1121 7 view .LVU292
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
 986              		.loc 1 1121 7 view .LVU293
1121:lwIP/src/core/tcp_in.c ****                   seg_list != NULL || dbg_other_seg_list != NULL);
 987              		.loc 1 1121 7 view .LVU294
 988 0084 FEE7     		b	.L85
 989              	.L99:
 990 0086 00BF     		.align	2
 991              	.L98:
 992 0088 00000000 		.word	.LANCHOR7
 993 008c 00000000 		.word	.LANCHOR6
 994 0090 00000000 		.word	.LC2
 995 0094 28000000 		.word	.LC3
 996              		.cfi_endproc
 997              	.LFE116:
 999              		.section	.rodata.tcp_receive.part.0.str1.4,"aMS",%progbits,1
 1000              		.align	2
 1001              	.LC4:
 1002 0000 696E7365 		.ascii	"inseg.p != NULL\000"
 1002      672E7020 
 1002      213D204E 
 1002      554C4C00 
 1003              		.align	2
 1004              	.LC5:
 1005 0010 696E7361 		.ascii	"insane offset!\000"
 1005      6E65206F 
 1005      66667365 
 1005      742100
 1006 001f 00       		.align	2
 1007              	.LC6:
 1008 0020 70627566 		.ascii	"pbuf too short!\000"
 1008      20746F6F 
 1008      2073686F 
 1008      72742100 
 1009              		.align	2
 1010              	.LC7:
 1011 0030 7463705F 		.ascii	"tcp_receive: segment not trimmed correctly to rcv_w"
 1011      72656365 
 1011      6976653A 
 1011      20736567 
 1011      6D656E74 
 1012 0063 6E6400   		.ascii	"nd\000"
 1013 0066 0000     		.align	2
 1014              	.LC8:
 1015 0068 7463705F 		.ascii	"tcp_receive: tcplen > rcv_wnd\000"
 1015      72656365 
 1015      6976653A 
 1015      20746370 
 1015      6C656E20 
 1016              		.section	.text.tcp_receive.part.0,"ax",%progbits
 1017              		.align	1
 1018              		.p2align 2,,3
 1019              		.syntax unified
ARM GAS  /tmp/ccFjUByx.s 			page 76


 1020              		.thumb
 1021              		.thumb_func
 1022              		.fpu fpv4-sp-d16
 1024              	tcp_receive.part.0:
 1025              	.LVL76:
 1026              	.LFB117:
1141:lwIP/src/core/tcp_in.c **** {
 1027              		.loc 1 1141 1 view -0
 1028              		.cfi_startproc
 1029              		@ args = 0, pretend = 0, frame = 0
 1030              		@ frame_needed = 0, uses_anonymous_args = 0
1148:lwIP/src/core/tcp_in.c **** 
 1031              		.loc 1 1148 3 view .LVU296
1150:lwIP/src/core/tcp_in.c ****     right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 1032              		.loc 1 1150 3 view .LVU297
1141:lwIP/src/core/tcp_in.c **** {
 1033              		.loc 1 1141 1 is_stmt 0 view .LVU298
 1034 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1035              	.LCFI6:
 1036              		.cfi_def_cfa_offset 32
 1037              		.cfi_offset 3, -32
 1038              		.cfi_offset 4, -28
 1039              		.cfi_offset 5, -24
 1040              		.cfi_offset 6, -20
 1041              		.cfi_offset 7, -16
 1042              		.cfi_offset 8, -12
 1043              		.cfi_offset 9, -8
 1044              		.cfi_offset 14, -4
1150:lwIP/src/core/tcp_in.c ****     right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 1045              		.loc 1 1150 13 view .LVU299
 1046 0004 B34B     		ldr	r3, .L210
1141:lwIP/src/core/tcp_in.c **** {
 1047              		.loc 1 1141 1 view .LVU300
 1048 0006 0446     		mov	r4, r0
 1049 0008 B34F     		ldr	r7, .L210+4
1150:lwIP/src/core/tcp_in.c ****     right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 1050              		.loc 1 1150 6 view .LVU301
 1051 000a 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1052 000c 3B68     		ldr	r3, [r7]
 1053 000e D206     		lsls	r2, r2, #27
 1054 0010 5BD4     		bmi	.L101
 1055 0012 B24E     		ldr	r6, .L210+8
 1056 0014 406A     		ldr	r0, [r0, #36]
 1057              	.LVL77:
1150:lwIP/src/core/tcp_in.c ****     right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 1058              		.loc 1 1150 6 view .LVU302
 1059 0016 B6F800C0 		ldrh	ip, [r6]
 1060              	.L102:
1373:lwIP/src/core/tcp_in.c ****     /* This code basically does three things:
 1061              		.loc 1 1373 3 is_stmt 1 view .LVU303
1373:lwIP/src/core/tcp_in.c ****     /* This code basically does three things:
 1062              		.loc 1 1373 6 is_stmt 0 view .LVU304
 1063 001a BCF1000F 		cmp	ip, #0
 1064 001e 44D0     		beq	.L128
 1065              	.L205:
1373:lwIP/src/core/tcp_in.c ****     /* This code basically does three things:
 1066              		.loc 1 1373 20 view .LVU305
ARM GAS  /tmp/ccFjUByx.s 			page 77


 1067 0020 227D     		ldrb	r2, [r4, #20]	@ zero_extendqisi2
 1068 0022 062A     		cmp	r2, #6
 1069 0024 41D8     		bhi	.L128
1404:lwIP/src/core/tcp_in.c ****       /* Trimming the first edge is done by pushing the payload
 1070              		.loc 1 1404 5 is_stmt 1 view .LVU306
1404:lwIP/src/core/tcp_in.c ****       /* Trimming the first edge is done by pushing the payload
 1071              		.loc 1 1404 9 is_stmt 0 view .LVU307
 1072 0026 C11A     		subs	r1, r0, r3
1404:lwIP/src/core/tcp_in.c ****       /* Trimming the first edge is done by pushing the payload
 1073              		.loc 1 1404 8 view .LVU308
 1074 0028 0129     		cmp	r1, #1
 1075 002a 07D4     		bmi	.L129
1404:lwIP/src/core/tcp_in.c ****       /* Trimming the first edge is done by pushing the payload
 1076              		.loc 1 1404 9 view .LVU309
 1077 002c 421C     		adds	r2, r0, #1
 1078 002e D21A     		subs	r2, r2, r3
 1079 0030 A2EB0C0C 		sub	ip, r2, ip
 1080 0034 BCF1000F 		cmp	ip, #0
 1081 0038 40F35A81 		ble	.L196
 1082              	.L129:
1445:lwIP/src/core/tcp_in.c ****         /* the whole segment is < rcv_nxt */
 1083              		.loc 1 1445 7 is_stmt 1 view .LVU310
1445:lwIP/src/core/tcp_in.c ****         /* the whole segment is < rcv_nxt */
 1084              		.loc 1 1445 11 is_stmt 0 view .LVU311
 1085 003c 1A1A     		subs	r2, r3, r0
1445:lwIP/src/core/tcp_in.c ****         /* the whole segment is < rcv_nxt */
 1086              		.loc 1 1445 10 view .LVU312
 1087 003e 002A     		cmp	r2, #0
 1088 0040 C0F24381 		blt	.L197
1450:lwIP/src/core/tcp_in.c ****       }
 1089              		.loc 1 1450 9 is_stmt 1 view .LVU313
1457:lwIP/src/core/tcp_in.c ****                         pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 1090              		.loc 1 1457 5 view .LVU314
1457:lwIP/src/core/tcp_in.c ****                         pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 1091              		.loc 1 1457 9 is_stmt 0 view .LVU315
 1092 0044 218D     		ldrh	r1, [r4, #40]
 1093 0046 C1F10102 		rsb	r2, r1, #1
 1094 004a 1A44     		add	r2, r2, r3
 1095 004c 121A     		subs	r2, r2, r0
 1096 004e 002A     		cmp	r2, #0
 1097 0050 40F37D81 		ble	.L198
 1098              	.L139:
1872:lwIP/src/core/tcp_in.c ****       }
 1099              		.loc 1 1872 9 is_stmt 1 view .LVU316
 1100 0054 2046     		mov	r0, r4
1885:lwIP/src/core/tcp_in.c **** 
 1101              		.loc 1 1885 1 is_stmt 0 view .LVU317
 1102 0056 BDE8F843 		pop	{r3, r4, r5, r6, r7, r8, r9, lr}
 1103              	.LCFI7:
 1104              		.cfi_remember_state
 1105              		.cfi_restore 14
 1106              		.cfi_restore 9
 1107              		.cfi_restore 8
 1108              		.cfi_restore 7
 1109              		.cfi_restore 6
 1110              		.cfi_restore 5
 1111              		.cfi_restore 4
ARM GAS  /tmp/ccFjUByx.s 			page 78


 1112              		.cfi_restore 3
 1113              		.cfi_def_cfa_offset 0
 1114              	.LVL78:
1872:lwIP/src/core/tcp_in.c ****       }
 1115              		.loc 1 1872 9 view .LVU318
 1116 005a FFF7FEBF 		b	tcp_send_empty_ack
 1117              	.LVL79:
 1118              	.L201:
 1119              	.LCFI8:
 1120              		.cfi_restore_state
1200:lwIP/src/core/tcp_in.c ****         /* Clause 3 */
 1121              		.loc 1 1200 7 is_stmt 1 view .LVU319
1200:lwIP/src/core/tcp_in.c ****         /* Clause 3 */
 1122              		.loc 1 1200 18 is_stmt 0 view .LVU320
 1123 005e 9F4E     		ldr	r6, .L210+8
 1124 0060 B6F800C0 		ldrh	ip, [r6]
1200:lwIP/src/core/tcp_in.c ****         /* Clause 3 */
 1125              		.loc 1 1200 10 view .LVU321
 1126 0064 BCF1000F 		cmp	ip, #0
 1127 0068 40F0FA80 		bne	.L109
1202:lwIP/src/core/tcp_in.c ****           /* Clause 4 */
 1128              		.loc 1 1202 9 is_stmt 1 view .LVU322
1151:lwIP/src/core/tcp_in.c **** 
 1129              		.loc 1 1151 20 is_stmt 0 view .LVU323
 1130 006c 7044     		add	r0, r0, lr
 1131              	.LVL80:
1202:lwIP/src/core/tcp_in.c ****           /* Clause 4 */
 1132              		.loc 1 1202 26 view .LVU324
 1133 006e 4A44     		add	r2, r2, r9
1202:lwIP/src/core/tcp_in.c ****           /* Clause 4 */
 1134              		.loc 1 1202 12 view .LVU325
 1135 0070 9042     		cmp	r0, r2
 1136 0072 40F0F580 		bne	.L109
1204:lwIP/src/core/tcp_in.c ****             /* Clause 5 */
 1137              		.loc 1 1204 11 is_stmt 1 view .LVU326
1206:lwIP/src/core/tcp_in.c ****               found_dupack = 1;
 1138              		.loc 1 1206 13 view .LVU327
1204:lwIP/src/core/tcp_in.c ****             /* Clause 5 */
 1139              		.loc 1 1204 14 is_stmt 0 view .LVU328
 1140 0076 228E     		ldrh	r2, [r4, #48]
1206:lwIP/src/core/tcp_in.c ****               found_dupack = 1;
 1141              		.loc 1 1206 16 view .LVU329
 1142 0078 D20B     		lsrs	r2, r2, #15
 1143 007a 40F0F180 		bne	.L109
 1144 007e 8845     		cmp	r8, r1
 1145 0080 40F0EE80 		bne	.L109
1207:lwIP/src/core/tcp_in.c ****               if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 1146              		.loc 1 1207 15 is_stmt 1 view .LVU330
 1147              	.LVL81:
1208:lwIP/src/core/tcp_in.c ****                 ++pcb->dupacks;
 1148              		.loc 1 1208 15 view .LVU331
1208:lwIP/src/core/tcp_in.c ****                 ++pcb->dupacks;
 1149              		.loc 1 1208 29 is_stmt 0 view .LVU332
 1150 0084 94F84320 		ldrb	r2, [r4, #67]	@ zero_extendqisi2
1208:lwIP/src/core/tcp_in.c ****                 ++pcb->dupacks;
 1151              		.loc 1 1208 18 view .LVU333
 1152 0088 FF2A     		cmp	r2, #255
ARM GAS  /tmp/ccFjUByx.s 			page 79


 1153 008a 00F0E681 		beq	.L113
1209:lwIP/src/core/tcp_in.c ****               }
 1154              		.loc 1 1209 17 is_stmt 1 view .LVU334
 1155 008e 0132     		adds	r2, r2, #1
 1156 0090 D2B2     		uxtb	r2, r2
1211:lwIP/src/core/tcp_in.c ****                 /* Inflate the congestion window */
 1157              		.loc 1 1211 18 is_stmt 0 view .LVU335
 1158 0092 032A     		cmp	r2, #3
1209:lwIP/src/core/tcp_in.c ****               }
 1159              		.loc 1 1209 17 view .LVU336
 1160 0094 84F84320 		strb	r2, [r4, #67]
1211:lwIP/src/core/tcp_in.c ****                 /* Inflate the congestion window */
 1161              		.loc 1 1211 15 is_stmt 1 view .LVU337
1211:lwIP/src/core/tcp_in.c ****                 /* Inflate the congestion window */
 1162              		.loc 1 1211 18 is_stmt 0 view .LVU338
 1163 0098 00F2DF81 		bhi	.L113
1213:lwIP/src/core/tcp_in.c ****               }
 1164              		.loc 1 1213 17 is_stmt 1 view .LVU339
1215:lwIP/src/core/tcp_in.c ****                 /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
 1165              		.loc 1 1215 15 view .LVU340
1215:lwIP/src/core/tcp_in.c ****                 /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
 1166              		.loc 1 1215 18 is_stmt 0 view .LVU341
 1167 009c 00F0E981 		beq	.L154
 1168              	.LVL82:
1339:lwIP/src/core/tcp_in.c **** 
 1169              		.loc 1 1339 65 is_stmt 1 view .LVU342
1344:lwIP/src/core/tcp_in.c ****       /* diff between this shouldn't exceed 32K since this are tcp timer ticks
 1170              		.loc 1 1344 5 view .LVU343
1344:lwIP/src/core/tcp_in.c ****       /* diff between this shouldn't exceed 32K since this are tcp timer ticks
 1171              		.loc 1 1344 12 is_stmt 0 view .LVU344
 1172 00a0 626B     		ldr	r2, [r4, #52]
 1173 00a2 606A     		ldr	r0, [r4, #36]
1344:lwIP/src/core/tcp_in.c ****       /* diff between this shouldn't exceed 32K since this are tcp timer ticks
 1174              		.loc 1 1344 8 view .LVU345
 1175 00a4 002A     		cmp	r2, #0
 1176 00a6 40F0AC80 		bne	.L156
 1177              	.L128:
1881:lwIP/src/core/tcp_in.c ****       tcp_ack_now(pcb);
 1178              		.loc 1 1881 5 is_stmt 1 view .LVU346
1881:lwIP/src/core/tcp_in.c ****       tcp_ack_now(pcb);
 1179              		.loc 1 1881 10 is_stmt 0 view .LVU347
 1180 00aa 1A1A     		subs	r2, r3, r0
1881:lwIP/src/core/tcp_in.c ****       tcp_ack_now(pcb);
 1181              		.loc 1 1881 8 view .LVU348
 1182 00ac 002A     		cmp	r2, #0
 1183 00ae 06DB     		blt	.L153
1881:lwIP/src/core/tcp_in.c ****       tcp_ack_now(pcb);
 1184              		.loc 1 1881 10 view .LVU349
 1185 00b0 228D     		ldrh	r2, [r4, #40]
 1186 00b2 C2F10102 		rsb	r2, r2, #1
 1187 00b6 1344     		add	r3, r3, r2
 1188 00b8 1B1A     		subs	r3, r3, r0
1881:lwIP/src/core/tcp_in.c ****       tcp_ack_now(pcb);
 1189              		.loc 1 1881 9 view .LVU350
 1190 00ba 002B     		cmp	r3, #0
 1191 00bc 03DD     		ble	.L100
 1192              	.L153:
ARM GAS  /tmp/ccFjUByx.s 			page 80


1882:lwIP/src/core/tcp_in.c ****     }
 1193              		.loc 1 1882 7 is_stmt 1 view .LVU351
1882:lwIP/src/core/tcp_in.c ****     }
 1194              		.loc 1 1882 7 view .LVU352
 1195 00be 638B     		ldrh	r3, [r4, #26]
 1196 00c0 43F00203 		orr	r3, r3, #2
 1197 00c4 6383     		strh	r3, [r4, #26]	@ movhi
1882:lwIP/src/core/tcp_in.c ****     }
 1198              		.loc 1 1882 7 view .LVU353
 1199              	.L100:
1885:lwIP/src/core/tcp_in.c **** 
 1200              		.loc 1 1885 1 is_stmt 0 view .LVU354
 1201 00c6 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1202              	.LVL83:
 1203              	.L101:
1151:lwIP/src/core/tcp_in.c **** 
 1204              		.loc 1 1151 5 is_stmt 1 view .LVU355
1154:lwIP/src/core/tcp_in.c ****         (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 1205              		.loc 1 1154 9 is_stmt 0 view .LVU356
 1206 00ca 426D     		ldr	r2, [r0, #84]
 1207 00cc 844D     		ldr	r5, .L210+12
 1208 00ce D61A     		subs	r6, r2, r3
1151:lwIP/src/core/tcp_in.c **** 
 1209              		.loc 1 1151 25 view .LVU357
 1210 00d0 B0F86000 		ldrh	r0, [r0, #96]
 1211              	.LVL84:
1151:lwIP/src/core/tcp_in.c **** 
 1212              		.loc 1 1151 25 view .LVU358
 1213 00d4 2968     		ldr	r1, [r5]
1154:lwIP/src/core/tcp_in.c ****         (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 1214              		.loc 1 1154 8 view .LVU359
 1215 00d6 002E     		cmp	r6, #0
1151:lwIP/src/core/tcp_in.c **** 
 1216              		.loc 1 1151 40 view .LVU360
 1217 00d8 D4F858E0 		ldr	lr, [r4, #88]
 1218              	.LVL85:
1154:lwIP/src/core/tcp_in.c ****         (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 1219              		.loc 1 1154 5 is_stmt 1 view .LVU361
1154:lwIP/src/core/tcp_in.c ****         (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 1220              		.loc 1 1154 8 is_stmt 0 view .LVU362
 1221 00dc 0BDB     		blt	.L190
1154:lwIP/src/core/tcp_in.c ****         (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 1222              		.loc 1 1154 41 view .LVU363
 1223 00de 9A42     		cmp	r2, r3
 1224 00e0 05D0     		beq	.L199
 1225              	.L105:
1155:lwIP/src/core/tcp_in.c ****         (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 1226              		.loc 1 1155 68 view .LVU364
 1227 00e2 8E45     		cmp	lr, r1
 1228 00e4 00F0C080 		beq	.L200
 1229              	.L158:
 1230 00e8 0246     		mov	r2, r0
 1231 00ea F146     		mov	r9, lr
 1232 00ec 11E0     		b	.L106
 1233              	.L199:
1155:lwIP/src/core/tcp_in.c ****         (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 1234              		.loc 1 1155 35 view .LVU365
ARM GAS  /tmp/ccFjUByx.s 			page 81


 1235 00ee AEEB0102 		sub	r2, lr, r1
1155:lwIP/src/core/tcp_in.c ****         (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 1236              		.loc 1 1155 32 view .LVU366
 1237 00f2 002A     		cmp	r2, #0
 1238 00f4 F5DA     		bge	.L105
 1239              	.L190:
1155:lwIP/src/core/tcp_in.c ****         (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 1240              		.loc 1 1155 32 view .LVU367
 1241 00f6 7B4A     		ldr	r2, .L210+16
 1242 00f8 1268     		ldr	r2, [r2]
 1243 00fa D289     		ldrh	r2, [r2, #14]	@ unaligned
 1244              	.L104:
1157:lwIP/src/core/tcp_in.c ****       /* keep track of the biggest window announced by the remote host to calculate
 1245              		.loc 1 1157 7 is_stmt 1 view .LVU368
1160:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd_max = pcb->snd_wnd;
 1246              		.loc 1 1160 10 is_stmt 0 view .LVU369
 1247 00fc B4F86260 		ldrh	r6, [r4, #98]
1164:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"TCPWNDSIZE_F"\n", pcb->snd_wnd));
 1248              		.loc 1 1164 20 view .LVU370
 1249 0100 8946     		mov	r9, r1
1157:lwIP/src/core/tcp_in.c ****       /* keep track of the biggest window announced by the remote host to calculate
 1250              		.loc 1 1157 20 view .LVU371
 1251 0102 A4F86020 		strh	r2, [r4, #96]	@ movhi
1160:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd_max = pcb->snd_wnd;
 1252              		.loc 1 1160 7 is_stmt 1 view .LVU372
1160:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd_max = pcb->snd_wnd;
 1253              		.loc 1 1160 10 is_stmt 0 view .LVU373
 1254 0106 9642     		cmp	r6, r2
1161:lwIP/src/core/tcp_in.c ****       }
 1255              		.loc 1 1161 9 is_stmt 1 view .LVU374
1163:lwIP/src/core/tcp_in.c ****       pcb->snd_wl2 = ackno;
 1256              		.loc 1 1163 20 is_stmt 0 view .LVU375
 1257 0108 6365     		str	r3, [r4, #84]
1164:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"TCPWNDSIZE_F"\n", pcb->snd_wnd));
 1258              		.loc 1 1164 20 view .LVU376
 1259 010a A165     		str	r1, [r4, #88]
1161:lwIP/src/core/tcp_in.c ****       }
 1260              		.loc 1 1161 26 view .LVU377
 1261 010c 38BF     		it	cc
 1262 010e A4F86220 		strhcc	r2, [r4, #98]	@ movhi
1163:lwIP/src/core/tcp_in.c ****       pcb->snd_wl2 = ackno;
 1263              		.loc 1 1163 7 is_stmt 1 view .LVU378
1164:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"TCPWNDSIZE_F"\n", pcb->snd_wnd));
 1264              		.loc 1 1164 7 view .LVU379
 1265              	.L106:
1165:lwIP/src/core/tcp_in.c **** #if TCP_WND_DEBUG
 1266              		.loc 1 1165 97 view .LVU380
1198:lwIP/src/core/tcp_in.c ****       /* Clause 2 */
 1267              		.loc 1 1198 5 view .LVU381
1198:lwIP/src/core/tcp_in.c ****       /* Clause 2 */
 1268              		.loc 1 1198 9 is_stmt 0 view .LVU382
 1269 0112 D4F84480 		ldr	r8, [r4, #68]
 1270 0116 A1EB0806 		sub	r6, r1, r8
1198:lwIP/src/core/tcp_in.c ****       /* Clause 2 */
 1271              		.loc 1 1198 8 view .LVU383
 1272 011a 002E     		cmp	r6, #0
 1273 011c 9FDD     		ble	.L201
ARM GAS  /tmp/ccFjUByx.s 			page 82


1228:lwIP/src/core/tcp_in.c ****       /* We come here when the ACK acknowledges new data. */
 1274              		.loc 1 1228 12 is_stmt 1 view .LVU384
1228:lwIP/src/core/tcp_in.c ****       /* We come here when the ACK acknowledges new data. */
 1275              		.loc 1 1228 16 is_stmt 0 view .LVU385
 1276 011e 236D     		ldr	r3, [r4, #80]
 1277 0120 CB1A     		subs	r3, r1, r3
 1278 0122 002B     		cmp	r3, #0
 1279 0124 60DC     		bgt	.L116
 1280              	.LBB200:
1230:lwIP/src/core/tcp_in.c **** 
 1281              		.loc 1 1230 7 is_stmt 1 view .LVU386
1235:lwIP/src/core/tcp_in.c ****         tcp_clear_flags(pcb, TF_INFR);
 1282              		.loc 1 1235 7 view .LVU387
1235:lwIP/src/core/tcp_in.c ****         tcp_clear_flags(pcb, TF_INFR);
 1283              		.loc 1 1235 14 is_stmt 0 view .LVU388
 1284 0126 638B     		ldrh	r3, [r4, #26]
 1285 0128 B4F84A20 		ldrh	r2, [r4, #74]
1235:lwIP/src/core/tcp_in.c ****         tcp_clear_flags(pcb, TF_INFR);
 1286              		.loc 1 1235 10 view .LVU389
 1287 012c 13F0040E 		ands	lr, r3, #4
 1288              	.LVL86:
1235:lwIP/src/core/tcp_in.c ****         tcp_clear_flags(pcb, TF_INFR);
 1289              		.loc 1 1235 10 view .LVU390
 1290 0130 40F0A180 		bne	.L117
1245:lwIP/src/core/tcp_in.c **** 
 1291              		.loc 1 1245 41 view .LVU391
 1292 0134 B4F93C00 		ldrsh	r0, [r4, #60]
1248:lwIP/src/core/tcp_in.c **** 
 1293              		.loc 1 1248 13 view .LVU392
 1294 0138 B6B2     		uxth	r6, r6
1245:lwIP/src/core/tcp_in.c **** 
 1295              		.loc 1 1245 41 view .LVU393
 1296 013a B4F83EC0 		ldrh	ip, [r4, #62]
1242:lwIP/src/core/tcp_in.c **** 
 1297              		.loc 1 1242 17 view .LVU394
 1298 013e A4F842E0 		strh	lr, [r4, #66]	@ movhi
1245:lwIP/src/core/tcp_in.c **** 
 1299              		.loc 1 1245 41 view .LVU395
 1300 0142 0CEBE00C 		add	ip, ip, r0, asr #3
 1301 0146 B4F84800 		ldrh	r0, [r4, #72]
1242:lwIP/src/core/tcp_in.c **** 
 1302              		.loc 1 1242 7 is_stmt 1 view .LVU396
1245:lwIP/src/core/tcp_in.c **** 
 1303              		.loc 1 1245 7 view .LVU397
1252:lwIP/src/core/tcp_in.c **** 
 1304              		.loc 1 1252 20 is_stmt 0 view .LVU398
 1305 014a 6164     		str	r1, [r4, #68]
1257:lwIP/src/core/tcp_in.c ****           tcpwnd_size_t increase;
 1306              		.loc 1 1257 12 view .LVU399
 1307 014c 8242     		cmp	r2, r0
1245:lwIP/src/core/tcp_in.c **** 
 1308              		.loc 1 1245 16 view .LVU400
 1309 014e A4F840C0 		strh	ip, [r4, #64]	@ movhi
1248:lwIP/src/core/tcp_in.c **** 
 1310              		.loc 1 1248 7 is_stmt 1 view .LVU401
 1311              	.LVL87:
1251:lwIP/src/core/tcp_in.c ****       pcb->lastack = ackno;
ARM GAS  /tmp/ccFjUByx.s 			page 83


 1312              		.loc 1 1251 7 view .LVU402
1252:lwIP/src/core/tcp_in.c **** 
 1313              		.loc 1 1252 7 view .LVU403
1256:lwIP/src/core/tcp_in.c ****         if (pcb->cwnd < pcb->ssthresh) {
 1314              		.loc 1 1256 7 view .LVU404
1257:lwIP/src/core/tcp_in.c ****           tcpwnd_size_t increase;
 1315              		.loc 1 1257 9 view .LVU405
1257:lwIP/src/core/tcp_in.c ****           tcpwnd_size_t increase;
 1316              		.loc 1 1257 12 is_stmt 0 view .LVU406
 1317 0152 40F29581 		bls	.L202
 1318              	.LBB201:
1258:lwIP/src/core/tcp_in.c ****           /* limit to 1 SMSS segment during period following RTO */
 1319              		.loc 1 1258 11 is_stmt 1 view .LVU407
1260:lwIP/src/core/tcp_in.c ****           /* RFC 3465, section 2.2 Slow Start */
 1320              		.loc 1 1260 11 view .LVU408
1260:lwIP/src/core/tcp_in.c ****           /* RFC 3465, section 2.2 Slow Start */
 1321              		.loc 1 1260 16 is_stmt 0 view .LVU409
 1322 0156 13F4006F 		tst	r3, #2048
1262:lwIP/src/core/tcp_in.c ****           TCP_WND_INC(pcb->cwnd, increase);
 1323              		.loc 1 1262 22 view .LVU410
 1324 015a 638E     		ldrh	r3, [r4, #50]
1260:lwIP/src/core/tcp_in.c ****           /* RFC 3465, section 2.2 Slow Start */
 1325              		.loc 1 1260 16 view .LVU411
 1326 015c 14BF     		ite	ne
 1327 015e 0122     		movne	r2, #1
 1328 0160 0222     		moveq	r2, #2
1262:lwIP/src/core/tcp_in.c ****           TCP_WND_INC(pcb->cwnd, increase);
 1329              		.loc 1 1262 11 is_stmt 1 view .LVU412
 1330              	.LVL88:
1263:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd)
 1331              		.loc 1 1263 11 view .LVU413
1263:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd)
 1332              		.loc 1 1263 11 view .LVU414
1262:lwIP/src/core/tcp_in.c ****           TCP_WND_INC(pcb->cwnd, increase);
 1333              		.loc 1 1262 22 is_stmt 0 view .LVU415
 1334 0162 13FB02F3 		smulbb	r3, r3, r2
1262:lwIP/src/core/tcp_in.c ****           TCP_WND_INC(pcb->cwnd, increase);
 1335              		.loc 1 1262 20 view .LVU416
 1336 0166 9BB2     		uxth	r3, r3
1263:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd)
 1337              		.loc 1 1263 11 view .LVU417
 1338 0168 B342     		cmp	r3, r6
 1339 016a 94BF     		ite	ls
 1340 016c C318     		addls	r3, r0, r3
 1341 016e 8319     		addhi	r3, r0, r6
 1342 0170 9BB2     		uxth	r3, r3
 1343 0172 8342     		cmp	r3, r0
 1344 0174 C0F0A480 		bcc	.L121
 1345              	.LVL89:
 1346              	.L191:
1263:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd)
 1347              		.loc 1 1263 11 view .LVU418
 1348              	.LBE201:
1270:lwIP/src/core/tcp_in.c ****           }
 1349              		.loc 1 1270 13 is_stmt 1 view .LVU419
 1350 0178 A4F84830 		strh	r3, [r4, #72]	@ movhi
 1351              	.L122:
ARM GAS  /tmp/ccFjUByx.s 			page 84


1270:lwIP/src/core/tcp_in.c ****           }
 1352              		.loc 1 1270 13 view .LVU420
1272:lwIP/src/core/tcp_in.c ****         }
 1353              		.loc 1 1272 111 view .LVU421
1280:lwIP/src/core/tcp_in.c **** 
 1354              		.loc 1 1280 109 view .LVU422
1284:lwIP/src/core/tcp_in.c ****       /* We go through the ->unsent list to see if any of the segments
 1355              		.loc 1 1284 7 view .LVU423
 1356 017c 04F16606 		add	r6, r4, #102
 1357              	.LVL90:
1284:lwIP/src/core/tcp_in.c ****       /* We go through the ->unsent list to see if any of the segments
 1358              		.loc 1 1284 22 is_stmt 0 view .LVU424
 1359 0180 D4E91B21 		ldrd	r2, r1, [r4, #108]
 1360 0184 3046     		mov	r0, r6
 1361 0186 FFF7FEFF 		bl	tcp_free_acked_segments.isra.0
 1362              	.LVL91:
 1363 018a 0246     		mov	r2, r0
1291:lwIP/src/core/tcp_in.c **** 
 1364              		.loc 1 1291 21 view .LVU425
 1365 018c E16E     		ldr	r1, [r4, #108]
 1366 018e 3046     		mov	r0, r6
1284:lwIP/src/core/tcp_in.c ****       /* We go through the ->unsent list to see if any of the segments
 1367              		.loc 1 1284 20 view .LVU426
 1368 0190 2267     		str	r2, [r4, #112]
1291:lwIP/src/core/tcp_in.c **** 
 1369              		.loc 1 1291 7 is_stmt 1 view .LVU427
1291:lwIP/src/core/tcp_in.c **** 
 1370              		.loc 1 1291 21 is_stmt 0 view .LVU428
 1371 0192 FFF7FEFF 		bl	tcp_free_acked_segments.isra.0
 1372              	.LVL92:
1295:lwIP/src/core/tcp_in.c ****         pcb->rtime = -1;
 1373              		.loc 1 1295 14 view .LVU429
 1374 0196 216F     		ldr	r1, [r4, #112]
1301:lwIP/src/core/tcp_in.c **** 
 1375              		.loc 1 1301 20 view .LVU430
 1376 0198 0022     		movs	r2, #0
1291:lwIP/src/core/tcp_in.c **** 
 1377              		.loc 1 1291 19 view .LVU431
 1378 019a E066     		str	r0, [r4, #108]
1295:lwIP/src/core/tcp_in.c ****         pcb->rtime = -1;
 1379              		.loc 1 1295 7 is_stmt 1 view .LVU432
1295:lwIP/src/core/tcp_in.c ****         pcb->rtime = -1;
 1380              		.loc 1 1295 10 is_stmt 0 view .LVU433
 1381 019c B1FA81F3 		clz	r3, r1
1301:lwIP/src/core/tcp_in.c **** 
 1382              		.loc 1 1301 20 view .LVU434
 1383 01a0 2277     		strb	r2, [r4, #28]
1295:lwIP/src/core/tcp_in.c ****         pcb->rtime = -1;
 1384              		.loc 1 1295 10 view .LVU435
 1385 01a2 5B09     		lsrs	r3, r3, #5
 1386 01a4 5B42     		rsbs	r3, r3, #0
 1387 01a6 2386     		strh	r3, [r4, #48]	@ movhi
1301:lwIP/src/core/tcp_in.c **** 
 1388              		.loc 1 1301 7 is_stmt 1 view .LVU436
1304:lwIP/src/core/tcp_in.c ****         pcb->unsent_oversize = 0;
 1389              		.loc 1 1304 7 view .LVU437
1304:lwIP/src/core/tcp_in.c ****         pcb->unsent_oversize = 0;
ARM GAS  /tmp/ccFjUByx.s 			page 85


 1390              		.loc 1 1304 10 is_stmt 0 view .LVU438
 1391 01a8 0028     		cmp	r0, #0
 1392 01aa 00F01481 		beq	.L203
 1393              	.L124:
1316:lwIP/src/core/tcp_in.c ****       /* check if this ACK ends our retransmission of in-flight data */
 1394              		.loc 1 1316 7 is_stmt 1 view .LVU439
1316:lwIP/src/core/tcp_in.c ****       /* check if this ACK ends our retransmission of in-flight data */
 1395              		.loc 1 1316 22 is_stmt 0 view .LVU440
 1396 01ae 4E4A     		ldr	r2, .L210+20
 1397 01b0 B4F86430 		ldrh	r3, [r4, #100]
 1398 01b4 1288     		ldrh	r2, [r2]
 1399 01b6 494E     		ldr	r6, .L210+8
 1400 01b8 1344     		add	r3, r3, r2
1318:lwIP/src/core/tcp_in.c ****         /* RTO is done if
 1401              		.loc 1 1318 14 view .LVU441
 1402 01ba 628B     		ldrh	r2, [r4, #26]
 1403 01bc B6F800C0 		ldrh	ip, [r6]
1318:lwIP/src/core/tcp_in.c ****         /* RTO is done if
 1404              		.loc 1 1318 10 view .LVU442
 1405 01c0 12F4006F 		tst	r2, #2048
1316:lwIP/src/core/tcp_in.c ****       /* check if this ACK ends our retransmission of in-flight data */
 1406              		.loc 1 1316 20 view .LVU443
 1407 01c4 A4F86430 		strh	r3, [r4, #100]	@ movhi
1318:lwIP/src/core/tcp_in.c ****         /* RTO is done if
 1408              		.loc 1 1318 7 is_stmt 1 view .LVU444
 1409 01c8 3B68     		ldr	r3, [r7]
1318:lwIP/src/core/tcp_in.c ****         /* RTO is done if
 1410              		.loc 1 1318 10 is_stmt 0 view .LVU445
 1411 01ca 14D0     		beq	.L115
1323:lwIP/src/core/tcp_in.c ****           if ((pcb->unsent == NULL) ||
 1412              		.loc 1 1323 9 is_stmt 1 view .LVU446
1323:lwIP/src/core/tcp_in.c ****           if ((pcb->unsent == NULL) ||
 1413              		.loc 1 1323 12 is_stmt 0 view .LVU447
 1414 01cc 0029     		cmp	r1, #0
 1415 01ce 00F00F81 		beq	.L204
1328:lwIP/src/core/tcp_in.c ****           tcp_clear_flags(pcb, TF_RTO);
 1416              		.loc 1 1328 16 is_stmt 1 view .LVU448
 1417              	.LVL93:
 1418              	.LBB202:
 1419              	.LBI202:
 900:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1420              		.loc 2 900 31 view .LVU449
 1421              	.LBB203:
 903:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 1422              		.loc 2 903 3 view .LVU450
 1423              	.LBE203:
 1424              	.LBE202:
1328:lwIP/src/core/tcp_in.c ****           tcp_clear_flags(pcb, TF_RTO);
 1425              		.loc 1 1328 20 is_stmt 0 view .LVU451
 1426 01d2 C868     		ldr	r0, [r1, #12]
 1427              	.LVL94:
 1428              	.L195:
1328:lwIP/src/core/tcp_in.c ****           tcp_clear_flags(pcb, TF_RTO);
 1429              		.loc 1 1328 20 view .LVU452
 1430 01d4 4068     		ldr	r0, [r0, #4]	@ unaligned
 1431 01d6 E16C     		ldr	r1, [r4, #76]
 1432              	.LBB205:
ARM GAS  /tmp/ccFjUByx.s 			page 86


 1433              	.LBB204:
 903:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 1434              		.loc 2 903 10 view .LVU453
 1435 01d8 00BA     		rev	r0, r0
 1436              	.LBE204:
 1437              	.LBE205:
1328:lwIP/src/core/tcp_in.c ****           tcp_clear_flags(pcb, TF_RTO);
 1438              		.loc 1 1328 20 view .LVU454
 1439 01da 091A     		subs	r1, r1, r0
1328:lwIP/src/core/tcp_in.c ****           tcp_clear_flags(pcb, TF_RTO);
 1440              		.loc 1 1328 19 view .LVU455
 1441 01dc 0029     		cmp	r1, #0
 1442 01de 0ADC     		bgt	.L115
 1443              	.L192:
1329:lwIP/src/core/tcp_in.c ****         }
 1444              		.loc 1 1329 11 is_stmt 1 view .LVU456
1329:lwIP/src/core/tcp_in.c ****         }
 1445              		.loc 1 1329 11 view .LVU457
 1446 01e0 22F40062 		bic	r2, r2, #2048
 1447 01e4 6283     		strh	r2, [r4, #26]	@ movhi
 1448 01e6 06E0     		b	.L115
 1449              	.LVL95:
 1450              	.L116:
1329:lwIP/src/core/tcp_in.c ****         }
 1451              		.loc 1 1329 11 is_stmt 0 view .LVU458
 1452              	.LBE200:
1335:lwIP/src/core/tcp_in.c ****     }
 1453              		.loc 1 1335 7 is_stmt 1 view .LVU459
 1454 01e8 3C4E     		ldr	r6, .L210+8
 1455 01ea 2046     		mov	r0, r4
 1456              	.LVL96:
1335:lwIP/src/core/tcp_in.c ****     }
 1457              		.loc 1 1335 7 is_stmt 0 view .LVU460
 1458 01ec FFF7FEFF 		bl	tcp_send_empty_ack
 1459              	.LVL97:
 1460 01f0 3B68     		ldr	r3, [r7]
 1461 01f2 B6F800C0 		ldrh	ip, [r6]
 1462              	.L115:
1339:lwIP/src/core/tcp_in.c **** 
 1463              		.loc 1 1339 65 is_stmt 1 view .LVU461
1344:lwIP/src/core/tcp_in.c ****       /* diff between this shouldn't exceed 32K since this are tcp timer ticks
 1464              		.loc 1 1344 5 view .LVU462
1344:lwIP/src/core/tcp_in.c ****       /* diff between this shouldn't exceed 32K since this are tcp timer ticks
 1465              		.loc 1 1344 12 is_stmt 0 view .LVU463
 1466 01f6 626B     		ldr	r2, [r4, #52]
 1467 01f8 606A     		ldr	r0, [r4, #36]
1344:lwIP/src/core/tcp_in.c ****       /* diff between this shouldn't exceed 32K since this are tcp timer ticks
 1468              		.loc 1 1344 8 view .LVU464
 1469 01fa 002A     		cmp	r2, #0
 1470 01fc 3FF40DAF 		beq	.L102
 1471 0200 2968     		ldr	r1, [r5]
 1472              	.L156:
1344:lwIP/src/core/tcp_in.c ****       /* diff between this shouldn't exceed 32K since this are tcp timer ticks
 1473              		.loc 1 1344 24 view .LVU465
 1474 0202 A56B     		ldr	r5, [r4, #56]
 1475 0204 691A     		subs	r1, r5, r1
1344:lwIP/src/core/tcp_in.c ****       /* diff between this shouldn't exceed 32K since this are tcp timer ticks
ARM GAS  /tmp/ccFjUByx.s 			page 87


 1476              		.loc 1 1344 21 view .LVU466
 1477 0206 0029     		cmp	r1, #0
 1478 0208 BFF607AF 		bge	.L102
1347:lwIP/src/core/tcp_in.c **** 
 1479              		.loc 1 1347 7 is_stmt 1 view .LVU467
1353:lwIP/src/core/tcp_in.c ****       pcb->sa = (s16_t)(pcb->sa + m);
 1480              		.loc 1 1353 27 is_stmt 0 view .LVU468
 1481 020c B4F93C50 		ldrsh	r5, [r4, #60]
1347:lwIP/src/core/tcp_in.c **** 
 1482              		.loc 1 1347 29 view .LVU469
 1483 0210 92B2     		uxth	r2, r2
 1484 0212 3649     		ldr	r1, .L210+24
1353:lwIP/src/core/tcp_in.c ****       pcb->sa = (s16_t)(pcb->sa + m);
 1485              		.loc 1 1353 21 view .LVU470
 1486 0214 C5F3CF0E 		ubfx	lr, r5, #3, #16
1347:lwIP/src/core/tcp_in.c **** 
 1487              		.loc 1 1347 29 view .LVU471
 1488 0218 B1F80080 		ldrh	r8, [r1]
 1489              	.LVL98:
1350:lwIP/src/core/tcp_in.c **** 
 1490              		.loc 1 1350 70 is_stmt 1 view .LVU472
1353:lwIP/src/core/tcp_in.c ****       pcb->sa = (s16_t)(pcb->sa + m);
 1491              		.loc 1 1353 7 view .LVU473
1353:lwIP/src/core/tcp_in.c ****       pcb->sa = (s16_t)(pcb->sa + m);
 1492              		.loc 1 1353 21 is_stmt 0 view .LVU474
 1493 021c A8EB0E01 		sub	r1, r8, lr
 1494 0220 891A     		subs	r1, r1, r2
 1495 0222 89B2     		uxth	r1, r1
 1496              	.LVL99:
1354:lwIP/src/core/tcp_in.c ****       if (m < 0) {
 1497              		.loc 1 1354 7 is_stmt 1 view .LVU475
1354:lwIP/src/core/tcp_in.c ****       if (m < 0) {
 1498              		.loc 1 1354 33 is_stmt 0 view .LVU476
 1499 0224 0D44     		add	r5, r5, r1
1355:lwIP/src/core/tcp_in.c ****         m = (s16_t) - m;
 1500              		.loc 1 1355 10 view .LVU477
 1501 0226 11F4004F 		tst	r1, #32768
1354:lwIP/src/core/tcp_in.c ****       if (m < 0) {
 1502              		.loc 1 1354 17 view .LVU478
 1503 022a 2DB2     		sxth	r5, r5
1354:lwIP/src/core/tcp_in.c ****       if (m < 0) {
 1504              		.loc 1 1354 15 view .LVU479
 1505 022c A587     		strh	r5, [r4, #60]	@ movhi
1355:lwIP/src/core/tcp_in.c ****         m = (s16_t) - m;
 1506              		.loc 1 1355 7 is_stmt 1 view .LVU480
1355:lwIP/src/core/tcp_in.c ****         m = (s16_t) - m;
 1507              		.loc 1 1355 10 is_stmt 0 view .LVU481
 1508 022e 03D0     		beq	.L127
1356:lwIP/src/core/tcp_in.c ****       }
 1509              		.loc 1 1356 9 is_stmt 1 view .LVU482
1356:lwIP/src/core/tcp_in.c ****       }
 1510              		.loc 1 1356 13 is_stmt 0 view .LVU483
 1511 0230 AEEB080E 		sub	lr, lr, r8
 1512 0234 7244     		add	r2, r2, lr
 1513 0236 91B2     		uxth	r1, r2
 1514              	.LVL100:
 1515              	.L127:
ARM GAS  /tmp/ccFjUByx.s 			page 88


1358:lwIP/src/core/tcp_in.c ****       pcb->sv = (s16_t)(pcb->sv + m);
 1516              		.loc 1 1358 7 is_stmt 1 view .LVU484
1358:lwIP/src/core/tcp_in.c ****       pcb->sv = (s16_t)(pcb->sv + m);
 1517              		.loc 1 1358 27 is_stmt 0 view .LVU485
 1518 0238 B4F93E20 		ldrsh	r2, [r4, #62]
1359:lwIP/src/core/tcp_in.c ****       pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 1519              		.loc 1 1359 7 is_stmt 1 view .LVU486
1365:lwIP/src/core/tcp_in.c ****     }
 1520              		.loc 1 1365 19 is_stmt 0 view .LVU487
 1521 023c 4FF0000E 		mov	lr, #0
1359:lwIP/src/core/tcp_in.c ****       pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 1522              		.loc 1 1359 33 view .LVU488
 1523 0240 A2EBA202 		sub	r2, r2, r2, asr #2
1365:lwIP/src/core/tcp_in.c ****     }
 1524              		.loc 1 1365 19 view .LVU489
 1525 0244 C4F834E0 		str	lr, [r4, #52]
1359:lwIP/src/core/tcp_in.c ****       pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 1526              		.loc 1 1359 33 view .LVU490
 1527 0248 0A44     		add	r2, r2, r1
 1528 024a 92B2     		uxth	r2, r2
1360:lwIP/src/core/tcp_in.c **** 
 1529              		.loc 1 1360 41 view .LVU491
 1530 024c 02EBE505 		add	r5, r2, r5, asr #3
1359:lwIP/src/core/tcp_in.c ****       pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 1531              		.loc 1 1359 15 view .LVU492
 1532 0250 E287     		strh	r2, [r4, #62]	@ movhi
1360:lwIP/src/core/tcp_in.c **** 
 1533              		.loc 1 1360 7 is_stmt 1 view .LVU493
1360:lwIP/src/core/tcp_in.c **** 
 1534              		.loc 1 1360 16 is_stmt 0 view .LVU494
 1535 0252 A4F84050 		strh	r5, [r4, #64]	@ movhi
1363:lwIP/src/core/tcp_in.c **** 
 1536              		.loc 1 1363 84 is_stmt 1 view .LVU495
1365:lwIP/src/core/tcp_in.c ****     }
 1537              		.loc 1 1365 7 view .LVU496
1373:lwIP/src/core/tcp_in.c ****     /* This code basically does three things:
 1538              		.loc 1 1373 3 view .LVU497
1373:lwIP/src/core/tcp_in.c ****     /* This code basically does three things:
 1539              		.loc 1 1373 6 is_stmt 0 view .LVU498
 1540 0256 BCF1000F 		cmp	ip, #0
 1541 025a 7FF4E1AE 		bne	.L205
 1542 025e 24E7     		b	.L128
 1543              	.L109:
1226:lwIP/src/core/tcp_in.c ****       }
 1544              		.loc 1 1226 9 is_stmt 1 view .LVU499
1226:lwIP/src/core/tcp_in.c ****       }
 1545              		.loc 1 1226 22 is_stmt 0 view .LVU500
 1546 0260 0022     		movs	r2, #0
 1547 0262 84F84320 		strb	r2, [r4, #67]
 1548 0266 C6E7     		b	.L115
 1549              	.LVL101:
 1550              	.L200:
1156:lwIP/src/core/tcp_in.c ****       pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 1551              		.loc 1 1156 42 view .LVU501
 1552 0268 1E4A     		ldr	r2, .L210+16
 1553 026a 1268     		ldr	r2, [r2]
 1554 026c D289     		ldrh	r2, [r2, #14]	@ unaligned
ARM GAS  /tmp/ccFjUByx.s 			page 89


1156:lwIP/src/core/tcp_in.c ****       pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 1555              		.loc 1 1156 32 view .LVU502
 1556 026e 9042     		cmp	r0, r2
 1557 0270 BFF43AAF 		bcs	.L158
 1558 0274 42E7     		b	.L104
 1559              	.LVL102:
 1560              	.L117:
 1561              	.LBB209:
1236:lwIP/src/core/tcp_in.c ****         pcb->cwnd = pcb->ssthresh;
 1562              		.loc 1 1236 9 is_stmt 1 view .LVU503
1236:lwIP/src/core/tcp_in.c ****         pcb->cwnd = pcb->ssthresh;
 1563              		.loc 1 1236 9 view .LVU504
 1564 0276 23F00403 		bic	r3, r3, #4
1245:lwIP/src/core/tcp_in.c **** 
 1565              		.loc 1 1245 41 is_stmt 0 view .LVU505
 1566 027a E08F     		ldrh	r0, [r4, #62]
1245:lwIP/src/core/tcp_in.c **** 
 1567              		.loc 1 1245 41 view .LVU506
 1568 027c B4F93CC0 		ldrsh	ip, [r4, #60]
1248:lwIP/src/core/tcp_in.c **** 
 1569              		.loc 1 1248 13 view .LVU507
 1570 0280 B6B2     		uxth	r6, r6
1236:lwIP/src/core/tcp_in.c ****         pcb->cwnd = pcb->ssthresh;
 1571              		.loc 1 1236 9 view .LVU508
 1572 0282 6383     		strh	r3, [r4, #26]	@ movhi
1236:lwIP/src/core/tcp_in.c ****         pcb->cwnd = pcb->ssthresh;
 1573              		.loc 1 1236 9 is_stmt 1 view .LVU509
1237:lwIP/src/core/tcp_in.c ****         pcb->bytes_acked = 0;
 1574              		.loc 1 1237 9 view .LVU510
1245:lwIP/src/core/tcp_in.c **** 
 1575              		.loc 1 1245 41 is_stmt 0 view .LVU511
 1576 0284 00EBEC03 		add	r3, r0, ip, asr #3
1238:lwIP/src/core/tcp_in.c ****       }
 1577              		.loc 1 1238 26 view .LVU512
 1578 0288 0020     		movs	r0, #0
1237:lwIP/src/core/tcp_in.c ****         pcb->bytes_acked = 0;
 1579              		.loc 1 1237 19 view .LVU513
 1580 028a A4F84820 		strh	r2, [r4, #72]	@ movhi
1238:lwIP/src/core/tcp_in.c ****       }
 1581              		.loc 1 1238 9 is_stmt 1 view .LVU514
1252:lwIP/src/core/tcp_in.c **** 
 1582              		.loc 1 1252 20 is_stmt 0 view .LVU515
 1583 028e 6164     		str	r1, [r4, #68]
1245:lwIP/src/core/tcp_in.c **** 
 1584              		.loc 1 1245 16 view .LVU516
 1585 0290 A4F84030 		strh	r3, [r4, #64]	@ movhi
1238:lwIP/src/core/tcp_in.c ****       }
 1586              		.loc 1 1238 26 view .LVU517
 1587 0294 A4F86A00 		strh	r0, [r4, #106]	@ movhi
1242:lwIP/src/core/tcp_in.c **** 
 1588              		.loc 1 1242 7 is_stmt 1 view .LVU518
1245:lwIP/src/core/tcp_in.c **** 
 1589              		.loc 1 1245 7 view .LVU519
1248:lwIP/src/core/tcp_in.c **** 
 1590              		.loc 1 1248 7 view .LVU520
 1591              	.LVL103:
1251:lwIP/src/core/tcp_in.c ****       pcb->lastack = ackno;
ARM GAS  /tmp/ccFjUByx.s 			page 90


 1592              		.loc 1 1251 7 view .LVU521
1242:lwIP/src/core/tcp_in.c **** 
 1593              		.loc 1 1242 17 is_stmt 0 view .LVU522
 1594 0298 A4F84200 		strh	r0, [r4, #66]	@ movhi
1252:lwIP/src/core/tcp_in.c **** 
 1595              		.loc 1 1252 7 is_stmt 1 view .LVU523
1256:lwIP/src/core/tcp_in.c ****         if (pcb->cwnd < pcb->ssthresh) {
 1596              		.loc 1 1256 7 view .LVU524
1257:lwIP/src/core/tcp_in.c ****           tcpwnd_size_t increase;
 1597              		.loc 1 1257 9 view .LVU525
 1598              	.L119:
1267:lwIP/src/core/tcp_in.c ****           if (pcb->bytes_acked >= pcb->cwnd) {
 1599              		.loc 1 1267 11 view .LVU526
1267:lwIP/src/core/tcp_in.c ****           if (pcb->bytes_acked >= pcb->cwnd) {
 1600              		.loc 1 1267 11 view .LVU527
 1601 029c B4F86A10 		ldrh	r1, [r4, #106]
 1602 02a0 8B19     		adds	r3, r1, r6
 1603 02a2 9BB2     		uxth	r3, r3
 1604 02a4 9942     		cmp	r1, r3
 1605 02a6 40F29980 		bls	.L206
1267:lwIP/src/core/tcp_in.c ****           if (pcb->bytes_acked >= pcb->cwnd) {
 1606              		.loc 1 1267 11 is_stmt 0 view .LVU528
 1607 02aa 4FF6FF73 		movw	r3, #65535
 1608              	.L123:
1269:lwIP/src/core/tcp_in.c ****             TCP_WND_INC(pcb->cwnd, pcb->mss);
 1609              		.loc 1 1269 13 is_stmt 1 view .LVU529
1270:lwIP/src/core/tcp_in.c ****           }
 1610              		.loc 1 1270 13 is_stmt 0 view .LVU530
 1611 02ae 618E     		ldrh	r1, [r4, #50]
1269:lwIP/src/core/tcp_in.c ****             TCP_WND_INC(pcb->cwnd, pcb->mss);
 1612              		.loc 1 1269 32 view .LVU531
 1613 02b0 9B1A     		subs	r3, r3, r2
1270:lwIP/src/core/tcp_in.c ****           }
 1614              		.loc 1 1270 13 view .LVU532
 1615 02b2 1144     		add	r1, r1, r2
1269:lwIP/src/core/tcp_in.c ****             TCP_WND_INC(pcb->cwnd, pcb->mss);
 1616              		.loc 1 1269 30 view .LVU533
 1617 02b4 A4F86A30 		strh	r3, [r4, #106]	@ movhi
1270:lwIP/src/core/tcp_in.c ****           }
 1618              		.loc 1 1270 13 is_stmt 1 view .LVU534
1270:lwIP/src/core/tcp_in.c ****           }
 1619              		.loc 1 1270 13 view .LVU535
 1620 02b8 8BB2     		uxth	r3, r1
 1621 02ba 9342     		cmp	r3, r2
 1622 02bc BFF45CAF 		bcs	.L191
 1623              	.L121:
 1624              	.LBB206:
1263:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd)
 1625              		.loc 1 1263 11 view .LVU536
 1626 02c0 4FF6FF73 		movw	r3, #65535
 1627 02c4 A4F84830 		strh	r3, [r4, #72]	@ movhi
 1628 02c8 58E7     		b	.L122
 1629              	.LVL104:
 1630              	.L197:
1263:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd)
 1631              		.loc 1 1263 11 is_stmt 0 view .LVU537
 1632              	.LBE206:
ARM GAS  /tmp/ccFjUByx.s 			page 91


 1633              	.LBE209:
1449:lwIP/src/core/tcp_in.c ****         tcp_ack_now(pcb);
 1634              		.loc 1 1449 89 is_stmt 1 view .LVU538
1450:lwIP/src/core/tcp_in.c ****       }
 1635              		.loc 1 1450 9 view .LVU539
1450:lwIP/src/core/tcp_in.c ****       }
 1636              		.loc 1 1450 9 view .LVU540
 1637 02ca 638B     		ldrh	r3, [r4, #26]
 1638 02cc 43F00203 		orr	r3, r3, #2
 1639 02d0 6383     		strh	r3, [r4, #26]	@ movhi
1450:lwIP/src/core/tcp_in.c ****       }
 1640              		.loc 1 1450 9 view .LVU541
1457:lwIP/src/core/tcp_in.c ****                         pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 1641              		.loc 1 1457 5 view .LVU542
 1642 02d2 BFE6     		b	.L139
 1643              	.L211:
 1644              		.align	2
 1645              	.L210:
 1646 02d4 00000000 		.word	.LANCHOR9
 1647 02d8 00000000 		.word	.LANCHOR8
 1648 02dc 00000000 		.word	.LANCHOR10
 1649 02e0 00000000 		.word	.LANCHOR7
 1650 02e4 00000000 		.word	.LANCHOR4
 1651 02e8 00000000 		.word	.LANCHOR6
 1652 02ec 00000000 		.word	tcp_ticks
 1653              	.L196:
 1654              	.LBB210:
1425:lwIP/src/core/tcp_in.c ****       u32_t off32 = pcb->rcv_nxt - seqno;
 1655              		.loc 1 1425 7 view .LVU543
1425:lwIP/src/core/tcp_in.c ****       u32_t off32 = pcb->rcv_nxt - seqno;
 1656              		.loc 1 1425 20 is_stmt 0 view .LVU544
 1657 02f0 664D     		ldr	r5, .L212
 1658 02f2 6868     		ldr	r0, [r5, #4]
 1659              	.LVL105:
1426:lwIP/src/core/tcp_in.c ****       u16_t new_tot_len, off;
 1660              		.loc 1 1426 7 is_stmt 1 view .LVU545
1427:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("inseg.p != NULL", inseg.p);
 1661              		.loc 1 1427 7 view .LVU546
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1662              		.loc 1 1428 7 view .LVU547
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1663              		.loc 1 1428 7 view .LVU548
 1664 02f4 0028     		cmp	r0, #0
 1665 02f6 77D0     		beq	.L207
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1666              		.loc 1 1428 7 view .LVU549
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 1667              		.loc 1 1429 7 view .LVU550
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 1668              		.loc 1 1429 7 view .LVU551
 1669 02f8 4FF6FE73 		movw	r3, #65534
 1670 02fc 9942     		cmp	r1, r3
 1671 02fe 00F2A880 		bhi	.L208
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 1672              		.loc 1 1429 7 view .LVU552
1430:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 1673              		.loc 1 1430 7 view .LVU553
ARM GAS  /tmp/ccFjUByx.s 			page 92


1430:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 1674              		.loc 1 1430 11 is_stmt 0 view .LVU554
 1675 0302 89B2     		uxth	r1, r1
 1676              	.LVL106:
1431:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
 1677              		.loc 1 1431 7 is_stmt 1 view .LVU555
1431:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
 1678              		.loc 1 1431 7 view .LVU556
 1679 0304 0389     		ldrh	r3, [r0, #8]
 1680 0306 9942     		cmp	r1, r3
 1681 0308 00F29F80 		bhi	.L209
1431:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
 1682              		.loc 1 1431 7 view .LVU557
1432:lwIP/src/core/tcp_in.c ****       new_tot_len = (u16_t)(inseg.p->tot_len - off);
 1683              		.loc 1 1432 7 view .LVU558
1432:lwIP/src/core/tcp_in.c ****       new_tot_len = (u16_t)(inseg.p->tot_len - off);
 1684              		.loc 1 1432 17 is_stmt 0 view .LVU559
 1685 030c B5F808C0 		ldrh	ip, [r5, #8]
1433:lwIP/src/core/tcp_in.c ****       while (p->len < off) {
 1686              		.loc 1 1433 19 view .LVU560
 1687 0310 5B1A     		subs	r3, r3, r1
1434:lwIP/src/core/tcp_in.c ****         off -= p->len;
 1688              		.loc 1 1434 15 view .LVU561
 1689 0312 4289     		ldrh	r2, [r0, #10]
1432:lwIP/src/core/tcp_in.c ****       new_tot_len = (u16_t)(inseg.p->tot_len - off);
 1690              		.loc 1 1432 17 view .LVU562
 1691 0314 ACEB010C 		sub	ip, ip, r1
1433:lwIP/src/core/tcp_in.c ****       while (p->len < off) {
 1692              		.loc 1 1433 19 view .LVU563
 1693 0318 9BB2     		uxth	r3, r3
1434:lwIP/src/core/tcp_in.c ****         off -= p->len;
 1694              		.loc 1 1434 13 view .LVU564
 1695 031a 9142     		cmp	r1, r2
1432:lwIP/src/core/tcp_in.c ****       new_tot_len = (u16_t)(inseg.p->tot_len - off);
 1696              		.loc 1 1432 17 view .LVU565
 1697 031c A5F808C0 		strh	ip, [r5, #8]	@ movhi
1433:lwIP/src/core/tcp_in.c ****       while (p->len < off) {
 1698              		.loc 1 1433 7 is_stmt 1 view .LVU566
 1699              	.LVL107:
1434:lwIP/src/core/tcp_in.c ****         off -= p->len;
 1700              		.loc 1 1434 7 view .LVU567
1434:lwIP/src/core/tcp_in.c ****         off -= p->len;
 1701              		.loc 1 1434 13 view .LVU568
 1702 0320 0AD9     		bls	.L136
1438:lwIP/src/core/tcp_in.c ****         p = p->next;
 1703              		.loc 1 1438 16 is_stmt 0 view .LVU569
 1704 0322 4FF0000C 		mov	ip, #0
 1705              	.L137:
1435:lwIP/src/core/tcp_in.c ****         /* all pbufs up to and including this one have len==0, so tot_len is equal */
 1706              		.loc 1 1435 9 is_stmt 1 view .LVU570
1435:lwIP/src/core/tcp_in.c ****         /* all pbufs up to and including this one have len==0, so tot_len is equal */
 1707              		.loc 1 1435 13 is_stmt 0 view .LVU571
 1708 0326 891A     		subs	r1, r1, r2
 1709              	.LVL108:
1438:lwIP/src/core/tcp_in.c ****         p = p->next;
 1710              		.loc 1 1438 16 view .LVU572
 1711 0328 A0F80AC0 		strh	ip, [r0, #10]	@ movhi
ARM GAS  /tmp/ccFjUByx.s 			page 93


1437:lwIP/src/core/tcp_in.c ****         p->len = 0;
 1712              		.loc 1 1437 20 view .LVU573
 1713 032c 0381     		strh	r3, [r0, #8]	@ movhi
1439:lwIP/src/core/tcp_in.c ****       }
 1714              		.loc 1 1439 11 view .LVU574
 1715 032e 0068     		ldr	r0, [r0]
 1716              	.LVL109:
1435:lwIP/src/core/tcp_in.c ****         /* all pbufs up to and including this one have len==0, so tot_len is equal */
 1717              		.loc 1 1435 13 view .LVU575
 1718 0330 89B2     		uxth	r1, r1
 1719              	.LVL110:
1437:lwIP/src/core/tcp_in.c ****         p->len = 0;
 1720              		.loc 1 1437 9 is_stmt 1 view .LVU576
1438:lwIP/src/core/tcp_in.c ****         p = p->next;
 1721              		.loc 1 1438 9 view .LVU577
1439:lwIP/src/core/tcp_in.c ****       }
 1722              		.loc 1 1439 9 view .LVU578
1434:lwIP/src/core/tcp_in.c ****         off -= p->len;
 1723              		.loc 1 1434 13 view .LVU579
1434:lwIP/src/core/tcp_in.c ****         off -= p->len;
 1724              		.loc 1 1434 15 is_stmt 0 view .LVU580
 1725 0332 4289     		ldrh	r2, [r0, #10]
1434:lwIP/src/core/tcp_in.c ****         off -= p->len;
 1726              		.loc 1 1434 13 view .LVU581
 1727 0334 8A42     		cmp	r2, r1
 1728 0336 F6D3     		bcc	.L137
 1729              	.L136:
1442:lwIP/src/core/tcp_in.c ****       inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 1730              		.loc 1 1442 7 is_stmt 1 view .LVU582
 1731 0338 FFF7FEFF 		bl	pbuf_remove_header
 1732              	.LVL111:
1443:lwIP/src/core/tcp_in.c ****     } else {
 1733              		.loc 1 1443 7 view .LVU583
1443:lwIP/src/core/tcp_in.c ****     } else {
 1734              		.loc 1 1443 40 is_stmt 0 view .LVU584
 1735 033c 636A     		ldr	r3, [r4, #36]
1443:lwIP/src/core/tcp_in.c ****     } else {
 1736              		.loc 1 1443 27 view .LVU585
 1737 033e EA68     		ldr	r2, [r5, #12]
 1738              	.LBE210:
1457:lwIP/src/core/tcp_in.c ****                         pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 1739              		.loc 1 1457 9 view .LVU586
 1740 0340 218D     		ldrh	r1, [r4, #40]
 1741              	.LBB211:
1443:lwIP/src/core/tcp_in.c ****     } else {
 1742              		.loc 1 1443 35 view .LVU587
 1743 0342 3B60     		str	r3, [r7]
1443:lwIP/src/core/tcp_in.c ****     } else {
 1744              		.loc 1 1443 27 view .LVU588
 1745 0344 5360     		str	r3, [r2, #4]	@ unaligned
 1746              	.LBE211:
1450:lwIP/src/core/tcp_in.c ****       }
 1747              		.loc 1 1450 9 is_stmt 1 view .LVU589
1457:lwIP/src/core/tcp_in.c ****                         pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 1748              		.loc 1 1457 5 view .LVU590
1457:lwIP/src/core/tcp_in.c ****                         pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 1749              		.loc 1 1457 9 is_stmt 0 view .LVU591
ARM GAS  /tmp/ccFjUByx.s 			page 94


 1750 0346 0029     		cmp	r1, #0
 1751 0348 3FF484AE 		beq	.L139
 1752 034c 03E0     		b	.L138
 1753              	.L198:
1459:lwIP/src/core/tcp_in.c ****         /* The incoming segment is the next in sequence. We check if
 1754              		.loc 1 1459 7 is_stmt 1 view .LVU592
1459:lwIP/src/core/tcp_in.c ****         /* The incoming segment is the next in sequence. We check if
 1755              		.loc 1 1459 10 is_stmt 0 view .LVU593
 1756 034e 8342     		cmp	r3, r0
 1757 0350 7FF480AE 		bne	.L139
 1758 0354 4D4D     		ldr	r5, .L212
 1759              	.L138:
1463:lwIP/src/core/tcp_in.c **** 
 1760              		.loc 1 1463 9 is_stmt 1 view .LVU594
1463:lwIP/src/core/tcp_in.c **** 
 1761              		.loc 1 1463 18 is_stmt 0 view .LVU595
 1762 0356 D5F80CC0 		ldr	ip, [r5, #12]
 1763 035a B5F80880 		ldrh	r8, [r5, #8]
 1764 035e BCF80CE0 		ldrh	lr, [ip, #12]	@ unaligned
 1765              	.LVL112:
 1766              	.LBB212:
 1767              	.LBI212:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1768              		.loc 2 934 30 is_stmt 1 view .LVU596
 1769              	.LBB213:
 1770              		.loc 2 937 3 view .LVU597
 1771              		.loc 2 937 19 is_stmt 0 view .LVU598
 1772 0362 9EFA9EF0 		rev16	r0, lr
 1773              	.LBE213:
 1774              	.LBE212:
1463:lwIP/src/core/tcp_in.c **** 
 1775              		.loc 1 1463 18 view .LVU599
 1776 0366 10F00302 		ands	r2, r0, #3
 1777 036a C0B2     		uxtb	r0, r0
 1778 036c 18BF     		it	ne
 1779 036e 0122     		movne	r2, #1
 1780 0370 4244     		add	r2, r2, r8
 1781 0372 92B2     		uxth	r2, r2
1465:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG,
 1782              		.loc 1 1465 12 view .LVU600
 1783 0374 8A42     		cmp	r2, r1
1463:lwIP/src/core/tcp_in.c **** 
 1784              		.loc 1 1463 16 view .LVU601
 1785 0376 3280     		strh	r2, [r6]	@ movhi
1465:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG,
 1786              		.loc 1 1465 9 is_stmt 1 view .LVU602
1465:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG,
 1787              		.loc 1 1465 12 is_stmt 0 view .LVU603
 1788 0378 46D9     		bls	.L141
1469:lwIP/src/core/tcp_in.c ****           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 1789              		.loc 1 1469 68 is_stmt 1 view .LVU604
1470:lwIP/src/core/tcp_in.c ****             /* Must remove the FIN from the header as we're trimming
 1790              		.loc 1 1470 11 view .LVU605
 1791              	.LVL113:
 1792              		.loc 2 937 3 view .LVU606
1470:lwIP/src/core/tcp_in.c ****             /* Must remove the FIN from the header as we're trimming
 1793              		.loc 1 1470 14 is_stmt 0 view .LVU607
ARM GAS  /tmp/ccFjUByx.s 			page 95


 1794 037a C307     		lsls	r3, r0, #31
 1795 037c 0AD5     		bpl	.L142
1473:lwIP/src/core/tcp_in.c ****           }
 1796              		.loc 1 1473 13 is_stmt 1 view .LVU608
 1797              	.LVL114:
 1798              		.loc 2 937 3 view .LVU609
 1799              	.LBB214:
 1800              	.LBI214:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1801              		.loc 2 934 30 view .LVU610
 1802              	.LBB215:
 1803              		.loc 2 937 3 view .LVU611
 1804              	.LBE215:
 1805              	.LBE214:
1473:lwIP/src/core/tcp_in.c ****           }
 1806              		.loc 1 1473 13 is_stmt 0 view .LVU612
 1807 037e 00F03E03 		and	r3, r0, #62
 1808 0382 2EF47C5E 		bic	lr, lr, #16128
 1809              	.LBB217:
 1810              	.LBB216:
 1811              		.loc 2 937 19 view .LVU613
 1812 0386 5BBA     		rev16	r3, r3
 1813              	.LBE216:
 1814              	.LBE217:
1473:lwIP/src/core/tcp_in.c ****           }
 1815              		.loc 1 1473 13 view .LVU614
 1816 0388 4EEA0303 		orr	r3, lr, r3
 1817 038c 58BA     		rev16	r0, r3
 1818 038e ACF80C30 		strh	r3, [ip, #12]	@ unaligned
 1819 0392 C0B2     		uxtb	r0, r0
 1820              	.L142:
1476:lwIP/src/core/tcp_in.c ****           inseg.len = (u16_t)pcb->rcv_wnd;
 1821              		.loc 1 1476 39 is_stmt 1 view .LVU615
1477:lwIP/src/core/tcp_in.c ****           if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 1822              		.loc 1 1477 11 view .LVU616
1478:lwIP/src/core/tcp_in.c ****             inseg.len -= 1;
 1823              		.loc 1 1478 11 view .LVU617
 1824              	.LVL115:
 1825              	.LBB218:
 1826              	.LBI218:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1827              		.loc 2 934 30 view .LVU618
 1828              	.LBE218:
 1829              		.loc 2 937 3 view .LVU619
1478:lwIP/src/core/tcp_in.c ****             inseg.len -= 1;
 1830              		.loc 1 1478 14 is_stmt 0 view .LVU620
 1831 0394 8007     		lsls	r0, r0, #30
1479:lwIP/src/core/tcp_in.c ****           }
 1832              		.loc 1 1479 13 is_stmt 1 view .LVU621
1481:lwIP/src/core/tcp_in.c ****           tcplen = TCP_TCPLEN(&inseg);
 1833              		.loc 1 1481 11 view .LVU622
 1834 0396 6868     		ldr	r0, [r5, #4]
1479:lwIP/src/core/tcp_in.c ****           }
 1835              		.loc 1 1479 23 is_stmt 0 view .LVU623
 1836 0398 44BF     		itt	mi
 1837 039a 01F1FF32 		addmi	r2, r1, #-1
 1838 039e 91B2     		uxthmi	r1, r2
ARM GAS  /tmp/ccFjUByx.s 			page 96


 1839 03a0 2981     		strh	r1, [r5, #8]	@ movhi
1481:lwIP/src/core/tcp_in.c ****           tcplen = TCP_TCPLEN(&inseg);
 1840              		.loc 1 1481 11 view .LVU624
 1841 03a2 FFF7FEFF 		bl	pbuf_realloc
 1842              	.LVL116:
1482:lwIP/src/core/tcp_in.c ****           LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 1843              		.loc 1 1482 11 is_stmt 1 view .LVU625
 1844              	.LBB219:
 1845              	.LBI219:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1846              		.loc 2 934 30 view .LVU626
 1847              	.LBB220:
 1848              		.loc 2 937 3 view .LVU627
 1849              		.loc 2 937 3 is_stmt 0 view .LVU628
 1850              	.LBE220:
 1851              	.LBE219:
1482:lwIP/src/core/tcp_in.c ****           LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 1852              		.loc 1 1482 20 view .LVU629
 1853 03a6 EB68     		ldr	r3, [r5, #12]
 1854 03a8 B5F808C0 		ldrh	ip, [r5, #8]
 1855 03ac 9B89     		ldrh	r3, [r3, #12]	@ unaligned
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1856              		.loc 1 1483 11 view .LVU630
 1857 03ae 626A     		ldr	r2, [r4, #36]
 1858              	.LBB222:
 1859              	.LBB221:
 1860              		.loc 2 937 19 view .LVU631
 1861 03b0 5BBA     		rev16	r3, r3
 1862              	.LBE221:
 1863              	.LBE222:
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1864              		.loc 1 1483 11 view .LVU632
 1865 03b2 218D     		ldrh	r1, [r4, #40]
 1866 03b4 3868     		ldr	r0, [r7]
1482:lwIP/src/core/tcp_in.c ****           LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 1867              		.loc 1 1482 20 view .LVU633
 1868 03b6 13F00303 		ands	r3, r3, #3
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1869              		.loc 1 1483 11 view .LVU634
 1870 03ba 01EB0207 		add	r7, r1, r2
1482:lwIP/src/core/tcp_in.c ****           LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 1871              		.loc 1 1482 20 view .LVU635
 1872 03be 18BF     		it	ne
 1873 03c0 0123     		movne	r3, #1
 1874 03c2 6344     		add	r3, r3, ip
 1875 03c4 9AB2     		uxth	r2, r3
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1876              		.loc 1 1483 11 view .LVU636
 1877 03c6 1044     		add	r0, r0, r2
1482:lwIP/src/core/tcp_in.c ****           LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 1878              		.loc 1 1482 18 view .LVU637
 1879 03c8 3280     		strh	r2, [r6]	@ movhi
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1880              		.loc 1 1483 11 is_stmt 1 view .LVU638
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1881              		.loc 1 1483 11 view .LVU639
 1882 03ca B842     		cmp	r0, r7
ARM GAS  /tmp/ccFjUByx.s 			page 97


 1883 03cc 15D0     		beq	.L145
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1884              		.loc 1 1483 11 view .LVU640
 1885 03ce 3048     		ldr	r0, .L212+4
 1886 03d0 FFF7FEFF 		bl	puts
 1887              	.LVL117:
 1888              	.L146:
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1889              		.loc 1 1483 11 view .LVU641
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1890              		.loc 1 1483 11 view .LVU642
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1891              		.loc 1 1483 11 view .LVU643
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1892              		.loc 1 1483 11 view .LVU644
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1893              		.loc 1 1483 11 view .LVU645
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1894              		.loc 1 1483 11 view .LVU646
 1895 03d4 FEE7     		b	.L146
 1896              	.L203:
 1897              	.LBB223:
1305:lwIP/src/core/tcp_in.c ****       }
 1898              		.loc 1 1305 9 view .LVU647
1305:lwIP/src/core/tcp_in.c ****       }
 1899              		.loc 1 1305 30 is_stmt 0 view .LVU648
 1900 03d6 A4F86800 		strh	r0, [r4, #104]	@ movhi
 1901 03da E8E6     		b	.L124
 1902              	.LVL118:
 1903              	.L206:
1267:lwIP/src/core/tcp_in.c ****           if (pcb->bytes_acked >= pcb->cwnd) {
 1904              		.loc 1 1267 11 is_stmt 1 view .LVU649
1268:lwIP/src/core/tcp_in.c ****             pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
 1905              		.loc 1 1268 11 view .LVU650
1268:lwIP/src/core/tcp_in.c ****             pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
 1906              		.loc 1 1268 14 is_stmt 0 view .LVU651
 1907 03dc 9342     		cmp	r3, r2
 1908 03de BFF466AF 		bcs	.L123
 1909 03e2 A4F86A30 		strh	r3, [r4, #106]	@ movhi
 1910 03e6 C9E6     		b	.L122
 1911              	.LVL119:
 1912              	.L207:
1268:lwIP/src/core/tcp_in.c ****             pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
 1913              		.loc 1 1268 14 view .LVU652
 1914              	.LBE223:
 1915              	.LBB224:
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1916              		.loc 1 1428 7 is_stmt 1 view .LVU653
 1917 03e8 2A48     		ldr	r0, .L212+8
 1918              	.LVL120:
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1919              		.loc 1 1428 7 is_stmt 0 view .LVU654
 1920 03ea FFF7FEFF 		bl	printf
 1921              	.LVL121:
 1922              	.L131:
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1923              		.loc 1 1428 7 is_stmt 1 view .LVU655
ARM GAS  /tmp/ccFjUByx.s 			page 98


1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1924              		.loc 1 1428 7 view .LVU656
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1925              		.loc 1 1428 7 view .LVU657
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1926              		.loc 1 1428 7 view .LVU658
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1927              		.loc 1 1428 7 view .LVU659
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1928              		.loc 1 1428 7 view .LVU660
 1929 03ee FEE7     		b	.L131
 1930              	.L204:
1428:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 1931              		.loc 1 1428 7 is_stmt 0 view .LVU661
 1932              	.LBE224:
 1933              	.LBB225:
1324:lwIP/src/core/tcp_in.c ****               (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
 1934              		.loc 1 1324 11 is_stmt 1 view .LVU662
1324:lwIP/src/core/tcp_in.c ****               (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
 1935              		.loc 1 1324 14 is_stmt 0 view .LVU663
 1936 03f0 0028     		cmp	r0, #0
 1937 03f2 3FF4F5AE 		beq	.L192
 1938              	.LVL122:
 1939              	.LBB207:
 1940              	.LBI207:
 900:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1941              		.loc 2 900 31 is_stmt 1 view .LVU664
 1942              	.LBB208:
 903:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 1943              		.loc 2 903 3 view .LVU665
 1944              	.LBE208:
 1945              	.LBE207:
1325:lwIP/src/core/tcp_in.c ****             tcp_clear_flags(pcb, TF_RTO);
 1946              		.loc 1 1325 16 is_stmt 0 view .LVU666
 1947 03f6 C068     		ldr	r0, [r0, #12]
 1948              	.LVL123:
1325:lwIP/src/core/tcp_in.c ****             tcp_clear_flags(pcb, TF_RTO);
 1949              		.loc 1 1325 16 view .LVU667
 1950 03f8 ECE6     		b	.L195
 1951              	.LVL124:
 1952              	.L145:
1325:lwIP/src/core/tcp_in.c ****             tcp_clear_flags(pcb, TF_RTO);
 1953              		.loc 1 1325 16 view .LVU668
 1954              	.LBE225:
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1955              		.loc 1 1483 11 is_stmt 1 view .LVU669
1540:lwIP/src/core/tcp_in.c **** 
 1956              		.loc 1 1540 9 view .LVU670
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1957              		.loc 1 1543 9 is_stmt 0 view .LVU671
 1958 03fa 8A42     		cmp	r2, r1
1540:lwIP/src/core/tcp_in.c **** 
 1959              		.loc 1 1540 22 view .LVU672
 1960 03fc 6062     		str	r0, [r4, #36]
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1961              		.loc 1 1543 9 is_stmt 1 view .LVU673
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
ARM GAS  /tmp/ccFjUByx.s 			page 99


 1962              		.loc 1 1543 9 view .LVU674
 1963 03fe 05D9     		bls	.L147
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1964              		.loc 1 1543 9 view .LVU675
 1965 0400 2548     		ldr	r0, .L212+12
 1966 0402 FFF7FEFF 		bl	puts
 1967              	.LVL125:
 1968              	.L148:
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1969              		.loc 1 1543 9 view .LVU676
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1970              		.loc 1 1543 9 view .LVU677
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1971              		.loc 1 1543 9 view .LVU678
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1972              		.loc 1 1543 9 view .LVU679
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1973              		.loc 1 1543 9 view .LVU680
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1974              		.loc 1 1543 9 view .LVU681
 1975 0406 FEE7     		b	.L148
 1976              	.L141:
1483:lwIP/src/core/tcp_in.c ****                       (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
 1977              		.loc 1 1483 11 view .LVU682
1540:lwIP/src/core/tcp_in.c **** 
 1978              		.loc 1 1540 9 view .LVU683
1540:lwIP/src/core/tcp_in.c **** 
 1979              		.loc 1 1540 22 is_stmt 0 view .LVU684
 1980 0408 1344     		add	r3, r3, r2
 1981 040a 6362     		str	r3, [r4, #36]
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1982              		.loc 1 1543 9 is_stmt 1 view .LVU685
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1983              		.loc 1 1543 9 view .LVU686
 1984              	.L147:
1543:lwIP/src/core/tcp_in.c ****         pcb->rcv_wnd -= tcplen;
 1985              		.loc 1 1543 9 view .LVU687
1544:lwIP/src/core/tcp_in.c **** 
 1986              		.loc 1 1544 9 view .LVU688
1544:lwIP/src/core/tcp_in.c **** 
 1987              		.loc 1 1544 22 is_stmt 0 view .LVU689
 1988 040c 8A1A     		subs	r2, r1, r2
1546:lwIP/src/core/tcp_in.c **** 
 1989              		.loc 1 1546 9 view .LVU690
 1990 040e 2046     		mov	r0, r4
1544:lwIP/src/core/tcp_in.c **** 
 1991              		.loc 1 1544 22 view .LVU691
 1992 0410 2285     		strh	r2, [r4, #40]	@ movhi
1546:lwIP/src/core/tcp_in.c **** 
 1993              		.loc 1 1546 9 is_stmt 1 view .LVU692
 1994 0412 FFF7FEFF 		bl	tcp_update_rcv_ann_wnd
 1995              	.LVL126:
1557:lwIP/src/core/tcp_in.c ****           recv_data = inseg.p;
 1996              		.loc 1 1557 9 view .LVU693
1557:lwIP/src/core/tcp_in.c ****           recv_data = inseg.p;
 1997              		.loc 1 1557 18 is_stmt 0 view .LVU694
 1998 0416 6B68     		ldr	r3, [r5, #4]
ARM GAS  /tmp/ccFjUByx.s 			page 100


1557:lwIP/src/core/tcp_in.c ****           recv_data = inseg.p;
 1999              		.loc 1 1557 12 view .LVU695
 2000 0418 1A89     		ldrh	r2, [r3, #8]
 2001 041a 1AB1     		cbz	r2, .L149
1558:lwIP/src/core/tcp_in.c ****           /* Since this pbuf now is the responsibility of the
 2002              		.loc 1 1558 11 is_stmt 1 view .LVU696
1558:lwIP/src/core/tcp_in.c ****           /* Since this pbuf now is the responsibility of the
 2003              		.loc 1 1558 21 is_stmt 0 view .LVU697
 2004 041c 1F49     		ldr	r1, .L212+16
1562:lwIP/src/core/tcp_in.c ****         }
 2005              		.loc 1 1562 19 view .LVU698
 2006 041e 0022     		movs	r2, #0
1558:lwIP/src/core/tcp_in.c ****           /* Since this pbuf now is the responsibility of the
 2007              		.loc 1 1558 21 view .LVU699
 2008 0420 0B60     		str	r3, [r1]
1562:lwIP/src/core/tcp_in.c ****         }
 2009              		.loc 1 1562 11 is_stmt 1 view .LVU700
1562:lwIP/src/core/tcp_in.c ****         }
 2010              		.loc 1 1562 19 is_stmt 0 view .LVU701
 2011 0422 6A60     		str	r2, [r5, #4]
 2012              	.L149:
1564:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
 2013              		.loc 1 1564 9 is_stmt 1 view .LVU702
 2014              	.LVL127:
 2015              	.LBB226:
 2016              	.LBI226:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2017              		.loc 2 934 30 view .LVU703
 2018              	.LBB227:
 2019              		.loc 2 937 3 view .LVU704
 2020              		.loc 2 937 3 is_stmt 0 view .LVU705
 2021              	.LBE227:
 2022              	.LBE226:
1564:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
 2023              		.loc 1 1564 13 view .LVU706
 2024 0424 EB68     		ldr	r3, [r5, #12]
 2025 0426 9B89     		ldrh	r3, [r3, #12]	@ unaligned
 2026              	.LBB229:
 2027              	.LBB228:
 2028              		.loc 2 937 19 view .LVU707
 2029 0428 5BBA     		rev16	r3, r3
 2030              	.LBE228:
 2031              	.LBE229:
1564:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
 2032              		.loc 1 1564 12 view .LVU708
 2033 042a D907     		lsls	r1, r3, #31
 2034 042c 04D5     		bpl	.L150
1565:lwIP/src/core/tcp_in.c ****           recv_flags |= TF_GOT_FIN;
 2035              		.loc 1 1565 73 is_stmt 1 view .LVU709
1566:lwIP/src/core/tcp_in.c ****         }
 2036              		.loc 1 1566 11 view .LVU710
1566:lwIP/src/core/tcp_in.c ****         }
 2037              		.loc 1 1566 22 is_stmt 0 view .LVU711
 2038 042e 1C4A     		ldr	r2, .L212+20
 2039 0430 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 2040 0432 43F02003 		orr	r3, r3, #32
 2041 0436 1370     		strb	r3, [r2]
ARM GAS  /tmp/ccFjUByx.s 			page 101


 2042              	.L150:
1625:lwIP/src/core/tcp_in.c **** 
 2043              		.loc 1 1625 9 is_stmt 1 view .LVU712
1625:lwIP/src/core/tcp_in.c **** 
 2044              		.loc 1 1625 9 view .LVU713
 2045 0438 638B     		ldrh	r3, [r4, #26]
 2046 043a DA07     		lsls	r2, r3, #31
 2047 043c 22D5     		bpl	.L151
1625:lwIP/src/core/tcp_in.c **** 
 2048              		.loc 1 1625 9 view .LVU714
1625:lwIP/src/core/tcp_in.c **** 
 2049              		.loc 1 1625 9 view .LVU715
1625:lwIP/src/core/tcp_in.c **** 
 2050              		.loc 1 1625 9 view .LVU716
1625:lwIP/src/core/tcp_in.c **** 
 2051              		.loc 1 1625 9 view .LVU717
1625:lwIP/src/core/tcp_in.c **** 
 2052              		.loc 1 1625 9 view .LVU718
 2053 043e 23F00103 		bic	r3, r3, #1
 2054 0442 43F00203 		orr	r3, r3, #2
 2055 0446 6383     		strh	r3, [r4, #26]	@ movhi
1625:lwIP/src/core/tcp_in.c **** 
 2056              		.loc 1 1625 9 view .LVU719
 2057 0448 3DE6     		b	.L100
 2058              	.LVL128:
 2059              	.L209:
 2060              	.LBB230:
1431:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
 2061              		.loc 1 1431 7 view .LVU720
 2062 044a 1648     		ldr	r0, .L212+24
 2063              	.LVL129:
1431:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
 2064              		.loc 1 1431 7 is_stmt 0 view .LVU721
 2065 044c FFF7FEFF 		bl	printf
 2066              	.LVL130:
 2067              	.L135:
1431:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
 2068              		.loc 1 1431 7 is_stmt 1 view .LVU722
1431:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
 2069              		.loc 1 1431 7 view .LVU723
1431:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
 2070              		.loc 1 1431 7 view .LVU724
1431:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
 2071              		.loc 1 1431 7 view .LVU725
1431:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
 2072              		.loc 1 1431 7 view .LVU726
1431:lwIP/src/core/tcp_in.c ****       inseg.len -= off;
 2073              		.loc 1 1431 7 view .LVU727
 2074 0450 FEE7     		b	.L135
 2075              	.LVL131:
 2076              	.L208:
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 2077              		.loc 1 1429 7 view .LVU728
 2078 0452 1548     		ldr	r0, .L212+28
 2079              	.LVL132:
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 2080              		.loc 1 1429 7 is_stmt 0 view .LVU729
ARM GAS  /tmp/ccFjUByx.s 			page 102


 2081 0454 FFF7FEFF 		bl	printf
 2082              	.LVL133:
 2083              	.L133:
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 2084              		.loc 1 1429 7 is_stmt 1 view .LVU730
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 2085              		.loc 1 1429 7 view .LVU731
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 2086              		.loc 1 1429 7 view .LVU732
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 2087              		.loc 1 1429 7 view .LVU733
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 2088              		.loc 1 1429 7 view .LVU734
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 2089              		.loc 1 1429 7 view .LVU735
 2090 0458 FEE7     		b	.L133
 2091              	.LVL134:
 2092              	.L113:
1429:lwIP/src/core/tcp_in.c ****       off = (u16_t)off32;
 2093              		.loc 1 1429 7 is_stmt 0 view .LVU736
 2094              	.LBE230:
1213:lwIP/src/core/tcp_in.c ****               }
 2095              		.loc 1 1213 17 is_stmt 1 view .LVU737
1213:lwIP/src/core/tcp_in.c ****               }
 2096              		.loc 1 1213 17 view .LVU738
 2097 045a B4F84820 		ldrh	r2, [r4, #72]
 2098 045e 4FF6FF71 		movw	r1, #65535
 2099 0462 638E     		ldrh	r3, [r4, #50]
 2100 0464 1344     		add	r3, r3, r2
 2101 0466 9BB2     		uxth	r3, r3
 2102 0468 9A42     		cmp	r2, r3
 2103 046a 88BF     		it	hi
 2104 046c 0B46     		movhi	r3, r1
 2105 046e A4F84830 		strh	r3, [r4, #72]	@ movhi
1213:lwIP/src/core/tcp_in.c ****               }
 2106              		.loc 1 1213 17 view .LVU739
1215:lwIP/src/core/tcp_in.c ****                 /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
 2107              		.loc 1 1215 15 view .LVU740
 2108              	.L154:
1217:lwIP/src/core/tcp_in.c ****               }
 2109              		.loc 1 1217 17 view .LVU741
 2110 0472 2046     		mov	r0, r4
 2111 0474 FFF7FEFF 		bl	tcp_rexmit_fast
 2112              	.LVL135:
1225:lwIP/src/core/tcp_in.c ****         pcb->dupacks = 0;
 2113              		.loc 1 1225 7 view .LVU742
 2114 0478 B6F800C0 		ldrh	ip, [r6]
 2115 047c 3B68     		ldr	r3, [r7]
 2116 047e BAE6     		b	.L115
 2117              	.LVL136:
 2118              	.L202:
 2119              	.LBB231:
1225:lwIP/src/core/tcp_in.c ****         pcb->dupacks = 0;
 2120              		.loc 1 1225 7 is_stmt 0 view .LVU743
 2121 0480 0246     		mov	r2, r0
 2122 0482 0BE7     		b	.L119
 2123              	.LVL137:
ARM GAS  /tmp/ccFjUByx.s 			page 103


 2124              	.L151:
1225:lwIP/src/core/tcp_in.c ****         pcb->dupacks = 0;
 2125              		.loc 1 1225 7 view .LVU744
 2126              	.LBE231:
1625:lwIP/src/core/tcp_in.c **** 
 2127              		.loc 1 1625 9 is_stmt 1 view .LVU745
1625:lwIP/src/core/tcp_in.c **** 
 2128              		.loc 1 1625 9 view .LVU746
 2129 0484 43F00103 		orr	r3, r3, #1
 2130 0488 6383     		strh	r3, [r4, #26]	@ movhi
 2131 048a 1CE6     		b	.L100
 2132              	.L213:
 2133              		.align	2
 2134              	.L212:
 2135 048c 00000000 		.word	.LANCHOR11
 2136 0490 30000000 		.word	.LC7
 2137 0494 00000000 		.word	.LC4
 2138 0498 68000000 		.word	.LC8
 2139 049c 00000000 		.word	.LANCHOR12
 2140 04a0 00000000 		.word	.LANCHOR5
 2141 04a4 20000000 		.word	.LC6
 2142 04a8 10000000 		.word	.LC5
 2143              		.cfi_endproc
 2144              	.LFE117:
 2146              		.section	.rodata.tcp_input.str1.4,"aMS",%progbits,1
 2147              		.align	2
 2148              	.LC9:
 2149 0000 7463705F 		.ascii	"tcp_input: invalid pbuf\000"
 2149      696E7075 
 2149      743A2069 
 2149      6E76616C 
 2149      69642070 
 2150              		.align	2
 2151              	.LC10:
 2152 0018 702D3E6E 		.ascii	"p->next != NULL\000"
 2152      65787420 
 2152      213D204E 
 2152      554C4C00 
 2153              		.align	2
 2154              	.LC11:
 2155 0028 702D3E6C 		.ascii	"p->len == 0\000"
 2155      656E203D 
 2155      3D203000 
 2156              		.align	2
 2157              	.LC12:
 2158 0034 702D3E74 		.ascii	"p->tot_len == p->next->tot_len\000"
 2158      6F745F6C 
 2158      656E203D 
 2158      3D20702D 
 2158      3E6E6578 
 2159 0053 00       		.align	2
 2160              	.LC13:
 2161 0054 7463705F 		.ascii	"tcp_input: active pcb->state != CLOSED\000"
 2161      696E7075 
 2161      743A2061 
 2161      63746976 
 2161      65207063 
ARM GAS  /tmp/ccFjUByx.s 			page 104


 2162 007b 00       		.align	2
 2163              	.LC14:
 2164 007c 7463705F 		.ascii	"tcp_input: active pcb->state != TIME-WAIT\000"
 2164      696E7075 
 2164      743A2061 
 2164      63746976 
 2164      65207063 
 2165 00a6 0000     		.align	2
 2166              	.LC15:
 2167 00a8 7463705F 		.ascii	"tcp_input: active pcb->state != LISTEN\000"
 2167      696E7075 
 2167      743A2061 
 2167      63746976 
 2167      65207063 
 2168 00cf 00       		.align	2
 2169              	.LC16:
 2170 00d0 7463705F 		.ascii	"tcp_input: pcb->next != pcb (before cache)\000"
 2170      696E7075 
 2170      743A2070 
 2170      63622D3E 
 2170      6E657874 
 2171 00fb 00       		.align	2
 2172              	.LC17:
 2173 00fc 7463705F 		.ascii	"tcp_input: pcb->next != pcb (after cache)\000"
 2173      696E7075 
 2173      743A2070 
 2173      63622D3E 
 2173      6E657874 
 2174 0126 0000     		.align	2
 2175              	.LC18:
 2176 0128 7463705F 		.ascii	"tcp_input: TIME-WAIT pcb->state == TIME-WAIT\000"
 2176      696E7075 
 2176      743A2054 
 2176      494D452D 
 2176      57414954 
 2177 0155 000000   		.align	2
 2178              	.LC19:
 2179 0158 7463705F 		.ascii	"tcp_input: pcb->state != CLOSED\000"
 2179      696E7075 
 2179      743A2070 
 2179      63622D3E 
 2179      73746174 
 2180              		.align	2
 2181              	.LC20:
 2182 0178 7063622D 		.ascii	"pcb->snd_queuelen > 0\000"
 2182      3E736E64 
 2182      5F717565 
 2182      75656C65 
 2182      6E203E20 
 2183 018e 0000     		.align	2
 2184              	.LC21:
 2185 0190 6E6F2073 		.ascii	"no segment to free\000"
 2185      65676D65 
 2185      6E742074 
 2185      6F206672 
 2185      656500
 2186 01a3 00       		.align	2
ARM GAS  /tmp/ccFjUByx.s 			page 105


 2187              	.LC22:
 2188 01a4 7063622D 		.ascii	"pcb->listener->accept != NULL\000"
 2188      3E6C6973 
 2188      74656E65 
 2188      722D3E61 
 2188      63636570 
 2189 01c2 0000     		.align	2
 2190              	.LC23:
 2191 01c4 7463705F 		.ascii	"tcp_receive: wrong state\000"
 2191      72656365 
 2191      6976653A 
 2191      2077726F 
 2191      6E672073 
 2192 01dd 000000   		.align	2
 2193              	.LC24:
 2194 01e0 7063622D 		.ascii	"pcb->refused_data == NULL\000"
 2194      3E726566 
 2194      75736564 
 2194      5F646174 
 2194      61203D3D 
 2195              		.section	.text.tcp_input,"ax",%progbits
 2196              		.align	1
 2197              		.p2align 2,,3
 2198              		.global	tcp_input
 2199              		.syntax unified
 2200              		.thumb
 2201              		.thumb_func
 2202              		.fpu fpv4-sp-d16
 2204              	tcp_input:
 2205              	.LVL138:
 2206              	.LFB105:
 119:lwIP/src/core/tcp_in.c ****   struct tcp_pcb *pcb, *prev;
 2207              		.loc 1 119 1 view -0
 2208              		.cfi_startproc
 2209              		@ args = 0, pretend = 0, frame = 32
 2210              		@ frame_needed = 0, uses_anonymous_args = 0
 120:lwIP/src/core/tcp_in.c ****   struct tcp_pcb_listen *lpcb;
 2211              		.loc 1 120 3 view .LVU748
 121:lwIP/src/core/tcp_in.c **** #if SO_REUSE
 2212              		.loc 1 121 3 view .LVU749
 126:lwIP/src/core/tcp_in.c ****   err_t err;
 2213              		.loc 1 126 3 view .LVU750
 127:lwIP/src/core/tcp_in.c **** 
 2214              		.loc 1 127 3 view .LVU751
 129:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT_CORE_LOCKED();
 2215              		.loc 1 129 3 view .LVU752
 130:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
 2216              		.loc 1 130 28 view .LVU753
 131:lwIP/src/core/tcp_in.c **** 
 2217              		.loc 1 131 3 view .LVU754
 131:lwIP/src/core/tcp_in.c **** 
 2218              		.loc 1 131 3 view .LVU755
 119:lwIP/src/core/tcp_in.c ****   struct tcp_pcb *pcb, *prev;
 2219              		.loc 1 119 1 is_stmt 0 view .LVU756
 2220 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2221              	.LCFI9:
 2222              		.cfi_def_cfa_offset 36
ARM GAS  /tmp/ccFjUByx.s 			page 106


 2223              		.cfi_offset 4, -36
 2224              		.cfi_offset 5, -32
 2225              		.cfi_offset 6, -28
 2226              		.cfi_offset 7, -24
 2227              		.cfi_offset 8, -20
 2228              		.cfi_offset 9, -16
 2229              		.cfi_offset 10, -12
 2230              		.cfi_offset 11, -8
 2231              		.cfi_offset 14, -4
 2232 0004 8DB0     		sub	sp, sp, #52
 2233              	.LCFI10:
 2234              		.cfi_def_cfa_offset 88
 131:lwIP/src/core/tcp_in.c **** 
 2235              		.loc 1 131 3 view .LVU757
 2236 0006 0028     		cmp	r0, #0
 2237 0008 6FD0     		beq	.L467
 145:lwIP/src/core/tcp_in.c ****     /* drop short packets */
 2238              		.loc 1 145 6 discriminator 2 view .LVU758
 2239 000a 4389     		ldrh	r3, [r0, #10]
 2240 000c 0546     		mov	r5, r0
 131:lwIP/src/core/tcp_in.c **** 
 2241              		.loc 1 131 3 is_stmt 1 discriminator 2 view .LVU759
 133:lwIP/src/core/tcp_in.c **** 
 2242              		.loc 1 133 13 discriminator 2 view .LVU760
 135:lwIP/src/core/tcp_in.c ****   MIB2_STATS_INC(mib2.tcpinsegs);
 2243              		.loc 1 135 26 discriminator 2 view .LVU761
 136:lwIP/src/core/tcp_in.c **** 
 2244              		.loc 1 136 33 discriminator 2 view .LVU762
 138:lwIP/src/core/tcp_in.c **** 
 2245              		.loc 1 138 3 discriminator 2 view .LVU763
 138:lwIP/src/core/tcp_in.c **** 
 2246              		.loc 1 138 10 is_stmt 0 discriminator 2 view .LVU764
 2247 000e DFF8F482 		ldr	r8, .L494+56
 2248 0012 4268     		ldr	r2, [r0, #4]
 145:lwIP/src/core/tcp_in.c ****     /* drop short packets */
 2249              		.loc 1 145 6 discriminator 2 view .LVU765
 2250 0014 132B     		cmp	r3, #19
 138:lwIP/src/core/tcp_in.c **** 
 2251              		.loc 1 138 10 discriminator 2 view .LVU766
 2252 0016 C8F80020 		str	r2, [r8]
 145:lwIP/src/core/tcp_in.c ****     /* drop short packets */
 2253              		.loc 1 145 3 is_stmt 1 discriminator 2 view .LVU767
 145:lwIP/src/core/tcp_in.c ****     /* drop short packets */
 2254              		.loc 1 145 6 is_stmt 0 discriminator 2 view .LVU768
 2255 001a 05D8     		bhi	.L468
 2256              	.LVL139:
 2257              	.L217:
 2258              	.LDL1:
 589:lwIP/src/core/tcp_in.c ****   MIB2_STATS_INC(mib2.tcpinerrs);
 2259              		.loc 1 589 26 is_stmt 1 view .LVU769
 590:lwIP/src/core/tcp_in.c ****   pbuf_free(p);
 2260              		.loc 1 590 33 view .LVU770
 591:lwIP/src/core/tcp_in.c **** }
 2261              		.loc 1 591 3 view .LVU771
 2262 001c 2846     		mov	r0, r5
 592:lwIP/src/core/tcp_in.c **** 
 2263              		.loc 1 592 1 is_stmt 0 view .LVU772
ARM GAS  /tmp/ccFjUByx.s 			page 107


 2264 001e 0DB0     		add	sp, sp, #52
 2265              	.LCFI11:
 2266              		.cfi_remember_state
 2267              		.cfi_def_cfa_offset 36
 2268              		@ sp needed
 2269 0020 BDE8F04F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2270              	.LCFI12:
 2271              		.cfi_restore 14
 2272              		.cfi_restore 11
 2273              		.cfi_restore 10
 2274              		.cfi_restore 9
 2275              		.cfi_restore 8
 2276              		.cfi_restore 7
 2277              		.cfi_restore 6
 2278              		.cfi_restore 5
 2279              		.cfi_restore 4
 2280              		.cfi_def_cfa_offset 0
 2281              	.LVL140:
 591:lwIP/src/core/tcp_in.c **** }
 2282              		.loc 1 591 3 view .LVU773
 2283 0024 FFF7FEBF 		b	pbuf_free
 2284              	.LVL141:
 2285              	.L468:
 2286              	.LCFI13:
 2287              		.cfi_restore_state
 153:lwIP/src/core/tcp_in.c ****       ip_addr_ismulticast(ip_current_dest_addr())) {
 2288              		.loc 1 153 3 is_stmt 1 view .LVU774
 153:lwIP/src/core/tcp_in.c ****       ip_addr_ismulticast(ip_current_dest_addr())) {
 2289              		.loc 1 153 7 is_stmt 0 view .LVU775
 2290 0028 A84E     		ldr	r6, .L494
 2291 002a 3168     		ldr	r1, [r6]
 2292              	.LVL142:
 153:lwIP/src/core/tcp_in.c ****       ip_addr_ismulticast(ip_current_dest_addr())) {
 2293              		.loc 1 153 7 view .LVU776
 2294 002c 7069     		ldr	r0, [r6, #20]
 2295              	.LVL143:
 153:lwIP/src/core/tcp_in.c ****       ip_addr_ismulticast(ip_current_dest_addr())) {
 2296              		.loc 1 153 7 view .LVU777
 2297 002e FFF7FEFF 		bl	ip4_addr_isbroadcast_u32
 2298              	.LVL144:
 153:lwIP/src/core/tcp_in.c ****       ip_addr_ismulticast(ip_current_dest_addr())) {
 2299              		.loc 1 153 6 view .LVU778
 2300 0032 0028     		cmp	r0, #0
 2301 0034 F2D1     		bne	.L217
 154:lwIP/src/core/tcp_in.c ****     TCP_STATS_INC(tcp.proterr);
 2302              		.loc 1 154 7 discriminator 1 view .LVU779
 2303 0036 7369     		ldr	r3, [r6, #20]
 2304 0038 03F0F003 		and	r3, r3, #240
 153:lwIP/src/core/tcp_in.c ****       ip_addr_ismulticast(ip_current_dest_addr())) {
 2305              		.loc 1 153 71 discriminator 1 view .LVU780
 2306 003c E02B     		cmp	r3, #224
 2307 003e EDD0     		beq	.L217
 2308              	.LBB271:
 162:lwIP/src/core/tcp_in.c ****                                     ip_current_src_addr(), ip_current_dest_addr());
 2309              		.loc 1 162 5 is_stmt 1 view .LVU781
 162:lwIP/src/core/tcp_in.c ****                                     ip_current_src_addr(), ip_current_dest_addr());
 2310              		.loc 1 162 20 is_stmt 0 view .LVU782
ARM GAS  /tmp/ccFjUByx.s 			page 108


 2311 0040 06F11400 		add	r0, r6, #20
 2312 0044 2A89     		ldrh	r2, [r5, #8]
 2313 0046 0621     		movs	r1, #6
 2314 0048 06F11003 		add	r3, r6, #16
 2315 004c 0090     		str	r0, [sp]
 2316 004e 2846     		mov	r0, r5
 2317 0050 FFF7FEFF 		bl	ip_chksum_pseudo
 2318              	.LVL145:
 164:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_
 2319              		.loc 1 164 5 is_stmt 1 view .LVU783
 164:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_
 2320              		.loc 1 164 8 is_stmt 0 view .LVU784
 2321 0054 0028     		cmp	r0, #0
 2322 0056 E1D1     		bne	.L217
 2323              	.LBE271:
 175:lwIP/src/core/tcp_in.c ****   if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 2324              		.loc 1 175 3 is_stmt 1 view .LVU785
 2325              	.LVL146:
 2326              	.LBB272:
 2327              	.LBI272:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2328              		.loc 2 934 30 view .LVU786
 2329              	.LBB273:
 2330              		.loc 2 937 3 view .LVU787
 2331              		.loc 2 937 3 is_stmt 0 view .LVU788
 2332              	.LBE273:
 2333              	.LBE272:
 175:lwIP/src/core/tcp_in.c ****   if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 2334              		.loc 1 175 18 view .LVU789
 2335 0058 D8F80030 		ldr	r3, [r8]
 2336 005c 9989     		ldrh	r1, [r3, #12]	@ unaligned
 2337              	.LBB275:
 2338              	.LBB274:
 2339              		.loc 2 937 19 view .LVU790
 2340 005e 49BA     		rev16	r1, r1
 2341              	.LBE274:
 2342              	.LBE275:
 175:lwIP/src/core/tcp_in.c ****   if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 2343              		.loc 1 175 18 view .LVU791
 2344 0060 C1F30331 		ubfx	r1, r1, #12, #4
 175:lwIP/src/core/tcp_in.c ****   if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 2345              		.loc 1 175 16 view .LVU792
 2346 0064 8900     		lsls	r1, r1, #2
 2347              	.LVL147:
 176:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: invalid header length (%"U16_F")\n", (u16_t)hdrlen_by
 2348              		.loc 1 176 3 is_stmt 1 view .LVU793
 176:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: invalid header length (%"U16_F")\n", (u16_t)hdrlen_by
 2349              		.loc 1 176 6 is_stmt 0 view .LVU794
 2350 0066 1329     		cmp	r1, #19
 2351 0068 D8D9     		bls	.L217
 176:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: invalid header length (%"U16_F")\n", (u16_t)hdrlen_by
 2352              		.loc 1 176 33 discriminator 1 view .LVU795
 2353 006a 2B89     		ldrh	r3, [r5, #8]
 176:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: invalid header length (%"U16_F")\n", (u16_t)hdrlen_by
 2354              		.loc 1 176 50 discriminator 1 view .LVU796
 2355 006c 8AB2     		uxth	r2, r1
 176:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: invalid header length (%"U16_F")\n", (u16_t)hdrlen_by
ARM GAS  /tmp/ccFjUByx.s 			page 109


 2356              		.loc 1 176 33 discriminator 1 view .LVU797
 2357 006e 8B42     		cmp	r3, r1
 2358 0070 D4D3     		bcc	.L217
 184:lwIP/src/core/tcp_in.c ****   tcphdr_opt2 = NULL;
 2359              		.loc 1 184 3 is_stmt 1 view .LVU798
 184:lwIP/src/core/tcp_in.c ****   tcphdr_opt2 = NULL;
 2360              		.loc 1 184 19 is_stmt 0 view .LVU799
 2361 0072 A2F11403 		sub	r3, r2, #20
 186:lwIP/src/core/tcp_in.c ****     /* all options are in the first pbuf */
 2362              		.loc 1 186 6 view .LVU800
 2363 0076 6F89     		ldrh	r7, [r5, #10]
 184:lwIP/src/core/tcp_in.c ****   tcphdr_opt2 = NULL;
 2364              		.loc 1 184 17 view .LVU801
 2365 0078 954C     		ldr	r4, .L494+4
 185:lwIP/src/core/tcp_in.c ****   if (p->len >= hdrlen_bytes) {
 2366              		.loc 1 185 15 view .LVU802
 2367 007a DFF88CA2 		ldr	r10, .L494+60
 184:lwIP/src/core/tcp_in.c ****   tcphdr_opt2 = NULL;
 2368              		.loc 1 184 19 view .LVU803
 2369 007e 9BB2     		uxth	r3, r3
 186:lwIP/src/core/tcp_in.c ****     /* all options are in the first pbuf */
 2370              		.loc 1 186 6 view .LVU804
 2371 0080 9742     		cmp	r7, r2
 185:lwIP/src/core/tcp_in.c ****   if (p->len >= hdrlen_bytes) {
 2372              		.loc 1 185 15 view .LVU805
 2373 0082 CAF80000 		str	r0, [r10]
 184:lwIP/src/core/tcp_in.c ****   tcphdr_opt2 = NULL;
 2374              		.loc 1 184 17 view .LVU806
 2375 0086 2380     		strh	r3, [r4]	@ movhi
 185:lwIP/src/core/tcp_in.c ****   if (p->len >= hdrlen_bytes) {
 2376              		.loc 1 185 3 is_stmt 1 view .LVU807
 186:lwIP/src/core/tcp_in.c ****     /* all options are in the first pbuf */
 2377              		.loc 1 186 3 view .LVU808
 186:lwIP/src/core/tcp_in.c ****     /* all options are in the first pbuf */
 2378              		.loc 1 186 6 is_stmt 0 view .LVU809
 2379 0088 33D2     		bcs	.L469
 2380              	.LBB276:
 191:lwIP/src/core/tcp_in.c ****     /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
 2381              		.loc 1 191 5 is_stmt 1 view .LVU810
 194:lwIP/src/core/tcp_in.c **** 
 2382              		.loc 1 194 5 view .LVU811
 194:lwIP/src/core/tcp_in.c **** 
 2383              		.loc 1 194 5 view .LVU812
 2384 008a 2B68     		ldr	r3, [r5]
 2385 008c 002B     		cmp	r3, #0
 2386 008e 00F05482 		beq	.L470
 194:lwIP/src/core/tcp_in.c **** 
 2387              		.loc 1 194 5 discriminator 2 view .LVU813
 197:lwIP/src/core/tcp_in.c **** 
 2388              		.loc 1 197 5 discriminator 2 view .LVU814
 2389 0092 1421     		movs	r1, #20
 2390              	.LVL148:
 197:lwIP/src/core/tcp_in.c **** 
 2391              		.loc 1 197 5 is_stmt 0 discriminator 2 view .LVU815
 2392 0094 2846     		mov	r0, r5
 2393              	.LVL149:
 197:lwIP/src/core/tcp_in.c **** 
ARM GAS  /tmp/ccFjUByx.s 			page 110


 2394              		.loc 1 197 5 discriminator 2 view .LVU816
 2395 0096 FFF7FEFF 		bl	pbuf_remove_header
 2396              	.LVL150:
 200:lwIP/src/core/tcp_in.c ****     opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 2397              		.loc 1 200 5 is_stmt 1 discriminator 2 view .LVU817
 201:lwIP/src/core/tcp_in.c **** 
 2398              		.loc 1 201 15 is_stmt 0 discriminator 2 view .LVU818
 2399 009a 2788     		ldrh	r7, [r4]
 200:lwIP/src/core/tcp_in.c ****     opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 2400              		.loc 1 200 23 discriminator 2 view .LVU819
 2401 009c 6C89     		ldrh	r4, [r5, #10]
 205:lwIP/src/core/tcp_in.c **** 
 2402              		.loc 1 205 5 discriminator 2 view .LVU820
 2403 009e 2846     		mov	r0, r5
 200:lwIP/src/core/tcp_in.c ****     opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 2404              		.loc 1 200 20 discriminator 2 view .LVU821
 2405 00a0 8C4B     		ldr	r3, .L494+8
 205:lwIP/src/core/tcp_in.c **** 
 2406              		.loc 1 205 5 discriminator 2 view .LVU822
 2407 00a2 2146     		mov	r1, r4
 201:lwIP/src/core/tcp_in.c **** 
 2408              		.loc 1 201 13 discriminator 2 view .LVU823
 2409 00a4 A7EB0409 		sub	r9, r7, r4
 200:lwIP/src/core/tcp_in.c ****     opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 2410              		.loc 1 200 20 discriminator 2 view .LVU824
 2411 00a8 1C80     		strh	r4, [r3]	@ movhi
 201:lwIP/src/core/tcp_in.c **** 
 2412              		.loc 1 201 5 is_stmt 1 discriminator 2 view .LVU825
 205:lwIP/src/core/tcp_in.c **** 
 2413              		.loc 1 205 5 is_stmt 0 discriminator 2 view .LVU826
 2414 00aa FFF7FEFF 		bl	pbuf_remove_header
 2415              	.LVL151:
 208:lwIP/src/core/tcp_in.c ****       /* drop short packets */
 2416              		.loc 1 208 20 discriminator 2 view .LVU827
 2417 00ae 2868     		ldr	r0, [r5]
 201:lwIP/src/core/tcp_in.c **** 
 2418              		.loc 1 201 13 discriminator 2 view .LVU828
 2419 00b0 1FFA89F9 		uxth	r9, r9
 2420              	.LVL152:
 205:lwIP/src/core/tcp_in.c **** 
 2421              		.loc 1 205 5 is_stmt 1 discriminator 2 view .LVU829
 208:lwIP/src/core/tcp_in.c ****       /* drop short packets */
 2422              		.loc 1 208 5 discriminator 2 view .LVU830
 208:lwIP/src/core/tcp_in.c ****       /* drop short packets */
 2423              		.loc 1 208 8 is_stmt 0 discriminator 2 view .LVU831
 2424 00b4 4389     		ldrh	r3, [r0, #10]
 2425 00b6 4B45     		cmp	r3, r9
 2426 00b8 B0D3     		bcc	.L217
 216:lwIP/src/core/tcp_in.c **** 
 2427              		.loc 1 216 5 is_stmt 1 view .LVU832
 216:lwIP/src/core/tcp_in.c **** 
 2428              		.loc 1 216 17 is_stmt 0 view .LVU833
 2429 00ba 4368     		ldr	r3, [r0, #4]
 220:lwIP/src/core/tcp_in.c ****     p->tot_len = (u16_t)(p->tot_len - opt2len);
 2430              		.loc 1 220 5 view .LVU834
 2431 00bc 4946     		mov	r1, r9
 216:lwIP/src/core/tcp_in.c **** 
ARM GAS  /tmp/ccFjUByx.s 			page 111


 2432              		.loc 1 216 17 view .LVU835
 2433 00be CAF80030 		str	r3, [r10]
 220:lwIP/src/core/tcp_in.c ****     p->tot_len = (u16_t)(p->tot_len - opt2len);
 2434              		.loc 1 220 5 is_stmt 1 view .LVU836
 2435 00c2 FFF7FEFF 		bl	pbuf_remove_header
 2436              	.LVL153:
 221:lwIP/src/core/tcp_in.c **** 
 2437              		.loc 1 221 5 view .LVU837
 221:lwIP/src/core/tcp_in.c **** 
 2438              		.loc 1 221 18 is_stmt 0 view .LVU838
 2439 00c6 2B89     		ldrh	r3, [r5, #8]
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 2440              		.loc 1 223 5 view .LVU839
 2441 00c8 6A89     		ldrh	r2, [r5, #10]
 221:lwIP/src/core/tcp_in.c **** 
 2442              		.loc 1 221 18 view .LVU840
 2443 00ca 2344     		add	r3, r3, r4
 2444 00cc DB1B     		subs	r3, r3, r7
 2445 00ce 9BB2     		uxth	r3, r3
 221:lwIP/src/core/tcp_in.c **** 
 2446              		.loc 1 221 16 view .LVU841
 2447 00d0 2B81     		strh	r3, [r5, #8]	@ movhi
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 2448              		.loc 1 223 5 is_stmt 1 view .LVU842
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 2449              		.loc 1 223 5 view .LVU843
 2450 00d2 002A     		cmp	r2, #0
 2451 00d4 40F03D82 		bne	.L471
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 2452              		.loc 1 223 5 discriminator 2 view .LVU844
 224:lwIP/src/core/tcp_in.c ****   }
 2453              		.loc 1 224 5 discriminator 2 view .LVU845
 224:lwIP/src/core/tcp_in.c ****   }
 2454              		.loc 1 224 5 discriminator 2 view .LVU846
 2455 00d8 2A68     		ldr	r2, [r5]
 2456 00da B2F808E0 		ldrh	lr, [r2, #8]
 2457 00de 7345     		cmp	r3, lr
 2458 00e0 0ED0     		beq	.L219
 224:lwIP/src/core/tcp_in.c ****   }
 2459              		.loc 1 224 5 discriminator 1 view .LVU847
 2460 00e2 7D48     		ldr	r0, .L494+12
 2461 00e4 FFF7FEFF 		bl	printf
 2462              	.LVL154:
 2463              	.L224:
 224:lwIP/src/core/tcp_in.c ****   }
 2464              		.loc 1 224 5 discriminator 4 view .LVU848
 224:lwIP/src/core/tcp_in.c ****   }
 2465              		.loc 1 224 5 discriminator 4 view .LVU849
 224:lwIP/src/core/tcp_in.c ****   }
 2466              		.loc 1 224 5 discriminator 4 view .LVU850
 224:lwIP/src/core/tcp_in.c ****   }
 2467              		.loc 1 224 5 discriminator 4 view .LVU851
 224:lwIP/src/core/tcp_in.c ****   }
 2468              		.loc 1 224 5 discriminator 4 view .LVU852
 224:lwIP/src/core/tcp_in.c ****   }
 2469              		.loc 1 224 5 discriminator 4 view .LVU853
 2470 00e8 FEE7     		b	.L224
ARM GAS  /tmp/ccFjUByx.s 			page 112


 2471              	.LVL155:
 2472              	.L467:
 224:lwIP/src/core/tcp_in.c ****   }
 2473              		.loc 1 224 5 is_stmt 0 discriminator 4 view .LVU854
 2474              	.LBE276:
 131:lwIP/src/core/tcp_in.c **** 
 2475              		.loc 1 131 3 is_stmt 1 discriminator 1 view .LVU855
 2476 00ea 7C48     		ldr	r0, .L494+16
 2477              	.LVL156:
 131:lwIP/src/core/tcp_in.c **** 
 2478              		.loc 1 131 3 is_stmt 0 discriminator 1 view .LVU856
 2479 00ec FFF7FEFF 		bl	printf
 2480              	.LVL157:
 2481              	.L216:
 131:lwIP/src/core/tcp_in.c **** 
 2482              		.loc 1 131 3 is_stmt 1 discriminator 1 view .LVU857
 131:lwIP/src/core/tcp_in.c **** 
 2483              		.loc 1 131 3 discriminator 1 view .LVU858
 131:lwIP/src/core/tcp_in.c **** 
 2484              		.loc 1 131 3 discriminator 1 view .LVU859
 131:lwIP/src/core/tcp_in.c **** 
 2485              		.loc 1 131 3 discriminator 1 view .LVU860
 131:lwIP/src/core/tcp_in.c **** 
 2486              		.loc 1 131 3 discriminator 1 view .LVU861
 131:lwIP/src/core/tcp_in.c **** 
 2487              		.loc 1 131 3 discriminator 1 view .LVU862
 2488 00f0 FEE7     		b	.L216
 2489              	.LVL158:
 2490              	.L469:
 188:lwIP/src/core/tcp_in.c ****     pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
 2491              		.loc 1 188 5 view .LVU863
 188:lwIP/src/core/tcp_in.c ****     pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
 2492              		.loc 1 188 20 is_stmt 0 view .LVU864
 2493 00f2 784A     		ldr	r2, .L494+8
 189:lwIP/src/core/tcp_in.c ****   } else {
 2494              		.loc 1 189 5 view .LVU865
 2495 00f4 2846     		mov	r0, r5
 2496              	.LVL159:
 188:lwIP/src/core/tcp_in.c ****     pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
 2497              		.loc 1 188 20 view .LVU866
 2498 00f6 1380     		strh	r3, [r2]	@ movhi
 189:lwIP/src/core/tcp_in.c ****   } else {
 2499              		.loc 1 189 5 is_stmt 1 view .LVU867
 2500 00f8 FFF7FEFF 		bl	pbuf_remove_header
 2501              	.LVL160:
 189:lwIP/src/core/tcp_in.c ****   } else {
 2502              		.loc 1 189 5 is_stmt 0 view .LVU868
 2503 00fc B5F808E0 		ldrh	lr, [r5, #8]
 2504              	.L219:
 2505              	.LBB277:
 224:lwIP/src/core/tcp_in.c ****   }
 2506              		.loc 1 224 5 is_stmt 1 discriminator 2 view .LVU869
 2507              	.LBE277:
 228:lwIP/src/core/tcp_in.c ****   tcphdr->dest = lwip_ntohs(tcphdr->dest);
 2508              		.loc 1 228 3 discriminator 2 view .LVU870
 228:lwIP/src/core/tcp_in.c ****   tcphdr->dest = lwip_ntohs(tcphdr->dest);
 2509              		.loc 1 228 17 is_stmt 0 discriminator 2 view .LVU871
ARM GAS  /tmp/ccFjUByx.s 			page 113


 2510 0100 D8F80030 		ldr	r3, [r8]
 2511              	.LVL161:
 2512              	.LBB278:
 2513              	.LBI278:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2514              		.loc 2 934 30 is_stmt 1 discriminator 2 view .LVU872
 2515              	.LBB279:
 2516              		.loc 2 937 3 discriminator 2 view .LVU873
 2517              	.LBE279:
 2518              	.LBE278:
 230:lwIP/src/core/tcp_in.c ****   ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 2519              		.loc 1 230 9 is_stmt 0 discriminator 2 view .LVU874
 2520 0104 764A     		ldr	r2, .L494+20
 230:lwIP/src/core/tcp_in.c ****   ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 2521              		.loc 1 230 27 discriminator 2 view .LVU875
 2522 0106 D3F804B0 		ldr	fp, [r3, #4]	@ unaligned
 229:lwIP/src/core/tcp_in.c ****   seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 2523              		.loc 1 229 18 discriminator 2 view .LVU876
 2524 010a 5888     		ldrh	r0, [r3, #2]	@ unaligned
 2525              	.LBB282:
 2526              	.LBB283:
 903:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 2527              		.loc 2 903 10 discriminator 2 view .LVU877
 2528 010c 9BFA8BFB 		rev	fp, fp
 2529              	.LBE283:
 2530              	.LBE282:
 231:lwIP/src/core/tcp_in.c ****   tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 2531              		.loc 1 231 9 discriminator 2 view .LVU878
 2532 0110 DFF8F891 		ldr	r9, .L494+64
 2533              	.LBB285:
 2534              	.LBB286:
 2535              		.loc 2 937 19 discriminator 2 view .LVU879
 2536 0114 40BA     		rev16	r0, r0
 2537              	.LBE286:
 2538              	.LBE285:
 228:lwIP/src/core/tcp_in.c ****   tcphdr->dest = lwip_ntohs(tcphdr->dest);
 2539              		.loc 1 228 17 discriminator 2 view .LVU880
 2540 0116 1C88     		ldrh	r4, [r3]	@ unaligned
 230:lwIP/src/core/tcp_in.c ****   ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 2541              		.loc 1 230 9 discriminator 2 view .LVU881
 2542 0118 C2F800B0 		str	fp, [r2]
 231:lwIP/src/core/tcp_in.c ****   tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 2543              		.loc 1 231 27 discriminator 2 view .LVU882
 2544 011c 9968     		ldr	r1, [r3, #8]	@ unaligned
 2545              	.LBB290:
 2546              	.LBB287:
 2547              		.loc 2 937 19 discriminator 2 view .LVU883
 2548 011e 82B2     		uxth	r2, r0
 2549              	.LBE287:
 2550              	.LBE290:
 229:lwIP/src/core/tcp_in.c ****   seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 2551              		.loc 1 229 16 discriminator 2 view .LVU884
 2552 0120 5880     		strh	r0, [r3, #2]	@ unaligned
 2553              	.LBB291:
 2554              	.LBB280:
 2555              		.loc 2 937 19 discriminator 2 view .LVU885
 2556 0122 64BA     		rev16	r4, r4
ARM GAS  /tmp/ccFjUByx.s 			page 114


 2557              	.LBE280:
 2558              	.LBE291:
 2559              	.LBB292:
 2560              	.LBB293:
 903:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 2561              		.loc 2 903 10 discriminator 2 view .LVU886
 2562 0124 09BA     		rev	r1, r1
 2563              	.LBE293:
 2564              	.LBE292:
 2565              	.LBB295:
 2566              	.LBB288:
 2567              		.loc 2 937 19 discriminator 2 view .LVU887
 2568 0126 0592     		str	r2, [sp, #20]
 2569              	.LBE288:
 2570              	.LBE295:
 228:lwIP/src/core/tcp_in.c ****   tcphdr->dest = lwip_ntohs(tcphdr->dest);
 2571              		.loc 1 228 15 discriminator 2 view .LVU888
 2572 0128 1C80     		strh	r4, [r3]	@ unaligned
 2573              	.LVL162:
 2574              	.LBB296:
 2575              	.LBB281:
 2576              		.loc 2 937 19 discriminator 2 view .LVU889
 2577 012a A2B2     		uxth	r2, r4
 2578              		.loc 2 937 19 discriminator 2 view .LVU890
 2579              	.LBE281:
 2580              	.LBE296:
 229:lwIP/src/core/tcp_in.c ****   seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 2581              		.loc 1 229 3 is_stmt 1 discriminator 2 view .LVU891
 2582              	.LBB297:
 2583              	.LBI285:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2584              		.loc 2 934 30 discriminator 2 view .LVU892
 2585              	.LBB289:
 2586              		.loc 2 937 3 discriminator 2 view .LVU893
 2587              	.LBE289:
 2588              	.LBE297:
 230:lwIP/src/core/tcp_in.c ****   ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 2589              		.loc 1 230 3 discriminator 2 view .LVU894
 2590              	.LBB298:
 2591              	.LBI282:
 900:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2592              		.loc 2 900 31 discriminator 2 view .LVU895
 2593              	.LBB284:
 903:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 2594              		.loc 2 903 3 discriminator 2 view .LVU896
 2595              	.LBE284:
 2596              	.LBE298:
 231:lwIP/src/core/tcp_in.c ****   tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 2597              		.loc 1 231 3 discriminator 2 view .LVU897
 2598              	.LBB299:
 2599              	.LBI292:
 900:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2600              		.loc 2 900 31 discriminator 2 view .LVU898
 2601              	.LBB294:
 903:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 2602              		.loc 2 903 3 discriminator 2 view .LVU899
 2603              	.LBE294:
ARM GAS  /tmp/ccFjUByx.s 			page 115


 2604              	.LBE299:
 232:lwIP/src/core/tcp_in.c **** 
 2605              		.loc 1 232 3 discriminator 2 view .LVU900
 2606              	.LVL163:
 2607              	.LBB300:
 2608              	.LBI300:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2609              		.loc 2 934 30 discriminator 2 view .LVU901
 2610              	.LBB301:
 2611              		.loc 2 937 3 discriminator 2 view .LVU902
 2612              		.loc 2 937 3 is_stmt 0 discriminator 2 view .LVU903
 2613              	.LBE301:
 2614              	.LBE300:
 231:lwIP/src/core/tcp_in.c ****   tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 2615              		.loc 1 231 9 discriminator 2 view .LVU904
 2616 012c C9F80010 		str	r1, [r9]
 232:lwIP/src/core/tcp_in.c **** 
 2617              		.loc 1 232 17 discriminator 2 view .LVU905
 2618 0130 DF89     		ldrh	r7, [r3, #14]	@ unaligned
 234:lwIP/src/core/tcp_in.c ****   tcplen = p->tot_len;
 2619              		.loc 1 234 11 discriminator 2 view .LVU906
 2620 0132 9889     		ldrh	r0, [r3, #12]	@ unaligned
 2621              	.LBB303:
 2622              	.LBB302:
 2623              		.loc 2 937 19 discriminator 2 view .LVU907
 2624 0134 7FBA     		rev16	r7, r7
 2625              	.LBE302:
 2626              	.LBE303:
 230:lwIP/src/core/tcp_in.c ****   ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 2627              		.loc 1 230 25 discriminator 2 view .LVU908
 2628 0136 C3F804B0 		str	fp, [r3, #4]	@ unaligned
 2629              	.LBB304:
 2630              	.LBB305:
 2631              		.loc 2 937 19 discriminator 2 view .LVU909
 2632 013a 40BA     		rev16	r0, r0
 2633              	.LBE305:
 2634              	.LBE304:
 231:lwIP/src/core/tcp_in.c ****   tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 2635              		.loc 1 231 25 discriminator 2 view .LVU910
 2636 013c 9960     		str	r1, [r3, #8]	@ unaligned
 232:lwIP/src/core/tcp_in.c **** 
 2637              		.loc 1 232 15 discriminator 2 view .LVU911
 2638 013e DF81     		strh	r7, [r3, #14]	@ unaligned
 234:lwIP/src/core/tcp_in.c ****   tcplen = p->tot_len;
 2639              		.loc 1 234 3 is_stmt 1 discriminator 2 view .LVU912
 2640              	.LVL164:
 2641              	.LBB307:
 2642              	.LBI304:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2643              		.loc 2 934 30 discriminator 2 view .LVU913
 2644              	.LBB306:
 2645              		.loc 2 937 3 discriminator 2 view .LVU914
 2646              		.loc 2 937 3 is_stmt 0 discriminator 2 view .LVU915
 2647              	.LBE306:
 2648              	.LBE307:
 234:lwIP/src/core/tcp_in.c ****   tcplen = p->tot_len;
 2649              		.loc 1 234 11 discriminator 2 view .LVU916
ARM GAS  /tmp/ccFjUByx.s 			page 116


 2650 0140 00F03F04 		and	r4, r0, #63
 2651 0144 5FFA80FC 		uxtb	ip, r0
 234:lwIP/src/core/tcp_in.c ****   tcplen = p->tot_len;
 2652              		.loc 1 234 9 discriminator 2 view .LVU917
 2653 0148 664F     		ldr	r7, .L494+24
 236:lwIP/src/core/tcp_in.c ****     tcplen++;
 2654              		.loc 1 236 6 discriminator 2 view .LVU918
 2655 014a 8007     		lsls	r0, r0, #30
 234:lwIP/src/core/tcp_in.c ****   tcplen = p->tot_len;
 2656              		.loc 1 234 9 discriminator 2 view .LVU919
 2657 014c 3C70     		strb	r4, [r7]
 235:lwIP/src/core/tcp_in.c ****   if (flags & (TCP_FIN | TCP_SYN)) {
 2658              		.loc 1 235 3 is_stmt 1 discriminator 2 view .LVU920
 236:lwIP/src/core/tcp_in.c ****     tcplen++;
 2659              		.loc 1 236 3 discriminator 2 view .LVU921
 236:lwIP/src/core/tcp_in.c ****     tcplen++;
 2660              		.loc 1 236 6 is_stmt 0 discriminator 2 view .LVU922
 2661 014e 40F01F81 		bne	.L225
 235:lwIP/src/core/tcp_in.c ****   if (flags & (TCP_FIN | TCP_SYN)) {
 2662              		.loc 1 235 10 view .LVU923
 2663 0152 6548     		ldr	r0, .L494+28
 2664 0154 F246     		mov	r10, lr
 2665 0156 0690     		str	r0, [sp, #24]
 2666 0158 A0F800E0 		strh	lr, [r0]	@ movhi
 2667              	.L226:
 248:lwIP/src/core/tcp_in.c **** 
 2668              		.loc 1 248 3 is_stmt 1 view .LVU924
 2669              	.LVL165:
 250:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 2670              		.loc 1 250 3 view .LVU925
 250:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 2671              		.loc 1 250 12 is_stmt 0 view .LVU926
 2672 015c 634F     		ldr	r7, .L494+32
 2673 015e 3C68     		ldr	r4, [r7]
 2674 0160 0B94     		str	r4, [sp, #44]
 2675              	.LVL166:
 250:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 2676              		.loc 1 250 31 is_stmt 1 view .LVU927
 250:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 2677              		.loc 1 250 3 is_stmt 0 view .LVU928
 2678 0162 002C     		cmp	r4, #0
 2679 0164 00F0A780 		beq	.L227
 257:lwIP/src/core/tcp_in.c ****       prev = pcb;
 2680              		.loc 1 257 28 view .LVU929
 2681 0168 7068     		ldr	r0, [r6, #4]
 2682 016a 07EE901A 		vmov	s15, r1	@ int
 2683 016e 0890     		str	r0, [sp, #32]
 264:lwIP/src/core/tcp_in.c ****         ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 2684              		.loc 1 264 9 view .LVU930
 2685 0170 3069     		ldr	r0, [r6, #16]
 2686 0172 0990     		str	r0, [sp, #36]
 248:lwIP/src/core/tcp_in.c **** 
 2687              		.loc 1 248 8 view .LVU931
 2688 0174 0020     		movs	r0, #0
 2689 0176 0790     		str	r0, [sp, #28]
 265:lwIP/src/core/tcp_in.c ****       /* Move this PCB to the front of the list so that subsequent
 2690              		.loc 1 265 9 view .LVU932
ARM GAS  /tmp/ccFjUByx.s 			page 117


 2691 0178 7069     		ldr	r0, [r6, #20]
 2692 017a 0A90     		str	r0, [sp, #40]
 2693 017c 05E0     		b	.L240
 2694              	.LVL167:
 2695              	.L235:
 250:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 2696              		.loc 1 250 44 is_stmt 1 discriminator 2 view .LVU933
 250:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 2697              		.loc 1 250 48 is_stmt 0 discriminator 2 view .LVU934
 2698 017e E068     		ldr	r0, [r4, #12]
 2699              	.LVL168:
 250:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 2700              		.loc 1 250 31 is_stmt 1 discriminator 2 view .LVU935
 2701 0180 0794     		str	r4, [sp, #28]
 250:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 2702              		.loc 1 250 3 is_stmt 0 discriminator 2 view .LVU936
 2703 0182 0028     		cmp	r0, #0
 2704 0184 00F09580 		beq	.L472
 250:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 2705              		.loc 1 250 3 discriminator 2 view .LVU937
 2706 0188 0446     		mov	r4, r0
 2707              	.LVL169:
 2708              	.L240:
 251:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 2709              		.loc 1 251 5 is_stmt 1 view .LVU938
 251:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 2710              		.loc 1 251 5 view .LVU939
 2711 018a 207D     		ldrb	r0, [r4, #20]	@ zero_extendqisi2
 2712 018c 0028     		cmp	r0, #0
 2713 018e 00F00F81 		beq	.L473
 251:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 2714              		.loc 1 251 5 discriminator 2 view .LVU940
 252:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 2715              		.loc 1 252 5 discriminator 2 view .LVU941
 252:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 2716              		.loc 1 252 5 discriminator 2 view .LVU942
 2717 0192 0A28     		cmp	r0, #10
 2718 0194 00F00881 		beq	.L474
 252:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 2719              		.loc 1 252 5 discriminator 2 view .LVU943
 253:lwIP/src/core/tcp_in.c **** 
 2720              		.loc 1 253 5 discriminator 2 view .LVU944
 253:lwIP/src/core/tcp_in.c **** 
 2721              		.loc 1 253 5 discriminator 2 view .LVU945
 2722 0198 0128     		cmp	r0, #1
 2723 019a 00F08680 		beq	.L475
 253:lwIP/src/core/tcp_in.c **** 
 2724              		.loc 1 253 5 discriminator 2 view .LVU946
 256:lwIP/src/core/tcp_in.c ****         (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 2725              		.loc 1 256 5 discriminator 2 view .LVU947
 256:lwIP/src/core/tcp_in.c ****         (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 2726              		.loc 1 256 13 is_stmt 0 discriminator 2 view .LVU948
 2727 019e 217A     		ldrb	r1, [r4, #8]	@ zero_extendqisi2
 256:lwIP/src/core/tcp_in.c ****         (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 2728              		.loc 1 256 8 discriminator 2 view .LVU949
 2729 01a0 31B1     		cbz	r1, .L234
 257:lwIP/src/core/tcp_in.c ****       prev = pcb;
ARM GAS  /tmp/ccFjUByx.s 			page 118


 2730              		.loc 1 257 28 discriminator 1 view .LVU950
 2731 01a2 0898     		ldr	r0, [sp, #32]
 2732 01a4 90F82800 		ldrb	r0, [r0, #40]	@ zero_extendqisi2
 2733 01a8 0130     		adds	r0, r0, #1
 256:lwIP/src/core/tcp_in.c ****         (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 2734              		.loc 1 256 44 discriminator 1 view .LVU951
 2735 01aa C0B2     		uxtb	r0, r0
 2736 01ac 8142     		cmp	r1, r0
 2737 01ae E6D1     		bne	.L235
 2738              	.L234:
 262:lwIP/src/core/tcp_in.c ****         pcb->local_port == tcphdr->dest &&
 2739              		.loc 1 262 5 is_stmt 1 view .LVU952
 262:lwIP/src/core/tcp_in.c ****         pcb->local_port == tcphdr->dest &&
 2740              		.loc 1 262 8 is_stmt 0 view .LVU953
 2741 01b0 208B     		ldrh	r0, [r4, #24]
 2742 01b2 9042     		cmp	r0, r2
 2743 01b4 E3D1     		bne	.L235
 262:lwIP/src/core/tcp_in.c ****         pcb->local_port == tcphdr->dest &&
 2744              		.loc 1 262 41 discriminator 1 view .LVU954
 2745 01b6 E08A     		ldrh	r0, [r4, #22]
 2746 01b8 0599     		ldr	r1, [sp, #20]
 2747 01ba 8842     		cmp	r0, r1
 2748 01bc DFD1     		bne	.L235
 263:lwIP/src/core/tcp_in.c ****         ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 2749              		.loc 1 263 41 view .LVU955
 2750 01be 6068     		ldr	r0, [r4, #4]
 2751 01c0 0999     		ldr	r1, [sp, #36]
 2752 01c2 8842     		cmp	r0, r1
 2753 01c4 DBD1     		bne	.L235
 264:lwIP/src/core/tcp_in.c ****         ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 2754              		.loc 1 264 61 view .LVU956
 2755 01c6 2068     		ldr	r0, [r4]
 2756 01c8 0A99     		ldr	r1, [sp, #40]
 2757 01ca 8842     		cmp	r0, r1
 2758 01cc D7D1     		bne	.L235
 269:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 2759              		.loc 1 269 7 is_stmt 1 view .LVU957
 269:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 2760              		.loc 1 269 7 view .LVU958
 2761 01ce E168     		ldr	r1, [r4, #12]
 2762 01d0 A142     		cmp	r1, r4
 2763 01d2 00F0FC82 		beq	.L476
 269:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 2764              		.loc 1 269 7 discriminator 2 view .LVU959
 270:lwIP/src/core/tcp_in.c ****         prev->next = pcb->next;
 2765              		.loc 1 270 7 discriminator 2 view .LVU960
 270:lwIP/src/core/tcp_in.c ****         prev->next = pcb->next;
 2766              		.loc 1 270 10 is_stmt 0 discriminator 2 view .LVU961
 2767 01d6 079A     		ldr	r2, [sp, #28]
 2768 01d8 32B1     		cbz	r2, .L238
 271:lwIP/src/core/tcp_in.c ****         pcb->next = tcp_active_pcbs;
 2769              		.loc 1 271 9 is_stmt 1 view .LVU962
 271:lwIP/src/core/tcp_in.c ****         pcb->next = tcp_active_pcbs;
 2770              		.loc 1 271 20 is_stmt 0 view .LVU963
 2771 01da D160     		str	r1, [r2, #12]
 272:lwIP/src/core/tcp_in.c ****         tcp_active_pcbs = pcb;
 2772              		.loc 1 272 9 is_stmt 1 view .LVU964
ARM GAS  /tmp/ccFjUByx.s 			page 119


 272:lwIP/src/core/tcp_in.c ****         tcp_active_pcbs = pcb;
 2773              		.loc 1 272 19 is_stmt 0 view .LVU965
 2774 01dc 0B9A     		ldr	r2, [sp, #44]
 273:lwIP/src/core/tcp_in.c ****       } else {
 2775              		.loc 1 273 25 view .LVU966
 2776 01de 3C60     		str	r4, [r7]
 277:lwIP/src/core/tcp_in.c ****       break;
 2777              		.loc 1 277 7 view .LVU967
 2778 01e0 A242     		cmp	r2, r4
 272:lwIP/src/core/tcp_in.c ****         tcp_active_pcbs = pcb;
 2779              		.loc 1 272 19 view .LVU968
 2780 01e2 E260     		str	r2, [r4, #12]
 273:lwIP/src/core/tcp_in.c ****       } else {
 2781              		.loc 1 273 9 is_stmt 1 view .LVU969
 275:lwIP/src/core/tcp_in.c ****       }
 2782              		.loc 1 275 36 view .LVU970
 277:lwIP/src/core/tcp_in.c ****       break;
 2783              		.loc 1 277 7 view .LVU971
 277:lwIP/src/core/tcp_in.c ****       break;
 2784              		.loc 1 277 7 view .LVU972
 2785 01e4 00F0F782 		beq	.L477
 2786              	.L238:
 283:lwIP/src/core/tcp_in.c ****     /* If it did not go to an active connection, we check the connections
 2787              		.loc 1 283 3 view .LVU973
 401:lwIP/src/core/tcp_in.c ****     /* The incoming segment belongs to a connection. */
 2788              		.loc 1 401 3 view .LVU974
 408:lwIP/src/core/tcp_in.c ****     inseg.len = p->tot_len;
 2789              		.loc 1 408 5 view .LVU975
 408:lwIP/src/core/tcp_in.c ****     inseg.len = p->tot_len;
 2790              		.loc 1 408 16 is_stmt 0 view .LVU976
 2791 01e8 DFF824A1 		ldr	r10, .L494+68
 2792 01ec 0021     		movs	r1, #0
 413:lwIP/src/core/tcp_in.c ****     recv_flags = 0;
 2793              		.loc 1 413 15 view .LVU977
 2794 01ee DFF824B1 		ldr	fp, .L494+72
 417:lwIP/src/core/tcp_in.c ****       p->flags |= PBUF_FLAG_PUSH;
 2795              		.loc 1 417 8 view .LVU978
 2796 01f2 1CF0080F 		tst	ip, #8
 414:lwIP/src/core/tcp_in.c ****     recv_acked = 0;
 2797              		.loc 1 414 16 view .LVU979
 2798 01f6 3E4E     		ldr	r6, .L494+36
 411:lwIP/src/core/tcp_in.c **** 
 2799              		.loc 1 411 18 view .LVU980
 2800 01f8 CAF80C30 		str	r3, [r10, #12]
 415:lwIP/src/core/tcp_in.c **** 
 2801              		.loc 1 415 16 view .LVU981
 2802 01fc 3D4B     		ldr	r3, .L494+40
 409:lwIP/src/core/tcp_in.c ****     inseg.p = p;
 2803              		.loc 1 409 15 view .LVU982
 2804 01fe AAF808E0 		strh	lr, [r10, #8]	@ movhi
 410:lwIP/src/core/tcp_in.c ****     inseg.tcphdr = tcphdr;
 2805              		.loc 1 410 13 view .LVU983
 2806 0202 CAF80450 		str	r5, [r10, #4]
 408:lwIP/src/core/tcp_in.c ****     inseg.len = p->tot_len;
 2807              		.loc 1 408 16 view .LVU984
 2808 0206 CAF80010 		str	r1, [r10]
 409:lwIP/src/core/tcp_in.c ****     inseg.p = p;
ARM GAS  /tmp/ccFjUByx.s 			page 120


 2809              		.loc 1 409 5 is_stmt 1 view .LVU985
 410:lwIP/src/core/tcp_in.c ****     inseg.tcphdr = tcphdr;
 2810              		.loc 1 410 5 view .LVU986
 411:lwIP/src/core/tcp_in.c **** 
 2811              		.loc 1 411 5 view .LVU987
 413:lwIP/src/core/tcp_in.c ****     recv_flags = 0;
 2812              		.loc 1 413 5 view .LVU988
 413:lwIP/src/core/tcp_in.c ****     recv_flags = 0;
 2813              		.loc 1 413 15 is_stmt 0 view .LVU989
 2814 020a CBF80010 		str	r1, [fp]
 414:lwIP/src/core/tcp_in.c ****     recv_acked = 0;
 2815              		.loc 1 414 5 is_stmt 1 view .LVU990
 414:lwIP/src/core/tcp_in.c ****     recv_acked = 0;
 2816              		.loc 1 414 16 is_stmt 0 view .LVU991
 2817 020e 3170     		strb	r1, [r6]
 415:lwIP/src/core/tcp_in.c **** 
 2818              		.loc 1 415 5 is_stmt 1 view .LVU992
 415:lwIP/src/core/tcp_in.c **** 
 2819              		.loc 1 415 16 is_stmt 0 view .LVU993
 2820 0210 1980     		strh	r1, [r3]	@ movhi
 417:lwIP/src/core/tcp_in.c ****       p->flags |= PBUF_FLAG_PUSH;
 2821              		.loc 1 417 5 is_stmt 1 view .LVU994
 417:lwIP/src/core/tcp_in.c ****       p->flags |= PBUF_FLAG_PUSH;
 2822              		.loc 1 417 8 is_stmt 0 view .LVU995
 2823 0212 03D0     		beq	.L339
 418:lwIP/src/core/tcp_in.c ****     }
 2824              		.loc 1 418 7 is_stmt 1 view .LVU996
 418:lwIP/src/core/tcp_in.c ****     }
 2825              		.loc 1 418 16 is_stmt 0 view .LVU997
 2826 0214 697B     		ldrb	r1, [r5, #13]	@ zero_extendqisi2
 2827 0216 41F00101 		orr	r1, r1, #1
 2828 021a 6973     		strb	r1, [r5, #13]
 2829              	.L339:
 422:lwIP/src/core/tcp_in.c ****       if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 2830              		.loc 1 422 5 is_stmt 1 view .LVU998
 422:lwIP/src/core/tcp_in.c ****       if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 2831              		.loc 1 422 8 is_stmt 0 view .LVU999
 2832 021c 616F     		ldr	r1, [r4, #116]
 2833 021e 61B1     		cbz	r1, .L259
 423:lwIP/src/core/tcp_in.c ****           ((pcb->refused_data != NULL) && (tcplen > 0))) {
 2834              		.loc 1 423 7 is_stmt 1 view .LVU1000
 423:lwIP/src/core/tcp_in.c ****           ((pcb->refused_data != NULL) && (tcplen > 0))) {
 2835              		.loc 1 423 12 is_stmt 0 view .LVU1001
 2836 0220 2046     		mov	r0, r4
 2837 0222 FFF7FEFF 		bl	tcp_process_refused_data
 2838              	.LVL170:
 423:lwIP/src/core/tcp_in.c ****           ((pcb->refused_data != NULL) && (tcplen > 0))) {
 2839              		.loc 1 423 10 view .LVU1002
 2840 0226 0D30     		adds	r0, r0, #13
 2841 0228 00F0D982 		beq	.L260
 423:lwIP/src/core/tcp_in.c ****           ((pcb->refused_data != NULL) && (tcplen > 0))) {
 2842              		.loc 1 423 55 discriminator 1 view .LVU1003
 2843 022c 616F     		ldr	r1, [r4, #116]
 2844 022e 21B1     		cbz	r1, .L259
 424:lwIP/src/core/tcp_in.c ****         /* pcb has been aborted or refused data is still refused and the new
 2845              		.loc 1 424 40 view .LVU1004
 2846 0230 069B     		ldr	r3, [sp, #24]
ARM GAS  /tmp/ccFjUByx.s 			page 121


 2847 0232 1988     		ldrh	r1, [r3]
 2848 0234 0029     		cmp	r1, #0
 2849 0236 40F0D282 		bne	.L260
 2850              	.L259:
 437:lwIP/src/core/tcp_in.c ****     err = tcp_process(pcb);
 2851              		.loc 1 437 5 is_stmt 1 view .LVU1005
 2852              	.LBB308:
 2853              	.LBB309:
 799:lwIP/src/core/tcp_in.c ****     /* First, determine if the reset is acceptable. */
 2854              		.loc 1 799 13 is_stmt 0 view .LVU1006
 2855 023a 2A4B     		ldr	r3, .L494+24
 2856              	.LBE309:
 2857              	.LBE308:
 437:lwIP/src/core/tcp_in.c ****     err = tcp_process(pcb);
 2858              		.loc 1 437 19 view .LVU1007
 2859 023c 2E4D     		ldr	r5, .L494+44
 2860              	.LVL171:
 2861              	.LBB343:
 2862              	.LBB328:
 799:lwIP/src/core/tcp_in.c ****     /* First, determine if the reset is acceptable. */
 2863              		.loc 1 799 13 view .LVU1008
 2864 023e 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 2865              	.LBE328:
 2866              	.LBE343:
 437:lwIP/src/core/tcp_in.c ****     err = tcp_process(pcb);
 2867              		.loc 1 437 19 view .LVU1009
 2868 0240 2C60     		str	r4, [r5]
 438:lwIP/src/core/tcp_in.c ****     /* A return value of ERR_ABRT means that tcp_abort() was called
 2869              		.loc 1 438 5 is_stmt 1 view .LVU1010
 2870              	.LVL172:
 2871              	.LBB344:
 2872              	.LBI308:
 788:lwIP/src/core/tcp_in.c **** {
 2873              		.loc 1 788 1 view .LVU1011
 2874              	.LBB329:
 790:lwIP/src/core/tcp_in.c ****   u8_t acceptable = 0;
 2875              		.loc 1 790 3 view .LVU1012
 791:lwIP/src/core/tcp_in.c ****   err_t err;
 2876              		.loc 1 791 3 view .LVU1013
 792:lwIP/src/core/tcp_in.c **** 
 2877              		.loc 1 792 3 view .LVU1014
 794:lwIP/src/core/tcp_in.c **** 
 2878              		.loc 1 794 3 view .LVU1015
 796:lwIP/src/core/tcp_in.c **** 
 2879              		.loc 1 796 3 view .LVU1016
 796:lwIP/src/core/tcp_in.c **** 
 2880              		.loc 1 796 3 view .LVU1017
 796:lwIP/src/core/tcp_in.c **** 
 2881              		.loc 1 796 3 view .LVU1018
 799:lwIP/src/core/tcp_in.c ****     /* First, determine if the reset is acceptable. */
 2882              		.loc 1 799 3 view .LVU1019
 799:lwIP/src/core/tcp_in.c ****     /* First, determine if the reset is acceptable. */
 2883              		.loc 1 799 6 is_stmt 0 view .LVU1020
 2884 0242 4A07     		lsls	r2, r1, #29
 2885 0244 40F11482 		bpl	.L263
 2886              	.LVL173:
 801:lwIP/src/core/tcp_in.c ****       /* "In the SYN-SENT state (a RST received in response to an initial SYN),
ARM GAS  /tmp/ccFjUByx.s 			page 122


 2887              		.loc 1 801 5 is_stmt 1 view .LVU1021
 801:lwIP/src/core/tcp_in.c ****       /* "In the SYN-SENT state (a RST received in response to an initial SYN),
 2888              		.loc 1 801 12 is_stmt 0 view .LVU1022
 2889 0248 217D     		ldrb	r1, [r4, #20]	@ zero_extendqisi2
 801:lwIP/src/core/tcp_in.c ****       /* "In the SYN-SENT state (a RST received in response to an initial SYN),
 2890              		.loc 1 801 8 view .LVU1023
 2891 024a 0229     		cmp	r1, #2
 2892 024c 00F0D181 		beq	.L478
 810:lwIP/src/core/tcp_in.c ****         acceptable = 1;
 2893              		.loc 1 810 7 is_stmt 1 view .LVU1024
 810:lwIP/src/core/tcp_in.c ****         acceptable = 1;
 2894              		.loc 1 810 17 is_stmt 0 view .LVU1025
 2895 0250 234B     		ldr	r3, .L494+20
 810:lwIP/src/core/tcp_in.c ****         acceptable = 1;
 2896              		.loc 1 810 23 view .LVU1026
 2897 0252 626A     		ldr	r2, [r4, #36]
 810:lwIP/src/core/tcp_in.c ****         acceptable = 1;
 2898              		.loc 1 810 17 view .LVU1027
 2899 0254 1B68     		ldr	r3, [r3]
 810:lwIP/src/core/tcp_in.c ****         acceptable = 1;
 2900              		.loc 1 810 10 view .LVU1028
 2901 0256 9A42     		cmp	r2, r3
 2902 0258 00F0C681 		beq	.L267
 812:lwIP/src/core/tcp_in.c ****                                   pcb->rcv_nxt + pcb->rcv_wnd)) {
 2903              		.loc 1 812 15 is_stmt 1 view .LVU1029
 812:lwIP/src/core/tcp_in.c ****                                   pcb->rcv_nxt + pcb->rcv_wnd)) {
 2904              		.loc 1 812 18 is_stmt 0 view .LVU1030
 2905 025c 9B1A     		subs	r3, r3, r2
 2906 025e 04D4     		bmi	.L266
 812:lwIP/src/core/tcp_in.c ****                                   pcb->rcv_nxt + pcb->rcv_wnd)) {
 2907              		.loc 1 812 19 view .LVU1031
 2908 0260 228D     		ldrh	r2, [r4, #40]
 2909 0262 9B1A     		subs	r3, r3, r2
 2910 0264 002B     		cmp	r3, #0
 2911 0266 40F31983 		ble	.L285
 2912              	.LVL174:
 2913              	.L266:
 812:lwIP/src/core/tcp_in.c ****                                   pcb->rcv_nxt + pcb->rcv_wnd)) {
 2914              		.loc 1 812 19 view .LVU1032
 2915              	.LBE329:
 2916              	.LBE344:
 442:lwIP/src/core/tcp_in.c ****         /* TF_RESET means that the connection was reset by the other
 2917              		.loc 1 442 7 is_stmt 1 view .LVU1033
 442:lwIP/src/core/tcp_in.c ****         /* TF_RESET means that the connection was reset by the other
 2918              		.loc 1 442 10 is_stmt 0 view .LVU1034
 2919 026a 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 2920 026c 1A07     		lsls	r2, r3, #28
 2921 026e 40F17481 		bpl	.L315
 447:lwIP/src/core/tcp_in.c ****         tcp_pcb_remove(&tcp_active_pcbs, pcb);
 2922              		.loc 1 447 9 is_stmt 1 view .LVU1035
 447:lwIP/src/core/tcp_in.c ****         tcp_pcb_remove(&tcp_active_pcbs, pcb);
 2923              		.loc 1 447 9 view .LVU1036
 447:lwIP/src/core/tcp_in.c ****         tcp_pcb_remove(&tcp_active_pcbs, pcb);
 2924              		.loc 1 447 9 view .LVU1037
 2925 0272 D4F88C30 		ldr	r3, [r4, #140]
 2926 0276 1BB1     		cbz	r3, .L316
 447:lwIP/src/core/tcp_in.c ****         tcp_pcb_remove(&tcp_active_pcbs, pcb);
ARM GAS  /tmp/ccFjUByx.s 			page 123


 2927              		.loc 1 447 9 discriminator 1 view .LVU1038
 2928 0278 6FF00D01 		mvn	r1, #13
 2929 027c 2069     		ldr	r0, [r4, #16]
 2930 027e 9847     		blx	r3
 2931              	.LVL175:
 2932              	.L316:
 447:lwIP/src/core/tcp_in.c ****         tcp_pcb_remove(&tcp_active_pcbs, pcb);
 2933              		.loc 1 447 9 discriminator 3 view .LVU1039
 448:lwIP/src/core/tcp_in.c ****         tcp_free(pcb);
 2934              		.loc 1 448 9 discriminator 3 view .LVU1040
 2935 0280 1A48     		ldr	r0, .L494+32
 2936 0282 2146     		mov	r1, r4
 2937 0284 FFF7FEFF 		bl	tcp_pcb_remove
 2938              	.LVL176:
 449:lwIP/src/core/tcp_in.c ****       } else {
 2939              		.loc 1 449 9 discriminator 3 view .LVU1041
 2940 0288 2046     		mov	r0, r4
 2941 028a FFF7FEFF 		bl	tcp_free
 2942              	.LVL177:
 2943              	.L262:
 564:lwIP/src/core/tcp_in.c ****     recv_data = NULL;
 2944              		.loc 1 564 5 view .LVU1042
 564:lwIP/src/core/tcp_in.c ****     recv_data = NULL;
 2945              		.loc 1 564 19 is_stmt 0 view .LVU1043
 2946 028e 0024     		movs	r4, #0
 2947              	.LVL178:
 568:lwIP/src/core/tcp_in.c ****       pbuf_free(inseg.p);
 2948              		.loc 1 568 14 view .LVU1044
 2949 0290 DAF80400 		ldr	r0, [r10, #4]
 564:lwIP/src/core/tcp_in.c ****     recv_data = NULL;
 2950              		.loc 1 564 19 view .LVU1045
 2951 0294 2C60     		str	r4, [r5]
 565:lwIP/src/core/tcp_in.c **** 
 2952              		.loc 1 565 5 is_stmt 1 view .LVU1046
 565:lwIP/src/core/tcp_in.c **** 
 2953              		.loc 1 565 15 is_stmt 0 view .LVU1047
 2954 0296 CBF80040 		str	r4, [fp]
 568:lwIP/src/core/tcp_in.c ****       pbuf_free(inseg.p);
 2955              		.loc 1 568 5 is_stmt 1 view .LVU1048
 568:lwIP/src/core/tcp_in.c ****       pbuf_free(inseg.p);
 2956              		.loc 1 568 8 is_stmt 0 view .LVU1049
 2957 029a 18B1     		cbz	r0, .L214
 569:lwIP/src/core/tcp_in.c ****       inseg.p = NULL;
 2958              		.loc 1 569 7 is_stmt 1 view .LVU1050
 2959 029c FFF7FEFF 		bl	pbuf_free
 2960              	.LVL179:
 570:lwIP/src/core/tcp_in.c ****     }
 2961              		.loc 1 570 7 view .LVU1051
 570:lwIP/src/core/tcp_in.c ****     }
 2962              		.loc 1 570 15 is_stmt 0 view .LVU1052
 2963 02a0 CAF80440 		str	r4, [r10, #4]
 2964              	.L214:
 592:lwIP/src/core/tcp_in.c **** 
 2965              		.loc 1 592 1 view .LVU1053
 2966 02a4 0DB0     		add	sp, sp, #52
 2967              	.LCFI14:
 2968              		.cfi_remember_state
ARM GAS  /tmp/ccFjUByx.s 			page 124


 2969              		.cfi_def_cfa_offset 36
 2970              		@ sp needed
 2971 02a6 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2972              	.LVL180:
 2973              	.L475:
 2974              	.LCFI15:
 2975              		.cfi_restore_state
 253:lwIP/src/core/tcp_in.c **** 
 2976              		.loc 1 253 5 is_stmt 1 discriminator 1 view .LVU1054
 2977 02aa 1448     		ldr	r0, .L494+48
 2978 02ac FFF7FEFF 		bl	printf
 2979              	.LVL181:
 2980              	.L233:
 253:lwIP/src/core/tcp_in.c **** 
 2981              		.loc 1 253 5 discriminator 7 view .LVU1055
 253:lwIP/src/core/tcp_in.c **** 
 2982              		.loc 1 253 5 discriminator 7 view .LVU1056
 253:lwIP/src/core/tcp_in.c **** 
 2983              		.loc 1 253 5 discriminator 7 view .LVU1057
 253:lwIP/src/core/tcp_in.c **** 
 2984              		.loc 1 253 5 discriminator 7 view .LVU1058
 253:lwIP/src/core/tcp_in.c **** 
 2985              		.loc 1 253 5 discriminator 7 view .LVU1059
 253:lwIP/src/core/tcp_in.c **** 
 2986              		.loc 1 253 5 discriminator 7 view .LVU1060
 2987 02b0 FEE7     		b	.L233
 2988              	.LVL182:
 2989              	.L472:
 253:lwIP/src/core/tcp_in.c **** 
 2990              		.loc 1 253 5 is_stmt 0 discriminator 7 view .LVU1061
 2991 02b2 17EE901A 		vmov	r1, s15	@ int
 2992              	.LVL183:
 2993              	.L227:
 283:lwIP/src/core/tcp_in.c ****     /* If it did not go to an active connection, we check the connections
 2994              		.loc 1 283 3 is_stmt 1 view .LVU1062
 286:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 2995              		.loc 1 286 5 view .LVU1063
 286:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 2996              		.loc 1 286 14 is_stmt 0 view .LVU1064
 2997 02b6 124B     		ldr	r3, .L494+52
 2998 02b8 1868     		ldr	r0, [r3]
 2999              	.LVL184:
 286:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 3000              		.loc 1 286 29 is_stmt 1 view .LVU1065
 286:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 3001              		.loc 1 286 5 is_stmt 0 view .LVU1066
 3002 02ba 0028     		cmp	r0, #0
 3003 02bc 7CD0     		beq	.L341
 291:lwIP/src/core/tcp_in.c ****         continue;
 3004              		.loc 1 291 30 view .LVU1067
 3005 02be D6F804E0 		ldr	lr, [r6, #4]
 298:lwIP/src/core/tcp_in.c ****         /* We don't really care enough to move this PCB to the front
 3006              		.loc 1 298 11 view .LVU1068
 3007 02c2 D6E90493 		ldrd	r9, r3, [r6, #16]
 3008 02c6 0693     		str	r3, [sp, #24]
 3009 02c8 29E0     		b	.L250
 3010              	.L495:
ARM GAS  /tmp/ccFjUByx.s 			page 125


 3011 02ca 00BF     		.align	2
 3012              	.L494:
 3013 02cc 00000000 		.word	ip_data
 3014 02d0 00000000 		.word	.LANCHOR0
 3015 02d4 00000000 		.word	.LANCHOR3
 3016 02d8 34000000 		.word	.LC12
 3017 02dc 00000000 		.word	.LC9
 3018 02e0 00000000 		.word	.LANCHOR8
 3019 02e4 00000000 		.word	.LANCHOR9
 3020 02e8 00000000 		.word	.LANCHOR10
 3021 02ec 00000000 		.word	tcp_active_pcbs
 3022 02f0 00000000 		.word	.LANCHOR5
 3023 02f4 00000000 		.word	.LANCHOR6
 3024 02f8 00000000 		.word	tcp_input_pcb
 3025 02fc A8000000 		.word	.LC15
 3026 0300 00000000 		.word	tcp_tw_pcbs
 3027 0304 00000000 		.word	.LANCHOR4
 3028 0308 00000000 		.word	.LANCHOR2
 3029 030c 00000000 		.word	.LANCHOR7
 3030 0310 00000000 		.word	.LANCHOR11
 3031 0314 00000000 		.word	.LANCHOR12
 3032              	.L244:
 286:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 3033              		.loc 1 286 46 discriminator 2 view .LVU1069
 3034 0318 C068     		ldr	r0, [r0, #12]
 3035              	.LVL185:
 286:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 3036              		.loc 1 286 29 is_stmt 1 discriminator 2 view .LVU1070
 286:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 3037              		.loc 1 286 5 is_stmt 0 discriminator 2 view .LVU1071
 3038 031a 0028     		cmp	r0, #0
 3039 031c 4CD0     		beq	.L341
 3040              	.L250:
 287:lwIP/src/core/tcp_in.c **** 
 3041              		.loc 1 287 7 is_stmt 1 view .LVU1072
 287:lwIP/src/core/tcp_in.c **** 
 3042              		.loc 1 287 7 view .LVU1073
 287:lwIP/src/core/tcp_in.c **** 
 3043              		.loc 1 287 7 view .LVU1074
 290:lwIP/src/core/tcp_in.c ****           (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 3044              		.loc 1 290 7 view .LVU1075
 295:lwIP/src/core/tcp_in.c ****           pcb->local_port == tcphdr->dest &&
 3045              		.loc 1 295 7 view .LVU1076
 286:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 3046              		.loc 1 286 42 view .LVU1077
 287:lwIP/src/core/tcp_in.c **** 
 3047              		.loc 1 287 7 is_stmt 0 view .LVU1078
 3048 031e 037D     		ldrb	r3, [r0, #20]	@ zero_extendqisi2
 3049 0320 0A2B     		cmp	r3, #10
 3050 0322 31D1     		bne	.L479
 290:lwIP/src/core/tcp_in.c ****           (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 3051              		.loc 1 290 15 discriminator 2 view .LVU1079
 3052 0324 047A     		ldrb	r4, [r0, #8]	@ zero_extendqisi2
 290:lwIP/src/core/tcp_in.c ****           (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 3053              		.loc 1 290 10 discriminator 2 view .LVU1080
 3054 0326 2CB1     		cbz	r4, .L243
 291:lwIP/src/core/tcp_in.c ****         continue;
ARM GAS  /tmp/ccFjUByx.s 			page 126


 3055              		.loc 1 291 30 discriminator 1 view .LVU1081
 3056 0328 9EF82830 		ldrb	r3, [lr, #40]	@ zero_extendqisi2
 3057 032c 0133     		adds	r3, r3, #1
 290:lwIP/src/core/tcp_in.c ****           (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 3058              		.loc 1 290 46 discriminator 1 view .LVU1082
 3059 032e DBB2     		uxtb	r3, r3
 3060 0330 9C42     		cmp	r4, r3
 3061 0332 F1D1     		bne	.L244
 3062              	.L243:
 295:lwIP/src/core/tcp_in.c ****           pcb->local_port == tcphdr->dest &&
 3063              		.loc 1 295 10 view .LVU1083
 3064 0334 038B     		ldrh	r3, [r0, #24]
 3065 0336 9342     		cmp	r3, r2
 3066 0338 EED1     		bne	.L244
 295:lwIP/src/core/tcp_in.c ****           pcb->local_port == tcphdr->dest &&
 3067              		.loc 1 295 43 discriminator 1 view .LVU1084
 3068 033a C38A     		ldrh	r3, [r0, #22]
 3069 033c 059C     		ldr	r4, [sp, #20]
 3070 033e A342     		cmp	r3, r4
 3071 0340 EAD1     		bne	.L244
 296:lwIP/src/core/tcp_in.c ****           ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 3072              		.loc 1 296 43 view .LVU1085
 3073 0342 4368     		ldr	r3, [r0, #4]
 3074 0344 4B45     		cmp	r3, r9
 3075 0346 E7D1     		bne	.L244
 297:lwIP/src/core/tcp_in.c ****           ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 3076              		.loc 1 297 63 view .LVU1086
 3077 0348 0368     		ldr	r3, [r0]
 3078 034a 069C     		ldr	r4, [sp, #24]
 3079 034c A342     		cmp	r3, r4
 3080 034e E3D1     		bne	.L244
 302:lwIP/src/core/tcp_in.c **** #ifdef LWIP_HOOK_TCP_INPACKET_PCB
 3081              		.loc 1 302 91 is_stmt 1 view .LVU1087
 308:lwIP/src/core/tcp_in.c ****         }
 3082              		.loc 1 308 11 view .LVU1088
 3083              	.LVL186:
 3084              	.LBB345:
 3085              	.LBI345:
 739:lwIP/src/core/tcp_in.c **** {
 3086              		.loc 1 739 1 view .LVU1089
 3087              	.LBB346:
 746:lwIP/src/core/tcp_in.c ****     return;
 3088              		.loc 1 746 3 view .LVU1090
 746:lwIP/src/core/tcp_in.c ****     return;
 3089              		.loc 1 746 6 is_stmt 0 view .LVU1091
 3090 0350 1CF0040F 		tst	ip, #4
 3091 0354 7FF462AE 		bne	.L217
 750:lwIP/src/core/tcp_in.c **** 
 3092              		.loc 1 750 3 is_stmt 1 view .LVU1092
 750:lwIP/src/core/tcp_in.c **** 
 3093              		.loc 1 750 3 view .LVU1093
 750:lwIP/src/core/tcp_in.c **** 
 3094              		.loc 1 750 3 view .LVU1094
 753:lwIP/src/core/tcp_in.c ****     /* If an incoming segment is not acceptable, an acknowledgment
 3095              		.loc 1 753 3 view .LVU1095
 753:lwIP/src/core/tcp_in.c ****     /* If an incoming segment is not acceptable, an acknowledgment
 3096              		.loc 1 753 6 is_stmt 0 view .LVU1096
ARM GAS  /tmp/ccFjUByx.s 			page 127


 3097 0358 1CF0020F 		tst	ip, #2
 3098 035c 00F0F180 		beq	.L247
 756:lwIP/src/core/tcp_in.c ****       /* If the SYN is in the window it is an error, send a reset */
 3099              		.loc 1 756 5 is_stmt 1 view .LVU1097
 756:lwIP/src/core/tcp_in.c ****       /* If the SYN is in the window it is an error, send a reset */
 3100              		.loc 1 756 9 is_stmt 0 view .LVU1098
 3101 0360 436A     		ldr	r3, [r0, #36]
 756:lwIP/src/core/tcp_in.c ****       /* If the SYN is in the window it is an error, send a reset */
 3102              		.loc 1 756 8 view .LVU1099
 3103 0362 BBEB0303 		subs	r3, fp, r3
 3104 0366 04D4     		bmi	.L248
 756:lwIP/src/core/tcp_in.c ****       /* If the SYN is in the window it is an error, send a reset */
 3105              		.loc 1 756 9 view .LVU1100
 3106 0368 048D     		ldrh	r4, [r0, #40]
 3107 036a 1B1B     		subs	r3, r3, r4
 3108 036c 002B     		cmp	r3, #0
 3109 036e 40F3D980 		ble	.L334
 3110              	.L248:
 768:lwIP/src/core/tcp_in.c ****     /* Acknowledge data, FIN or out-of-window SYN */
 3111              		.loc 1 768 3 is_stmt 1 view .LVU1101
 768:lwIP/src/core/tcp_in.c ****     /* Acknowledge data, FIN or out-of-window SYN */
 3112              		.loc 1 768 6 is_stmt 0 view .LVU1102
 3113 0372 BAF1000F 		cmp	r10, #0
 3114 0376 3FF451AE 		beq	.L217
 770:lwIP/src/core/tcp_in.c ****     tcp_output(pcb);
 3115              		.loc 1 770 5 is_stmt 1 view .LVU1103
 770:lwIP/src/core/tcp_in.c ****     tcp_output(pcb);
 3116              		.loc 1 770 5 view .LVU1104
 3117 037a 438B     		ldrh	r3, [r0, #26]
 3118 037c 43F00203 		orr	r3, r3, #2
 3119 0380 4383     		strh	r3, [r0, #26]	@ movhi
 770:lwIP/src/core/tcp_in.c ****     tcp_output(pcb);
 3120              		.loc 1 770 5 view .LVU1105
 771:lwIP/src/core/tcp_in.c ****   }
 3121              		.loc 1 771 5 view .LVU1106
 3122 0382 FFF7FEFF 		bl	tcp_output
 3123              	.LVL187:
 771:lwIP/src/core/tcp_in.c ****   }
 3124              		.loc 1 771 5 is_stmt 0 view .LVU1107
 3125              	.LBE346:
 3126              	.LBE345:
 310:lwIP/src/core/tcp_in.c ****         return;
 3127              		.loc 1 310 9 is_stmt 1 view .LVU1108
 3128 0386 49E6     		b	.L217
 3129              	.LVL188:
 3130              	.L479:
 287:lwIP/src/core/tcp_in.c **** 
 3131              		.loc 1 287 7 discriminator 1 view .LVU1109
 3132 0388 AB48     		ldr	r0, .L496
 3133              	.LVL189:
 287:lwIP/src/core/tcp_in.c **** 
 3134              		.loc 1 287 7 is_stmt 0 discriminator 1 view .LVU1110
 3135 038a FFF7FEFF 		bl	printf
 3136              	.LVL190:
 3137              	.L242:
 287:lwIP/src/core/tcp_in.c **** 
 3138              		.loc 1 287 7 is_stmt 1 discriminator 10 view .LVU1111
ARM GAS  /tmp/ccFjUByx.s 			page 128


 287:lwIP/src/core/tcp_in.c **** 
 3139              		.loc 1 287 7 discriminator 10 view .LVU1112
 287:lwIP/src/core/tcp_in.c **** 
 3140              		.loc 1 287 7 discriminator 10 view .LVU1113
 287:lwIP/src/core/tcp_in.c **** 
 3141              		.loc 1 287 7 discriminator 10 view .LVU1114
 287:lwIP/src/core/tcp_in.c **** 
 3142              		.loc 1 287 7 discriminator 10 view .LVU1115
 287:lwIP/src/core/tcp_in.c **** 
 3143              		.loc 1 287 7 discriminator 10 view .LVU1116
 3144 038e FEE7     		b	.L242
 3145              	.L225:
 237:lwIP/src/core/tcp_in.c ****     if (tcplen < p->tot_len) {
 3146              		.loc 1 237 5 view .LVU1117
 237:lwIP/src/core/tcp_in.c ****     if (tcplen < p->tot_len) {
 3147              		.loc 1 237 11 is_stmt 0 view .LVU1118
 3148 0390 0EF1010A 		add	r10, lr, #1
 3149 0394 A948     		ldr	r0, .L496+4
 3150 0396 1FFA8AFA 		uxth	r10, r10
 3151 039a 0690     		str	r0, [sp, #24]
 238:lwIP/src/core/tcp_in.c ****       /* u16_t overflow, cannot handle this */
 3152              		.loc 1 238 8 view .LVU1119
 3153 039c F245     		cmp	r10, lr
 237:lwIP/src/core/tcp_in.c ****     if (tcplen < p->tot_len) {
 3154              		.loc 1 237 11 view .LVU1120
 3155 039e A0F800A0 		strh	r10, [r0]	@ movhi
 238:lwIP/src/core/tcp_in.c ****       /* u16_t overflow, cannot handle this */
 3156              		.loc 1 238 5 is_stmt 1 view .LVU1121
 238:lwIP/src/core/tcp_in.c ****       /* u16_t overflow, cannot handle this */
 3157              		.loc 1 238 8 is_stmt 0 view .LVU1122
 3158 03a2 BFF4DBAE 		bcs	.L226
 3159 03a6 39E6     		b	.L217
 3160              	.LVL191:
 3161              	.L474:
 252:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 3162              		.loc 1 252 5 is_stmt 1 discriminator 1 view .LVU1123
 3163 03a8 A548     		ldr	r0, .L496+8
 3164 03aa FFF7FEFF 		bl	printf
 3165              	.LVL192:
 3166              	.L231:
 252:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 3167              		.loc 1 252 5 discriminator 6 view .LVU1124
 252:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 3168              		.loc 1 252 5 discriminator 6 view .LVU1125
 252:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 3169              		.loc 1 252 5 discriminator 6 view .LVU1126
 252:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 3170              		.loc 1 252 5 discriminator 6 view .LVU1127
 252:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 3171              		.loc 1 252 5 discriminator 6 view .LVU1128
 252:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 3172              		.loc 1 252 5 discriminator 6 view .LVU1129
 3173 03ae FEE7     		b	.L231
 3174              	.L473:
 251:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 3175              		.loc 1 251 5 discriminator 1 view .LVU1130
 3176 03b0 A448     		ldr	r0, .L496+12
ARM GAS  /tmp/ccFjUByx.s 			page 129


 3177 03b2 FFF7FEFF 		bl	printf
 3178              	.LVL193:
 3179              	.L229:
 251:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 3180              		.loc 1 251 5 discriminator 5 view .LVU1131
 251:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 3181              		.loc 1 251 5 discriminator 5 view .LVU1132
 251:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 3182              		.loc 1 251 5 discriminator 5 view .LVU1133
 251:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 3183              		.loc 1 251 5 discriminator 5 view .LVU1134
 251:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 3184              		.loc 1 251 5 discriminator 5 view .LVU1135
 251:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 3185              		.loc 1 251 5 discriminator 5 view .LVU1136
 3186 03b6 FEE7     		b	.L229
 3187              	.LVL194:
 3188              	.L341:
 317:lwIP/src/core/tcp_in.c ****     for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 3189              		.loc 1 317 5 view .LVU1137
 318:lwIP/src/core/tcp_in.c ****       /* check if PCB is bound to specific netif */
 3190              		.loc 1 318 5 view .LVU1138
 318:lwIP/src/core/tcp_in.c ****       /* check if PCB is bound to specific netif */
 3191              		.loc 1 318 15 is_stmt 0 view .LVU1139
 3192 03b8 A34B     		ldr	r3, .L496+16
 3193 03ba 1C68     		ldr	r4, [r3]
 3194              	.LVL195:
 318:lwIP/src/core/tcp_in.c ****       /* check if PCB is bound to specific netif */
 3195              		.loc 1 318 46 is_stmt 1 view .LVU1140
 318:lwIP/src/core/tcp_in.c ****       /* check if PCB is bound to specific netif */
 3196              		.loc 1 318 5 is_stmt 0 view .LVU1141
 3197 03bc 002C     		cmp	r4, #0
 3198 03be 00F0AD80 		beq	.L251
 321:lwIP/src/core/tcp_in.c ****         prev = (struct tcp_pcb *)lpcb;
 3199              		.loc 1 321 31 view .LVU1142
 3200 03c2 7368     		ldr	r3, [r6, #4]
 336:lwIP/src/core/tcp_in.c ****             /* found an exact match */
 3201              		.loc 1 336 15 view .LVU1143
 3202 03c4 A146     		mov	r9, r4
 317:lwIP/src/core/tcp_in.c ****     for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 3203              		.loc 1 317 10 view .LVU1144
 3204 03c6 4FF0000E 		mov	lr, #0
 321:lwIP/src/core/tcp_in.c ****         prev = (struct tcp_pcb *)lpcb;
 3205              		.loc 1 321 31 view .LVU1145
 3206 03ca 0693     		str	r3, [sp, #24]
 336:lwIP/src/core/tcp_in.c ****             /* found an exact match */
 3207              		.loc 1 336 15 view .LVU1146
 3208 03cc 7369     		ldr	r3, [r6, #20]
 3209 03ce 0793     		str	r3, [sp, #28]
 3210 03d0 06E0     		b	.L255
 3211              	.LVL196:
 3212              	.L253:
 318:lwIP/src/core/tcp_in.c ****       /* check if PCB is bound to specific netif */
 3213              		.loc 1 318 65 discriminator 2 view .LVU1147
 3214 03d2 D9F80C30 		ldr	r3, [r9, #12]
 3215              	.LVL197:
 318:lwIP/src/core/tcp_in.c ****       /* check if PCB is bound to specific netif */
ARM GAS  /tmp/ccFjUByx.s 			page 130


 3216              		.loc 1 318 46 is_stmt 1 discriminator 2 view .LVU1148
 3217 03d6 CE46     		mov	lr, r9
 3218 03d8 9946     		mov	r9, r3
 3219              	.LVL198:
 318:lwIP/src/core/tcp_in.c ****       /* check if PCB is bound to specific netif */
 3220              		.loc 1 318 5 is_stmt 0 discriminator 2 view .LVU1149
 3221 03da 002B     		cmp	r3, #0
 3222 03dc 00F09E80 		beq	.L251
 3223              	.LVL199:
 3224              	.L255:
 320:lwIP/src/core/tcp_in.c ****           (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 3225              		.loc 1 320 7 is_stmt 1 view .LVU1150
 326:lwIP/src/core/tcp_in.c ****         if (IP_IS_ANY_TYPE_VAL(lpcb->local_ip)) {
 3226              		.loc 1 326 7 view .LVU1151
 318:lwIP/src/core/tcp_in.c ****       /* check if PCB is bound to specific netif */
 3227              		.loc 1 318 60 view .LVU1152
 320:lwIP/src/core/tcp_in.c ****           (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 3228              		.loc 1 320 16 is_stmt 0 view .LVU1153
 3229 03e0 99F80800 		ldrb	r0, [r9, #8]	@ zero_extendqisi2
 320:lwIP/src/core/tcp_in.c ****           (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 3230              		.loc 1 320 10 view .LVU1154
 3231 03e4 30B1     		cbz	r0, .L252
 321:lwIP/src/core/tcp_in.c ****         prev = (struct tcp_pcb *)lpcb;
 3232              		.loc 1 321 31 discriminator 1 view .LVU1155
 3233 03e6 069B     		ldr	r3, [sp, #24]
 3234 03e8 93F82830 		ldrb	r3, [r3, #40]	@ zero_extendqisi2
 3235 03ec 0133     		adds	r3, r3, #1
 320:lwIP/src/core/tcp_in.c ****           (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 3236              		.loc 1 320 47 discriminator 1 view .LVU1156
 3237 03ee DBB2     		uxtb	r3, r3
 3238 03f0 9842     		cmp	r0, r3
 3239 03f2 EED1     		bne	.L253
 3240              	.L252:
 326:lwIP/src/core/tcp_in.c ****         if (IP_IS_ANY_TYPE_VAL(lpcb->local_ip)) {
 3241              		.loc 1 326 10 view .LVU1157
 3242 03f4 B9F81630 		ldrh	r3, [r9, #22]
 3243 03f8 0598     		ldr	r0, [sp, #20]
 3244 03fa 8342     		cmp	r3, r0
 3245 03fc E9D1     		bne	.L253
 327:lwIP/src/core/tcp_in.c ****           /* found an ANY TYPE (IPv4/IPv6) match */
 3246              		.loc 1 327 9 is_stmt 1 view .LVU1158
 335:lwIP/src/core/tcp_in.c ****           if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 3247              		.loc 1 335 16 view .LVU1159
 336:lwIP/src/core/tcp_in.c ****             /* found an exact match */
 3248              		.loc 1 336 11 view .LVU1160
 336:lwIP/src/core/tcp_in.c ****             /* found an exact match */
 3249              		.loc 1 336 15 is_stmt 0 view .LVU1161
 3250 03fe D9F80030 		ldr	r3, [r9]
 339:lwIP/src/core/tcp_in.c ****             /* found an ANY-match */
 3251              		.loc 1 339 18 is_stmt 1 view .LVU1162
 339:lwIP/src/core/tcp_in.c ****             /* found an ANY-match */
 3252              		.loc 1 339 22 is_stmt 0 view .LVU1163
 3253 0402 13B1     		cbz	r3, .L254
 3254 0404 0798     		ldr	r0, [sp, #28]
 3255 0406 8342     		cmp	r3, r0
 3256 0408 E3D1     		bne	.L253
 3257              	.L254:
ARM GAS  /tmp/ccFjUByx.s 			page 131


 360:lwIP/src/core/tcp_in.c ****       /* Move this PCB to the front of the list so that subsequent
 3258              		.loc 1 360 5 is_stmt 1 view .LVU1164
 364:lwIP/src/core/tcp_in.c ****         ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 3259              		.loc 1 364 7 view .LVU1165
 364:lwIP/src/core/tcp_in.c ****         ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 3260              		.loc 1 364 10 is_stmt 0 view .LVU1166
 3261 040a BEF1000F 		cmp	lr, #0
 3262 040e 08D0     		beq	.L336
 365:lwIP/src/core/tcp_in.c ****         /* our successor is the remainder of the listening list */
 3263              		.loc 1 365 9 is_stmt 1 view .LVU1167
 365:lwIP/src/core/tcp_in.c ****         /* our successor is the remainder of the listening list */
 3264              		.loc 1 365 53 is_stmt 0 view .LVU1168
 3265 0410 D9F80C30 		ldr	r3, [r9, #12]
 369:lwIP/src/core/tcp_in.c ****       } else {
 3266              		.loc 1 369 37 view .LVU1169
 3267 0414 8C48     		ldr	r0, .L496+16
 365:lwIP/src/core/tcp_in.c ****         /* our successor is the remainder of the listening list */
 3268              		.loc 1 365 47 view .LVU1170
 3269 0416 CEF80C30 		str	r3, [lr, #12]
 367:lwIP/src/core/tcp_in.c ****         /* put this listening pcb at the head of the listening list */
 3270              		.loc 1 367 9 is_stmt 1 view .LVU1171
 369:lwIP/src/core/tcp_in.c ****       } else {
 3271              		.loc 1 369 37 is_stmt 0 view .LVU1172
 3272 041a C0F80090 		str	r9, [r0]
 367:lwIP/src/core/tcp_in.c ****         /* put this listening pcb at the head of the listening list */
 3273              		.loc 1 367 20 view .LVU1173
 3274 041e C9F80C40 		str	r4, [r9, #12]
 369:lwIP/src/core/tcp_in.c ****       } else {
 3275              		.loc 1 369 9 is_stmt 1 view .LVU1174
 3276              	.L336:
 371:lwIP/src/core/tcp_in.c ****       }
 3277              		.loc 1 371 36 view .LVU1175
 374:lwIP/src/core/tcp_in.c **** #ifdef LWIP_HOOK_TCP_INPACKET_PCB
 3278              		.loc 1 374 86 view .LVU1176
 380:lwIP/src/core/tcp_in.c ****       }
 3279              		.loc 1 380 9 view .LVU1177
 3280              	.LVL200:
 3281              	.LBB348:
 3282              	.LBI348:
 630:lwIP/src/core/tcp_in.c **** {
 3283              		.loc 1 630 1 view .LVU1178
 3284              	.LBB349:
 632:lwIP/src/core/tcp_in.c ****   u32_t iss;
 3285              		.loc 1 632 3 view .LVU1179
 633:lwIP/src/core/tcp_in.c ****   err_t rc;
 3286              		.loc 1 633 3 view .LVU1180
 634:lwIP/src/core/tcp_in.c **** 
 3287              		.loc 1 634 3 view .LVU1181
 636:lwIP/src/core/tcp_in.c ****     /* An incoming RST should be ignored. Return. */
 3288              		.loc 1 636 3 view .LVU1182
 636:lwIP/src/core/tcp_in.c ****     /* An incoming RST should be ignored. Return. */
 3289              		.loc 1 636 6 is_stmt 0 view .LVU1183
 3290 0422 1CF0040F 		tst	ip, #4
 3291 0426 7FF4F9AD 		bne	.L217
 641:lwIP/src/core/tcp_in.c **** 
 3292              		.loc 1 641 3 is_stmt 1 view .LVU1184
 641:lwIP/src/core/tcp_in.c **** 
ARM GAS  /tmp/ccFjUByx.s 			page 132


 3293              		.loc 1 641 3 view .LVU1185
 641:lwIP/src/core/tcp_in.c **** 
 3294              		.loc 1 641 3 view .LVU1186
 645:lwIP/src/core/tcp_in.c ****     /* For incoming segments with the ACK flag set, respond with a
 3295              		.loc 1 645 3 view .LVU1187
 645:lwIP/src/core/tcp_in.c ****     /* For incoming segments with the ACK flag set, respond with a
 3296              		.loc 1 645 6 is_stmt 0 view .LVU1188
 3297 042a 1CF01004 		ands	r4, ip, #16
 3298 042e 40F04C82 		bne	.L480
 651:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->
 3299              		.loc 1 651 10 is_stmt 1 view .LVU1189
 651:lwIP/src/core/tcp_in.c ****     LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->
 3300              		.loc 1 651 13 is_stmt 0 view .LVU1190
 3301 0432 1CF0020F 		tst	ip, #2
 3302 0436 3FF4F1AD 		beq	.L217
 652:lwIP/src/core/tcp_in.c **** #if TCP_LISTEN_BACKLOG
 3303              		.loc 1 652 106 is_stmt 1 view .LVU1191
 659:lwIP/src/core/tcp_in.c ****     /* If a new PCB could not be created (probably due to lack of memory),
 3304              		.loc 1 659 5 view .LVU1192
 659:lwIP/src/core/tcp_in.c ****     /* If a new PCB could not be created (probably due to lack of memory),
 3305              		.loc 1 659 12 is_stmt 0 view .LVU1193
 3306 043a 99F81500 		ldrb	r0, [r9, #21]	@ zero_extendqisi2
 3307 043e FFF7FEFF 		bl	tcp_alloc
 3308              	.LVL201:
 663:lwIP/src/core/tcp_in.c ****       err_t err;
 3309              		.loc 1 663 5 is_stmt 1 view .LVU1194
 663:lwIP/src/core/tcp_in.c ****       err_t err;
 3310              		.loc 1 663 8 is_stmt 0 view .LVU1195
 3311 0442 8246     		mov	r10, r0
 3312 0444 0028     		cmp	r0, #0
 3313 0446 00F03382 		beq	.L481
 676:lwIP/src/core/tcp_in.c ****     ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 3314              		.loc 1 676 5 is_stmt 1 view .LVU1196
 679:lwIP/src/core/tcp_in.c ****     npcb->state = SYN_RCVD;
 3315              		.loc 1 679 31 is_stmt 0 view .LVU1197
 3316 044a D8F80020 		ldr	r2, [r8]
 680:lwIP/src/core/tcp_in.c ****     npcb->rcv_nxt = seqno + 1;
 3317              		.loc 1 680 17 view .LVU1198
 3318 044e 4FF0030C 		mov	ip, #3
 681:lwIP/src/core/tcp_in.c ****     npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 3319              		.loc 1 681 27 view .LVU1199
 3320 0452 7E4B     		ldr	r3, .L496+20
 679:lwIP/src/core/tcp_in.c ****     npcb->state = SYN_RCVD;
 3321              		.loc 1 679 31 view .LVU1200
 3322 0454 92F801B0 		ldrb	fp, [r2, #1]	@ zero_extendqisi2
 3323 0458 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 681:lwIP/src/core/tcp_in.c ****     npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 3324              		.loc 1 681 27 view .LVU1201
 3325 045a 1B68     		ldr	r3, [r3]
 679:lwIP/src/core/tcp_in.c ****     npcb->state = SYN_RCVD;
 3326              		.loc 1 679 31 view .LVU1202
 3327 045c 41EA0B21 		orr	r1, r1, fp, lsl #8
 678:lwIP/src/core/tcp_in.c ****     npcb->remote_port = tcphdr->src;
 3328              		.loc 1 678 22 view .LVU1203
 3329 0460 B9F816B0 		ldrh	fp, [r9, #22]
 681:lwIP/src/core/tcp_in.c ****     npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 3330              		.loc 1 681 27 view .LVU1204
ARM GAS  /tmp/ccFjUByx.s 			page 133


 3331 0464 0133     		adds	r3, r3, #1
 679:lwIP/src/core/tcp_in.c ****     npcb->state = SYN_RCVD;
 3332              		.loc 1 679 23 view .LVU1205
 3333 0466 0183     		strh	r1, [r0, #24]	@ movhi
 681:lwIP/src/core/tcp_in.c ****     npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 3334              		.loc 1 681 19 view .LVU1206
 3335 0468 4362     		str	r3, [r0, #36]
 682:lwIP/src/core/tcp_in.c ****     iss = tcp_next_iss(npcb);
 3336              		.loc 1 682 30 view .LVU1207
 3337 046a C362     		str	r3, [r0, #44]
 677:lwIP/src/core/tcp_in.c ****     npcb->local_port = pcb->local_port;
 3338              		.loc 1 677 5 view .LVU1208
 3339 046c D6E90421 		ldrd	r2, r1, [r6, #16]
 680:lwIP/src/core/tcp_in.c ****     npcb->rcv_nxt = seqno + 1;
 3340              		.loc 1 680 17 view .LVU1209
 3341 0470 80F814C0 		strb	ip, [r0, #20]
 706:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 3342              		.loc 1 706 17 view .LVU1210
 3343 0474 061D     		adds	r6, r0, #4
 676:lwIP/src/core/tcp_in.c ****     ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 3344              		.loc 1 676 5 view .LVU1211
 3345 0476 0160     		str	r1, [r0]
 677:lwIP/src/core/tcp_in.c ****     npcb->local_port = pcb->local_port;
 3346              		.loc 1 677 5 is_stmt 1 view .LVU1212
 3347 0478 4260     		str	r2, [r0, #4]
 678:lwIP/src/core/tcp_in.c ****     npcb->remote_port = tcphdr->src;
 3348              		.loc 1 678 5 view .LVU1213
 679:lwIP/src/core/tcp_in.c ****     npcb->state = SYN_RCVD;
 3349              		.loc 1 679 5 view .LVU1214
 680:lwIP/src/core/tcp_in.c ****     npcb->rcv_nxt = seqno + 1;
 3350              		.loc 1 680 5 view .LVU1215
 681:lwIP/src/core/tcp_in.c ****     npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 3351              		.loc 1 681 5 view .LVU1216
 682:lwIP/src/core/tcp_in.c ****     iss = tcp_next_iss(npcb);
 3352              		.loc 1 682 5 view .LVU1217
 683:lwIP/src/core/tcp_in.c ****     npcb->snd_wl2 = iss;
 3353              		.loc 1 683 5 view .LVU1218
 678:lwIP/src/core/tcp_in.c ****     npcb->remote_port = tcphdr->src;
 3354              		.loc 1 678 22 is_stmt 0 view .LVU1219
 3355 047a A0F816B0 		strh	fp, [r0, #22]	@ movhi
 683:lwIP/src/core/tcp_in.c ****     npcb->snd_wl2 = iss;
 3356              		.loc 1 683 11 view .LVU1220
 3357 047e FFF7FEFF 		bl	tcp_next_iss
 3358              	.LVL202:
 688:lwIP/src/core/tcp_in.c ****     npcb->callback_arg = pcb->callback_arg;
 3359              		.loc 1 688 27 view .LVU1221
 3360 0482 724B     		ldr	r3, .L496+20
 3361 0484 1A68     		ldr	r2, [r3]
 3362              	.LVL203:
 684:lwIP/src/core/tcp_in.c ****     npcb->snd_nxt = iss;
 3363              		.loc 1 684 5 is_stmt 1 view .LVU1222
 689:lwIP/src/core/tcp_in.c **** #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
 3364              		.loc 1 689 24 is_stmt 0 view .LVU1223
 3365 0486 D9F81030 		ldr	r3, [r9, #16]
 688:lwIP/src/core/tcp_in.c ****     npcb->callback_arg = pcb->callback_arg;
 3366              		.loc 1 688 27 view .LVU1224
 3367 048a 013A     		subs	r2, r2, #1
ARM GAS  /tmp/ccFjUByx.s 			page 134


 684:lwIP/src/core/tcp_in.c ****     npcb->snd_nxt = iss;
 3368              		.loc 1 684 19 view .LVU1225
 3369 048c CAF85800 		str	r0, [r10, #88]
 685:lwIP/src/core/tcp_in.c ****     npcb->lastack = iss;
 3370              		.loc 1 685 5 is_stmt 1 view .LVU1226
 685:lwIP/src/core/tcp_in.c ****     npcb->lastack = iss;
 3371              		.loc 1 685 19 is_stmt 0 view .LVU1227
 3372 0490 CAF85000 		str	r0, [r10, #80]
 686:lwIP/src/core/tcp_in.c ****     npcb->snd_lbb = iss;
 3373              		.loc 1 686 5 is_stmt 1 view .LVU1228
 686:lwIP/src/core/tcp_in.c ****     npcb->snd_lbb = iss;
 3374              		.loc 1 686 19 is_stmt 0 view .LVU1229
 3375 0494 CAF84400 		str	r0, [r10, #68]
 687:lwIP/src/core/tcp_in.c ****     npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 3376              		.loc 1 687 5 is_stmt 1 view .LVU1230
 687:lwIP/src/core/tcp_in.c ****     npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 3377              		.loc 1 687 19 is_stmt 0 view .LVU1231
 3378 0498 CAF85C00 		str	r0, [r10, #92]
 688:lwIP/src/core/tcp_in.c ****     npcb->callback_arg = pcb->callback_arg;
 3379              		.loc 1 688 5 is_stmt 1 view .LVU1232
 688:lwIP/src/core/tcp_in.c ****     npcb->callback_arg = pcb->callback_arg;
 3380              		.loc 1 688 19 is_stmt 0 view .LVU1233
 3381 049c CAF85420 		str	r2, [r10, #84]
 689:lwIP/src/core/tcp_in.c **** #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
 3382              		.loc 1 689 5 is_stmt 1 view .LVU1234
 691:lwIP/src/core/tcp_in.c **** #endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
 3383              		.loc 1 691 20 is_stmt 0 view .LVU1235
 3384 04a0 CAF87890 		str	r9, [r10, #120]
 689:lwIP/src/core/tcp_in.c **** #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
 3385              		.loc 1 689 24 view .LVU1236
 3386 04a4 CAF81030 		str	r3, [r10, #16]
 691:lwIP/src/core/tcp_in.c **** #endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
 3387              		.loc 1 691 5 is_stmt 1 view .LVU1237
 694:lwIP/src/core/tcp_in.c ****     npcb->netif_idx = pcb->netif_idx;
 3388              		.loc 1 694 5 view .LVU1238
 694:lwIP/src/core/tcp_in.c ****     npcb->netif_idx = pcb->netif_idx;
 3389              		.loc 1 694 40 is_stmt 0 view .LVU1239
 3390 04a8 99F80930 		ldrb	r3, [r9, #9]	@ zero_extendqisi2
 698:lwIP/src/core/tcp_in.c **** 
 3391              		.loc 1 698 5 view .LVU1240
 3392 04ac 3A68     		ldr	r2, [r7]
 694:lwIP/src/core/tcp_in.c ****     npcb->netif_idx = pcb->netif_idx;
 3393              		.loc 1 694 40 view .LVU1241
 3394 04ae 03F00C03 		and	r3, r3, #12
 698:lwIP/src/core/tcp_in.c **** 
 3395              		.loc 1 698 5 view .LVU1242
 3396 04b2 C7F800A0 		str	r10, [r7]
 694:lwIP/src/core/tcp_in.c ****     npcb->netif_idx = pcb->netif_idx;
 3397              		.loc 1 694 22 view .LVU1243
 3398 04b6 8AF80930 		strb	r3, [r10, #9]
 695:lwIP/src/core/tcp_in.c ****     /* Register the new PCB so that we can begin receiving segments
 3399              		.loc 1 695 5 is_stmt 1 view .LVU1244
 695:lwIP/src/core/tcp_in.c ****     /* Register the new PCB so that we can begin receiving segments
 3400              		.loc 1 695 21 is_stmt 0 view .LVU1245
 3401 04ba 99F80830 		ldrb	r3, [r9, #8]	@ zero_extendqisi2
 698:lwIP/src/core/tcp_in.c **** 
 3402              		.loc 1 698 5 view .LVU1246
ARM GAS  /tmp/ccFjUByx.s 			page 135


 3403 04be CAF80C20 		str	r2, [r10, #12]
 695:lwIP/src/core/tcp_in.c ****     /* Register the new PCB so that we can begin receiving segments
 3404              		.loc 1 695 21 view .LVU1247
 3405 04c2 8AF80830 		strb	r3, [r10, #8]
 698:lwIP/src/core/tcp_in.c **** 
 3406              		.loc 1 698 5 is_stmt 1 view .LVU1248
 698:lwIP/src/core/tcp_in.c **** 
 3407              		.loc 1 698 5 view .LVU1249
 698:lwIP/src/core/tcp_in.c **** 
 3408              		.loc 1 698 5 view .LVU1250
 698:lwIP/src/core/tcp_in.c **** 
 3409              		.loc 1 698 5 view .LVU1251
 698:lwIP/src/core/tcp_in.c **** 
 3410              		.loc 1 698 5 view .LVU1252
 3411 04c6 FFF7FEFF 		bl	tcp_timer_needed
 3412              	.LVL204:
 698:lwIP/src/core/tcp_in.c **** 
 3413              		.loc 1 698 5 view .LVU1253
 698:lwIP/src/core/tcp_in.c **** 
 3414              		.loc 1 698 5 view .LVU1254
 3415 04ca 0122     		movs	r2, #1
 3416 04cc 604B     		ldr	r3, .L496+24
 701:lwIP/src/core/tcp_in.c ****     npcb->snd_wnd = tcphdr->wnd;
 3417              		.loc 1 701 5 is_stmt 0 view .LVU1255
 3418 04ce 5046     		mov	r0, r10
 698:lwIP/src/core/tcp_in.c **** 
 3419              		.loc 1 698 5 view .LVU1256
 3420 04d0 1A70     		strb	r2, [r3]
 698:lwIP/src/core/tcp_in.c **** 
 3421              		.loc 1 698 5 is_stmt 1 view .LVU1257
 701:lwIP/src/core/tcp_in.c ****     npcb->snd_wnd = tcphdr->wnd;
 3422              		.loc 1 701 5 view .LVU1258
 3423 04d2 FFF7FEFF 		bl	tcp_parseopt
 3424              	.LVL205:
 702:lwIP/src/core/tcp_in.c ****     npcb->snd_wnd_max = npcb->snd_wnd;
 3425              		.loc 1 702 5 view .LVU1259
 702:lwIP/src/core/tcp_in.c ****     npcb->snd_wnd_max = npcb->snd_wnd;
 3426              		.loc 1 702 27 is_stmt 0 view .LVU1260
 3427 04d6 D8F80010 		ldr	r1, [r8]
 702:lwIP/src/core/tcp_in.c ****     npcb->snd_wnd_max = npcb->snd_wnd;
 3428              		.loc 1 702 19 view .LVU1261
 3429 04da 2346     		mov	r3, r4
 706:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 3430              		.loc 1 706 17 view .LVU1262
 3431 04dc 0596     		str	r6, [sp, #20]
 3432 04de 3046     		mov	r0, r6
 702:lwIP/src/core/tcp_in.c ****     npcb->snd_wnd_max = npcb->snd_wnd;
 3433              		.loc 1 702 27 view .LVU1263
 3434 04e0 C989     		ldrh	r1, [r1, #14]	@ unaligned
 703:lwIP/src/core/tcp_in.c **** 
 3435              		.loc 1 703 5 is_stmt 1 view .LVU1264
 706:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 3436              		.loc 1 706 17 is_stmt 0 view .LVU1265
 3437 04e2 BAF83260 		ldrh	r6, [r10, #50]
 702:lwIP/src/core/tcp_in.c ****     npcb->snd_wnd_max = npcb->snd_wnd;
 3438              		.loc 1 702 19 view .LVU1266
 3439 04e6 61F30F03 		bfi	r3, r1, #0, #16
ARM GAS  /tmp/ccFjUByx.s 			page 136


 3440 04ea 61F31F43 		bfi	r3, r1, #16, #16
 3441 04ee CAF86030 		str	r3, [r10, #96]
 706:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 3442              		.loc 1 706 5 is_stmt 1 view .LVU1267
 706:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 3443              		.loc 1 706 17 is_stmt 0 view .LVU1268
 3444 04f2 FFF7FEFF 		bl	ip4_route
 3445              	.LVL206:
 3446 04f6 059A     		ldr	r2, [sp, #20]
 3447 04f8 0146     		mov	r1, r0
 3448 04fa 3046     		mov	r0, r6
 3449 04fc FFF7FEFF 		bl	tcp_eff_send_mss_netif
 3450              	.LVL207:
 3451 0500 0346     		mov	r3, r0
 719:lwIP/src/core/tcp_in.c ****     if (rc != ERR_OK) {
 3452              		.loc 1 719 10 view .LVU1269
 3453 0502 1221     		movs	r1, #18
 3454 0504 5046     		mov	r0, r10
 706:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 3455              		.loc 1 706 15 view .LVU1270
 3456 0506 AAF83230 		strh	r3, [r10, #50]	@ movhi
 709:lwIP/src/core/tcp_in.c **** 
 3457              		.loc 1 709 41 is_stmt 1 view .LVU1271
 719:lwIP/src/core/tcp_in.c ****     if (rc != ERR_OK) {
 3458              		.loc 1 719 5 view .LVU1272
 719:lwIP/src/core/tcp_in.c ****     if (rc != ERR_OK) {
 3459              		.loc 1 719 10 is_stmt 0 view .LVU1273
 3460 050a FFF7FEFF 		bl	tcp_enqueue_flags
 3461              	.LVL208:
 720:lwIP/src/core/tcp_in.c ****       tcp_abandon(npcb, 0);
 3462              		.loc 1 720 5 is_stmt 1 view .LVU1274
 720:lwIP/src/core/tcp_in.c ****       tcp_abandon(npcb, 0);
 3463              		.loc 1 720 8 is_stmt 0 view .LVU1275
 3464 050e 0028     		cmp	r0, #0
 3465 0510 40F02781 		bne	.L482
 724:lwIP/src/core/tcp_in.c ****   }
 3466              		.loc 1 724 5 is_stmt 1 view .LVU1276
 3467 0514 5046     		mov	r0, r10
 3468              	.LVL209:
 724:lwIP/src/core/tcp_in.c ****   }
 3469              		.loc 1 724 5 is_stmt 0 view .LVU1277
 3470 0516 FFF7FEFF 		bl	tcp_output
 3471              	.LVL210:
 3472 051a 7FE5     		b	.L217
 3473              	.LVL211:
 3474              	.L251:
 724:lwIP/src/core/tcp_in.c ****   }
 3475              		.loc 1 724 5 view .LVU1278
 3476              	.LBE349:
 3477              	.LBE348:
 360:lwIP/src/core/tcp_in.c ****       /* Move this PCB to the front of the list so that subsequent
 3478              		.loc 1 360 5 is_stmt 1 view .LVU1279
 575:lwIP/src/core/tcp_in.c ****     if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 3479              		.loc 1 575 80 view .LVU1280
 576:lwIP/src/core/tcp_in.c ****       TCP_STATS_INC(tcp.proterr);
 3480              		.loc 1 576 5 view .LVU1281
 3481              		.loc 2 937 3 view .LVU1282
ARM GAS  /tmp/ccFjUByx.s 			page 137


 576:lwIP/src/core/tcp_in.c ****       TCP_STATS_INC(tcp.proterr);
 3482              		.loc 1 576 8 is_stmt 0 view .LVU1283
 3483 051c 1CF00400 		ands	r0, ip, #4
 3484 0520 7FF47CAD 		bne	.L217
 3485              	.L334:
 577:lwIP/src/core/tcp_in.c ****       TCP_STATS_INC(tcp.drop);
 3486              		.loc 1 577 33 is_stmt 1 view .LVU1284
 578:lwIP/src/core/tcp_in.c ****       tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 3487              		.loc 1 578 30 view .LVU1285
 579:lwIP/src/core/tcp_in.c ****               ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 3488              		.loc 1 579 7 view .LVU1286
 3489 0524 059B     		ldr	r3, [sp, #20]
 3490 0526 0292     		str	r2, [sp, #8]
 3491 0528 0AEB0B02 		add	r2, r10, fp
 3492 052c 0193     		str	r3, [sp, #4]
 3493 052e 494B     		ldr	r3, .L496+28
 3494 0530 0093     		str	r3, [sp]
 3495 0532 0433     		adds	r3, r3, #4
 3496 0534 FFF7FEFF 		bl	tcp_rst
 3497              	.LVL212:
 3498 0538 70E5     		b	.L217
 3499              	.LVL213:
 3500              	.L470:
 3501              	.LBB353:
 194:lwIP/src/core/tcp_in.c **** 
 3502              		.loc 1 194 5 discriminator 1 view .LVU1287
 3503 053a 4748     		ldr	r0, .L496+32
 3504              	.LVL214:
 194:lwIP/src/core/tcp_in.c **** 
 3505              		.loc 1 194 5 is_stmt 0 discriminator 1 view .LVU1288
 3506 053c FFF7FEFF 		bl	printf
 3507              	.LVL215:
 3508              	.L221:
 194:lwIP/src/core/tcp_in.c **** 
 3509              		.loc 1 194 5 is_stmt 1 discriminator 2 view .LVU1289
 194:lwIP/src/core/tcp_in.c **** 
 3510              		.loc 1 194 5 discriminator 2 view .LVU1290
 194:lwIP/src/core/tcp_in.c **** 
 3511              		.loc 1 194 5 discriminator 2 view .LVU1291
 194:lwIP/src/core/tcp_in.c **** 
 3512              		.loc 1 194 5 discriminator 2 view .LVU1292
 194:lwIP/src/core/tcp_in.c **** 
 3513              		.loc 1 194 5 discriminator 2 view .LVU1293
 194:lwIP/src/core/tcp_in.c **** 
 3514              		.loc 1 194 5 discriminator 2 view .LVU1294
 3515 0540 FEE7     		b	.L221
 3516              	.LVL216:
 3517              	.L247:
 194:lwIP/src/core/tcp_in.c **** 
 3518              		.loc 1 194 5 is_stmt 0 discriminator 2 view .LVU1295
 3519              	.LBE353:
 3520              	.LBB354:
 3521              	.LBB347:
 762:lwIP/src/core/tcp_in.c ****     /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
 3522              		.loc 1 762 10 is_stmt 1 view .LVU1296
 762:lwIP/src/core/tcp_in.c ****     /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
 3523              		.loc 1 762 13 is_stmt 0 view .LVU1297
ARM GAS  /tmp/ccFjUByx.s 			page 138


 3524 0542 1CF0010F 		tst	ip, #1
 3525 0546 3FF414AF 		beq	.L248
 765:lwIP/src/core/tcp_in.c ****   }
 3526              		.loc 1 765 5 is_stmt 1 view .LVU1298
 765:lwIP/src/core/tcp_in.c ****   }
 3527              		.loc 1 765 14 is_stmt 0 view .LVU1299
 3528 054a 444B     		ldr	r3, .L496+36
 3529 054c 1B68     		ldr	r3, [r3]
 3530 054e 0362     		str	r3, [r0, #32]
 3531 0550 0FE7     		b	.L248
 3532              	.LVL217:
 3533              	.L471:
 765:lwIP/src/core/tcp_in.c ****   }
 3534              		.loc 1 765 14 view .LVU1300
 3535              	.LBE347:
 3536              	.LBE354:
 3537              	.LBB355:
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 3538              		.loc 1 223 5 is_stmt 1 discriminator 1 view .LVU1301
 3539 0552 4348     		ldr	r0, .L496+40
 3540 0554 FFF7FEFF 		bl	printf
 3541              	.LVL218:
 3542              	.L223:
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 3543              		.loc 1 223 5 discriminator 3 view .LVU1302
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 3544              		.loc 1 223 5 discriminator 3 view .LVU1303
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 3545              		.loc 1 223 5 discriminator 3 view .LVU1304
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 3546              		.loc 1 223 5 discriminator 3 view .LVU1305
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 3547              		.loc 1 223 5 discriminator 3 view .LVU1306
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 3548              		.loc 1 223 5 discriminator 3 view .LVU1307
 3549 0558 FEE7     		b	.L223
 3550              	.LVL219:
 3551              	.L315:
 223:lwIP/src/core/tcp_in.c ****     LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 3552              		.loc 1 223 5 is_stmt 0 discriminator 3 view .LVU1308
 3553              	.LBE355:
 451:lwIP/src/core/tcp_in.c ****         /* If the application has registered a "sent" function to be
 3554              		.loc 1 451 9 is_stmt 1 view .LVU1309
 455:lwIP/src/core/tcp_in.c ****           u16_t acked16;
 3555              		.loc 1 455 9 view .LVU1310
 455:lwIP/src/core/tcp_in.c ****           u16_t acked16;
 3556              		.loc 1 455 24 is_stmt 0 view .LVU1311
 3557 055a 424B     		ldr	r3, .L496+44
 3558 055c 1A88     		ldrh	r2, [r3]
 455:lwIP/src/core/tcp_in.c ****           u16_t acked16;
 3559              		.loc 1 455 12 view .LVU1312
 3560 055e 52B1     		cbz	r2, .L317
 3561              	.LBB356:
 456:lwIP/src/core/tcp_in.c **** #if LWIP_WND_SCALE
 3562              		.loc 1 456 11 is_stmt 1 view .LVU1313
 466:lwIP/src/core/tcp_in.c **** #endif
 3563              		.loc 1 466 13 view .LVU1314
ARM GAS  /tmp/ccFjUByx.s 			page 139


 3564              	.LVL220:
 468:lwIP/src/core/tcp_in.c ****             if (err == ERR_ABRT) {
 3565              		.loc 1 468 13 view .LVU1315
 468:lwIP/src/core/tcp_in.c ****             if (err == ERR_ABRT) {
 3566              		.loc 1 468 13 view .LVU1316
 3567 0560 E36F     		ldr	r3, [r4, #124]
 3568 0562 2BB1     		cbz	r3, .L319
 468:lwIP/src/core/tcp_in.c ****             if (err == ERR_ABRT) {
 3569              		.loc 1 468 13 discriminator 1 view .LVU1317
 3570 0564 2146     		mov	r1, r4
 3571 0566 2069     		ldr	r0, [r4, #16]
 3572 0568 9847     		blx	r3
 3573              	.LVL221:
 468:lwIP/src/core/tcp_in.c ****             if (err == ERR_ABRT) {
 3574              		.loc 1 468 13 discriminator 1 view .LVU1318
 469:lwIP/src/core/tcp_in.c ****               goto aborted;
 3575              		.loc 1 469 13 discriminator 1 view .LVU1319
 469:lwIP/src/core/tcp_in.c ****               goto aborted;
 3576              		.loc 1 469 16 is_stmt 0 discriminator 1 view .LVU1320
 3577 056a 0D30     		adds	r0, r0, #13
 3578              	.LVL222:
 469:lwIP/src/core/tcp_in.c ****               goto aborted;
 3579              		.loc 1 469 16 discriminator 1 view .LVU1321
 3580 056c 3FF48FAE 		beq	.L262
 3581              	.L319:
 473:lwIP/src/core/tcp_in.c ****         }
 3582              		.loc 1 473 11 is_stmt 1 view .LVU1322
 473:lwIP/src/core/tcp_in.c ****         }
 3583              		.loc 1 473 22 is_stmt 0 view .LVU1323
 3584 0570 0023     		movs	r3, #0
 3585 0572 3C4A     		ldr	r2, .L496+44
 3586 0574 1380     		strh	r3, [r2]	@ movhi
 3587              	.L317:
 473:lwIP/src/core/tcp_in.c ****         }
 3588              		.loc 1 473 22 view .LVU1324
 3589              	.LBE356:
 475:lwIP/src/core/tcp_in.c ****           goto aborted;
 3590              		.loc 1 475 9 is_stmt 1 view .LVU1325
 475:lwIP/src/core/tcp_in.c ****           goto aborted;
 3591              		.loc 1 475 13 is_stmt 0 view .LVU1326
 3592 0576 2046     		mov	r0, r4
 3593 0578 FFF7FEFF 		bl	tcp_input_delayed_close
 3594              	.LVL223:
 475:lwIP/src/core/tcp_in.c ****           goto aborted;
 3595              		.loc 1 475 12 view .LVU1327
 3596 057c 0028     		cmp	r0, #0
 3597 057e 7FF486AE 		bne	.L262
 483:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
 3598              		.loc 1 483 9 is_stmt 1 view .LVU1328
 483:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
 3599              		.loc 1 483 23 is_stmt 0 view .LVU1329
 3600 0582 DBF80020 		ldr	r2, [fp]
 483:lwIP/src/core/tcp_in.c **** #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
 3601              		.loc 1 483 12 view .LVU1330
 3602 0586 D2B1     		cbz	r2, .L321
 486:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_RXCLOSED) {
 3603              		.loc 1 486 11 is_stmt 1 view .LVU1331
ARM GAS  /tmp/ccFjUByx.s 			page 140


 486:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_RXCLOSED) {
 3604              		.loc 1 486 11 view .LVU1332
 3605 0588 636F     		ldr	r3, [r4, #116]
 3606 058a 1BB1     		cbz	r3, .L322
 486:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_RXCLOSED) {
 3607              		.loc 1 486 11 discriminator 1 view .LVU1333
 3608 058c 3648     		ldr	r0, .L496+48
 3609 058e FFF7FEFF 		bl	printf
 3610              	.LVL224:
 3611              	.L323:
 486:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_RXCLOSED) {
 3612              		.loc 1 486 11 discriminator 11 view .LVU1334
 486:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_RXCLOSED) {
 3613              		.loc 1 486 11 discriminator 11 view .LVU1335
 486:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_RXCLOSED) {
 3614              		.loc 1 486 11 discriminator 11 view .LVU1336
 486:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_RXCLOSED) {
 3615              		.loc 1 486 11 discriminator 11 view .LVU1337
 486:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_RXCLOSED) {
 3616              		.loc 1 486 11 discriminator 11 view .LVU1338
 486:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_RXCLOSED) {
 3617              		.loc 1 486 11 discriminator 11 view .LVU1339
 3618 0592 FEE7     		b	.L323
 3619              	.L322:
 486:lwIP/src/core/tcp_in.c ****           if (pcb->flags & TF_RXCLOSED) {
 3620              		.loc 1 486 11 discriminator 2 view .LVU1340
 487:lwIP/src/core/tcp_in.c ****             /* received data although already closed -> abort (send RST) to
 3621              		.loc 1 487 11 discriminator 2 view .LVU1341
 487:lwIP/src/core/tcp_in.c ****             /* received data although already closed -> abort (send RST) to
 3622              		.loc 1 487 14 is_stmt 0 discriminator 2 view .LVU1342
 3623 0594 638B     		ldrh	r3, [r4, #26]
 3624 0596 13F01003 		ands	r3, r3, #16
 3625 059a 40F0DE81 		bne	.L483
 501:lwIP/src/core/tcp_in.c ****           if (err == ERR_ABRT) {
 3626              		.loc 1 501 11 is_stmt 1 view .LVU1343
 501:lwIP/src/core/tcp_in.c ****           if (err == ERR_ABRT) {
 3627              		.loc 1 501 11 view .LVU1344
 3628 059e D4F88070 		ldr	r7, [r4, #128]
 3629 05a2 002F     		cmp	r7, #0
 3630 05a4 00F0D481 		beq	.L325
 501:lwIP/src/core/tcp_in.c ****           if (err == ERR_ABRT) {
 3631              		.loc 1 501 11 discriminator 1 view .LVU1345
 3632 05a8 2146     		mov	r1, r4
 3633 05aa 2069     		ldr	r0, [r4, #16]
 3634 05ac B847     		blx	r7
 3635              	.LVL225:
 3636              	.L326:
 501:lwIP/src/core/tcp_in.c ****           if (err == ERR_ABRT) {
 3637              		.loc 1 501 11 discriminator 4 view .LVU1346
 502:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
 3638              		.loc 1 502 11 discriminator 4 view .LVU1347
 502:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
 3639              		.loc 1 502 14 is_stmt 0 discriminator 4 view .LVU1348
 3640 05ae 10F10D0F 		cmn	r0, #13
 3641 05b2 3FF46CAE 		beq	.L262
 512:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
 3642              		.loc 1 512 11 is_stmt 1 view .LVU1349
ARM GAS  /tmp/ccFjUByx.s 			page 141


 512:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
 3643              		.loc 1 512 14 is_stmt 0 view .LVU1350
 3644 05b6 10B1     		cbz	r0, .L321
 518:lwIP/src/core/tcp_in.c ****             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"
 3645              		.loc 1 518 13 is_stmt 1 view .LVU1351
 518:lwIP/src/core/tcp_in.c ****             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"
 3646              		.loc 1 518 31 is_stmt 0 view .LVU1352
 3647 05b8 DBF80030 		ldr	r3, [fp]
 3648 05bc 6367     		str	r3, [r4, #116]
 3649              	.LVL226:
 3650              	.L321:
 519:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
 3651              		.loc 1 519 105 is_stmt 1 view .LVU1353
 531:lwIP/src/core/tcp_in.c ****           if (pcb->refused_data != NULL) {
 3652              		.loc 1 531 9 view .LVU1354
 531:lwIP/src/core/tcp_in.c ****           if (pcb->refused_data != NULL) {
 3653              		.loc 1 531 12 is_stmt 0 view .LVU1355
 3654 05be 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3655 05c0 9B06     		lsls	r3, r3, #26
 3656 05c2 05D5     		bpl	.L329
 532:lwIP/src/core/tcp_in.c ****             /* Delay this if we have refused data. */
 3657              		.loc 1 532 11 is_stmt 1 view .LVU1356
 532:lwIP/src/core/tcp_in.c ****             /* Delay this if we have refused data. */
 3658              		.loc 1 532 18 is_stmt 0 view .LVU1357
 3659 05c4 636F     		ldr	r3, [r4, #116]
 532:lwIP/src/core/tcp_in.c ****             /* Delay this if we have refused data. */
 3660              		.loc 1 532 14 view .LVU1358
 3661 05c6 1BB3     		cbz	r3, .L330
 534:lwIP/src/core/tcp_in.c ****           } else {
 3662              		.loc 1 534 13 is_stmt 1 view .LVU1359
 534:lwIP/src/core/tcp_in.c ****           } else {
 3663              		.loc 1 534 38 is_stmt 0 view .LVU1360
 3664 05c8 5A7B     		ldrb	r2, [r3, #13]	@ zero_extendqisi2
 3665 05ca 42F02002 		orr	r2, r2, #32
 3666 05ce 5A73     		strb	r2, [r3, #13]
 3667              	.L329:
 548:lwIP/src/core/tcp_in.c ****         if (tcp_input_delayed_close(pcb)) {
 3668              		.loc 1 548 9 is_stmt 1 view .LVU1361
 548:lwIP/src/core/tcp_in.c ****         if (tcp_input_delayed_close(pcb)) {
 3669              		.loc 1 548 23 is_stmt 0 view .LVU1362
 3670 05d0 0023     		movs	r3, #0
 549:lwIP/src/core/tcp_in.c ****           goto aborted;
 3671              		.loc 1 549 13 view .LVU1363
 3672 05d2 2046     		mov	r0, r4
 548:lwIP/src/core/tcp_in.c ****         if (tcp_input_delayed_close(pcb)) {
 3673              		.loc 1 548 23 view .LVU1364
 3674 05d4 2B60     		str	r3, [r5]
 549:lwIP/src/core/tcp_in.c ****           goto aborted;
 3675              		.loc 1 549 9 is_stmt 1 view .LVU1365
 549:lwIP/src/core/tcp_in.c ****           goto aborted;
 3676              		.loc 1 549 13 is_stmt 0 view .LVU1366
 3677 05d6 FFF7FEFF 		bl	tcp_input_delayed_close
 3678              	.LVL227:
 549:lwIP/src/core/tcp_in.c ****           goto aborted;
 3679              		.loc 1 549 12 view .LVU1367
 3680 05da 0028     		cmp	r0, #0
 3681 05dc 7FF457AE 		bne	.L262
ARM GAS  /tmp/ccFjUByx.s 			page 142


 553:lwIP/src/core/tcp_in.c **** #if TCP_INPUT_DEBUG
 3682              		.loc 1 553 9 is_stmt 1 view .LVU1368
 3683 05e0 2046     		mov	r0, r4
 3684 05e2 FFF7FEFF 		bl	tcp_output
 3685              	.LVL228:
 3686 05e6 52E6     		b	.L262
 3687              	.LVL229:
 3688              	.L267:
 3689              	.LBB357:
 3690              	.LBB330:
 823:lwIP/src/core/tcp_in.c ****       LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 3691              		.loc 1 823 72 view .LVU1369
 824:lwIP/src/core/tcp_in.c ****       recv_flags |= TF_RESET;
 3692              		.loc 1 824 7 view .LVU1370
 824:lwIP/src/core/tcp_in.c ****       recv_flags |= TF_RESET;
 3693              		.loc 1 824 7 view .LVU1371
 3694 05e8 49B9     		cbnz	r1, .L265
 824:lwIP/src/core/tcp_in.c ****       recv_flags |= TF_RESET;
 3695              		.loc 1 824 7 view .LVU1372
 3696 05ea 2048     		ldr	r0, .L496+52
 3697 05ec FFF7FEFF 		bl	printf
 3698              	.LVL230:
 3699              	.L269:
 824:lwIP/src/core/tcp_in.c ****       recv_flags |= TF_RESET;
 3700              		.loc 1 824 7 view .LVU1373
 824:lwIP/src/core/tcp_in.c ****       recv_flags |= TF_RESET;
 3701              		.loc 1 824 7 view .LVU1374
 824:lwIP/src/core/tcp_in.c ****       recv_flags |= TF_RESET;
 3702              		.loc 1 824 7 view .LVU1375
 824:lwIP/src/core/tcp_in.c ****       recv_flags |= TF_RESET;
 3703              		.loc 1 824 7 view .LVU1376
 824:lwIP/src/core/tcp_in.c ****       recv_flags |= TF_RESET;
 3704              		.loc 1 824 7 view .LVU1377
 824:lwIP/src/core/tcp_in.c ****       recv_flags |= TF_RESET;
 3705              		.loc 1 824 7 view .LVU1378
 3706 05f0 FEE7     		b	.L269
 3707              	.LVL231:
 3708              	.L478:
 804:lwIP/src/core/tcp_in.c ****         acceptable = 1;
 3709              		.loc 1 804 7 view .LVU1379
 804:lwIP/src/core/tcp_in.c ****         acceptable = 1;
 3710              		.loc 1 804 10 is_stmt 0 view .LVU1380
 3711 05f2 D9F80030 		ldr	r3, [r9]
 3712 05f6 226D     		ldr	r2, [r4, #80]
 3713 05f8 9A42     		cmp	r2, r3
 3714 05fa 7FF436AE 		bne	.L266
 3715              	.LVL232:
 3716              	.L265:
 824:lwIP/src/core/tcp_in.c ****       recv_flags |= TF_RESET;
 3717              		.loc 1 824 7 is_stmt 1 view .LVU1381
 825:lwIP/src/core/tcp_in.c ****       tcp_clear_flags(pcb, TF_ACK_DELAY);
 3718              		.loc 1 825 7 view .LVU1382
 825:lwIP/src/core/tcp_in.c ****       tcp_clear_flags(pcb, TF_ACK_DELAY);
 3719              		.loc 1 825 18 is_stmt 0 view .LVU1383
 3720 05fe 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 826:lwIP/src/core/tcp_in.c ****       return ERR_RST;
 3721              		.loc 1 826 7 view .LVU1384
ARM GAS  /tmp/ccFjUByx.s 			page 143


 3722 0600 638B     		ldrh	r3, [r4, #26]
 825:lwIP/src/core/tcp_in.c ****       tcp_clear_flags(pcb, TF_ACK_DELAY);
 3723              		.loc 1 825 18 view .LVU1385
 3724 0602 42F00802 		orr	r2, r2, #8
 826:lwIP/src/core/tcp_in.c ****       return ERR_RST;
 3725              		.loc 1 826 7 view .LVU1386
 3726 0606 23F00103 		bic	r3, r3, #1
 825:lwIP/src/core/tcp_in.c ****       tcp_clear_flags(pcb, TF_ACK_DELAY);
 3727              		.loc 1 825 18 view .LVU1387
 3728 060a 3270     		strb	r2, [r6]
 826:lwIP/src/core/tcp_in.c ****       return ERR_RST;
 3729              		.loc 1 826 7 is_stmt 1 view .LVU1388
 826:lwIP/src/core/tcp_in.c ****       return ERR_RST;
 3730              		.loc 1 826 7 view .LVU1389
 3731 060c 6383     		strh	r3, [r4, #26]	@ movhi
 826:lwIP/src/core/tcp_in.c ****       return ERR_RST;
 3732              		.loc 1 826 7 view .LVU1390
 827:lwIP/src/core/tcp_in.c ****     } else {
 3733              		.loc 1 827 7 view .LVU1391
 3734              	.LVL233:
 827:lwIP/src/core/tcp_in.c ****     } else {
 3735              		.loc 1 827 7 is_stmt 0 view .LVU1392
 3736              	.LBE330:
 3737              	.LBE357:
 441:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 3738              		.loc 1 441 5 is_stmt 1 view .LVU1393
 3739 060e 2CE6     		b	.L266
 3740              	.LVL234:
 3741              	.L330:
 538:lwIP/src/core/tcp_in.c ****               pcb->rcv_wnd++;
 3742              		.loc 1 538 13 view .LVU1394
 538:lwIP/src/core/tcp_in.c ****               pcb->rcv_wnd++;
 3743              		.loc 1 538 20 is_stmt 0 view .LVU1395
 3744 0610 238D     		ldrh	r3, [r4, #40]
 538:lwIP/src/core/tcp_in.c ****               pcb->rcv_wnd++;
 3745              		.loc 1 538 16 view .LVU1396
 3746 0612 40F66832 		movw	r2, #2920
 3747 0616 9342     		cmp	r3, r2
 3748 0618 01D0     		beq	.L331
 539:lwIP/src/core/tcp_in.c ****             }
 3749              		.loc 1 539 15 is_stmt 1 view .LVU1397
 539:lwIP/src/core/tcp_in.c ****             }
 3750              		.loc 1 539 27 is_stmt 0 view .LVU1398
 3751 061a 0133     		adds	r3, r3, #1
 3752 061c 2385     		strh	r3, [r4, #40]	@ movhi
 3753              	.L331:
 541:lwIP/src/core/tcp_in.c ****             if (err == ERR_ABRT) {
 3754              		.loc 1 541 13 is_stmt 1 view .LVU1399
 541:lwIP/src/core/tcp_in.c ****             if (err == ERR_ABRT) {
 3755              		.loc 1 541 13 view .LVU1400
 3756 061e D4F88060 		ldr	r6, [r4, #128]
 3757 0622 002E     		cmp	r6, #0
 3758 0624 D4D0     		beq	.L329
 541:lwIP/src/core/tcp_in.c ****             if (err == ERR_ABRT) {
 3759              		.loc 1 541 13 discriminator 1 view .LVU1401
 3760 0626 0023     		movs	r3, #0
 3761 0628 2146     		mov	r1, r4
ARM GAS  /tmp/ccFjUByx.s 			page 144


 3762 062a 2069     		ldr	r0, [r4, #16]
 3763 062c 1A46     		mov	r2, r3
 3764 062e B047     		blx	r6
 3765              	.LVL235:
 541:lwIP/src/core/tcp_in.c ****             if (err == ERR_ABRT) {
 3766              		.loc 1 541 13 discriminator 1 view .LVU1402
 542:lwIP/src/core/tcp_in.c ****               goto aborted;
 3767              		.loc 1 542 13 discriminator 1 view .LVU1403
 542:lwIP/src/core/tcp_in.c ****               goto aborted;
 3768              		.loc 1 542 16 is_stmt 0 discriminator 1 view .LVU1404
 3769 0630 0D30     		adds	r0, r0, #13
 3770              	.LVL236:
 542:lwIP/src/core/tcp_in.c ****               goto aborted;
 3771              		.loc 1 542 16 discriminator 1 view .LVU1405
 3772 0632 CDD1     		bne	.L329
 3773 0634 2BE6     		b	.L262
 3774              	.L497:
 3775 0636 00BF     		.align	2
 3776              	.L496:
 3777 0638 28010000 		.word	.LC18
 3778 063c 00000000 		.word	.LANCHOR10
 3779 0640 7C000000 		.word	.LC14
 3780 0644 54000000 		.word	.LC13
 3781 0648 00000000 		.word	tcp_listen_pcbs
 3782 064c 00000000 		.word	.LANCHOR8
 3783 0650 00000000 		.word	tcp_active_pcbs_changed
 3784 0654 10000000 		.word	ip_data+16
 3785 0658 18000000 		.word	.LC10
 3786 065c 00000000 		.word	tcp_ticks
 3787 0660 28000000 		.word	.LC11
 3788 0664 00000000 		.word	.LANCHOR6
 3789 0668 E0010000 		.word	.LC24
 3790 066c 58010000 		.word	.LC19
 3791              	.LVL237:
 3792              	.L263:
 3793              	.LBB358:
 3794              	.LBB331:
 837:lwIP/src/core/tcp_in.c ****     /* Cope with new connection attempt after remote end crashed */
 3795              		.loc 1 837 3 is_stmt 1 view .LVU1406
 837:lwIP/src/core/tcp_in.c ****     /* Cope with new connection attempt after remote end crashed */
 3796              		.loc 1 837 6 is_stmt 0 view .LVU1407
 3797 0670 8B07     		lsls	r3, r1, #30
 3798 0672 608B     		ldrh	r0, [r4, #26]
 3799 0674 03D5     		bpl	.L270
 837:lwIP/src/core/tcp_in.c ****     /* Cope with new connection attempt after remote end crashed */
 3800              		.loc 1 837 52 view .LVU1408
 3801 0676 217D     		ldrb	r1, [r4, #20]	@ zero_extendqisi2
 837:lwIP/src/core/tcp_in.c ****     /* Cope with new connection attempt after remote end crashed */
 3802              		.loc 1 837 25 view .LVU1409
 3803 0678 0239     		subs	r1, r1, #2
 3804 067a 0129     		cmp	r1, #1
 3805 067c 19D8     		bhi	.L484
 3806              	.L270:
 843:lwIP/src/core/tcp_in.c ****     /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
 3807              		.loc 1 843 3 is_stmt 1 view .LVU1410
 843:lwIP/src/core/tcp_in.c ****     /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
 3808              		.loc 1 843 6 is_stmt 0 view .LVU1411
ARM GAS  /tmp/ccFjUByx.s 			page 145


 3809 067e C006     		lsls	r0, r0, #27
 3810 0680 02D4     		bmi	.L271
 845:lwIP/src/core/tcp_in.c ****   }
 3811              		.loc 1 845 5 is_stmt 1 view .LVU1412
 845:lwIP/src/core/tcp_in.c ****   }
 3812              		.loc 1 845 14 is_stmt 0 view .LVU1413
 3813 0682 B949     		ldr	r1, .L498
 3814 0684 0968     		ldr	r1, [r1]
 3815 0686 2162     		str	r1, [r4, #32]
 3816              	.L271:
 847:lwIP/src/core/tcp_in.c ****   pcb->persist_probe = 0;
 3817              		.loc 1 847 3 is_stmt 1 view .LVU1414
 848:lwIP/src/core/tcp_in.c **** 
 3818              		.loc 1 848 3 view .LVU1415
 848:lwIP/src/core/tcp_in.c **** 
 3819              		.loc 1 848 22 is_stmt 0 view .LVU1416
 3820 0688 0021     		movs	r1, #0
 850:lwIP/src/core/tcp_in.c **** 
 3821              		.loc 1 850 3 view .LVU1417
 3822 068a 2046     		mov	r0, r4
 848:lwIP/src/core/tcp_in.c **** 
 3823              		.loc 1 848 22 view .LVU1418
 3824 068c A4F89610 		strh	r1, [r4, #150]	@ movhi
 850:lwIP/src/core/tcp_in.c **** 
 3825              		.loc 1 850 3 is_stmt 1 view .LVU1419
 3826 0690 FFF7FEFF 		bl	tcp_parseopt
 3827              	.LVL238:
 853:lwIP/src/core/tcp_in.c ****     case SYN_SENT:
 3828              		.loc 1 853 3 view .LVU1420
 3829 0694 217D     		ldrb	r1, [r4, #20]	@ zero_extendqisi2
 3830 0696 0239     		subs	r1, r1, #2
 3831 0698 0729     		cmp	r1, #7
 3832 069a 3FF6E6AD 		bhi	.L266
 3833 069e DFE811F0 		tbh	[pc, r1, lsl #1]
 3834              	.L337:
 3835 06a2 7501     		.2byte	(.L272-.L337)/2
 3836 06a4 6500     		.2byte	(.L286-.L337)/2
 3837 06a6 F601     		.2byte	(.L299-.L337)/2
 3838 06a8 2F01     		.2byte	(.L300-.L337)/2
 3839 06aa 4500     		.2byte	(.L306-.L337)/2
 3840 06ac F601     		.2byte	(.L299-.L337)/2
 3841 06ae 2300     		.2byte	(.L310-.L337)/2
 3842 06b0 0C00     		.2byte	(.L314-.L337)/2
 3843              		.p2align 1
 3844              	.L484:
 839:lwIP/src/core/tcp_in.c ****     return ERR_OK;
 3845              		.loc 1 839 5 view .LVU1421
 839:lwIP/src/core/tcp_in.c ****     return ERR_OK;
 3846              		.loc 1 839 5 view .LVU1422
 3847 06b2 40F00200 		orr	r0, r0, #2
 3848 06b6 6083     		strh	r0, [r4, #26]	@ movhi
 839:lwIP/src/core/tcp_in.c ****     return ERR_OK;
 3849              		.loc 1 839 5 view .LVU1423
 840:lwIP/src/core/tcp_in.c ****   }
 3850              		.loc 1 840 5 view .LVU1424
 3851              	.LVL239:
 840:lwIP/src/core/tcp_in.c ****   }
ARM GAS  /tmp/ccFjUByx.s 			page 146


 3852              		.loc 1 840 5 is_stmt 0 view .LVU1425
 3853              	.LBE331:
 3854              	.LBE358:
 441:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 3855              		.loc 1 441 5 is_stmt 1 view .LVU1426
 3856 06b8 D7E5     		b	.L266
 3857              	.LVL240:
 3858              	.L314:
 3859              	.LBB359:
 3860              	.LBB332:
1031:lwIP/src/core/tcp_in.c ****       if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 3861              		.loc 1 1031 7 view .LVU1427
 3862              	.LBB310:
 3863              	.LBI310:
1141:lwIP/src/core/tcp_in.c **** {
 3864              		.loc 1 1141 1 view .LVU1428
 3865              	.LBB311:
1143:lwIP/src/core/tcp_in.c ****   u32_t right_wnd_edge;
 3866              		.loc 1 1143 3 view .LVU1429
1144:lwIP/src/core/tcp_in.c ****   int found_dupack = 0;
 3867              		.loc 1 1144 3 view .LVU1430
1145:lwIP/src/core/tcp_in.c **** 
 3868              		.loc 1 1145 3 view .LVU1431
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 3869              		.loc 1 1147 3 view .LVU1432
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 3870              		.loc 1 1147 3 view .LVU1433
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 3871              		.loc 1 1147 3 view .LVU1434
1148:lwIP/src/core/tcp_in.c **** 
 3872              		.loc 1 1148 3 view .LVU1435
1148:lwIP/src/core/tcp_in.c **** 
 3873              		.loc 1 1148 3 view .LVU1436
 3874 06ba 2046     		mov	r0, r4
 3875 06bc FFF7FEFF 		bl	tcp_receive.part.0
 3876              	.LVL241:
1882:lwIP/src/core/tcp_in.c ****     }
 3877              		.loc 1 1882 7 view .LVU1437
1882:lwIP/src/core/tcp_in.c ****     }
 3878              		.loc 1 1882 7 is_stmt 0 view .LVU1438
 3879              	.LBE311:
 3880              	.LBE310:
1032:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tc
 3881              		.loc 1 1032 7 is_stmt 1 view .LVU1439
1032:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tc
 3882              		.loc 1 1032 10 is_stmt 0 view .LVU1440
 3883 06c0 AA4B     		ldr	r3, .L498+4
 3884 06c2 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3885 06c4 D106     		lsls	r1, r2, #27
 3886 06c6 7FF5D0AD 		bpl	.L266
1032:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tc
 3887              		.loc 1 1032 29 view .LVU1441
 3888 06ca D9F80030 		ldr	r3, [r9]
 3889 06ce 226D     		ldr	r2, [r4, #80]
 3890 06d0 9A42     		cmp	r2, r3
 3891 06d2 7FF4CAAD 		bne	.L266
1032:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tc
ARM GAS  /tmp/ccFjUByx.s 			page 147


 3892              		.loc 1 1032 54 view .LVU1442
 3893 06d6 E36E     		ldr	r3, [r4, #108]
 3894 06d8 002B     		cmp	r3, #0
 3895 06da 7FF4C6AD 		bne	.L266
1033:lwIP/src/core/tcp_in.c ****         /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
 3896              		.loc 1 1033 131 is_stmt 1 view .LVU1443
1035:lwIP/src/core/tcp_in.c ****       }
 3897              		.loc 1 1035 9 view .LVU1444
1035:lwIP/src/core/tcp_in.c ****       }
 3898              		.loc 1 1035 20 is_stmt 0 view .LVU1445
 3899 06de 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3900 06e0 43F01003 		orr	r3, r3, #16
 3901 06e4 3370     		strb	r3, [r6]
 3902              	.LVL242:
1035:lwIP/src/core/tcp_in.c ****       }
 3903              		.loc 1 1035 20 view .LVU1446
 3904              	.LBE332:
 3905              	.LBE359:
 441:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 3906              		.loc 1 441 5 is_stmt 1 view .LVU1447
 3907 06e6 C0E5     		b	.L266
 3908              	.LVL243:
 3909              	.L310:
 3910              	.LBB360:
 3911              	.LBB333:
1021:lwIP/src/core/tcp_in.c ****       if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 3912              		.loc 1 1021 7 view .LVU1448
 3913              	.LBB312:
 3914              	.LBI312:
1141:lwIP/src/core/tcp_in.c **** {
 3915              		.loc 1 1141 1 view .LVU1449
 3916              	.LBB313:
1143:lwIP/src/core/tcp_in.c ****   u32_t right_wnd_edge;
 3917              		.loc 1 1143 3 view .LVU1450
1144:lwIP/src/core/tcp_in.c ****   int found_dupack = 0;
 3918              		.loc 1 1144 3 view .LVU1451
1145:lwIP/src/core/tcp_in.c **** 
 3919              		.loc 1 1145 3 view .LVU1452
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 3920              		.loc 1 1147 3 view .LVU1453
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 3921              		.loc 1 1147 3 view .LVU1454
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 3922              		.loc 1 1147 3 view .LVU1455
1148:lwIP/src/core/tcp_in.c **** 
 3923              		.loc 1 1148 3 view .LVU1456
1148:lwIP/src/core/tcp_in.c **** 
 3924              		.loc 1 1148 3 view .LVU1457
 3925 06e8 2046     		mov	r0, r4
 3926 06ea FFF7FEFF 		bl	tcp_receive.part.0
 3927              	.LVL244:
1882:lwIP/src/core/tcp_in.c ****     }
 3928              		.loc 1 1882 7 view .LVU1458
1882:lwIP/src/core/tcp_in.c ****     }
 3929              		.loc 1 1882 7 is_stmt 0 view .LVU1459
 3930              	.LBE313:
 3931              	.LBE312:
ARM GAS  /tmp/ccFjUByx.s 			page 148


1022:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcp
 3932              		.loc 1 1022 7 is_stmt 1 view .LVU1460
1022:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcp
 3933              		.loc 1 1022 10 is_stmt 0 view .LVU1461
 3934 06ee 9F4B     		ldr	r3, .L498+4
 3935 06f0 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 3936 06f2 D006     		lsls	r0, r2, #27
 3937 06f4 7FF5B9AD 		bpl	.L266
1022:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcp
 3938              		.loc 1 1022 29 view .LVU1462
 3939 06f8 D9F80030 		ldr	r3, [r9]
 3940 06fc 226D     		ldr	r2, [r4, #80]
 3941 06fe 9A42     		cmp	r2, r3
 3942 0700 7FF4B3AD 		bne	.L266
1022:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcp
 3943              		.loc 1 1022 54 view .LVU1463
 3944 0704 E36E     		ldr	r3, [r4, #108]
 3945 0706 002B     		cmp	r3, #0
 3946 0708 7FF4AFAD 		bne	.L266
1023:lwIP/src/core/tcp_in.c ****         tcp_pcb_purge(pcb);
 3947              		.loc 1 1023 130 is_stmt 1 view .LVU1464
1024:lwIP/src/core/tcp_in.c ****         TCP_RMV_ACTIVE(pcb);
 3948              		.loc 1 1024 9 view .LVU1465
 3949 070c 2046     		mov	r0, r4
 3950 070e FFF7FEFF 		bl	tcp_pcb_purge
 3951              	.LVL245:
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 3952              		.loc 1 1025 9 view .LVU1466
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 3953              		.loc 1 1025 9 view .LVU1467
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 3954              		.loc 1 1025 9 view .LVU1468
 3955 0712 3B68     		ldr	r3, [r7]
 3956 0714 9C42     		cmp	r4, r3
 3957 0716 00F0A781 		beq	.L465
 3958              	.L311:
 3959              	.LBB314:
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 3960              		.loc 1 1025 9 view .LVU1469
 3961              	.LVL246:
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 3962              		.loc 1 1025 9 view .LVU1470
 3963 071a 002B     		cmp	r3, #0
 3964 071c 00F0E480 		beq	.L312
 3965 0720 DA68     		ldr	r2, [r3, #12]
 3966 0722 9442     		cmp	r4, r2
 3967 0724 00F0DE80 		beq	.L466
 3968 0728 1346     		mov	r3, r2
 3969              	.LVL247:
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 3970              		.loc 1 1025 9 is_stmt 0 view .LVU1471
 3971 072a F6E7     		b	.L311
 3972              	.LVL248:
 3973              	.L306:
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 3974              		.loc 1 1025 9 view .LVU1472
 3975              	.LBE314:
ARM GAS  /tmp/ccFjUByx.s 			page 149


1010:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_GOT_FIN) {
 3976              		.loc 1 1010 7 is_stmt 1 view .LVU1473
 3977              	.LBB315:
 3978              	.LBI315:
1141:lwIP/src/core/tcp_in.c **** {
 3979              		.loc 1 1141 1 view .LVU1474
 3980              	.LBB316:
1143:lwIP/src/core/tcp_in.c ****   u32_t right_wnd_edge;
 3981              		.loc 1 1143 3 view .LVU1475
1144:lwIP/src/core/tcp_in.c ****   int found_dupack = 0;
 3982              		.loc 1 1144 3 view .LVU1476
1145:lwIP/src/core/tcp_in.c **** 
 3983              		.loc 1 1145 3 view .LVU1477
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 3984              		.loc 1 1147 3 view .LVU1478
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 3985              		.loc 1 1147 3 view .LVU1479
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 3986              		.loc 1 1147 3 view .LVU1480
1148:lwIP/src/core/tcp_in.c **** 
 3987              		.loc 1 1148 3 view .LVU1481
1148:lwIP/src/core/tcp_in.c **** 
 3988              		.loc 1 1148 3 view .LVU1482
 3989 072c 2046     		mov	r0, r4
 3990 072e FFF7FEFF 		bl	tcp_receive.part.0
 3991              	.LVL249:
1882:lwIP/src/core/tcp_in.c ****     }
 3992              		.loc 1 1882 7 view .LVU1483
1882:lwIP/src/core/tcp_in.c ****     }
 3993              		.loc 1 1882 7 is_stmt 0 view .LVU1484
 3994              	.LBE316:
 3995              	.LBE315:
1011:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.
 3996              		.loc 1 1011 7 is_stmt 1 view .LVU1485
1011:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.
 3997              		.loc 1 1011 10 is_stmt 0 view .LVU1486
 3998 0732 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3999 0734 9B06     		lsls	r3, r3, #26
 4000 0736 7FF598AD 		bpl	.L266
1012:lwIP/src/core/tcp_in.c ****         tcp_ack_now(pcb);
 4001              		.loc 1 1012 133 is_stmt 1 view .LVU1487
1013:lwIP/src/core/tcp_in.c ****         tcp_pcb_purge(pcb);
 4002              		.loc 1 1013 9 view .LVU1488
1013:lwIP/src/core/tcp_in.c ****         tcp_pcb_purge(pcb);
 4003              		.loc 1 1013 9 view .LVU1489
 4004 073a 638B     		ldrh	r3, [r4, #26]
1014:lwIP/src/core/tcp_in.c ****         TCP_RMV_ACTIVE(pcb);
 4005              		.loc 1 1014 9 is_stmt 0 view .LVU1490
 4006 073c 2046     		mov	r0, r4
1013:lwIP/src/core/tcp_in.c ****         tcp_pcb_purge(pcb);
 4007              		.loc 1 1013 9 view .LVU1491
 4008 073e 43F00203 		orr	r3, r3, #2
 4009 0742 6383     		strh	r3, [r4, #26]	@ movhi
1013:lwIP/src/core/tcp_in.c ****         tcp_pcb_purge(pcb);
 4010              		.loc 1 1013 9 is_stmt 1 view .LVU1492
1014:lwIP/src/core/tcp_in.c ****         TCP_RMV_ACTIVE(pcb);
 4011              		.loc 1 1014 9 view .LVU1493
ARM GAS  /tmp/ccFjUByx.s 			page 150


 4012 0744 FFF7FEFF 		bl	tcp_pcb_purge
 4013              	.LVL250:
1015:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4014              		.loc 1 1015 9 view .LVU1494
1015:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4015              		.loc 1 1015 9 view .LVU1495
1015:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4016              		.loc 1 1015 9 view .LVU1496
 4017 0748 3B68     		ldr	r3, [r7]
 4018 074a 9C42     		cmp	r4, r3
 4019 074c 00F08C81 		beq	.L465
 4020              	.L307:
 4021              	.LBB317:
1015:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4022              		.loc 1 1015 9 view .LVU1497
 4023              	.LVL251:
1015:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4024              		.loc 1 1015 9 view .LVU1498
 4025 0750 002B     		cmp	r3, #0
 4026 0752 00F0C980 		beq	.L312
 4027 0756 DA68     		ldr	r2, [r3, #12]
 4028 0758 9442     		cmp	r4, r2
 4029 075a 00F0C380 		beq	.L466
 4030 075e 1346     		mov	r3, r2
 4031              	.LVL252:
1015:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4032              		.loc 1 1015 9 is_stmt 0 view .LVU1499
 4033 0760 F6E7     		b	.L307
 4034              	.LVL253:
 4035              	.L482:
1015:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4036              		.loc 1 1015 9 view .LVU1500
 4037              	.LBE317:
 4038              	.LBE333:
 4039              	.LBE360:
 4040              	.LBB361:
 4041              	.LBB351:
 721:lwIP/src/core/tcp_in.c ****       return;
 4042              		.loc 1 721 7 is_stmt 1 view .LVU1501
 4043 0762 2146     		mov	r1, r4
 4044 0764 5046     		mov	r0, r10
 4045              	.LVL254:
 721:lwIP/src/core/tcp_in.c ****       return;
 4046              		.loc 1 721 7 is_stmt 0 view .LVU1502
 4047 0766 FFF7FEFF 		bl	tcp_abandon
 4048              	.LVL255:
 722:lwIP/src/core/tcp_in.c ****     }
 4049              		.loc 1 722 7 is_stmt 1 view .LVU1503
 4050 076a 57E4     		b	.L217
 4051              	.LVL256:
 4052              	.L286:
 722:lwIP/src/core/tcp_in.c ****     }
 4053              		.loc 1 722 7 is_stmt 0 view .LVU1504
 4054              	.LBE351:
 4055              	.LBE361:
 4056              	.LBB362:
 4057              	.LBB334:
ARM GAS  /tmp/ccFjUByx.s 			page 151


 923:lwIP/src/core/tcp_in.c ****         /* expected ACK number? */
 4058              		.loc 1 923 7 is_stmt 1 view .LVU1505
 923:lwIP/src/core/tcp_in.c ****         /* expected ACK number? */
 4059              		.loc 1 923 17 is_stmt 0 view .LVU1506
 4060 076c 7F4B     		ldr	r3, .L498+4
 4061 076e 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 923:lwIP/src/core/tcp_in.c ****         /* expected ACK number? */
 4062              		.loc 1 923 10 view .LVU1507
 4063 0770 CA06     		lsls	r2, r1, #27
 4064 0772 1ED5     		bpl	.L287
 925:lwIP/src/core/tcp_in.c ****           pcb->state = ESTABLISHED;
 4065              		.loc 1 925 9 is_stmt 1 view .LVU1508
 925:lwIP/src/core/tcp_in.c ****           pcb->state = ESTABLISHED;
 4066              		.loc 1 925 13 is_stmt 0 view .LVU1509
 4067 0774 606C     		ldr	r0, [r4, #68]
 4068 0776 D9F80010 		ldr	r1, [r9]
 4069 077a C043     		mvns	r0, r0
 925:lwIP/src/core/tcp_in.c ****           pcb->state = ESTABLISHED;
 4070              		.loc 1 925 12 view .LVU1510
 4071 077c C842     		cmn	r0, r1
 4072 077e 04D4     		bmi	.L288
 925:lwIP/src/core/tcp_in.c ****           pcb->state = ESTABLISHED;
 4073              		.loc 1 925 13 view .LVU1511
 4074 0780 236D     		ldr	r3, [r4, #80]
 4075 0782 CB1A     		subs	r3, r1, r3
 4076 0784 002B     		cmp	r3, #0
 4077 0786 40F32A81 		ble	.L485
 4078              	.L288:
 971:lwIP/src/core/tcp_in.c ****                   ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 4079              		.loc 1 971 11 is_stmt 1 view .LVU1512
 4080 078a 069A     		ldr	r2, [sp, #24]
 4081 078c 2046     		mov	r0, r4
 972:lwIP/src/core/tcp_in.c ****         }
 4082              		.loc 1 972 48 is_stmt 0 view .LVU1513
 4083 078e D8F80030 		ldr	r3, [r8]
 971:lwIP/src/core/tcp_in.c ****                   ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 4084              		.loc 1 971 11 view .LVU1514
 4085 0792 1788     		ldrh	r7, [r2]
 4086 0794 764A     		ldr	r2, .L498+8
 4087 0796 B3F800C0 		ldrh	ip, [r3]	@ unaligned
 4088 079a 1268     		ldr	r2, [r2]
 4089 079c CDF808C0 		str	ip, [sp, #8]
 4090 07a0 3A44     		add	r2, r2, r7
 4091 07a2 5B88     		ldrh	r3, [r3, #2]	@ unaligned
 4092 07a4 734F     		ldr	r7, .L498+12
 4093 07a6 CDE90073 		strd	r7, r3, [sp]
 4094 07aa 3B1D     		adds	r3, r7, #4
 4095 07ac FFF7FEFF 		bl	tcp_rst
 4096              	.LVL257:
 971:lwIP/src/core/tcp_in.c ****                   ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 4097              		.loc 1 971 11 view .LVU1515
 4098              	.LBE334:
 4099              	.LBE362:
 441:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 4100              		.loc 1 441 5 is_stmt 1 view .LVU1516
 4101 07b0 5BE5     		b	.L266
 4102              	.LVL258:
ARM GAS  /tmp/ccFjUByx.s 			page 152


 4103              	.L287:
 4104              	.LBB363:
 4105              	.LBB335:
 974:lwIP/src/core/tcp_in.c ****         /* Looks like another copy of the SYN - retransmit our SYN-ACK */
 4106              		.loc 1 974 14 view .LVU1517
 974:lwIP/src/core/tcp_in.c ****         /* Looks like another copy of the SYN - retransmit our SYN-ACK */
 4107              		.loc 1 974 17 is_stmt 0 view .LVU1518
 4108 07b2 8F07     		lsls	r7, r1, #30
 4109 07b4 7FF559AD 		bpl	.L266
 974:lwIP/src/core/tcp_in.c ****         /* Looks like another copy of the SYN - retransmit our SYN-ACK */
 4110              		.loc 1 974 62 view .LVU1519
 4111 07b8 636A     		ldr	r3, [r4, #36]
 974:lwIP/src/core/tcp_in.c ****         /* Looks like another copy of the SYN - retransmit our SYN-ACK */
 4112              		.loc 1 974 36 view .LVU1520
 4113 07ba 6D4A     		ldr	r2, .L498+8
 974:lwIP/src/core/tcp_in.c ****         /* Looks like another copy of the SYN - retransmit our SYN-ACK */
 4114              		.loc 1 974 62 view .LVU1521
 4115 07bc 013B     		subs	r3, r3, #1
 974:lwIP/src/core/tcp_in.c ****         /* Looks like another copy of the SYN - retransmit our SYN-ACK */
 4116              		.loc 1 974 36 view .LVU1522
 4117 07be 1268     		ldr	r2, [r2]
 4118 07c0 9342     		cmp	r3, r2
 4119 07c2 7FF452AD 		bne	.L266
 976:lwIP/src/core/tcp_in.c ****       }
 4120              		.loc 1 976 9 is_stmt 1 view .LVU1523
 4121 07c6 2046     		mov	r0, r4
 4122 07c8 FFF7FEFF 		bl	tcp_rexmit
 4123              	.LVL259:
 976:lwIP/src/core/tcp_in.c ****       }
 4124              		.loc 1 976 9 is_stmt 0 view .LVU1524
 4125              	.LBE335:
 4126              	.LBE363:
 441:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 4127              		.loc 1 441 5 is_stmt 1 view .LVU1525
 4128 07cc 4DE5     		b	.L266
 4129              	.LVL260:
 4130              	.L476:
 269:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 4131              		.loc 1 269 7 discriminator 1 view .LVU1526
 4132 07ce 6A48     		ldr	r0, .L498+16
 4133 07d0 FFF7FEFF 		bl	printf
 4134              	.LVL261:
 4135              	.L237:
 269:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 4136              		.loc 1 269 7 discriminator 8 view .LVU1527
 269:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 4137              		.loc 1 269 7 discriminator 8 view .LVU1528
 269:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 4138              		.loc 1 269 7 discriminator 8 view .LVU1529
 269:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 4139              		.loc 1 269 7 discriminator 8 view .LVU1530
 269:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 4140              		.loc 1 269 7 discriminator 8 view .LVU1531
 269:lwIP/src/core/tcp_in.c ****       if (prev != NULL) {
 4141              		.loc 1 269 7 discriminator 8 view .LVU1532
 4142 07d4 FEE7     		b	.L237
 4143              	.L477:
ARM GAS  /tmp/ccFjUByx.s 			page 153


 277:lwIP/src/core/tcp_in.c ****       break;
 4144              		.loc 1 277 7 discriminator 1 view .LVU1533
 4145 07d6 6948     		ldr	r0, .L498+20
 4146 07d8 FFF7FEFF 		bl	printf
 4147              	.LVL262:
 4148              	.L239:
 277:lwIP/src/core/tcp_in.c ****       break;
 4149              		.loc 1 277 7 discriminator 9 view .LVU1534
 277:lwIP/src/core/tcp_in.c ****       break;
 4150              		.loc 1 277 7 discriminator 9 view .LVU1535
 277:lwIP/src/core/tcp_in.c ****       break;
 4151              		.loc 1 277 7 discriminator 9 view .LVU1536
 277:lwIP/src/core/tcp_in.c ****       break;
 4152              		.loc 1 277 7 discriminator 9 view .LVU1537
 277:lwIP/src/core/tcp_in.c ****       break;
 4153              		.loc 1 277 7 discriminator 9 view .LVU1538
 277:lwIP/src/core/tcp_in.c ****       break;
 4154              		.loc 1 277 7 discriminator 9 view .LVU1539
 4155 07dc FEE7     		b	.L239
 4156              	.L260:
 427:lwIP/src/core/tcp_in.c ****           /* this is a zero-window probe, we respond to it with current RCV.NXT
 4157              		.loc 1 427 9 view .LVU1540
 427:lwIP/src/core/tcp_in.c ****           /* this is a zero-window probe, we respond to it with current RCV.NXT
 4158              		.loc 1 427 12 is_stmt 0 view .LVU1541
 4159 07de 638D     		ldrh	r3, [r4, #42]
 4160 07e0 002B     		cmp	r3, #0
 4161 07e2 60D0     		beq	.L261
 4162 07e4 664D     		ldr	r5, .L498+24
 4163              	.LVL263:
 427:lwIP/src/core/tcp_in.c ****           /* this is a zero-window probe, we respond to it with current RCV.NXT
 4164              		.loc 1 427 12 view .LVU1542
 4165 07e6 52E5     		b	.L262
 4166              	.LVL264:
 4167              	.L489:
 4168              	.LBB364:
 4169              	.LBB336:
 859:lwIP/src/core/tcp_in.c ****         pcb->rcv_nxt = seqno + 1;
 4170              		.loc 1 859 37 view .LVU1543
 4171 07e8 616C     		ldr	r1, [r4, #68]
 859:lwIP/src/core/tcp_in.c ****         pcb->rcv_nxt = seqno + 1;
 4172              		.loc 1 859 21 view .LVU1544
 4173 07ea D9F80000 		ldr	r0, [r9]
 859:lwIP/src/core/tcp_in.c ****         pcb->rcv_nxt = seqno + 1;
 4174              		.loc 1 859 37 view .LVU1545
 4175 07ee 0131     		adds	r1, r1, #1
 859:lwIP/src/core/tcp_in.c ****         pcb->rcv_nxt = seqno + 1;
 4176              		.loc 1 859 11 view .LVU1546
 4177 07f0 8142     		cmp	r1, r0
 4178 07f2 40F0D280 		bne	.L273
 860:lwIP/src/core/tcp_in.c ****         pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 4179              		.loc 1 860 9 is_stmt 1 view .LVU1547
 860:lwIP/src/core/tcp_in.c ****         pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 4180              		.loc 1 860 30 is_stmt 0 view .LVU1548
 4181 07f6 5E4B     		ldr	r3, .L498+8
 866:lwIP/src/core/tcp_in.c **** 
 4182              		.loc 1 866 20 view .LVU1549
 4183 07f8 0427     		movs	r7, #4
ARM GAS  /tmp/ccFjUByx.s 			page 154


 863:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd_max = pcb->snd_wnd;
 4184              		.loc 1 863 30 view .LVU1550
 4185 07fa D8F800C0 		ldr	ip, [r8]
 860:lwIP/src/core/tcp_in.c ****         pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 4186              		.loc 1 860 30 view .LVU1551
 4187 07fe 1A68     		ldr	r2, [r3]
 863:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd_max = pcb->snd_wnd;
 4188              		.loc 1 863 22 view .LVU1552
 4189 0800 0023     		movs	r3, #0
 862:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd = tcphdr->wnd;
 4190              		.loc 1 862 22 view .LVU1553
 4191 0802 6164     		str	r1, [r4, #68]
 860:lwIP/src/core/tcp_in.c ****         pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 4192              		.loc 1 860 30 view .LVU1554
 4193 0804 501C     		adds	r0, r2, #1
 865:lwIP/src/core/tcp_in.c ****         pcb->state = ESTABLISHED;
 4194              		.loc 1 865 30 view .LVU1555
 4195 0806 02F1FF3E 		add	lr, r2, #-1
 869:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 4196              		.loc 1 869 20 view .LVU1556
 4197 080a E219     		adds	r2, r4, r7
 860:lwIP/src/core/tcp_in.c ****         pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 4198              		.loc 1 860 22 view .LVU1557
 4199 080c 6062     		str	r0, [r4, #36]
 861:lwIP/src/core/tcp_in.c ****         pcb->lastack = ackno;
 4200              		.loc 1 861 9 is_stmt 1 view .LVU1558
 861:lwIP/src/core/tcp_in.c ****         pcb->lastack = ackno;
 4201              		.loc 1 861 33 is_stmt 0 view .LVU1559
 4202 080e E062     		str	r0, [r4, #44]
 862:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd = tcphdr->wnd;
 4203              		.loc 1 862 9 is_stmt 1 view .LVU1560
 863:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd_max = pcb->snd_wnd;
 4204              		.loc 1 863 9 view .LVU1561
 869:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 4205              		.loc 1 869 20 is_stmt 0 view .LVU1562
 4206 0810 1046     		mov	r0, r2
 4207 0812 0592     		str	r2, [sp, #20]
 863:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd_max = pcb->snd_wnd;
 4208              		.loc 1 863 30 view .LVU1563
 4209 0814 BCF80E10 		ldrh	r1, [ip, #14]	@ unaligned
 864:lwIP/src/core/tcp_in.c ****         pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 4210              		.loc 1 864 9 is_stmt 1 view .LVU1564
 866:lwIP/src/core/tcp_in.c **** 
 4211              		.loc 1 866 20 is_stmt 0 view .LVU1565
 4212 0818 2775     		strb	r7, [r4, #20]
 863:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd_max = pcb->snd_wnd;
 4213              		.loc 1 863 22 view .LVU1566
 4214 081a 61F30F03 		bfi	r3, r1, #0, #16
 869:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 4215              		.loc 1 869 20 view .LVU1567
 4216 081e 678E     		ldrh	r7, [r4, #50]
 865:lwIP/src/core/tcp_in.c ****         pcb->state = ESTABLISHED;
 4217              		.loc 1 865 22 view .LVU1568
 4218 0820 C4F854E0 		str	lr, [r4, #84]
 863:lwIP/src/core/tcp_in.c ****         pcb->snd_wnd_max = pcb->snd_wnd;
 4219              		.loc 1 863 22 view .LVU1569
 4220 0824 61F31F43 		bfi	r3, r1, #16, #16
ARM GAS  /tmp/ccFjUByx.s 			page 155


 4221 0828 2366     		str	r3, [r4, #96]
 865:lwIP/src/core/tcp_in.c ****         pcb->state = ESTABLISHED;
 4222              		.loc 1 865 9 is_stmt 1 view .LVU1570
 866:lwIP/src/core/tcp_in.c **** 
 4223              		.loc 1 866 9 view .LVU1571
 869:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 4224              		.loc 1 869 9 view .LVU1572
 869:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 4225              		.loc 1 869 20 is_stmt 0 view .LVU1573
 4226 082a FFF7FEFF 		bl	ip4_route
 4227              	.LVL265:
 4228 082e 059A     		ldr	r2, [sp, #20]
 4229 0830 0146     		mov	r1, r0
 4230 0832 3846     		mov	r0, r7
 4231 0834 FFF7FEFF 		bl	tcp_eff_send_mss_netif
 4232              	.LVL266:
 872:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
 4233              		.loc 1 872 21 view .LVU1574
 4234 0838 41F21C13 		movw	r3, #4380
 4235 083c 4200     		lsls	r2, r0, #1
 869:lwIP/src/core/tcp_in.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 4236              		.loc 1 869 18 view .LVU1575
 4237 083e 6086     		strh	r0, [r4, #50]	@ movhi
 872:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
 4238              		.loc 1 872 9 is_stmt 1 view .LVU1576
 872:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
 4239              		.loc 1 872 21 is_stmt 0 view .LVU1577
 4240 0840 8100     		lsls	r1, r0, #2
 4241 0842 9A42     		cmp	r2, r3
 4242 0844 1746     		mov	r7, r2
 4243 0846 38BF     		it	cc
 4244 0848 1F46     		movcc	r7, r3
 4245 084a B7EB800F 		cmp	r7, r0, lsl #2
 4246 084e 40F22E81 		bls	.L274
 4247 0852 8BB2     		uxth	r3, r1
 4248              	.L275:
 876:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 4249              		.loc 1 876 9 view .LVU1578
 4250 0854 B4F86620 		ldrh	r2, [r4, #102]
 872:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
 4251              		.loc 1 872 19 view .LVU1579
 4252 0858 A4F84830 		strh	r3, [r4, #72]	@ movhi
 875:lwIP/src/core/tcp_in.c ****         LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 4253              		.loc 1 875 64 is_stmt 1 view .LVU1580
 876:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 4254              		.loc 1 876 9 view .LVU1581
 876:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 4255              		.loc 1 876 9 view .LVU1582
 4256 085c 002A     		cmp	r2, #0
 4257 085e 00F01281 		beq	.L486
 876:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 4258              		.loc 1 876 9 view .LVU1583
 877:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_
 4259              		.loc 1 877 9 view .LVU1584
 4260 0862 013A     		subs	r2, r2, #1
 879:lwIP/src/core/tcp_in.c ****         if (rseg == NULL) {
 4261              		.loc 1 879 14 is_stmt 0 view .LVU1585
ARM GAS  /tmp/ccFjUByx.s 			page 156


 4262 0864 206F     		ldr	r0, [r4, #112]
 877:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_
 4263              		.loc 1 877 9 view .LVU1586
 4264 0866 A4F86620 		strh	r2, [r4, #102]	@ movhi
 878:lwIP/src/core/tcp_in.c ****         rseg = pcb->unacked;
 4265              		.loc 1 878 126 is_stmt 1 view .LVU1587
 879:lwIP/src/core/tcp_in.c ****         if (rseg == NULL) {
 4266              		.loc 1 879 9 view .LVU1588
 4267              	.LVL267:
 880:lwIP/src/core/tcp_in.c ****           /* might happen if tcp_output fails in tcp_rexmit_rto()
 4268              		.loc 1 880 9 view .LVU1589
 880:lwIP/src/core/tcp_in.c ****           /* might happen if tcp_output fails in tcp_rexmit_rto()
 4269              		.loc 1 880 12 is_stmt 0 view .LVU1590
 4270 086a 0028     		cmp	r0, #0
 4271 086c 00F00681 		beq	.L487
 887:lwIP/src/core/tcp_in.c ****         }
 4272              		.loc 1 887 11 is_stmt 1 view .LVU1591
 887:lwIP/src/core/tcp_in.c ****         }
 4273              		.loc 1 887 24 is_stmt 0 view .LVU1592
 4274 0870 0368     		ldr	r3, [r0]
 4275 0872 2367     		str	r3, [r4, #112]
 4276              	.L281:
 889:lwIP/src/core/tcp_in.c **** 
 4277              		.loc 1 889 9 is_stmt 1 view .LVU1593
 4278 0874 FFF7FEFF 		bl	tcp_seg_free
 4279              	.LVL268:
 893:lwIP/src/core/tcp_in.c ****           pcb->rtime = -1;
 4280              		.loc 1 893 9 view .LVU1594
 893:lwIP/src/core/tcp_in.c ****           pcb->rtime = -1;
 4281              		.loc 1 893 12 is_stmt 0 view .LVU1595
 4282 0878 236F     		ldr	r3, [r4, #112]
 4283 087a 002B     		cmp	r3, #0
 4284 087c 00F0FB80 		beq	.L345
 896:lwIP/src/core/tcp_in.c ****           pcb->nrtx = 0;
 4285              		.loc 1 896 11 is_stmt 1 view .LVU1596
 897:lwIP/src/core/tcp_in.c ****         }
 4286              		.loc 1 897 11 view .LVU1597
 897:lwIP/src/core/tcp_in.c ****         }
 4287              		.loc 1 897 21 is_stmt 0 view .LVU1598
 4288 0880 0023     		movs	r3, #0
 4289 0882 84F84230 		strb	r3, [r4, #66]
 4290              	.L282:
 902:lwIP/src/core/tcp_in.c ****         if (err == ERR_ABRT) {
 4291              		.loc 1 902 9 view .LVU1599
 4292 0886 D4F88470 		ldr	r7, [r4, #132]
 4293 088a 2386     		strh	r3, [r4, #48]	@ movhi
 902:lwIP/src/core/tcp_in.c ****         if (err == ERR_ABRT) {
 4294              		.loc 1 902 9 is_stmt 1 view .LVU1600
 902:lwIP/src/core/tcp_in.c ****         if (err == ERR_ABRT) {
 4295              		.loc 1 902 9 view .LVU1601
 4296 088c 37B1     		cbz	r7, .L285
 902:lwIP/src/core/tcp_in.c ****         if (err == ERR_ABRT) {
 4297              		.loc 1 902 9 view .LVU1602
 4298 088e 0022     		movs	r2, #0
 4299 0890 2146     		mov	r1, r4
 4300 0892 2069     		ldr	r0, [r4, #16]
 4301 0894 B847     		blx	r7
ARM GAS  /tmp/ccFjUByx.s 			page 157


 4302              	.LVL269:
 902:lwIP/src/core/tcp_in.c ****         if (err == ERR_ABRT) {
 4303              		.loc 1 902 9 view .LVU1603
 903:lwIP/src/core/tcp_in.c ****           return ERR_ABRT;
 4304              		.loc 1 903 9 view .LVU1604
 903:lwIP/src/core/tcp_in.c ****           return ERR_ABRT;
 4305              		.loc 1 903 12 is_stmt 0 view .LVU1605
 4306 0896 0D30     		adds	r0, r0, #13
 4307              	.LVL270:
 903:lwIP/src/core/tcp_in.c ****           return ERR_ABRT;
 4308              		.loc 1 903 12 view .LVU1606
 4309 0898 3FF4F9AC 		beq	.L262
 4310              	.L285:
 906:lwIP/src/core/tcp_in.c ****       }
 4311              		.loc 1 906 9 is_stmt 1 view .LVU1607
 906:lwIP/src/core/tcp_in.c ****       }
 4312              		.loc 1 906 9 view .LVU1608
 4313 089c 638B     		ldrh	r3, [r4, #26]
 4314 089e 43F00203 		orr	r3, r3, #2
 4315 08a2 6383     		strh	r3, [r4, #26]	@ movhi
 906:lwIP/src/core/tcp_in.c ****       }
 4316              		.loc 1 906 9 view .LVU1609
 4317              	.LVL271:
 906:lwIP/src/core/tcp_in.c ****       }
 4318              		.loc 1 906 9 is_stmt 0 view .LVU1610
 4319              	.LBE336:
 4320              	.LBE364:
 441:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 4321              		.loc 1 441 5 is_stmt 1 view .LVU1611
 4322 08a4 E1E4     		b	.L266
 4323              	.LVL272:
 4324              	.L261:
 430:lwIP/src/core/tcp_in.c ****         }
 4325              		.loc 1 430 11 view .LVU1612
 4326 08a6 2046     		mov	r0, r4
 4327 08a8 354D     		ldr	r5, .L498+24
 4328              	.LVL273:
 430:lwIP/src/core/tcp_in.c ****         }
 4329              		.loc 1 430 11 is_stmt 0 view .LVU1613
 4330 08aa FFF7FEFF 		bl	tcp_send_empty_ack
 4331              	.LVL274:
 4332 08ae EEE4     		b	.L262
 4333              	.LVL275:
 4334              	.L481:
 4335              	.LBB365:
 4336              	.LBB352:
 4337              	.LBB350:
 664:lwIP/src/core/tcp_in.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
 4338              		.loc 1 664 7 is_stmt 1 view .LVU1614
 665:lwIP/src/core/tcp_in.c ****       TCP_STATS_INC(tcp.memerr);
 4339              		.loc 1 665 77 view .LVU1615
 666:lwIP/src/core/tcp_in.c ****       TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 4340              		.loc 1 666 32 view .LVU1616
 667:lwIP/src/core/tcp_in.c ****       LWIP_UNUSED_ARG(err); /* err not useful here */
 4341              		.loc 1 667 7 view .LVU1617
 667:lwIP/src/core/tcp_in.c ****       LWIP_UNUSED_ARG(err); /* err not useful here */
 4342              		.loc 1 667 7 view .LVU1618
ARM GAS  /tmp/ccFjUByx.s 			page 158


 4343 08b0 D9F81830 		ldr	r3, [r9, #24]
 4344 08b4 002B     		cmp	r3, #0
 4345 08b6 3FF4B1AB 		beq	.L217
 667:lwIP/src/core/tcp_in.c ****       LWIP_UNUSED_ARG(err); /* err not useful here */
 4346              		.loc 1 667 7 view .LVU1619
 4347 08ba 0146     		mov	r1, r0
 4348 08bc 4FF0FF32 		mov	r2, #-1
 4349 08c0 D9F81000 		ldr	r0, [r9, #16]
 4350              	.LVL276:
 667:lwIP/src/core/tcp_in.c ****       LWIP_UNUSED_ARG(err); /* err not useful here */
 4351              		.loc 1 667 7 is_stmt 0 view .LVU1620
 4352 08c4 9847     		blx	r3
 4353              	.LVL277:
 4354 08c6 FFF7A9BB 		b	.L217
 4355              	.LVL278:
 4356              	.L480:
 667:lwIP/src/core/tcp_in.c ****       LWIP_UNUSED_ARG(err); /* err not useful here */
 4357              		.loc 1 667 7 view .LVU1621
 4358              	.LBE350:
 648:lwIP/src/core/tcp_in.c ****     tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 4359              		.loc 1 648 85 is_stmt 1 view .LVU1622
 649:lwIP/src/core/tcp_in.c ****             ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 4360              		.loc 1 649 5 view .LVU1623
 4361 08ca 059B     		ldr	r3, [sp, #20]
 4362 08cc 4846     		mov	r0, r9
 4363 08ce 0292     		str	r2, [sp, #8]
 4364 08d0 0AEB0B02 		add	r2, r10, fp
 4365 08d4 0193     		str	r3, [sp, #4]
 4366 08d6 274B     		ldr	r3, .L498+12
 4367 08d8 0093     		str	r3, [sp]
 4368 08da 0433     		adds	r3, r3, #4
 4369 08dc FFF7FEFF 		bl	tcp_rst
 4370              	.LVL279:
 4371 08e0 FFF79CBB 		b	.L217
 4372              	.LVL280:
 4373              	.L466:
 649:lwIP/src/core/tcp_in.c ****             ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 4374              		.loc 1 649 5 is_stmt 0 view .LVU1624
 4375              	.LBE352:
 4376              	.LBE365:
 4377              	.LBB366:
 4378              	.LBB337:
 4379              	.LBB318:
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4380              		.loc 1 1025 9 is_stmt 1 view .LVU1625
 4381 08e4 E268     		ldr	r2, [r4, #12]
 4382 08e6 DA60     		str	r2, [r3, #12]
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4383              		.loc 1 1025 9 view .LVU1626
 4384              	.L312:
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4385              		.loc 1 1025 9 is_stmt 0 view .LVU1627
 4386              	.LBE318:
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4387              		.loc 1 1025 9 is_stmt 1 view .LVU1628
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4388              		.loc 1 1025 9 view .LVU1629
ARM GAS  /tmp/ccFjUByx.s 			page 159


1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4389              		.loc 1 1025 9 view .LVU1630
1027:lwIP/src/core/tcp_in.c ****       }
 4390              		.loc 1 1027 9 is_stmt 0 view .LVU1631
 4391 08e8 264B     		ldr	r3, .L498+28
1026:lwIP/src/core/tcp_in.c ****         TCP_REG(&tcp_tw_pcbs, pcb);
 4392              		.loc 1 1026 20 view .LVU1632
 4393 08ea 0A20     		movs	r0, #10
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4394              		.loc 1 1025 9 view .LVU1633
 4395 08ec 0121     		movs	r1, #1
1027:lwIP/src/core/tcp_in.c ****       }
 4396              		.loc 1 1027 9 view .LVU1634
 4397 08ee 1A68     		ldr	r2, [r3]
1026:lwIP/src/core/tcp_in.c ****         TCP_REG(&tcp_tw_pcbs, pcb);
 4398              		.loc 1 1026 20 view .LVU1635
 4399 08f0 2075     		strb	r0, [r4, #20]
1027:lwIP/src/core/tcp_in.c ****       }
 4400              		.loc 1 1027 9 view .LVU1636
 4401 08f2 E260     		str	r2, [r4, #12]
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4402              		.loc 1 1025 9 view .LVU1637
 4403 08f4 244A     		ldr	r2, .L498+32
1027:lwIP/src/core/tcp_in.c ****       }
 4404              		.loc 1 1027 9 view .LVU1638
 4405 08f6 1C60     		str	r4, [r3]
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4406              		.loc 1 1025 9 view .LVU1639
 4407 08f8 1170     		strb	r1, [r2]
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4408              		.loc 1 1025 9 is_stmt 1 view .LVU1640
1026:lwIP/src/core/tcp_in.c ****         TCP_REG(&tcp_tw_pcbs, pcb);
 4409              		.loc 1 1026 9 view .LVU1641
1027:lwIP/src/core/tcp_in.c ****       }
 4410              		.loc 1 1027 9 view .LVU1642
1027:lwIP/src/core/tcp_in.c ****       }
 4411              		.loc 1 1027 9 view .LVU1643
1027:lwIP/src/core/tcp_in.c ****       }
 4412              		.loc 1 1027 9 view .LVU1644
1027:lwIP/src/core/tcp_in.c ****       }
 4413              		.loc 1 1027 9 view .LVU1645
 4414 08fa FFF7FEFF 		bl	tcp_timer_needed
 4415              	.LVL281:
1027:lwIP/src/core/tcp_in.c ****       }
 4416              		.loc 1 1027 9 is_stmt 0 view .LVU1646
 4417              	.LBE337:
 4418              	.LBE366:
 441:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 4419              		.loc 1 441 5 is_stmt 1 view .LVU1647
 4420 08fe B4E4     		b	.L266
 4421              	.LVL282:
 4422              	.L300:
 4423              	.LBB367:
 4424              	.LBB338:
 989:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_GOT_FIN) {
 4425              		.loc 1 989 7 view .LVU1648
 4426              	.LBB319:
ARM GAS  /tmp/ccFjUByx.s 			page 160


 4427              	.LBI319:
1141:lwIP/src/core/tcp_in.c **** {
 4428              		.loc 1 1141 1 view .LVU1649
 4429              	.LBB320:
1143:lwIP/src/core/tcp_in.c ****   u32_t right_wnd_edge;
 4430              		.loc 1 1143 3 view .LVU1650
1144:lwIP/src/core/tcp_in.c ****   int found_dupack = 0;
 4431              		.loc 1 1144 3 view .LVU1651
1145:lwIP/src/core/tcp_in.c **** 
 4432              		.loc 1 1145 3 view .LVU1652
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 4433              		.loc 1 1147 3 view .LVU1653
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 4434              		.loc 1 1147 3 view .LVU1654
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 4435              		.loc 1 1147 3 view .LVU1655
1148:lwIP/src/core/tcp_in.c **** 
 4436              		.loc 1 1148 3 view .LVU1656
1148:lwIP/src/core/tcp_in.c **** 
 4437              		.loc 1 1148 3 view .LVU1657
1148:lwIP/src/core/tcp_in.c **** 
 4438              		.loc 1 1148 3 is_stmt 0 view .LVU1658
 4439 0900 2046     		mov	r0, r4
 4440 0902 FFF7FEFF 		bl	tcp_receive.part.0
 4441              	.LVL283:
1882:lwIP/src/core/tcp_in.c ****     }
 4442              		.loc 1 1882 7 is_stmt 1 view .LVU1659
1882:lwIP/src/core/tcp_in.c ****     }
 4443              		.loc 1 1882 7 is_stmt 0 view .LVU1660
 4444              	.LBE320:
 4445              	.LBE319:
 990:lwIP/src/core/tcp_in.c ****         if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 4446              		.loc 1 990 7 is_stmt 1 view .LVU1661
 990:lwIP/src/core/tcp_in.c ****         if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 4447              		.loc 1 990 10 is_stmt 0 view .LVU1662
 4448 0906 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 991:lwIP/src/core/tcp_in.c ****             pcb->unsent == NULL) {
 4449              		.loc 1 991 12 view .LVU1663
 4450 0908 184B     		ldr	r3, .L498+4
 990:lwIP/src/core/tcp_in.c ****         if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 4451              		.loc 1 990 10 view .LVU1664
 4452 090a 12F0200F 		tst	r2, #32
 991:lwIP/src/core/tcp_in.c ****             pcb->unsent == NULL) {
 4453              		.loc 1 991 12 view .LVU1665
 4454 090e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 990:lwIP/src/core/tcp_in.c ****         if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 4455              		.loc 1 990 10 view .LVU1666
 4456 0910 0ED0     		beq	.L301
 991:lwIP/src/core/tcp_in.c ****             pcb->unsent == NULL) {
 4457              		.loc 1 991 9 is_stmt 1 view .LVU1667
 991:lwIP/src/core/tcp_in.c ****             pcb->unsent == NULL) {
 4458              		.loc 1 991 12 is_stmt 0 view .LVU1668
 4459 0912 D106     		lsls	r1, r2, #27
 4460 0914 05D5     		bpl	.L302
 991:lwIP/src/core/tcp_in.c ****             pcb->unsent == NULL) {
 4461              		.loc 1 991 31 view .LVU1669
 4462 0916 D9F80030 		ldr	r3, [r9]
ARM GAS  /tmp/ccFjUByx.s 			page 161


 4463 091a 226D     		ldr	r2, [r4, #80]
 4464 091c 9A42     		cmp	r2, r3
 4465 091e 00F09580 		beq	.L488
 4466              	.L302:
1001:lwIP/src/core/tcp_in.c ****           pcb->state = CLOSING;
 4467              		.loc 1 1001 11 is_stmt 1 view .LVU1670
1001:lwIP/src/core/tcp_in.c ****           pcb->state = CLOSING;
 4468              		.loc 1 1001 11 view .LVU1671
 4469 0922 638B     		ldrh	r3, [r4, #26]
1002:lwIP/src/core/tcp_in.c ****         }
 4470              		.loc 1 1002 22 is_stmt 0 view .LVU1672
 4471 0924 0822     		movs	r2, #8
1001:lwIP/src/core/tcp_in.c ****           pcb->state = CLOSING;
 4472              		.loc 1 1001 11 view .LVU1673
 4473 0926 43F00203 		orr	r3, r3, #2
1002:lwIP/src/core/tcp_in.c ****         }
 4474              		.loc 1 1002 22 view .LVU1674
 4475 092a 2275     		strb	r2, [r4, #20]
1001:lwIP/src/core/tcp_in.c ****           pcb->state = CLOSING;
 4476              		.loc 1 1001 11 view .LVU1675
 4477 092c 6383     		strh	r3, [r4, #26]	@ movhi
1001:lwIP/src/core/tcp_in.c ****           pcb->state = CLOSING;
 4478              		.loc 1 1001 11 is_stmt 1 view .LVU1676
1002:lwIP/src/core/tcp_in.c ****         }
 4479              		.loc 1 1002 11 view .LVU1677
 4480              	.LVL284:
1002:lwIP/src/core/tcp_in.c ****         }
 4481              		.loc 1 1002 11 is_stmt 0 view .LVU1678
 4482              	.LBE338:
 4483              	.LBE367:
 441:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 4484              		.loc 1 441 5 is_stmt 1 view .LVU1679
 4485 092e 9CE4     		b	.L266
 4486              	.LVL285:
 4487              	.L301:
 4488              	.LBB368:
 4489              	.LBB339:
1004:lwIP/src/core/tcp_in.c ****                  pcb->unsent == NULL) {
 4490              		.loc 1 1004 14 view .LVU1680
1004:lwIP/src/core/tcp_in.c ****                  pcb->unsent == NULL) {
 4491              		.loc 1 1004 17 is_stmt 0 view .LVU1681
 4492 0930 D206     		lsls	r2, r2, #27
 4493 0932 7FF59AAC 		bpl	.L266
1004:lwIP/src/core/tcp_in.c ****                  pcb->unsent == NULL) {
 4494              		.loc 1 1004 36 view .LVU1682
 4495 0936 D9F80030 		ldr	r3, [r9]
 4496 093a 226D     		ldr	r2, [r4, #80]
 4497 093c 9A42     		cmp	r2, r3
 4498 093e 7FF494AC 		bne	.L266
1004:lwIP/src/core/tcp_in.c ****                  pcb->unsent == NULL) {
 4499              		.loc 1 1004 63 view .LVU1683
 4500 0942 E36E     		ldr	r3, [r4, #108]
 4501 0944 002B     		cmp	r3, #0
 4502 0946 7FF490AC 		bne	.L266
1006:lwIP/src/core/tcp_in.c ****       }
 4503              		.loc 1 1006 9 is_stmt 1 view .LVU1684
1006:lwIP/src/core/tcp_in.c ****       }
ARM GAS  /tmp/ccFjUByx.s 			page 162


 4504              		.loc 1 1006 20 is_stmt 0 view .LVU1685
 4505 094a 0623     		movs	r3, #6
 4506 094c 2375     		strb	r3, [r4, #20]
 4507              	.LVL286:
1006:lwIP/src/core/tcp_in.c ****       }
 4508              		.loc 1 1006 20 view .LVU1686
 4509              	.LBE339:
 4510              	.LBE368:
 441:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 4511              		.loc 1 441 5 is_stmt 1 view .LVU1687
 4512 094e 8CE4     		b	.L266
 4513              	.LVL287:
 4514              	.L325:
 501:lwIP/src/core/tcp_in.c ****           if (err == ERR_ABRT) {
 4515              		.loc 1 501 11 discriminator 2 view .LVU1688
 4516 0950 3B46     		mov	r3, r7
 4517 0952 2146     		mov	r1, r4
 4518 0954 FFF7FEFF 		bl	tcp_recv_null
 4519              	.LVL288:
 501:lwIP/src/core/tcp_in.c ****           if (err == ERR_ABRT) {
 4520              		.loc 1 501 11 is_stmt 0 discriminator 2 view .LVU1689
 4521 0958 29E6     		b	.L326
 4522              	.LVL289:
 4523              	.L483:
 490:lwIP/src/core/tcp_in.c **** #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
 4524              		.loc 1 490 13 is_stmt 1 view .LVU1690
 4525 095a 1046     		mov	r0, r2
 4526 095c FFF7FEFF 		bl	pbuf_free
 4527              	.LVL290:
 4528              	.L464:
 496:lwIP/src/core/tcp_in.c ****             goto aborted;
 4529              		.loc 1 496 13 view .LVU1691
 4530 0960 2046     		mov	r0, r4
 4531 0962 FFF7FEFF 		bl	tcp_abort
 4532              	.LVL291:
 497:lwIP/src/core/tcp_in.c ****           }
 4533              		.loc 1 497 13 view .LVU1692
 4534 0966 92E4     		b	.L262
 4535              	.L499:
 4536              		.align	2
 4537              	.L498:
 4538 0968 00000000 		.word	tcp_ticks
 4539 096c 00000000 		.word	.LANCHOR9
 4540 0970 00000000 		.word	.LANCHOR8
 4541 0974 10000000 		.word	ip_data+16
 4542 0978 D0000000 		.word	.LC16
 4543 097c FC000000 		.word	.LC17
 4544 0980 00000000 		.word	tcp_input_pcb
 4545 0984 00000000 		.word	tcp_tw_pcbs
 4546 0988 00000000 		.word	tcp_active_pcbs_changed
 4547              	.LVL292:
 4548              	.L272:
 4549              	.LBB369:
 4550              	.LBB340:
 856:lwIP/src/core/tcp_in.c ****       /* received SYN ACK with expected sequence number? */
 4551              		.loc 1 856 92 view .LVU1693
 858:lwIP/src/core/tcp_in.c ****           && (ackno == pcb->lastack + 1)) {
ARM GAS  /tmp/ccFjUByx.s 			page 163


 4552              		.loc 1 858 7 view .LVU1694
 858:lwIP/src/core/tcp_in.c ****           && (ackno == pcb->lastack + 1)) {
 4553              		.loc 1 858 29 is_stmt 0 view .LVU1695
 4554 098c 504B     		ldr	r3, .L500
 4555 098e 1F78     		ldrb	r7, [r3]	@ zero_extendqisi2
 858:lwIP/src/core/tcp_in.c ****           && (ackno == pcb->lastack + 1)) {
 4556              		.loc 1 858 10 view .LVU1696
 4557 0990 07F01201 		and	r1, r7, #18
 4558 0994 1229     		cmp	r1, #18
 4559 0996 3FF427AF 		beq	.L489
 4560              	.L273:
 909:lwIP/src/core/tcp_in.c ****         /* send a RST to bring the other side in a non-synchronized state. */
 4561              		.loc 1 909 12 is_stmt 1 view .LVU1697
 909:lwIP/src/core/tcp_in.c ****         /* send a RST to bring the other side in a non-synchronized state. */
 4562              		.loc 1 909 15 is_stmt 0 view .LVU1698
 4563 099a F906     		lsls	r1, r7, #27
 4564 099c 7FF565AC 		bpl	.L266
 911:lwIP/src/core/tcp_in.c ****                 ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 4565              		.loc 1 911 9 is_stmt 1 view .LVU1699
 912:lwIP/src/core/tcp_in.c ****         /* Resend SYN immediately (don't wait for rto timeout) to establish
 4566              		.loc 1 912 46 is_stmt 0 view .LVU1700
 4567 09a0 D8F80010 		ldr	r1, [r8]
 911:lwIP/src/core/tcp_in.c ****                 ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 4568              		.loc 1 911 9 view .LVU1701
 4569 09a4 2046     		mov	r0, r4
 4570 09a6 069B     		ldr	r3, [sp, #24]
 4571 09a8 0F88     		ldrh	r7, [r1]	@ unaligned
 4572 09aa B3F800C0 		ldrh	ip, [r3]
 4573 09ae 494B     		ldr	r3, .L500+4
 4574 09b0 1A68     		ldr	r2, [r3]
 4575 09b2 0297     		str	r7, [sp, #8]
 4576 09b4 484B     		ldr	r3, .L500+8
 4577 09b6 6244     		add	r2, r2, ip
 4578 09b8 4F88     		ldrh	r7, [r1, #2]	@ unaligned
 4579 09ba D9F80010 		ldr	r1, [r9]
 4580 09be 0093     		str	r3, [sp]
 4581 09c0 0433     		adds	r3, r3, #4
 4582 09c2 0197     		str	r7, [sp, #4]
 4583 09c4 FFF7FEFF 		bl	tcp_rst
 4584              	.LVL293:
 916:lwIP/src/core/tcp_in.c ****           pcb->rtime = 0;
 4585              		.loc 1 916 9 is_stmt 1 view .LVU1702
 916:lwIP/src/core/tcp_in.c ****           pcb->rtime = 0;
 4586              		.loc 1 916 12 is_stmt 0 view .LVU1703
 4587 09c8 94F84230 		ldrb	r3, [r4, #66]	@ zero_extendqisi2
 4588 09cc 052B     		cmp	r3, #5
 4589 09ce 3FF64CAC 		bhi	.L266
 917:lwIP/src/core/tcp_in.c ****           tcp_rexmit_rto(pcb);
 4590              		.loc 1 917 11 is_stmt 1 view .LVU1704
 917:lwIP/src/core/tcp_in.c ****           tcp_rexmit_rto(pcb);
 4591              		.loc 1 917 22 is_stmt 0 view .LVU1705
 4592 09d2 0023     		movs	r3, #0
 918:lwIP/src/core/tcp_in.c ****         }
 4593              		.loc 1 918 11 view .LVU1706
 4594 09d4 2046     		mov	r0, r4
 917:lwIP/src/core/tcp_in.c ****           tcp_rexmit_rto(pcb);
 4595              		.loc 1 917 22 view .LVU1707
ARM GAS  /tmp/ccFjUByx.s 			page 164


 4596 09d6 2386     		strh	r3, [r4, #48]	@ movhi
 918:lwIP/src/core/tcp_in.c ****         }
 4597              		.loc 1 918 11 is_stmt 1 view .LVU1708
 4598 09d8 FFF7FEFF 		bl	tcp_rexmit_rto
 4599              	.LVL294:
 918:lwIP/src/core/tcp_in.c ****         }
 4600              		.loc 1 918 11 is_stmt 0 view .LVU1709
 4601              	.LBE340:
 4602              	.LBE369:
 441:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 4603              		.loc 1 441 5 is_stmt 1 view .LVU1710
 4604 09dc 45E4     		b	.L266
 4605              	.LVL295:
 4606              	.L485:
 4607              	.LBB370:
 4608              	.LBB341:
 926:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphd
 4609              		.loc 1 926 11 view .LVU1711
 926:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphd
 4610              		.loc 1 926 22 is_stmt 0 view .LVU1712
 4611 09de 0422     		movs	r2, #4
 929:lwIP/src/core/tcp_in.c ****             /* listen pcb might be closed by now */
 4612              		.loc 1 929 18 view .LVU1713
 4613 09e0 A36F     		ldr	r3, [r4, #120]
 926:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphd
 4614              		.loc 1 926 22 view .LVU1714
 4615 09e2 2275     		strb	r2, [r4, #20]
 927:lwIP/src/core/tcp_in.c **** #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
 4616              		.loc 1 927 128 is_stmt 1 view .LVU1715
 929:lwIP/src/core/tcp_in.c ****             /* listen pcb might be closed by now */
 4617              		.loc 1 929 11 view .LVU1716
 929:lwIP/src/core/tcp_in.c ****             /* listen pcb might be closed by now */
 4618              		.loc 1 929 14 is_stmt 0 view .LVU1717
 4619 09e4 002B     		cmp	r3, #0
 4620 09e6 BBD0     		beq	.L464
 936:lwIP/src/core/tcp_in.c **** #endif
 4621              		.loc 1 936 13 is_stmt 1 view .LVU1718
 936:lwIP/src/core/tcp_in.c **** #endif
 4622              		.loc 1 936 13 view .LVU1719
 4623 09e8 9B69     		ldr	r3, [r3, #24]
 4624 09ea 002B     		cmp	r3, #0
 4625 09ec 3FD0     		beq	.L490
 936:lwIP/src/core/tcp_in.c **** #endif
 4626              		.loc 1 936 13 view .LVU1720
 938:lwIP/src/core/tcp_in.c ****             /* Call the accept function. */
 4627              		.loc 1 938 38 view .LVU1721
 940:lwIP/src/core/tcp_in.c ****           }
 4628              		.loc 1 940 13 view .LVU1722
 940:lwIP/src/core/tcp_in.c ****           }
 4629              		.loc 1 940 13 view .LVU1723
 940:lwIP/src/core/tcp_in.c ****           }
 4630              		.loc 1 940 13 view .LVU1724
 4631 09ee 0022     		movs	r2, #0
 4632 09f0 2146     		mov	r1, r4
 4633 09f2 2069     		ldr	r0, [r4, #16]
 4634 09f4 9847     		blx	r3
 4635              	.LVL296:
ARM GAS  /tmp/ccFjUByx.s 			page 165


 940:lwIP/src/core/tcp_in.c ****           }
 4636              		.loc 1 940 13 view .LVU1725
 942:lwIP/src/core/tcp_in.c ****             /* If the accept function returns with an error, we abort
 4637              		.loc 1 942 11 view .LVU1726
 942:lwIP/src/core/tcp_in.c ****             /* If the accept function returns with an error, we abort
 4638              		.loc 1 942 14 is_stmt 0 view .LVU1727
 4639 09f6 0028     		cmp	r0, #0
 4640 09f8 51D1     		bne	.L491
 953:lwIP/src/core/tcp_in.c **** 
 4641              		.loc 1 953 11 is_stmt 1 view .LVU1728
 4642              	.LVL297:
 4643              	.LBB321:
 4644              	.LBI321:
1141:lwIP/src/core/tcp_in.c **** {
 4645              		.loc 1 1141 1 view .LVU1729
 4646              	.LBB322:
1143:lwIP/src/core/tcp_in.c ****   u32_t right_wnd_edge;
 4647              		.loc 1 1143 3 view .LVU1730
1144:lwIP/src/core/tcp_in.c ****   int found_dupack = 0;
 4648              		.loc 1 1144 3 view .LVU1731
1145:lwIP/src/core/tcp_in.c **** 
 4649              		.loc 1 1145 3 view .LVU1732
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 4650              		.loc 1 1147 3 view .LVU1733
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 4651              		.loc 1 1147 3 view .LVU1734
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 4652              		.loc 1 1147 3 view .LVU1735
1148:lwIP/src/core/tcp_in.c **** 
 4653              		.loc 1 1148 3 view .LVU1736
1148:lwIP/src/core/tcp_in.c **** 
 4654              		.loc 1 1148 3 view .LVU1737
 4655 09fa 237D     		ldrb	r3, [r4, #20]	@ zero_extendqisi2
 4656 09fc 032B     		cmp	r3, #3
 4657 09fe 21D9     		bls	.L492
 4658 0a00 2046     		mov	r0, r4
 4659              	.LVL298:
1148:lwIP/src/core/tcp_in.c **** 
 4660              		.loc 1 1148 3 is_stmt 0 view .LVU1738
 4661 0a02 FFF7FEFF 		bl	tcp_receive.part.0
 4662              	.LVL299:
1882:lwIP/src/core/tcp_in.c ****     }
 4663              		.loc 1 1882 7 is_stmt 1 view .LVU1739
1882:lwIP/src/core/tcp_in.c ****     }
 4664              		.loc 1 1882 7 is_stmt 0 view .LVU1740
 4665              	.LBE322:
 4666              	.LBE321:
 956:lwIP/src/core/tcp_in.c ****             recv_acked--;
 4667              		.loc 1 956 11 is_stmt 1 view .LVU1741
 956:lwIP/src/core/tcp_in.c ****             recv_acked--;
 4668              		.loc 1 956 26 is_stmt 0 view .LVU1742
 4669 0a06 354A     		ldr	r2, .L500+12
 4670 0a08 1388     		ldrh	r3, [r2]
 956:lwIP/src/core/tcp_in.c ****             recv_acked--;
 4671              		.loc 1 956 14 view .LVU1743
 4672 0a0a 0BB1     		cbz	r3, .L296
 957:lwIP/src/core/tcp_in.c ****           }
ARM GAS  /tmp/ccFjUByx.s 			page 166


 4673              		.loc 1 957 13 is_stmt 1 view .LVU1744
 957:lwIP/src/core/tcp_in.c ****           }
 4674              		.loc 1 957 23 is_stmt 0 view .LVU1745
 4675 0a0c 013B     		subs	r3, r3, #1
 4676 0a0e 1380     		strh	r3, [r2]	@ movhi
 4677              	.L296:
 960:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
 4678              		.loc 1 960 11 is_stmt 1 view .LVU1746
 960:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
 4679              		.loc 1 960 23 is_stmt 0 view .LVU1747
 4680 0a10 618E     		ldrh	r1, [r4, #50]
 4681 0a12 41F21C13 		movw	r3, #4380
 4682 0a16 4A00     		lsls	r2, r1, #1
 4683 0a18 8800     		lsls	r0, r1, #2
 4684 0a1a 9A42     		cmp	r2, r3
 4685 0a1c 1746     		mov	r7, r2
 4686 0a1e 38BF     		it	cc
 4687 0a20 1F46     		movcc	r7, r3
 4688 0a22 B7EB810F 		cmp	r7, r1, lsl #2
 4689 0a26 3ED9     		bls	.L297
 4690 0a28 83B2     		uxth	r3, r0
 4691              	.L298:
 965:lwIP/src/core/tcp_in.c ****             tcp_ack_now(pcb);
 4692              		.loc 1 965 14 view .LVU1748
 4693 0a2a 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 960:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
 4694              		.loc 1 960 21 view .LVU1749
 4695 0a2c A4F84830 		strh	r3, [r4, #72]	@ movhi
 963:lwIP/src/core/tcp_in.c **** 
 4696              		.loc 1 963 66 is_stmt 1 view .LVU1750
 965:lwIP/src/core/tcp_in.c ****             tcp_ack_now(pcb);
 4697              		.loc 1 965 11 view .LVU1751
 965:lwIP/src/core/tcp_in.c ****             tcp_ack_now(pcb);
 4698              		.loc 1 965 14 is_stmt 0 view .LVU1752
 4699 0a30 9306     		lsls	r3, r2, #26
 4700 0a32 7FF51AAC 		bpl	.L266
 4701              	.LVL300:
 4702              	.L463:
 984:lwIP/src/core/tcp_in.c ****         pcb->state = CLOSE_WAIT;
 4703              		.loc 1 984 9 is_stmt 1 view .LVU1753
 984:lwIP/src/core/tcp_in.c ****         pcb->state = CLOSE_WAIT;
 4704              		.loc 1 984 9 view .LVU1754
 4705 0a36 638B     		ldrh	r3, [r4, #26]
 985:lwIP/src/core/tcp_in.c ****       }
 4706              		.loc 1 985 20 is_stmt 0 view .LVU1755
 4707 0a38 0722     		movs	r2, #7
 984:lwIP/src/core/tcp_in.c ****         pcb->state = CLOSE_WAIT;
 4708              		.loc 1 984 9 view .LVU1756
 4709 0a3a 43F00203 		orr	r3, r3, #2
 985:lwIP/src/core/tcp_in.c ****       }
 4710              		.loc 1 985 20 view .LVU1757
 4711 0a3e 2275     		strb	r2, [r4, #20]
 984:lwIP/src/core/tcp_in.c ****         pcb->state = CLOSE_WAIT;
 4712              		.loc 1 984 9 view .LVU1758
 4713 0a40 6383     		strh	r3, [r4, #26]	@ movhi
 984:lwIP/src/core/tcp_in.c ****         pcb->state = CLOSE_WAIT;
 4714              		.loc 1 984 9 is_stmt 1 view .LVU1759
ARM GAS  /tmp/ccFjUByx.s 			page 167


 985:lwIP/src/core/tcp_in.c ****       }
 4715              		.loc 1 985 9 view .LVU1760
 4716              	.LVL301:
 985:lwIP/src/core/tcp_in.c ****       }
 4717              		.loc 1 985 9 is_stmt 0 view .LVU1761
 4718              	.LBE341:
 4719              	.LBE370:
 441:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_RESET) {
 4720              		.loc 1 441 5 is_stmt 1 view .LVU1762
 4721 0a42 12E4     		b	.L266
 4722              	.LVL302:
 4723              	.L492:
 4724              	.LBB371:
 4725              	.LBB342:
 4726              	.LBB324:
 4727              	.LBB323:
1148:lwIP/src/core/tcp_in.c **** 
 4728              		.loc 1 1148 3 view .LVU1763
 4729 0a44 2648     		ldr	r0, .L500+16
 4730              	.LVL303:
1148:lwIP/src/core/tcp_in.c **** 
 4731              		.loc 1 1148 3 is_stmt 0 view .LVU1764
 4732 0a46 FFF7FEFF 		bl	printf
 4733              	.LVL304:
 4734              	.L295:
1148:lwIP/src/core/tcp_in.c **** 
 4735              		.loc 1 1148 3 is_stmt 1 view .LVU1765
1148:lwIP/src/core/tcp_in.c **** 
 4736              		.loc 1 1148 3 view .LVU1766
1148:lwIP/src/core/tcp_in.c **** 
 4737              		.loc 1 1148 3 view .LVU1767
1148:lwIP/src/core/tcp_in.c **** 
 4738              		.loc 1 1148 3 view .LVU1768
1148:lwIP/src/core/tcp_in.c **** 
 4739              		.loc 1 1148 3 view .LVU1769
1148:lwIP/src/core/tcp_in.c **** 
 4740              		.loc 1 1148 3 view .LVU1770
 4741 0a4a FEE7     		b	.L295
 4742              	.LVL305:
 4743              	.L488:
1148:lwIP/src/core/tcp_in.c **** 
 4744              		.loc 1 1148 3 is_stmt 0 view .LVU1771
 4745              	.LBE323:
 4746              	.LBE324:
 991:lwIP/src/core/tcp_in.c ****             pcb->unsent == NULL) {
 4747              		.loc 1 991 58 view .LVU1772
 4748 0a4c E36E     		ldr	r3, [r4, #108]
 4749 0a4e 002B     		cmp	r3, #0
 4750 0a50 7FF467AF 		bne	.L302
 994:lwIP/src/core/tcp_in.c ****           tcp_ack_now(pcb);
 4751              		.loc 1 994 124 is_stmt 1 view .LVU1773
 995:lwIP/src/core/tcp_in.c ****           tcp_pcb_purge(pcb);
 4752              		.loc 1 995 11 view .LVU1774
 995:lwIP/src/core/tcp_in.c ****           tcp_pcb_purge(pcb);
 4753              		.loc 1 995 11 view .LVU1775
 4754 0a54 638B     		ldrh	r3, [r4, #26]
 996:lwIP/src/core/tcp_in.c ****           TCP_RMV_ACTIVE(pcb);
ARM GAS  /tmp/ccFjUByx.s 			page 168


 4755              		.loc 1 996 11 is_stmt 0 view .LVU1776
 4756 0a56 2046     		mov	r0, r4
 995:lwIP/src/core/tcp_in.c ****           tcp_pcb_purge(pcb);
 4757              		.loc 1 995 11 view .LVU1777
 4758 0a58 43F00203 		orr	r3, r3, #2
 4759 0a5c 6383     		strh	r3, [r4, #26]	@ movhi
 995:lwIP/src/core/tcp_in.c ****           tcp_pcb_purge(pcb);
 4760              		.loc 1 995 11 is_stmt 1 view .LVU1778
 996:lwIP/src/core/tcp_in.c ****           TCP_RMV_ACTIVE(pcb);
 4761              		.loc 1 996 11 view .LVU1779
 4762 0a5e FFF7FEFF 		bl	tcp_pcb_purge
 4763              	.LVL306:
 997:lwIP/src/core/tcp_in.c ****           pcb->state = TIME_WAIT;
 4764              		.loc 1 997 11 view .LVU1780
 997:lwIP/src/core/tcp_in.c ****           pcb->state = TIME_WAIT;
 4765              		.loc 1 997 11 view .LVU1781
 997:lwIP/src/core/tcp_in.c ****           pcb->state = TIME_WAIT;
 4766              		.loc 1 997 11 view .LVU1782
 4767 0a62 3B68     		ldr	r3, [r7]
 4768 0a64 9C42     		cmp	r4, r3
 4769 0a66 2AD1     		bne	.L303
 4770              	.LVL307:
 4771              	.L465:
1025:lwIP/src/core/tcp_in.c ****         pcb->state = TIME_WAIT;
 4772              		.loc 1 1025 9 view .LVU1783
 4773 0a68 E368     		ldr	r3, [r4, #12]
 4774 0a6a 3B60     		str	r3, [r7]
 4775 0a6c 3CE7     		b	.L312
 4776              	.L490:
 936:lwIP/src/core/tcp_in.c **** #endif
 4777              		.loc 1 936 13 view .LVU1784
 4778 0a6e 1D48     		ldr	r0, .L500+20
 4779 0a70 FFF7FEFF 		bl	printf
 4780              	.LVL308:
 4781              	.L291:
 936:lwIP/src/core/tcp_in.c **** #endif
 4782              		.loc 1 936 13 view .LVU1785
 936:lwIP/src/core/tcp_in.c **** #endif
 4783              		.loc 1 936 13 view .LVU1786
 936:lwIP/src/core/tcp_in.c **** #endif
 4784              		.loc 1 936 13 view .LVU1787
 936:lwIP/src/core/tcp_in.c **** #endif
 4785              		.loc 1 936 13 view .LVU1788
 936:lwIP/src/core/tcp_in.c **** #endif
 4786              		.loc 1 936 13 view .LVU1789
 936:lwIP/src/core/tcp_in.c **** #endif
 4787              		.loc 1 936 13 view .LVU1790
 4788 0a74 FEE7     		b	.L291
 4789              	.L345:
 894:lwIP/src/core/tcp_in.c ****         } else {
 4790              		.loc 1 894 22 is_stmt 0 view .LVU1791
 4791 0a76 4FF0FF33 		mov	r3, #-1
 4792 0a7a 04E7     		b	.L282
 4793              	.LVL309:
 4794              	.L487:
 883:lwIP/src/core/tcp_in.c ****           LWIP_ASSERT("no segment to free", rseg != NULL);
 4795              		.loc 1 883 11 is_stmt 1 view .LVU1792
ARM GAS  /tmp/ccFjUByx.s 			page 169


 883:lwIP/src/core/tcp_in.c ****           LWIP_ASSERT("no segment to free", rseg != NULL);
 4796              		.loc 1 883 16 is_stmt 0 view .LVU1793
 4797 0a7c E06E     		ldr	r0, [r4, #108]
 4798              	.LVL310:
 884:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 4799              		.loc 1 884 11 is_stmt 1 view .LVU1794
 884:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 4800              		.loc 1 884 11 view .LVU1795
 4801 0a7e D0B1     		cbz	r0, .L493
 884:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 4802              		.loc 1 884 11 view .LVU1796
 885:lwIP/src/core/tcp_in.c ****         } else {
 4803              		.loc 1 885 11 view .LVU1797
 885:lwIP/src/core/tcp_in.c ****         } else {
 4804              		.loc 1 885 23 is_stmt 0 view .LVU1798
 4805 0a80 0368     		ldr	r3, [r0]
 4806 0a82 E366     		str	r3, [r4, #108]
 4807 0a84 F6E6     		b	.L281
 4808              	.LVL311:
 4809              	.L486:
 876:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 4810              		.loc 1 876 9 is_stmt 1 view .LVU1799
 4811 0a86 1848     		ldr	r0, .L500+24
 4812 0a88 FFF7FEFF 		bl	printf
 4813              	.LVL312:
 4814              	.L277:
 876:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 4815              		.loc 1 876 9 view .LVU1800
 876:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 4816              		.loc 1 876 9 view .LVU1801
 876:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 4817              		.loc 1 876 9 view .LVU1802
 876:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 4818              		.loc 1 876 9 view .LVU1803
 876:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 4819              		.loc 1 876 9 view .LVU1804
 876:lwIP/src/core/tcp_in.c ****         --pcb->snd_queuelen;
 4820              		.loc 1 876 9 view .LVU1805
 4821 0a8c FEE7     		b	.L277
 4822              	.L299:
 982:lwIP/src/core/tcp_in.c ****       if (recv_flags & TF_GOT_FIN) { /* passive close */
 4823              		.loc 1 982 7 view .LVU1806
 4824              	.LVL313:
 4825              	.LBB325:
 4826              	.LBI325:
1141:lwIP/src/core/tcp_in.c **** {
 4827              		.loc 1 1141 1 view .LVU1807
 4828              	.LBB326:
1143:lwIP/src/core/tcp_in.c ****   u32_t right_wnd_edge;
 4829              		.loc 1 1143 3 view .LVU1808
1144:lwIP/src/core/tcp_in.c ****   int found_dupack = 0;
 4830              		.loc 1 1144 3 view .LVU1809
1145:lwIP/src/core/tcp_in.c **** 
 4831              		.loc 1 1145 3 view .LVU1810
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 4832              		.loc 1 1147 3 view .LVU1811
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
ARM GAS  /tmp/ccFjUByx.s 			page 170


 4833              		.loc 1 1147 3 view .LVU1812
1147:lwIP/src/core/tcp_in.c ****   LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 4834              		.loc 1 1147 3 view .LVU1813
1148:lwIP/src/core/tcp_in.c **** 
 4835              		.loc 1 1148 3 view .LVU1814
1148:lwIP/src/core/tcp_in.c **** 
 4836              		.loc 1 1148 3 view .LVU1815
1148:lwIP/src/core/tcp_in.c **** 
 4837              		.loc 1 1148 3 is_stmt 0 view .LVU1816
 4838 0a8e 2046     		mov	r0, r4
 4839 0a90 FFF7FEFF 		bl	tcp_receive.part.0
 4840              	.LVL314:
1882:lwIP/src/core/tcp_in.c ****     }
 4841              		.loc 1 1882 7 is_stmt 1 view .LVU1817
1882:lwIP/src/core/tcp_in.c ****     }
 4842              		.loc 1 1882 7 is_stmt 0 view .LVU1818
 4843              	.LBE326:
 4844              	.LBE325:
 983:lwIP/src/core/tcp_in.c ****         tcp_ack_now(pcb);
 4845              		.loc 1 983 7 is_stmt 1 view .LVU1819
 983:lwIP/src/core/tcp_in.c ****         tcp_ack_now(pcb);
 4846              		.loc 1 983 10 is_stmt 0 view .LVU1820
 4847 0a94 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 4848 0a96 9806     		lsls	r0, r3, #26
 4849 0a98 7FF5E7AB 		bpl	.L266
 4850 0a9c CBE7     		b	.L463
 4851              	.LVL315:
 4852              	.L491:
 946:lwIP/src/core/tcp_in.c ****               tcp_abort(pcb);
 4853              		.loc 1 946 13 is_stmt 1 view .LVU1821
 946:lwIP/src/core/tcp_in.c ****               tcp_abort(pcb);
 4854              		.loc 1 946 16 is_stmt 0 view .LVU1822
 4855 0a9e 0D30     		adds	r0, r0, #13
 4856 0aa0 3FF4F5AB 		beq	.L262
 4857 0aa4 5CE7     		b	.L464
 4858              	.LVL316:
 4859              	.L297:
 960:lwIP/src/core/tcp_in.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
 4860              		.loc 1 960 23 view .LVU1823
 4861 0aa6 9A42     		cmp	r2, r3
 4862 0aa8 88BF     		it	hi
 4863 0aaa 93B2     		uxthhi	r3, r2
 4864 0aac BDE7     		b	.L298
 4865              	.LVL317:
 4866              	.L274:
 872:lwIP/src/core/tcp_in.c ****         LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
 4867              		.loc 1 872 21 view .LVU1824
 4868 0aae 9A42     		cmp	r2, r3
 4869 0ab0 88BF     		it	hi
 4870 0ab2 93B2     		uxthhi	r3, r2
 4871 0ab4 CEE6     		b	.L275
 4872              	.LVL318:
 4873              	.L493:
 884:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 4874              		.loc 1 884 11 is_stmt 1 view .LVU1825
 4875 0ab6 0D48     		ldr	r0, .L500+28
 4876              	.LVL319:
ARM GAS  /tmp/ccFjUByx.s 			page 171


 884:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 4877              		.loc 1 884 11 is_stmt 0 view .LVU1826
 4878 0ab8 FFF7FEFF 		bl	printf
 4879              	.LVL320:
 4880              	.L280:
 884:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 4881              		.loc 1 884 11 is_stmt 1 view .LVU1827
 884:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 4882              		.loc 1 884 11 view .LVU1828
 884:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 4883              		.loc 1 884 11 view .LVU1829
 884:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 4884              		.loc 1 884 11 view .LVU1830
 884:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 4885              		.loc 1 884 11 view .LVU1831
 884:lwIP/src/core/tcp_in.c ****           pcb->unsent = rseg->next;
 4886              		.loc 1 884 11 view .LVU1832
 4887 0abc FEE7     		b	.L280
 4888              	.LVL321:
 4889              	.L303:
 4890              	.LBB327:
 997:lwIP/src/core/tcp_in.c ****           pcb->state = TIME_WAIT;
 4891              		.loc 1 997 11 view .LVU1833
 997:lwIP/src/core/tcp_in.c ****           pcb->state = TIME_WAIT;
 4892              		.loc 1 997 11 view .LVU1834
 4893 0abe 002B     		cmp	r3, #0
 4894 0ac0 3FF412AF 		beq	.L312
 4895 0ac4 DA68     		ldr	r2, [r3, #12]
 4896 0ac6 9442     		cmp	r4, r2
 4897 0ac8 3FF40CAF 		beq	.L466
 4898 0acc 1346     		mov	r3, r2
 4899              	.LVL322:
 997:lwIP/src/core/tcp_in.c ****           pcb->state = TIME_WAIT;
 4900              		.loc 1 997 11 is_stmt 0 view .LVU1835
 4901 0ace F6E7     		b	.L303
 4902              	.L501:
 4903              		.align	2
 4904              	.L500:
 4905 0ad0 00000000 		.word	.LANCHOR9
 4906 0ad4 00000000 		.word	.LANCHOR8
 4907 0ad8 10000000 		.word	ip_data+16
 4908 0adc 00000000 		.word	.LANCHOR6
 4909 0ae0 C4010000 		.word	.LC23
 4910 0ae4 A4010000 		.word	.LC22
 4911 0ae8 78010000 		.word	.LC20
 4912 0aec 90010000 		.word	.LC21
 4913              	.LBE327:
 4914              	.LBE342:
 4915              	.LBE371:
 4916              		.cfi_endproc
 4917              	.LFE105:
 4919              		.section	.text.tcp_trigger_input_pcb_close,"ax",%progbits
 4920              		.align	1
 4921              		.p2align 2,,3
 4922              		.global	tcp_trigger_input_pcb_close
 4923              		.syntax unified
 4924              		.thumb
ARM GAS  /tmp/ccFjUByx.s 			page 172


 4925              		.thumb_func
 4926              		.fpu fpv4-sp-d16
 4928              	tcp_trigger_input_pcb_close:
 4929              	.LFB114:
2027:lwIP/src/core/tcp_in.c **** 
2028:lwIP/src/core/tcp_in.c **** void
2029:lwIP/src/core/tcp_in.c **** tcp_trigger_input_pcb_close(void)
2030:lwIP/src/core/tcp_in.c **** {
 4930              		.loc 1 2030 1 is_stmt 1 view -0
 4931              		.cfi_startproc
 4932              		@ args = 0, pretend = 0, frame = 0
 4933              		@ frame_needed = 0, uses_anonymous_args = 0
 4934              		@ link register save eliminated.
2031:lwIP/src/core/tcp_in.c ****   recv_flags |= TF_CLOSED;
 4935              		.loc 1 2031 3 view .LVU1837
 4936              		.loc 1 2031 14 is_stmt 0 view .LVU1838
 4937 0000 024A     		ldr	r2, .L503
 4938 0002 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 4939 0004 43F01003 		orr	r3, r3, #16
 4940 0008 1370     		strb	r3, [r2]
2032:lwIP/src/core/tcp_in.c **** }
 4941              		.loc 1 2032 1 view .LVU1839
 4942 000a 7047     		bx	lr
 4943              	.L504:
 4944              		.align	2
 4945              	.L503:
 4946 000c 00000000 		.word	.LANCHOR5
 4947              		.cfi_endproc
 4948              	.LFE114:
 4950              		.comm	tcp_input_pcb,4,4
 4951              		.section	.bss.ackno,"aw",%nobits
 4952              		.align	2
 4953              		.set	.LANCHOR7,. + 0
 4956              	ackno:
 4957 0000 00000000 		.space	4
 4958              		.section	.bss.flags,"aw",%nobits
 4959              		.set	.LANCHOR9,. + 0
 4962              	flags:
 4963 0000 00       		.space	1
 4964              		.section	.bss.inseg,"aw",%nobits
 4965              		.align	2
 4966              		.set	.LANCHOR11,. + 0
 4969              	inseg:
 4970 0000 00000000 		.space	16
 4970      00000000 
 4970      00000000 
 4970      00000000 
 4971              		.section	.bss.recv_acked,"aw",%nobits
 4972              		.align	1
 4973              		.set	.LANCHOR6,. + 0
 4976              	recv_acked:
 4977 0000 0000     		.space	2
 4978              		.section	.bss.recv_data,"aw",%nobits
 4979              		.align	2
 4980              		.set	.LANCHOR12,. + 0
 4983              	recv_data:
 4984 0000 00000000 		.space	4
ARM GAS  /tmp/ccFjUByx.s 			page 173


 4985              		.section	.bss.recv_flags,"aw",%nobits
 4986              		.set	.LANCHOR5,. + 0
 4989              	recv_flags:
 4990 0000 00       		.space	1
 4991              		.section	.bss.seqno,"aw",%nobits
 4992              		.align	2
 4993              		.set	.LANCHOR8,. + 0
 4996              	seqno:
 4997 0000 00000000 		.space	4
 4998              		.section	.bss.tcp_optidx,"aw",%nobits
 4999              		.align	1
 5000              		.set	.LANCHOR1,. + 0
 5003              	tcp_optidx:
 5004 0000 0000     		.space	2
 5005              		.section	.bss.tcphdr,"aw",%nobits
 5006              		.align	2
 5007              		.set	.LANCHOR4,. + 0
 5010              	tcphdr:
 5011 0000 00000000 		.space	4
 5012              		.section	.bss.tcphdr_opt1len,"aw",%nobits
 5013              		.align	1
 5014              		.set	.LANCHOR3,. + 0
 5017              	tcphdr_opt1len:
 5018 0000 0000     		.space	2
 5019              		.section	.bss.tcphdr_opt2,"aw",%nobits
 5020              		.align	2
 5021              		.set	.LANCHOR2,. + 0
 5024              	tcphdr_opt2:
 5025 0000 00000000 		.space	4
 5026              		.section	.bss.tcphdr_optlen,"aw",%nobits
 5027              		.align	1
 5028              		.set	.LANCHOR0,. + 0
 5031              	tcphdr_optlen:
 5032 0000 0000     		.space	2
 5033              		.section	.bss.tcplen,"aw",%nobits
 5034              		.align	1
 5035              		.set	.LANCHOR10,. + 0
 5038              	tcplen:
 5039 0000 0000     		.space	2
 5040              		.text
 5041              	.Letext0:
 5042              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
 5043              		.file 4 "/usr/arm-none-eabi/include/sys/lock.h"
 5044              		.file 5 "/usr/arm-none-eabi/include/sys/_types.h"
 5045              		.file 6 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h"
 5046              		.file 7 "/usr/arm-none-eabi/include/sys/reent.h"
 5047              		.file 8 "/usr/arm-none-eabi/include/stdlib.h"
 5048              		.file 9 "/usr/arm-none-eabi/include/sys/_stdint.h"
 5049              		.file 10 "lwIP/src/include/lwip/arch.h"
 5050              		.file 11 "/usr/arm-none-eabi/include/ctype.h"
 5051              		.file 12 "lwIP/src/include/lwip/tcpbase.h"
 5052              		.file 13 "lwIP/src/include/lwip/err.h"
 5053              		.file 14 "lwIP/src/include/lwip/pbuf.h"
 5054              		.file 15 "lwIP/src/include/lwip/ip4_addr.h"
 5055              		.file 16 "lwIP/src/include/lwip/ip_addr.h"
 5056              		.file 17 "lwIP/src/include/lwip/memp.h"
 5057              		.file 18 "lwIP/src/include/lwip/priv/memp_priv.h"
ARM GAS  /tmp/ccFjUByx.s 			page 174


 5058              		.file 19 "lwIP/src/include/lwip/netif.h"
 5059              		.file 20 "lwIP/src/include/lwip/prot/ip4.h"
 5060              		.file 21 "lwIP/src/include/lwip/ip.h"
 5061              		.file 22 "lwIP/src/include/lwip/tcp.h"
 5062              		.file 23 "lwIP/src/include/lwip/priv/tcp_priv.h"
 5063              		.file 24 "lwIP/src/include/lwip/prot/tcp.h"
 5064              		.file 25 "/usr/arm-none-eabi/include/stdio.h"
 5065              		.file 26 "lwIP/src/include/lwip/inet_chksum.h"
 5066              		.file 27 "lwIP/src/include/lwip/ip4.h"
 5067              		.file 28 "<built-in>"
ARM GAS  /tmp/ccFjUByx.s 			page 175


DEFINED SYMBOLS
                            *ABS*:0000000000000000 tcp_in.c
     /tmp/ccFjUByx.s:18     .rodata.tcp_parseopt.str1.4:0000000000000000 $d
     /tmp/ccFjUByx.s:22     .text.tcp_parseopt:0000000000000000 $t
     /tmp/ccFjUByx.s:30     .text.tcp_parseopt:0000000000000000 tcp_parseopt
     /tmp/ccFjUByx.s:672    .text.tcp_parseopt:0000000000000160 $d
     /tmp/ccFjUByx.s:685    .rodata.tcp_input_delayed_close.str1.4:0000000000000000 $d
     /tmp/ccFjUByx.s:689    .text.tcp_input_delayed_close:0000000000000000 $t
     /tmp/ccFjUByx.s:696    .text.tcp_input_delayed_close:0000000000000000 tcp_input_delayed_close
     /tmp/ccFjUByx.s:787    .text.tcp_input_delayed_close:0000000000000044 $d
     /tmp/ccFjUByx.s:794    .rodata.tcp_free_acked_segments.isra.0.str1.4:0000000000000000 $d
     /tmp/ccFjUByx.s:801    .text.tcp_free_acked_segments.isra.0:0000000000000000 $t
     /tmp/ccFjUByx.s:808    .text.tcp_free_acked_segments.isra.0:0000000000000000 tcp_free_acked_segments.isra.0
     /tmp/ccFjUByx.s:992    .text.tcp_free_acked_segments.isra.0:0000000000000088 $d
     /tmp/ccFjUByx.s:1000   .rodata.tcp_receive.part.0.str1.4:0000000000000000 $d
     /tmp/ccFjUByx.s:1017   .text.tcp_receive.part.0:0000000000000000 $t
     /tmp/ccFjUByx.s:1024   .text.tcp_receive.part.0:0000000000000000 tcp_receive.part.0
     /tmp/ccFjUByx.s:1646   .text.tcp_receive.part.0:00000000000002d4 $d
     /tmp/ccFjUByx.s:1657   .text.tcp_receive.part.0:00000000000002f0 $t
     /tmp/ccFjUByx.s:2135   .text.tcp_receive.part.0:000000000000048c $d
     /tmp/ccFjUByx.s:2147   .rodata.tcp_input.str1.4:0000000000000000 $d
     /tmp/ccFjUByx.s:2196   .text.tcp_input:0000000000000000 $t
     /tmp/ccFjUByx.s:2204   .text.tcp_input:0000000000000000 tcp_input
     /tmp/ccFjUByx.s:3013   .text.tcp_input:00000000000002cc $d
                            *COM*:0000000000000004 tcp_input_pcb
     /tmp/ccFjUByx.s:3034   .text.tcp_input:0000000000000318 $t
     /tmp/ccFjUByx.s:3777   .text.tcp_input:0000000000000638 $d
     /tmp/ccFjUByx.s:3797   .text.tcp_input:0000000000000670 $t
     /tmp/ccFjUByx.s:3835   .text.tcp_input:00000000000006a2 $d
     /tmp/ccFjUByx.s:3843   .text.tcp_input:00000000000006b2 $t
     /tmp/ccFjUByx.s:4538   .text.tcp_input:0000000000000968 $d
     /tmp/ccFjUByx.s:4554   .text.tcp_input:000000000000098c $t
     /tmp/ccFjUByx.s:4905   .text.tcp_input:0000000000000ad0 $d
     /tmp/ccFjUByx.s:4920   .text.tcp_trigger_input_pcb_close:0000000000000000 $t
     /tmp/ccFjUByx.s:4928   .text.tcp_trigger_input_pcb_close:0000000000000000 tcp_trigger_input_pcb_close
     /tmp/ccFjUByx.s:4946   .text.tcp_trigger_input_pcb_close:000000000000000c $d
     /tmp/ccFjUByx.s:4952   .bss.ackno:0000000000000000 $d
     /tmp/ccFjUByx.s:4956   .bss.ackno:0000000000000000 ackno
     /tmp/ccFjUByx.s:4962   .bss.flags:0000000000000000 flags
     /tmp/ccFjUByx.s:4963   .bss.flags:0000000000000000 $d
     /tmp/ccFjUByx.s:4965   .bss.inseg:0000000000000000 $d
     /tmp/ccFjUByx.s:4969   .bss.inseg:0000000000000000 inseg
     /tmp/ccFjUByx.s:4972   .bss.recv_acked:0000000000000000 $d
     /tmp/ccFjUByx.s:4976   .bss.recv_acked:0000000000000000 recv_acked
     /tmp/ccFjUByx.s:4979   .bss.recv_data:0000000000000000 $d
     /tmp/ccFjUByx.s:4983   .bss.recv_data:0000000000000000 recv_data
     /tmp/ccFjUByx.s:4989   .bss.recv_flags:0000000000000000 recv_flags
     /tmp/ccFjUByx.s:4990   .bss.recv_flags:0000000000000000 $d
     /tmp/ccFjUByx.s:4992   .bss.seqno:0000000000000000 $d
     /tmp/ccFjUByx.s:4996   .bss.seqno:0000000000000000 seqno
     /tmp/ccFjUByx.s:4999   .bss.tcp_optidx:0000000000000000 $d
     /tmp/ccFjUByx.s:5003   .bss.tcp_optidx:0000000000000000 tcp_optidx
     /tmp/ccFjUByx.s:5006   .bss.tcphdr:0000000000000000 $d
     /tmp/ccFjUByx.s:5010   .bss.tcphdr:0000000000000000 tcphdr
     /tmp/ccFjUByx.s:5013   .bss.tcphdr_opt1len:0000000000000000 $d
     /tmp/ccFjUByx.s:5017   .bss.tcphdr_opt1len:0000000000000000 tcphdr_opt1len
     /tmp/ccFjUByx.s:5020   .bss.tcphdr_opt2:0000000000000000 $d
ARM GAS  /tmp/ccFjUByx.s 			page 176


     /tmp/ccFjUByx.s:5024   .bss.tcphdr_opt2:0000000000000000 tcphdr_opt2
     /tmp/ccFjUByx.s:5027   .bss.tcphdr_optlen:0000000000000000 $d
     /tmp/ccFjUByx.s:5031   .bss.tcphdr_optlen:0000000000000000 tcphdr_optlen
     /tmp/ccFjUByx.s:5034   .bss.tcplen:0000000000000000 $d
     /tmp/ccFjUByx.s:5038   .bss.tcplen:0000000000000000 tcplen

UNDEFINED SYMBOLS
printf
tcp_pcb_remove
tcp_free
tcp_active_pcbs
pbuf_clen
tcp_seg_free
tcp_send_empty_ack
tcp_ticks
pbuf_remove_header
pbuf_realloc
puts
tcp_update_rcv_ann_wnd
tcp_rexmit_fast
pbuf_free
ip4_addr_isbroadcast_u32
ip_chksum_pseudo
tcp_process_refused_data
ip_data
tcp_tw_pcbs
tcp_output
tcp_alloc
tcp_next_iss
tcp_timer_needed
ip4_route
tcp_eff_send_mss_netif
tcp_enqueue_flags
tcp_rst
tcp_listen_pcbs
tcp_active_pcbs_changed
tcp_pcb_purge
tcp_abandon
tcp_rexmit
tcp_recv_null
tcp_abort
tcp_rexmit_rto
