ARM GAS  /tmp/cctoFbTf.s 			page 1


   1              		.cpu cortex-m7
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"udp.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.udp_init,"ax",%progbits
  18              		.align	1
  19              		.p2align 2,,3
  20              		.global	udp_init
  21              		.arch armv7e-m
  22              		.syntax unified
  23              		.thumb
  24              		.thumb_func
  25              		.fpu fpv4-sp-d16
  27              	udp_init:
  28              	.LFB105:
  29              		.file 1 "lwIP/src/core/udp.c"
   1:lwIP/src/core/udp.c **** /**
   2:lwIP/src/core/udp.c ****  * @file
   3:lwIP/src/core/udp.c ****  * User Datagram Protocol module\n
   4:lwIP/src/core/udp.c ****  * The code for the User Datagram Protocol UDP & UDPLite (RFC 3828).\n
   5:lwIP/src/core/udp.c ****  * See also @ref udp_raw
   6:lwIP/src/core/udp.c ****  *
   7:lwIP/src/core/udp.c ****  * @defgroup udp_raw UDP
   8:lwIP/src/core/udp.c ****  * @ingroup callbackstyle_api
   9:lwIP/src/core/udp.c ****  * User Datagram Protocol module\n
  10:lwIP/src/core/udp.c ****  * @see @ref api
  11:lwIP/src/core/udp.c ****  */
  12:lwIP/src/core/udp.c **** 
  13:lwIP/src/core/udp.c **** /*
  14:lwIP/src/core/udp.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  15:lwIP/src/core/udp.c ****  * All rights reserved.
  16:lwIP/src/core/udp.c ****  *
  17:lwIP/src/core/udp.c ****  * Redistribution and use in source and binary forms, with or without modification,
  18:lwIP/src/core/udp.c ****  * are permitted provided that the following conditions are met:
  19:lwIP/src/core/udp.c ****  *
  20:lwIP/src/core/udp.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  21:lwIP/src/core/udp.c ****  *    this list of conditions and the following disclaimer.
  22:lwIP/src/core/udp.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  23:lwIP/src/core/udp.c ****  *    this list of conditions and the following disclaimer in the documentation
  24:lwIP/src/core/udp.c ****  *    and/or other materials provided with the distribution.
  25:lwIP/src/core/udp.c ****  * 3. The name of the author may not be used to endorse or promote products
  26:lwIP/src/core/udp.c ****  *    derived from this software without specific prior written permission.
  27:lwIP/src/core/udp.c ****  *
  28:lwIP/src/core/udp.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  29:lwIP/src/core/udp.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
ARM GAS  /tmp/cctoFbTf.s 			page 2


  30:lwIP/src/core/udp.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  31:lwIP/src/core/udp.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  32:lwIP/src/core/udp.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  33:lwIP/src/core/udp.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  34:lwIP/src/core/udp.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  35:lwIP/src/core/udp.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  36:lwIP/src/core/udp.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  37:lwIP/src/core/udp.c ****  * OF SUCH DAMAGE.
  38:lwIP/src/core/udp.c ****  *
  39:lwIP/src/core/udp.c ****  * This file is part of the lwIP TCP/IP stack.
  40:lwIP/src/core/udp.c ****  *
  41:lwIP/src/core/udp.c ****  * Author: Adam Dunkels <adam@sics.se>
  42:lwIP/src/core/udp.c ****  *
  43:lwIP/src/core/udp.c ****  */
  44:lwIP/src/core/udp.c **** 
  45:lwIP/src/core/udp.c **** /* @todo Check the use of '(struct udp_pcb).chksum_len_rx'!
  46:lwIP/src/core/udp.c ****  */
  47:lwIP/src/core/udp.c **** 
  48:lwIP/src/core/udp.c **** #include "lwip/opt.h"
  49:lwIP/src/core/udp.c **** 
  50:lwIP/src/core/udp.c **** #if LWIP_UDP /* don't build if not configured for use in lwipopts.h */
  51:lwIP/src/core/udp.c **** 
  52:lwIP/src/core/udp.c **** #include "lwip/udp.h"
  53:lwIP/src/core/udp.c **** #include "lwip/def.h"
  54:lwIP/src/core/udp.c **** #include "lwip/memp.h"
  55:lwIP/src/core/udp.c **** #include "lwip/inet_chksum.h"
  56:lwIP/src/core/udp.c **** #include "lwip/ip_addr.h"
  57:lwIP/src/core/udp.c **** #include "lwip/ip6.h"
  58:lwIP/src/core/udp.c **** #include "lwip/ip6_addr.h"
  59:lwIP/src/core/udp.c **** #include "lwip/netif.h"
  60:lwIP/src/core/udp.c **** #include "lwip/icmp.h"
  61:lwIP/src/core/udp.c **** #include "lwip/icmp6.h"
  62:lwIP/src/core/udp.c **** #include "lwip/stats.h"
  63:lwIP/src/core/udp.c **** #include "lwip/snmp.h"
  64:lwIP/src/core/udp.c **** #include "lwip/dhcp.h"
  65:lwIP/src/core/udp.c **** 
  66:lwIP/src/core/udp.c **** #include <string.h>
  67:lwIP/src/core/udp.c **** 
  68:lwIP/src/core/udp.c **** #ifndef UDP_LOCAL_PORT_RANGE_START
  69:lwIP/src/core/udp.c **** /* From http://www.iana.org/assignments/port-numbers:
  70:lwIP/src/core/udp.c ****    "The Dynamic and/or Private Ports are those from 49152 through 65535" */
  71:lwIP/src/core/udp.c **** #define UDP_LOCAL_PORT_RANGE_START  0xc000
  72:lwIP/src/core/udp.c **** #define UDP_LOCAL_PORT_RANGE_END    0xffff
  73:lwIP/src/core/udp.c **** #define UDP_ENSURE_LOCAL_PORT_RANGE(port) ((u16_t)(((port) & (u16_t)~UDP_LOCAL_PORT_RANGE_START) + 
  74:lwIP/src/core/udp.c **** #endif
  75:lwIP/src/core/udp.c **** 
  76:lwIP/src/core/udp.c **** /* last local UDP port */
  77:lwIP/src/core/udp.c **** static u16_t udp_port = UDP_LOCAL_PORT_RANGE_START;
  78:lwIP/src/core/udp.c **** 
  79:lwIP/src/core/udp.c **** /* The list of UDP PCBs */
  80:lwIP/src/core/udp.c **** /* exported in udp.h (was static) */
  81:lwIP/src/core/udp.c **** struct udp_pcb *udp_pcbs;
  82:lwIP/src/core/udp.c **** 
  83:lwIP/src/core/udp.c **** /**
  84:lwIP/src/core/udp.c ****  * Initialize this module.
  85:lwIP/src/core/udp.c ****  */
  86:lwIP/src/core/udp.c **** void
ARM GAS  /tmp/cctoFbTf.s 			page 3


  87:lwIP/src/core/udp.c **** udp_init(void)
  88:lwIP/src/core/udp.c **** {
  30              		.loc 1 88 1 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 0
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  89:lwIP/src/core/udp.c **** #ifdef LWIP_RAND
  90:lwIP/src/core/udp.c ****   udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
  34              		.loc 1 90 3 view .LVU1
  88:lwIP/src/core/udp.c **** #ifdef LWIP_RAND
  35              		.loc 1 88 1 is_stmt 0 view .LVU2
  36 0000 08B5     		push	{r3, lr}
  37              	.LCFI0:
  38              		.cfi_def_cfa_offset 8
  39              		.cfi_offset 3, -8
  40              		.cfi_offset 14, -4
  41              		.loc 1 90 14 view .LVU3
  42 0002 FFF7FEFF 		bl	rand
  43              	.LVL0:
  44 0006 024B     		ldr	r3, .L4
  45              		.loc 1 90 12 view .LVU4
  46 0008 024A     		ldr	r2, .L4+4
  47              		.loc 1 90 14 view .LVU5
  48 000a 0343     		orrs	r3, r3, r0
  49              		.loc 1 90 12 view .LVU6
  50 000c 1380     		strh	r3, [r2]	@ movhi
  91:lwIP/src/core/udp.c **** #endif /* LWIP_RAND */
  92:lwIP/src/core/udp.c **** }
  51              		.loc 1 92 1 view .LVU7
  52 000e 08BD     		pop	{r3, pc}
  53              	.L5:
  54              		.align	2
  55              	.L4:
  56 0010 00C0FFFF 		.word	-16384
  57 0014 00000000 		.word	.LANCHOR0
  58              		.cfi_endproc
  59              	.LFE105:
  61              		.section	.rodata.udp_input.str1.4,"aMS",%progbits,1
  62              		.align	2
  63              	.LC0:
  64 0000 7564705F 		.ascii	"udp_input: invalid pbuf\000"
  64      696E7075 
  64      743A2069 
  64      6E76616C 
  64      69642070 
  65              		.align	2
  66              	.LC1:
  67 0018 7564705F 		.ascii	"udp_input: invalid netif\000"
  67      696E7075 
  67      743A2069 
  67      6E76616C 
  67      6964206E 
  68 0031 000000   		.align	2
  69              	.LC2:
  70 0034 70627566 		.ascii	"pbuf_remove_header failed\000"
  70      5F72656D 
  70      6F76655F 
ARM GAS  /tmp/cctoFbTf.s 			page 4


  70      68656164 
  70      65722066 
  71              		.section	.text.udp_input,"ax",%progbits
  72              		.align	1
  73              		.p2align 2,,3
  74              		.global	udp_input
  75              		.syntax unified
  76              		.thumb
  77              		.thumb_func
  78              		.fpu fpv4-sp-d16
  80              	udp_input:
  81              	.LVL1:
  82              	.LFB108:
  93:lwIP/src/core/udp.c **** 
  94:lwIP/src/core/udp.c **** /**
  95:lwIP/src/core/udp.c ****  * Allocate a new local UDP port.
  96:lwIP/src/core/udp.c ****  *
  97:lwIP/src/core/udp.c ****  * @return a new (free) local UDP port number
  98:lwIP/src/core/udp.c ****  */
  99:lwIP/src/core/udp.c **** static u16_t
 100:lwIP/src/core/udp.c **** udp_new_port(void)
 101:lwIP/src/core/udp.c **** {
 102:lwIP/src/core/udp.c ****   u16_t n = 0;
 103:lwIP/src/core/udp.c ****   struct udp_pcb *pcb;
 104:lwIP/src/core/udp.c **** 
 105:lwIP/src/core/udp.c **** again:
 106:lwIP/src/core/udp.c ****   if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 107:lwIP/src/core/udp.c ****     udp_port = UDP_LOCAL_PORT_RANGE_START;
 108:lwIP/src/core/udp.c ****   }
 109:lwIP/src/core/udp.c ****   /* Check all PCBs. */
 110:lwIP/src/core/udp.c ****   for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 111:lwIP/src/core/udp.c ****     if (pcb->local_port == udp_port) {
 112:lwIP/src/core/udp.c ****       if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 113:lwIP/src/core/udp.c ****         return 0;
 114:lwIP/src/core/udp.c ****       }
 115:lwIP/src/core/udp.c ****       goto again;
 116:lwIP/src/core/udp.c ****     }
 117:lwIP/src/core/udp.c ****   }
 118:lwIP/src/core/udp.c ****   return udp_port;
 119:lwIP/src/core/udp.c **** }
 120:lwIP/src/core/udp.c **** 
 121:lwIP/src/core/udp.c **** /** Common code to see if the current input packet matches the pcb
 122:lwIP/src/core/udp.c ****  * (current input packet is accessed via ip(4/6)_current_* macros)
 123:lwIP/src/core/udp.c ****  *
 124:lwIP/src/core/udp.c ****  * @param pcb pcb to check
 125:lwIP/src/core/udp.c ****  * @param inp network interface on which the datagram was received (only used for IPv4)
 126:lwIP/src/core/udp.c ****  * @param broadcast 1 if his is an IPv4 broadcast (global or subnet-only), 0 otherwise (only used f
 127:lwIP/src/core/udp.c ****  * @return 1 on match, 0 otherwise
 128:lwIP/src/core/udp.c ****  */
 129:lwIP/src/core/udp.c **** static u8_t
 130:lwIP/src/core/udp.c **** udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
 131:lwIP/src/core/udp.c **** {
 132:lwIP/src/core/udp.c ****   LWIP_UNUSED_ARG(inp);       /* in IPv6 only case */
 133:lwIP/src/core/udp.c ****   LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */
 134:lwIP/src/core/udp.c **** 
 135:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
 136:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
ARM GAS  /tmp/cctoFbTf.s 			page 5


 137:lwIP/src/core/udp.c **** 
 138:lwIP/src/core/udp.c ****   /* check if PCB is bound to specific netif */
 139:lwIP/src/core/udp.c ****   if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 140:lwIP/src/core/udp.c ****       (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 141:lwIP/src/core/udp.c ****     return 0;
 142:lwIP/src/core/udp.c ****   }
 143:lwIP/src/core/udp.c **** 
 144:lwIP/src/core/udp.c ****   /* Dual-stack: PCBs listening to any IP type also listen to any IP address */
 145:lwIP/src/core/udp.c ****   if (IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
 146:lwIP/src/core/udp.c **** #if LWIP_IPV4 && IP_SOF_BROADCAST_RECV
 147:lwIP/src/core/udp.c ****     if ((broadcast != 0) && !ip_get_option(pcb, SOF_BROADCAST)) {
 148:lwIP/src/core/udp.c ****       return 0;
 149:lwIP/src/core/udp.c ****     }
 150:lwIP/src/core/udp.c **** #endif /* LWIP_IPV4 && IP_SOF_BROADCAST_RECV */
 151:lwIP/src/core/udp.c ****     return 1;
 152:lwIP/src/core/udp.c ****   }
 153:lwIP/src/core/udp.c **** 
 154:lwIP/src/core/udp.c ****   /* Only need to check PCB if incoming IP version matches PCB IP version */
 155:lwIP/src/core/udp.c ****   if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
 156:lwIP/src/core/udp.c **** #if LWIP_IPV4
 157:lwIP/src/core/udp.c ****     /* Special case: IPv4 broadcast: all or broadcasts in my subnet
 158:lwIP/src/core/udp.c ****      * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
 159:lwIP/src/core/udp.c ****     if (broadcast != 0) {
 160:lwIP/src/core/udp.c **** #if IP_SOF_BROADCAST_RECV
 161:lwIP/src/core/udp.c ****       if (ip_get_option(pcb, SOF_BROADCAST))
 162:lwIP/src/core/udp.c **** #endif /* IP_SOF_BROADCAST_RECV */
 163:lwIP/src/core/udp.c ****       {
 164:lwIP/src/core/udp.c ****         if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 165:lwIP/src/core/udp.c ****             ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 166:lwIP/src/core/udp.c ****             ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(in
 167:lwIP/src/core/udp.c ****           return 1;
 168:lwIP/src/core/udp.c ****         }
 169:lwIP/src/core/udp.c ****       }
 170:lwIP/src/core/udp.c ****     } else
 171:lwIP/src/core/udp.c **** #endif /* LWIP_IPV4 */
 172:lwIP/src/core/udp.c ****       /* Handle IPv4 and IPv6: all or exact match */
 173:lwIP/src/core/udp.c ****       if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 174:lwIP/src/core/udp.c ****         return 1;
 175:lwIP/src/core/udp.c ****       }
 176:lwIP/src/core/udp.c ****   }
 177:lwIP/src/core/udp.c **** 
 178:lwIP/src/core/udp.c ****   return 0;
 179:lwIP/src/core/udp.c **** }
 180:lwIP/src/core/udp.c **** 
 181:lwIP/src/core/udp.c **** /**
 182:lwIP/src/core/udp.c ****  * Process an incoming UDP datagram.
 183:lwIP/src/core/udp.c ****  *
 184:lwIP/src/core/udp.c ****  * Given an incoming UDP datagram (as a chain of pbufs) this function
 185:lwIP/src/core/udp.c ****  * finds a corresponding UDP PCB and hands over the pbuf to the pcbs
 186:lwIP/src/core/udp.c ****  * recv function. If no pcb is found or the datagram is incorrect, the
 187:lwIP/src/core/udp.c ****  * pbuf is freed.
 188:lwIP/src/core/udp.c ****  *
 189:lwIP/src/core/udp.c ****  * @param p pbuf to be demultiplexed to a UDP PCB (p->payload pointing to the UDP header)
 190:lwIP/src/core/udp.c ****  * @param inp network interface on which the datagram was received.
 191:lwIP/src/core/udp.c ****  *
 192:lwIP/src/core/udp.c ****  */
 193:lwIP/src/core/udp.c **** void
ARM GAS  /tmp/cctoFbTf.s 			page 6


 194:lwIP/src/core/udp.c **** udp_input(struct pbuf *p, struct netif *inp)
 195:lwIP/src/core/udp.c **** {
  83              		.loc 1 195 1 is_stmt 1 view -0
  84              		.cfi_startproc
  85              		@ args = 0, pretend = 0, frame = 16
  86              		@ frame_needed = 0, uses_anonymous_args = 0
 196:lwIP/src/core/udp.c ****   struct udp_hdr *udphdr;
  87              		.loc 1 196 3 view .LVU9
 197:lwIP/src/core/udp.c ****   struct udp_pcb *pcb, *prev;
  88              		.loc 1 197 3 view .LVU10
 198:lwIP/src/core/udp.c ****   struct udp_pcb *uncon_pcb;
  89              		.loc 1 198 3 view .LVU11
 199:lwIP/src/core/udp.c ****   u16_t src, dest;
  90              		.loc 1 199 3 view .LVU12
 200:lwIP/src/core/udp.c ****   u8_t broadcast;
  91              		.loc 1 200 3 view .LVU13
 201:lwIP/src/core/udp.c ****   u8_t for_us = 0;
  92              		.loc 1 201 3 view .LVU14
 202:lwIP/src/core/udp.c **** 
 203:lwIP/src/core/udp.c ****   LWIP_UNUSED_ARG(inp);
  93              		.loc 1 203 3 view .LVU15
 204:lwIP/src/core/udp.c **** 
 205:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
  94              		.loc 1 205 28 view .LVU16
 206:lwIP/src/core/udp.c **** 
 207:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
  95              		.loc 1 207 3 view .LVU17
  96              		.loc 1 207 3 view .LVU18
 195:lwIP/src/core/udp.c ****   struct udp_hdr *udphdr;
  97              		.loc 1 195 1 is_stmt 0 view .LVU19
  98 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
  99              	.LCFI1:
 100              		.cfi_def_cfa_offset 36
 101              		.cfi_offset 4, -36
 102              		.cfi_offset 5, -32
 103              		.cfi_offset 6, -28
 104              		.cfi_offset 7, -24
 105              		.cfi_offset 8, -20
 106              		.cfi_offset 9, -16
 107              		.cfi_offset 10, -12
 108              		.cfi_offset 11, -8
 109              		.cfi_offset 14, -4
 110 0004 87B0     		sub	sp, sp, #28
 111              	.LCFI2:
 112              		.cfi_def_cfa_offset 64
 113              		.loc 1 207 3 view .LVU20
 114 0006 0028     		cmp	r0, #0
 115 0008 00F0AD80 		beq	.L69
 116              		.loc 1 207 3 is_stmt 1 discriminator 2 view .LVU21
 208:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 117              		.loc 1 208 3 discriminator 2 view .LVU22
 118              		.loc 1 208 3 discriminator 2 view .LVU23
 119 000c 0F46     		mov	r7, r1
 120 000e 0029     		cmp	r1, #0
 121 0010 00F0AD80 		beq	.L70
 209:lwIP/src/core/udp.c **** 
 210:lwIP/src/core/udp.c ****   PERF_START;
ARM GAS  /tmp/cctoFbTf.s 			page 7


 211:lwIP/src/core/udp.c **** 
 212:lwIP/src/core/udp.c ****   UDP_STATS_INC(udp.recv);
 213:lwIP/src/core/udp.c **** 
 214:lwIP/src/core/udp.c ****   /* Check minimum length (UDP header) */
 215:lwIP/src/core/udp.c ****   if (p->len < UDP_HLEN) {
 122              		.loc 1 215 6 is_stmt 0 discriminator 2 view .LVU24
 123 0014 4389     		ldrh	r3, [r0, #10]
 124 0016 0546     		mov	r5, r0
 208:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 125              		.loc 1 208 3 is_stmt 1 discriminator 2 view .LVU25
 210:lwIP/src/core/udp.c **** 
 126              		.loc 1 210 13 discriminator 2 view .LVU26
 212:lwIP/src/core/udp.c **** 
 127              		.loc 1 212 26 discriminator 2 view .LVU27
 128              		.loc 1 215 3 discriminator 2 view .LVU28
 129              		.loc 1 215 6 is_stmt 0 discriminator 2 view .LVU29
 130 0018 072B     		cmp	r3, #7
 131 001a 40F29380 		bls	.L22
 216:lwIP/src/core/udp.c ****     /* drop short packets */
 217:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG,
 218:lwIP/src/core/udp.c ****                 ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
 219:lwIP/src/core/udp.c ****     UDP_STATS_INC(udp.lenerr);
 220:lwIP/src/core/udp.c ****     UDP_STATS_INC(udp.drop);
 221:lwIP/src/core/udp.c ****     MIB2_STATS_INC(mib2.udpinerrors);
 222:lwIP/src/core/udp.c ****     pbuf_free(p);
 223:lwIP/src/core/udp.c ****     goto end;
 224:lwIP/src/core/udp.c ****   }
 225:lwIP/src/core/udp.c **** 
 226:lwIP/src/core/udp.c ****   udphdr = (struct udp_hdr *)p->payload;
 132              		.loc 1 226 3 is_stmt 1 view .LVU30
 227:lwIP/src/core/udp.c **** 
 228:lwIP/src/core/udp.c ****   /* is broadcast packet ? */
 229:lwIP/src/core/udp.c ****   broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 133              		.loc 1 229 15 is_stmt 0 view .LVU31
 134 001e 604E     		ldr	r6, .L74
 226:lwIP/src/core/udp.c **** 
 135              		.loc 1 226 10 view .LVU32
 136 0020 D0F80490 		ldr	r9, [r0, #4]
 137              	.LVL2:
 138              		.loc 1 229 3 is_stmt 1 view .LVU33
 139              		.loc 1 229 15 is_stmt 0 view .LVU34
 140 0024 3168     		ldr	r1, [r6]
 141              	.LVL3:
 142              		.loc 1 229 15 view .LVU35
 143 0026 7069     		ldr	r0, [r6, #20]
 144              	.LVL4:
 145              		.loc 1 229 15 view .LVU36
 146 0028 FFF7FEFF 		bl	ip4_addr_isbroadcast_u32
 147              	.LVL5:
 230:lwIP/src/core/udp.c **** 
 231:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));
 232:lwIP/src/core/udp.c **** 
 233:lwIP/src/core/udp.c ****   /* convert src and dest ports to host byte order */
 234:lwIP/src/core/udp.c ****   src = lwip_ntohs(udphdr->src);
 148              		.loc 1 234 9 view .LVU37
 149 002c B9F80020 		ldrh	r2, [r9]	@ unaligned
 235:lwIP/src/core/udp.c ****   dest = lwip_ntohs(udphdr->dest);
ARM GAS  /tmp/cctoFbTf.s 			page 8


 150              		.loc 1 235 10 view .LVU38
 151 0030 B9F80230 		ldrh	r3, [r9, #2]	@ unaligned
 229:lwIP/src/core/udp.c **** 
 152              		.loc 1 229 15 view .LVU39
 153 0034 8046     		mov	r8, r0
 154              	.LVL6:
 231:lwIP/src/core/udp.c **** 
 155              		.loc 1 231 92 is_stmt 1 view .LVU40
 234:lwIP/src/core/udp.c ****   dest = lwip_ntohs(udphdr->dest);
 156              		.loc 1 234 3 view .LVU41
 157              	.LBB26:
 158              	.LBI26:
 159              		.file 2 "STM32_XPD/CMSIS/Include/cmsis_gcc.h"
   1:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /*
   8:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  10:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  12:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  16:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  18:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
  24:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  25:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  28:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  34:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  38:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  39:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  43:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
ARM GAS  /tmp/cctoFbTf.s 			page 9


  45:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  46:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  49:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  55:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  58:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  61:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  64:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  67:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  70:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  78:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  86:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  94:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/cctoFbTf.s 			page 10


 102:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 110:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 113:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 116:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 117:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 118:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   @{
 122:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 123:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 124:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 125:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 129:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 131:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 133:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 134:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 135:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 136:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 140:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 142:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 144:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 145:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 146:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 147:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 151:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 153:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 155:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 158:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/cctoFbTf.s 			page 11


 159:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 160:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 162:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 166:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 168:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 170:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 173:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 174:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 175:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 176:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 177:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 181:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 183:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 185:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 186:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 187:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 189:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 193:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 195:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 197:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 198:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 199:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 200:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 201:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 205:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 207:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 209:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 212:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 213:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 214:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 215:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
ARM GAS  /tmp/cctoFbTf.s 			page 12


 216:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 219:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 221:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 223:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 226:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 227:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 228:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 229:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 233:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 235:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 237:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 240:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 241:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 242:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 243:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 247:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 249:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 251:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 254:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 255:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 256:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 258:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 262:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 264:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 266:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 269:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 270:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 271:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 272:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/cctoFbTf.s 			page 13


 273:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 277:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 279:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 281:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 282:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 283:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 285:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 289:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 291:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 293:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 294:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 295:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 296:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 297:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 301:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 303:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 305:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 308:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 309:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 310:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 312:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 316:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 318:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 320:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 323:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 324:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 325:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 326:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 327:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
ARM GAS  /tmp/cctoFbTf.s 			page 14


 330:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 331:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 333:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 335:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 336:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 337:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 339:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 343:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 345:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 347:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 348:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 349:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 350:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 352:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 356:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 358:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 360:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 363:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 364:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 365:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 366:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 370:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 372:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 374:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 375:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 376:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 377:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 378:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 382:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 384:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 386:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
ARM GAS  /tmp/cctoFbTf.s 			page 15


 387:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 389:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 390:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 391:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 393:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 397:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 399:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 401:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 404:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 405:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 406:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 407:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 408:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 412:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 414:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 416:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 417:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 418:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 420:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 424:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 426:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 428:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 429:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 430:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 431:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 435:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 439:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 441:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 443:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/cctoFbTf.s 			page 16


 444:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 445:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 446:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 450:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 452:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 454:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 455:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 456:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 457:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 461:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 463:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 465:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 468:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 469:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 470:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 472:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 476:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 478:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 480:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 483:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 484:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 485:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 486:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 487:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 491:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 493:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 495:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 496:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 497:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 499:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
ARM GAS  /tmp/cctoFbTf.s 			page 17


 501:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 503:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 505:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 507:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 508:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 509:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 510:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 511:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 516:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 518:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 520:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 521:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 522:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 523:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 527:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 529:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 531:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 534:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 535:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 536:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 538:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 542:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 544:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 546:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 549:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 550:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 551:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 552:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 553:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 557:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
ARM GAS  /tmp/cctoFbTf.s 			page 18


 558:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 559:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 561:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 562:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 563:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 565:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 569:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 571:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 573:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 574:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 575:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 579:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 580:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 583:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 584:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   
 589:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 592:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 594:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 599:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 603:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 604:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 605:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 607:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 611:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 614:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
ARM GAS  /tmp/cctoFbTf.s 			page 19


 615:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 616:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 620:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 624:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 625:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 626:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 627:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 628:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 629:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   
 634:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 637:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 639:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 644:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 646:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 647:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 648:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 649:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 651:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 655:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 658:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 660:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 664:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 666:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 667:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 668:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 669:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 670:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 671:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
ARM GAS  /tmp/cctoFbTf.s 			page 20


 672:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 676:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 679:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 681:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 686:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 690:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 691:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 692:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 693:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 695:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 699:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 702:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 704:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 708:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 712:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 713:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 714:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 715:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 716:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 717:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 722:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 725:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 727:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
ARM GAS  /tmp/cctoFbTf.s 			page 21


 729:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 732:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 734:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 735:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 736:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 737:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 739:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 743:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 746:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 748:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 752:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 754:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 755:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 756:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 757:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 760:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 761:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 762:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 766:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 768:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 776:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 778:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 781:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 782:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 784:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 785:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/cctoFbTf.s 			page 22


 786:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 787:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 788:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 792:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 794:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 802:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 804:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 805:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 807:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 808:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 809:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 810:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 812:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 813:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   @{
 817:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** */
 818:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 819:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 827:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 831:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 832:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 833:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 836:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 838:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 839:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 842:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
ARM GAS  /tmp/cctoFbTf.s 			page 23


 843:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 844:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 845:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 846:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 850:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 852:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 853:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 854:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 857:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 859:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 860:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 861:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 866:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 868:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 870:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 871:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 872:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 873:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 877:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 879:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 881:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 882:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 883:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 884:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 885:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 886:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 887:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 888:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 890:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 892:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 893:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 894:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 895:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 899:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/cctoFbTf.s 			page 24


 900:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 901:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 902:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 903:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 904:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 905:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 906:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 907:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 909:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 910:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 911:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 912:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 913:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 914:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 917:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 918:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 919:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 921:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 922:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 923:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 924:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 925:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 926:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 927:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 928:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 929:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 933:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 160              		.loc 2 934 30 view .LVU42
 161              	.LBB27:
 935:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 936:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 162              		.loc 2 937 3 view .LVU43
 163              		.loc 2 937 19 is_stmt 0 view .LVU44
 164 0036 52BA     		rev16	r2, r2
 165              	.LBE27:
 166              	.LBE26:
 236:lwIP/src/core/udp.c **** 
 237:lwIP/src/core/udp.c ****   udp_debug_print(udphdr);
 238:lwIP/src/core/udp.c **** 
 239:lwIP/src/core/udp.c ****   /* print the UDP source and destination */
 240:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp ("));
 241:lwIP/src/core/udp.c ****   ip_addr_debug_print_val(UDP_DEBUG, *ip_current_dest_addr());
 242:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
 243:lwIP/src/core/udp.c ****   ip_addr_debug_print_val(UDP_DEBUG, *ip_current_src_addr());
 244:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));
 245:lwIP/src/core/udp.c **** 
 246:lwIP/src/core/udp.c ****   pcb = NULL;
 247:lwIP/src/core/udp.c ****   prev = NULL;
ARM GAS  /tmp/cctoFbTf.s 			page 25


 248:lwIP/src/core/udp.c ****   uncon_pcb = NULL;
 249:lwIP/src/core/udp.c ****   /* Iterate through the UDP pcb list for a matching pcb.
 250:lwIP/src/core/udp.c ****    * 'Perfect match' pcbs (connected to the remote port & ip address) are
 251:lwIP/src/core/udp.c ****    * preferred. If no perfect match is found, the first unconnected pcb that
 252:lwIP/src/core/udp.c ****    * matches the local port and ip address gets the datagram. */
 253:lwIP/src/core/udp.c ****   for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 167              		.loc 1 253 12 view .LVU45
 168 0038 5A49     		ldr	r1, .L74+4
 169              	.LBB30:
 170              	.LBB31:
 171              		.loc 2 937 19 view .LVU46
 172 003a 5BBA     		rev16	r3, r3
 173              	.LBE31:
 174              	.LBE30:
 175              	.LBB34:
 176              	.LBB28:
 177 003c 92B2     		uxth	r2, r2
 178              	.LBE28:
 179              	.LBE34:
 180              		.loc 1 253 12 view .LVU47
 181 003e D1F800A0 		ldr	r10, [r1]
 182              	.LBB35:
 183              	.LBB32:
 184              		.loc 2 937 19 view .LVU48
 185 0042 98B2     		uxth	r0, r3
 186              	.LBE32:
 187              	.LBE35:
 188              	.LBB36:
 189              	.LBB29:
 190 0044 9346     		mov	fp, r2
 191              	.LVL7:
 192              		.loc 2 937 19 view .LVU49
 193              	.LBE29:
 194              	.LBE36:
 235:lwIP/src/core/udp.c **** 
 195              		.loc 1 235 3 is_stmt 1 view .LVU50
 196              	.LBB37:
 197              	.LBI30:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 198              		.loc 2 934 30 view .LVU51
 199              	.LBB33:
 200              		.loc 2 937 3 view .LVU52
 201              		.loc 2 937 3 is_stmt 0 view .LVU53
 202              	.LBE33:
 203              	.LBE37:
 237:lwIP/src/core/udp.c **** 
 204              		.loc 1 237 26 is_stmt 1 view .LVU54
 240:lwIP/src/core/udp.c ****   ip_addr_debug_print_val(UDP_DEBUG, *ip_current_dest_addr());
 205              		.loc 1 240 36 view .LVU55
 241:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
 206              		.loc 1 241 62 view .LVU56
 242:lwIP/src/core/udp.c ****   ip_addr_debug_print_val(UDP_DEBUG, *ip_current_src_addr());
 207              		.loc 1 242 74 view .LVU57
 243:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));
 208              		.loc 1 243 61 view .LVU58
 244:lwIP/src/core/udp.c **** 
 209              		.loc 1 244 69 view .LVU59
ARM GAS  /tmp/cctoFbTf.s 			page 26


 246:lwIP/src/core/udp.c ****   prev = NULL;
 210              		.loc 1 246 3 view .LVU60
 247:lwIP/src/core/udp.c ****   uncon_pcb = NULL;
 211              		.loc 1 247 3 view .LVU61
 248:lwIP/src/core/udp.c ****   /* Iterate through the UDP pcb list for a matching pcb.
 212              		.loc 1 248 3 view .LVU62
 213              		.loc 1 253 3 view .LVU63
 214              		.loc 1 253 24 view .LVU64
 215              		.loc 1 253 3 is_stmt 0 view .LVU65
 216 0046 BAF1000F 		cmp	r10, #0
 217 004a 00F09480 		beq	.L12
 218              	.LBB38:
 219              	.LBB39:
 140:lwIP/src/core/udp.c ****     return 0;
 220              		.loc 1 140 26 view .LVU66
 221 004e 7268     		ldr	r2, [r6, #4]
 222              	.LVL8:
 140:lwIP/src/core/udp.c ****     return 0;
 223              		.loc 1 140 26 view .LVU67
 224              	.LBE39:
 225              	.LBE38:
 248:lwIP/src/core/udp.c ****   /* Iterate through the UDP pcb list for a matching pcb.
 226              		.loc 1 248 13 view .LVU68
 227 0050 0023     		movs	r3, #0
 228              	.LVL9:
 254:lwIP/src/core/udp.c ****     /* print the PCB local and remote address */
 255:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("pcb ("));
 256:lwIP/src/core/udp.c ****     ip_addr_debug_print_val(UDP_DEBUG, pcb->local_ip);
 257:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
 258:lwIP/src/core/udp.c ****     ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
 259:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));
 260:lwIP/src/core/udp.c **** 
 261:lwIP/src/core/udp.c ****     /* compare PCB local addr+port to UDP destination addr+port */
 262:lwIP/src/core/udp.c ****     if ((pcb->local_port == dest) &&
 263:lwIP/src/core/udp.c ****         (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 264:lwIP/src/core/udp.c ****       if ((pcb->flags & UDP_FLAGS_CONNECTED) == 0) {
 265:lwIP/src/core/udp.c ****         if (uncon_pcb == NULL) {
 266:lwIP/src/core/udp.c ****           /* the first unconnected matching PCB */
 267:lwIP/src/core/udp.c ****           uncon_pcb = pcb;
 268:lwIP/src/core/udp.c **** #if LWIP_IPV4
 269:lwIP/src/core/udp.c ****         } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
 270:lwIP/src/core/udp.c ****           /* global broadcast address (only valid for IPv4; match was checked before) */
 271:lwIP/src/core/udp.c ****           if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), n
 272:lwIP/src/core/udp.c ****             /* uncon_pcb does not match the input netif, check this pcb */
 273:lwIP/src/core/udp.c ****             if (IP_IS_V4_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), netif_ip4_add
 274:lwIP/src/core/udp.c ****               /* better match */
 275:lwIP/src/core/udp.c ****               uncon_pcb = pcb;
 276:lwIP/src/core/udp.c ****             }
 277:lwIP/src/core/udp.c ****           }
 278:lwIP/src/core/udp.c **** #endif /* LWIP_IPV4 */
 279:lwIP/src/core/udp.c ****         }
 280:lwIP/src/core/udp.c **** #if SO_REUSE
 281:lwIP/src/core/udp.c ****         else if (!ip_addr_isany(&pcb->local_ip)) {
 282:lwIP/src/core/udp.c ****           /* prefer specific IPs over catch-all */
 283:lwIP/src/core/udp.c ****           uncon_pcb = pcb;
 284:lwIP/src/core/udp.c ****         }
 285:lwIP/src/core/udp.c **** #endif /* SO_REUSE */
ARM GAS  /tmp/cctoFbTf.s 			page 27


 286:lwIP/src/core/udp.c ****       }
 287:lwIP/src/core/udp.c **** 
 288:lwIP/src/core/udp.c ****       /* compare PCB remote addr+port to UDP source addr+port */
 289:lwIP/src/core/udp.c ****       if ((pcb->remote_port == src) &&
 290:lwIP/src/core/udp.c ****           (ip_addr_isany_val(pcb->remote_ip) ||
 291:lwIP/src/core/udp.c ****            ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 229              		.loc 1 291 12 view .LVU69
 230 0052 3169     		ldr	r1, [r6, #16]
 231 0054 5446     		mov	r4, r10
 232              	.LBB44:
 233              	.LBB40:
 140:lwIP/src/core/udp.c ****     return 0;
 234              		.loc 1 140 26 view .LVU70
 235 0056 0592     		str	r2, [sp, #20]
 236              	.LBE40:
 237              	.LBE44:
 247:lwIP/src/core/udp.c ****   uncon_pcb = NULL;
 238              		.loc 1 247 8 view .LVU71
 239 0058 9E46     		mov	lr, r3
 240              	.LBB45:
 241              	.LBB41:
 173:lwIP/src/core/udp.c ****         return 1;
 242              		.loc 1 173 44 view .LVU72
 243 005a 7269     		ldr	r2, [r6, #20]
 244 005c CDE90301 		strd	r0, r1, [sp, #12]
 245 0060 04E0     		b	.L20
 246              	.LVL10:
 247              	.L13:
 173:lwIP/src/core/udp.c ****         return 1;
 248              		.loc 1 173 44 view .LVU73
 249              	.LBE41:
 250              	.LBE45:
 292:lwIP/src/core/udp.c ****         /* the first fully matching PCB */
 293:lwIP/src/core/udp.c ****         if (prev != NULL) {
 294:lwIP/src/core/udp.c ****           /* move the pcb to the front of udp_pcbs so that is
 295:lwIP/src/core/udp.c ****              found faster next time */
 296:lwIP/src/core/udp.c ****           prev->next = pcb->next;
 297:lwIP/src/core/udp.c ****           pcb->next = udp_pcbs;
 298:lwIP/src/core/udp.c ****           udp_pcbs = pcb;
 299:lwIP/src/core/udp.c ****         } else {
 300:lwIP/src/core/udp.c ****           UDP_STATS_INC(udp.cachehit);
 301:lwIP/src/core/udp.c ****         }
 302:lwIP/src/core/udp.c ****         break;
 303:lwIP/src/core/udp.c ****       }
 304:lwIP/src/core/udp.c ****     }
 305:lwIP/src/core/udp.c **** 
 306:lwIP/src/core/udp.c ****     prev = pcb;
 251              		.loc 1 306 5 is_stmt 1 discriminator 2 view .LVU74
 253:lwIP/src/core/udp.c ****     /* print the PCB local and remote address */
 252              		.loc 1 253 37 discriminator 2 view .LVU75
 253:lwIP/src/core/udp.c ****     /* print the PCB local and remote address */
 253              		.loc 1 253 41 is_stmt 0 discriminator 2 view .LVU76
 254 0062 E168     		ldr	r1, [r4, #12]
 255              	.LVL11:
 253:lwIP/src/core/udp.c ****     /* print the PCB local and remote address */
 256              		.loc 1 253 24 is_stmt 1 discriminator 2 view .LVU77
 257 0064 A646     		mov	lr, r4
ARM GAS  /tmp/cctoFbTf.s 			page 28


 253:lwIP/src/core/udp.c ****     /* print the PCB local and remote address */
 258              		.loc 1 253 3 is_stmt 0 discriminator 2 view .LVU78
 259 0066 0029     		cmp	r1, #0
 260 0068 7AD0     		beq	.L71
 261              	.L30:
 253:lwIP/src/core/udp.c ****     /* print the PCB local and remote address */
 262              		.loc 1 253 3 discriminator 2 view .LVU79
 263 006a 0C46     		mov	r4, r1
 264              	.LVL12:
 265              	.L20:
 255:lwIP/src/core/udp.c ****     ip_addr_debug_print_val(UDP_DEBUG, pcb->local_ip);
 266              		.loc 1 255 38 is_stmt 1 view .LVU80
 256:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
 267              		.loc 1 256 54 view .LVU81
 257:lwIP/src/core/udp.c ****     ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
 268              		.loc 1 257 67 view .LVU82
 258:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));
 269              		.loc 1 258 55 view .LVU83
 259:lwIP/src/core/udp.c **** 
 270              		.loc 1 259 64 view .LVU84
 262:lwIP/src/core/udp.c ****         (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 271              		.loc 1 262 5 view .LVU85
 262:lwIP/src/core/udp.c ****         (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 272              		.loc 1 262 8 is_stmt 0 view .LVU86
 273 006c 618A     		ldrh	r1, [r4, #18]
 274 006e 0398     		ldr	r0, [sp, #12]
 275 0070 8142     		cmp	r1, r0
 276 0072 F6D1     		bne	.L13
 277              	.LVL13:
 278              	.LBB46:
 279              	.LBI38:
 130:lwIP/src/core/udp.c **** {
 280              		.loc 1 130 1 is_stmt 1 view .LVU87
 281              	.LBB42:
 132:lwIP/src/core/udp.c ****   LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */
 282              		.loc 1 132 3 view .LVU88
 133:lwIP/src/core/udp.c **** 
 283              		.loc 1 133 3 view .LVU89
 135:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
 284              		.loc 1 135 3 view .LVU90
 135:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
 285              		.loc 1 135 3 view .LVU91
 135:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
 286              		.loc 1 135 3 view .LVU92
 136:lwIP/src/core/udp.c **** 
 287              		.loc 1 136 3 view .LVU93
 136:lwIP/src/core/udp.c **** 
 288              		.loc 1 136 3 view .LVU94
 136:lwIP/src/core/udp.c **** 
 289              		.loc 1 136 3 view .LVU95
 139:lwIP/src/core/udp.c ****       (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 290              		.loc 1 139 3 view .LVU96
 139:lwIP/src/core/udp.c ****       (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 291              		.loc 1 139 11 is_stmt 0 view .LVU97
 292 0074 94F808C0 		ldrb	ip, [r4, #8]	@ zero_extendqisi2
 139:lwIP/src/core/udp.c ****       (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 293              		.loc 1 139 6 view .LVU98
ARM GAS  /tmp/cctoFbTf.s 			page 29


 294 0078 BCF1000F 		cmp	ip, #0
 295 007c 06D0     		beq	.L14
 140:lwIP/src/core/udp.c ****     return 0;
 296              		.loc 1 140 26 view .LVU99
 297 007e 0599     		ldr	r1, [sp, #20]
 298 0080 91F82810 		ldrb	r1, [r1, #40]	@ zero_extendqisi2
 299 0084 0131     		adds	r1, r1, #1
 139:lwIP/src/core/udp.c ****       (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 300              		.loc 1 139 42 view .LVU100
 301 0086 C9B2     		uxtb	r1, r1
 302 0088 8C45     		cmp	ip, r1
 303 008a EAD1     		bne	.L13
 304              	.L14:
 145:lwIP/src/core/udp.c **** #if LWIP_IPV4 && IP_SOF_BROADCAST_RECV
 305              		.loc 1 145 3 is_stmt 1 view .LVU101
 155:lwIP/src/core/udp.c **** #if LWIP_IPV4
 306              		.loc 1 155 3 view .LVU102
 159:lwIP/src/core/udp.c **** #if IP_SOF_BROADCAST_RECV
 307              		.loc 1 159 5 view .LVU103
 308 008c 2168     		ldr	r1, [r4]
 159:lwIP/src/core/udp.c **** #if IP_SOF_BROADCAST_RECV
 309              		.loc 1 159 8 is_stmt 0 view .LVU104
 310 008e B8F1000F 		cmp	r8, #0
 311 0092 5DD0     		beq	.L15
 164:lwIP/src/core/udp.c ****             ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 312              		.loc 1 164 9 is_stmt 1 view .LVU105
 164:lwIP/src/core/udp.c ****             ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 313              		.loc 1 164 13 is_stmt 0 view .LVU106
 314 0094 39B1     		cbz	r1, .L16
 164:lwIP/src/core/udp.c ****             ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 315              		.loc 1 164 54 view .LVU107
 316 0096 501C     		adds	r0, r2, #1
 317 0098 05D0     		beq	.L16
 166:lwIP/src/core/udp.c ****           return 1;
 318              		.loc 1 166 13 view .LVU108
 319 009a 81EA020C 		eor	ip, r1, r2
 165:lwIP/src/core/udp.c ****             ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(in
 320              		.loc 1 165 67 view .LVU109
 321 009e 7868     		ldr	r0, [r7, #4]
 322 00a0 1CEA000F 		tst	ip, r0
 323 00a4 DDD1     		bne	.L13
 324              	.L16:
 325              	.LVL14:
 165:lwIP/src/core/udp.c ****             ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(in
 326              		.loc 1 165 67 view .LVU110
 327              	.LBE42:
 328              	.LBE46:
 264:lwIP/src/core/udp.c ****         if (uncon_pcb == NULL) {
 329              		.loc 1 264 7 is_stmt 1 view .LVU111
 264:lwIP/src/core/udp.c ****         if (uncon_pcb == NULL) {
 330              		.loc 1 264 10 is_stmt 0 view .LVU112
 331 00a6 94F810C0 		ldrb	ip, [r4, #16]	@ zero_extendqisi2
 332 00aa 1CF0040F 		tst	ip, #4
 333 00ae 06D1     		bne	.L17
 265:lwIP/src/core/udp.c ****           /* the first unconnected matching PCB */
 334              		.loc 1 265 9 is_stmt 1 view .LVU113
 265:lwIP/src/core/udp.c ****           /* the first unconnected matching PCB */
ARM GAS  /tmp/cctoFbTf.s 			page 30


 335              		.loc 1 265 12 is_stmt 0 view .LVU114
 336 00b0 002B     		cmp	r3, #0
 337 00b2 73D0     		beq	.L29
 269:lwIP/src/core/udp.c ****           /* global broadcast address (only valid for IPv4; match was checked before) */
 338              		.loc 1 269 16 is_stmt 1 view .LVU115
 269:lwIP/src/core/udp.c ****           /* global broadcast address (only valid for IPv4; match was checked before) */
 339              		.loc 1 269 19 is_stmt 0 view .LVU116
 340 00b4 B8F1000F 		cmp	r8, #0
 341 00b8 01D0     		beq	.L17
 269:lwIP/src/core/udp.c ****           /* global broadcast address (only valid for IPv4; match was checked before) */
 342              		.loc 1 269 30 discriminator 1 view .LVU117
 343 00ba 501C     		adds	r0, r2, #1
 344 00bc 61D0     		beq	.L72
 345              	.LVL15:
 346              	.L17:
 289:lwIP/src/core/udp.c ****           (ip_addr_isany_val(pcb->remote_ip) ||
 347              		.loc 1 289 7 is_stmt 1 view .LVU118
 289:lwIP/src/core/udp.c ****           (ip_addr_isany_val(pcb->remote_ip) ||
 348              		.loc 1 289 10 is_stmt 0 view .LVU119
 349 00be A18A     		ldrh	r1, [r4, #20]
 350 00c0 5945     		cmp	r1, fp
 351 00c2 CED1     		bne	.L13
 290:lwIP/src/core/udp.c ****            ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 352              		.loc 1 290 12 discriminator 1 view .LVU120
 353 00c4 6168     		ldr	r1, [r4, #4]
 289:lwIP/src/core/udp.c ****           (ip_addr_isany_val(pcb->remote_ip) ||
 354              		.loc 1 289 37 discriminator 1 view .LVU121
 355 00c6 11B1     		cbz	r1, .L18
 290:lwIP/src/core/udp.c ****            ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 356              		.loc 1 290 46 view .LVU122
 357 00c8 0498     		ldr	r0, [sp, #16]
 358 00ca 8142     		cmp	r1, r0
 359 00cc C9D1     		bne	.L13
 360              	.L18:
 293:lwIP/src/core/udp.c ****           /* move the pcb to the front of udp_pcbs so that is
 361              		.loc 1 293 9 is_stmt 1 view .LVU123
 293:lwIP/src/core/udp.c ****           /* move the pcb to the front of udp_pcbs so that is
 362              		.loc 1 293 12 is_stmt 0 view .LVU124
 363 00ce BEF1000F 		cmp	lr, #0
 364 00d2 06D0     		beq	.L19
 296:lwIP/src/core/udp.c ****           pcb->next = udp_pcbs;
 365              		.loc 1 296 11 is_stmt 1 view .LVU125
 296:lwIP/src/core/udp.c ****           pcb->next = udp_pcbs;
 366              		.loc 1 296 27 is_stmt 0 view .LVU126
 367 00d4 E368     		ldr	r3, [r4, #12]
 368              	.LVL16:
 298:lwIP/src/core/udp.c ****         } else {
 369              		.loc 1 298 20 view .LVU127
 370 00d6 334A     		ldr	r2, .L74+4
 296:lwIP/src/core/udp.c ****           pcb->next = udp_pcbs;
 371              		.loc 1 296 22 view .LVU128
 372 00d8 CEF80C30 		str	r3, [lr, #12]
 297:lwIP/src/core/udp.c ****           udp_pcbs = pcb;
 373              		.loc 1 297 11 is_stmt 1 view .LVU129
 298:lwIP/src/core/udp.c ****         } else {
 374              		.loc 1 298 20 is_stmt 0 view .LVU130
 375 00dc 1460     		str	r4, [r2]
ARM GAS  /tmp/cctoFbTf.s 			page 31


 297:lwIP/src/core/udp.c ****           udp_pcbs = pcb;
 376              		.loc 1 297 21 view .LVU131
 377 00de C4F80CA0 		str	r10, [r4, #12]
 298:lwIP/src/core/udp.c ****         } else {
 378              		.loc 1 298 11 is_stmt 1 view .LVU132
 379              	.LVL17:
 380              	.L19:
 307:lwIP/src/core/udp.c ****   }
 308:lwIP/src/core/udp.c ****   /* no fully matching pcb found? then look for an unconnected pcb */
 309:lwIP/src/core/udp.c ****   if (pcb == NULL) {
 310:lwIP/src/core/udp.c ****     pcb = uncon_pcb;
 311:lwIP/src/core/udp.c ****   }
 312:lwIP/src/core/udp.c **** 
 313:lwIP/src/core/udp.c ****   /* Check checksum if this is a match or if it was directed at us. */
 314:lwIP/src/core/udp.c ****   if (pcb != NULL) {
 315:lwIP/src/core/udp.c ****     for_us = 1;
 316:lwIP/src/core/udp.c ****   } else {
 317:lwIP/src/core/udp.c **** #if LWIP_IPV6
 318:lwIP/src/core/udp.c ****     if (ip_current_is_v6()) {
 319:lwIP/src/core/udp.c ****       for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
 320:lwIP/src/core/udp.c ****     }
 321:lwIP/src/core/udp.c **** #endif /* LWIP_IPV6 */
 322:lwIP/src/core/udp.c **** #if LWIP_IPV4
 323:lwIP/src/core/udp.c ****     if (!ip_current_is_v6()) {
 324:lwIP/src/core/udp.c ****       for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 325:lwIP/src/core/udp.c ****     }
 326:lwIP/src/core/udp.c **** #endif /* LWIP_IPV4 */
 327:lwIP/src/core/udp.c ****   }
 328:lwIP/src/core/udp.c **** 
 329:lwIP/src/core/udp.c ****   if (for_us) {
 330:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
 381              		.loc 1 330 83 view .LVU133
 331:lwIP/src/core/udp.c **** #if CHECKSUM_CHECK_UDP
 332:lwIP/src/core/udp.c ****     IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_UDP) {
 333:lwIP/src/core/udp.c **** #if LWIP_UDPLITE
 334:lwIP/src/core/udp.c ****       if (ip_current_header_proto() == IP_PROTO_UDPLITE) {
 335:lwIP/src/core/udp.c ****         /* Do the UDP Lite checksum */
 336:lwIP/src/core/udp.c ****         u16_t chklen = lwip_ntohs(udphdr->len);
 337:lwIP/src/core/udp.c ****         if (chklen < sizeof(struct udp_hdr)) {
 338:lwIP/src/core/udp.c ****           if (chklen == 0) {
 339:lwIP/src/core/udp.c ****             /* For UDP-Lite, checksum length of 0 means checksum
 340:lwIP/src/core/udp.c ****                over the complete packet (See RFC 3828 chap. 3.1) */
 341:lwIP/src/core/udp.c ****             chklen = p->tot_len;
 342:lwIP/src/core/udp.c ****           } else {
 343:lwIP/src/core/udp.c ****             /* At least the UDP-Lite header must be covered by the
 344:lwIP/src/core/udp.c ****                checksum! (Again, see RFC 3828 chap. 3.1) */
 345:lwIP/src/core/udp.c ****             goto chkerr;
 346:lwIP/src/core/udp.c ****           }
 347:lwIP/src/core/udp.c ****         }
 348:lwIP/src/core/udp.c ****         if (ip_chksum_pseudo_partial(p, IP_PROTO_UDPLITE,
 349:lwIP/src/core/udp.c ****                                      p->tot_len, chklen,
 350:lwIP/src/core/udp.c ****                                      ip_current_src_addr(), ip_current_dest_addr()) != 0) {
 351:lwIP/src/core/udp.c ****           goto chkerr;
 352:lwIP/src/core/udp.c ****         }
 353:lwIP/src/core/udp.c ****       } else
 354:lwIP/src/core/udp.c **** #endif /* LWIP_UDPLITE */
 355:lwIP/src/core/udp.c ****       {
ARM GAS  /tmp/cctoFbTf.s 			page 32


 356:lwIP/src/core/udp.c ****         if (udphdr->chksum != 0) {
 382              		.loc 1 356 9 view .LVU134
 383              		.loc 1 356 12 is_stmt 0 view .LVU135
 384 00e2 B9F80630 		ldrh	r3, [r9, #6]	@ unaligned
 385 00e6 43B1     		cbz	r3, .L23
 357:lwIP/src/core/udp.c ****           if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
 386              		.loc 1 357 11 is_stmt 1 view .LVU136
 387              		.loc 1 357 15 is_stmt 0 view .LVU137
 388 00e8 2F4B     		ldr	r3, .L74+8
 389 00ea 1121     		movs	r1, #17
 390 00ec 2A89     		ldrh	r2, [r5, #8]
 391 00ee 2846     		mov	r0, r5
 392 00f0 0093     		str	r3, [sp]
 393 00f2 043B     		subs	r3, r3, #4
 394 00f4 FFF7FEFF 		bl	ip_chksum_pseudo
 395              	.LVL18:
 396              		.loc 1 357 14 view .LVU138
 397 00f8 20BB     		cbnz	r0, .L22
 398              	.L23:
 358:lwIP/src/core/udp.c ****                                ip_current_src_addr(),
 359:lwIP/src/core/udp.c ****                                ip_current_dest_addr()) != 0) {
 360:lwIP/src/core/udp.c ****             goto chkerr;
 361:lwIP/src/core/udp.c ****           }
 362:lwIP/src/core/udp.c ****         }
 363:lwIP/src/core/udp.c ****       }
 364:lwIP/src/core/udp.c ****     }
 365:lwIP/src/core/udp.c **** #endif /* CHECKSUM_CHECK_UDP */
 366:lwIP/src/core/udp.c ****     if (pbuf_remove_header(p, UDP_HLEN)) {
 399              		.loc 1 366 5 is_stmt 1 view .LVU139
 400              		.loc 1 366 9 is_stmt 0 view .LVU140
 401 00fa 0821     		movs	r1, #8
 402 00fc 2846     		mov	r0, r5
 403 00fe FFF7FEFF 		bl	pbuf_remove_header
 404              	.LVL19:
 405              		.loc 1 366 8 view .LVU141
 406 0102 0028     		cmp	r0, #0
 407 0104 46D1     		bne	.L73
 367:lwIP/src/core/udp.c ****       /* Can we cope with this failing? Just assert for now */
 368:lwIP/src/core/udp.c ****       LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 369:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 370:lwIP/src/core/udp.c ****       MIB2_STATS_INC(mib2.udpinerrors);
 371:lwIP/src/core/udp.c ****       pbuf_free(p);
 372:lwIP/src/core/udp.c ****       goto end;
 373:lwIP/src/core/udp.c ****     }
 374:lwIP/src/core/udp.c **** 
 375:lwIP/src/core/udp.c ****     if (pcb != NULL) {
 408              		.loc 1 375 5 is_stmt 1 view .LVU142
 409              		.loc 1 375 8 is_stmt 0 view .LVU143
 410 0106 5CB1     		cbz	r4, .L26
 376:lwIP/src/core/udp.c ****       MIB2_STATS_INC(mib2.udpindatagrams);
 411              		.loc 1 376 42 is_stmt 1 view .LVU144
 377:lwIP/src/core/udp.c **** #if SO_REUSE && SO_REUSE_RXTOALL
 378:lwIP/src/core/udp.c ****       if (ip_get_option(pcb, SOF_REUSEADDR) &&
 379:lwIP/src/core/udp.c ****           (broadcast || ip_addr_ismulticast(ip_current_dest_addr()))) {
 380:lwIP/src/core/udp.c ****         /* pass broadcast- or multicast packets to all multicast pcbs
 381:lwIP/src/core/udp.c ****            if SOF_REUSEADDR is set on the first match */
 382:lwIP/src/core/udp.c ****         struct udp_pcb *mpcb;
ARM GAS  /tmp/cctoFbTf.s 			page 33


 383:lwIP/src/core/udp.c ****         for (mpcb = udp_pcbs; mpcb != NULL; mpcb = mpcb->next) {
 384:lwIP/src/core/udp.c ****           if (mpcb != pcb) {
 385:lwIP/src/core/udp.c ****             /* compare PCB local addr+port to UDP destination addr+port */
 386:lwIP/src/core/udp.c ****             if ((mpcb->local_port == dest) &&
 387:lwIP/src/core/udp.c ****                 (udp_input_local_match(mpcb, inp, broadcast) != 0)) {
 388:lwIP/src/core/udp.c ****               /* pass a copy of the packet to all local matches */
 389:lwIP/src/core/udp.c ****               if (mpcb->recv != NULL) {
 390:lwIP/src/core/udp.c ****                 struct pbuf *q;
 391:lwIP/src/core/udp.c ****                 q = pbuf_clone(PBUF_RAW, PBUF_POOL, p);
 392:lwIP/src/core/udp.c ****                 if (q != NULL) {
 393:lwIP/src/core/udp.c ****                   mpcb->recv(mpcb->recv_arg, mpcb, q, ip_current_src_addr(), src);
 394:lwIP/src/core/udp.c ****                 }
 395:lwIP/src/core/udp.c ****               }
 396:lwIP/src/core/udp.c ****             }
 397:lwIP/src/core/udp.c ****           }
 398:lwIP/src/core/udp.c ****         }
 399:lwIP/src/core/udp.c ****       }
 400:lwIP/src/core/udp.c **** #endif /* SO_REUSE && SO_REUSE_RXTOALL */
 401:lwIP/src/core/udp.c ****       /* callback */
 402:lwIP/src/core/udp.c ****       if (pcb->recv != NULL) {
 412              		.loc 1 402 7 view .LVU145
 413              		.loc 1 402 14 is_stmt 0 view .LVU146
 414 0108 A669     		ldr	r6, [r4, #24]
 415              		.loc 1 402 10 view .LVU147
 416 010a DEB1     		cbz	r6, .L22
 403:lwIP/src/core/udp.c ****         /* now the recv function is responsible for freeing p */
 404:lwIP/src/core/udp.c ****         pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 417              		.loc 1 404 9 is_stmt 1 view .LVU148
 418 010c E069     		ldr	r0, [r4, #28]
 419 010e 2A46     		mov	r2, r5
 420 0110 2146     		mov	r1, r4
 421 0112 264B     		ldr	r3, .L74+12
 422 0114 CDF800B0 		str	fp, [sp]
 423 0118 B047     		blx	r6
 424              	.LVL20:
 405:lwIP/src/core/udp.c ****       } else {
 406:lwIP/src/core/udp.c ****         /* no recv function registered? then we have to free the pbuf! */
 407:lwIP/src/core/udp.c ****         pbuf_free(p);
 408:lwIP/src/core/udp.c ****         goto end;
 409:lwIP/src/core/udp.c ****       }
 410:lwIP/src/core/udp.c ****     } else {
 411:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));
 412:lwIP/src/core/udp.c **** 
 413:lwIP/src/core/udp.c **** #if LWIP_ICMP || LWIP_ICMP6
 414:lwIP/src/core/udp.c ****       /* No match was found, send ICMP destination port unreachable unless
 415:lwIP/src/core/udp.c ****          destination address was broadcast/multicast. */
 416:lwIP/src/core/udp.c ****       if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 417:lwIP/src/core/udp.c ****         /* move payload pointer back to ip header */
 418:lwIP/src/core/udp.c ****         pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 419:lwIP/src/core/udp.c ****         icmp_port_unreach(ip_current_is_v6(), p);
 420:lwIP/src/core/udp.c ****       }
 421:lwIP/src/core/udp.c **** #endif /* LWIP_ICMP || LWIP_ICMP6 */
 422:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.proterr);
 423:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 424:lwIP/src/core/udp.c ****       MIB2_STATS_INC(mib2.udpnoports);
 425:lwIP/src/core/udp.c ****       pbuf_free(p);
 426:lwIP/src/core/udp.c ****     }
ARM GAS  /tmp/cctoFbTf.s 			page 34


 427:lwIP/src/core/udp.c ****   } else {
 428:lwIP/src/core/udp.c ****     pbuf_free(p);
 429:lwIP/src/core/udp.c ****   }
 430:lwIP/src/core/udp.c **** end:
 431:lwIP/src/core/udp.c ****   PERF_STOP("udp_input");
 432:lwIP/src/core/udp.c ****   return;
 433:lwIP/src/core/udp.c **** #if CHECKSUM_CHECK_UDP
 434:lwIP/src/core/udp.c **** chkerr:
 435:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 436:lwIP/src/core/udp.c ****               ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
 437:lwIP/src/core/udp.c ****   UDP_STATS_INC(udp.chkerr);
 438:lwIP/src/core/udp.c ****   UDP_STATS_INC(udp.drop);
 439:lwIP/src/core/udp.c ****   MIB2_STATS_INC(mib2.udpinerrors);
 440:lwIP/src/core/udp.c ****   pbuf_free(p);
 441:lwIP/src/core/udp.c ****   PERF_STOP("udp_input");
 442:lwIP/src/core/udp.c **** #endif /* CHECKSUM_CHECK_UDP */
 443:lwIP/src/core/udp.c **** }
 425              		.loc 1 443 1 is_stmt 0 view .LVU149
 426 011a 07B0     		add	sp, sp, #28
 427              	.LCFI3:
 428              		.cfi_remember_state
 429              		.cfi_def_cfa_offset 36
 430              		@ sp needed
 431 011c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 432              	.LVL21:
 433              	.L26:
 434              	.LCFI4:
 435              		.cfi_restore_state
 411:lwIP/src/core/udp.c **** 
 436              		.loc 1 411 76 is_stmt 1 view .LVU150
 416:lwIP/src/core/udp.c ****         /* move payload pointer back to ip header */
 437              		.loc 1 416 7 view .LVU151
 416:lwIP/src/core/udp.c ****         /* move payload pointer back to ip header */
 438              		.loc 1 416 10 is_stmt 0 view .LVU152
 439 0120 B8F1000F 		cmp	r8, #0
 440 0124 0ED1     		bne	.L22
 416:lwIP/src/core/udp.c ****         /* move payload pointer back to ip header */
 441              		.loc 1 416 26 discriminator 1 view .LVU153
 442 0126 7369     		ldr	r3, [r6, #20]
 443 0128 03F0F003 		and	r3, r3, #240
 416:lwIP/src/core/udp.c ****         /* move payload pointer back to ip header */
 444              		.loc 1 416 22 discriminator 1 view .LVU154
 445 012c E02B     		cmp	r3, #224
 446 012e 09D0     		beq	.L22
 418:lwIP/src/core/udp.c ****         icmp_port_unreach(ip_current_is_v6(), p);
 447              		.loc 1 418 9 is_stmt 1 view .LVU155
 418:lwIP/src/core/udp.c ****         icmp_port_unreach(ip_current_is_v6(), p);
 448              		.loc 1 418 66 is_stmt 0 view .LVU156
 449 0130 B189     		ldrh	r1, [r6, #12]
 418:lwIP/src/core/udp.c ****         icmp_port_unreach(ip_current_is_v6(), p);
 450              		.loc 1 418 9 view .LVU157
 451 0132 2846     		mov	r0, r5
 418:lwIP/src/core/udp.c ****         icmp_port_unreach(ip_current_is_v6(), p);
 452              		.loc 1 418 66 view .LVU158
 453 0134 0831     		adds	r1, r1, #8
 418:lwIP/src/core/udp.c ****         icmp_port_unreach(ip_current_is_v6(), p);
 454              		.loc 1 418 9 view .LVU159
ARM GAS  /tmp/cctoFbTf.s 			page 35


 455 0136 09B2     		sxth	r1, r1
 456 0138 FFF7FEFF 		bl	pbuf_header_force
 457              	.LVL22:
 419:lwIP/src/core/udp.c ****       }
 458              		.loc 1 419 9 is_stmt 1 view .LVU160
 459 013c 0321     		movs	r1, #3
 460 013e 2846     		mov	r0, r5
 461 0140 FFF7FEFF 		bl	icmp_dest_unreach
 462              	.LVL23:
 463              	.L22:
 218:lwIP/src/core/udp.c ****     UDP_STATS_INC(udp.lenerr);
 464              		.loc 1 218 92 view .LVU161
 219:lwIP/src/core/udp.c ****     UDP_STATS_INC(udp.drop);
 465              		.loc 1 219 30 view .LVU162
 220:lwIP/src/core/udp.c ****     MIB2_STATS_INC(mib2.udpinerrors);
 466              		.loc 1 220 28 view .LVU163
 221:lwIP/src/core/udp.c ****     pbuf_free(p);
 467              		.loc 1 221 37 view .LVU164
 222:lwIP/src/core/udp.c ****     goto end;
 468              		.loc 1 222 5 view .LVU165
 469 0144 2846     		mov	r0, r5
 470              		.loc 1 443 1 is_stmt 0 view .LVU166
 471 0146 07B0     		add	sp, sp, #28
 472              	.LCFI5:
 473              		.cfi_remember_state
 474              		.cfi_def_cfa_offset 36
 475              		@ sp needed
 476 0148 BDE8F04F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 477              	.LCFI6:
 478              		.cfi_restore 14
 479              		.cfi_restore 11
 480              		.cfi_restore 10
 481              		.cfi_restore 9
 482              		.cfi_restore 8
 483              		.cfi_restore 7
 484              		.cfi_restore 6
 485              		.cfi_restore 5
 486              		.cfi_restore 4
 487              		.cfi_def_cfa_offset 0
 488              	.LVL24:
 222:lwIP/src/core/udp.c ****     goto end;
 489              		.loc 1 222 5 view .LVU167
 490 014c FFF7FEBF 		b	pbuf_free
 491              	.LVL25:
 492              	.L15:
 493              	.LCFI7:
 494              		.cfi_restore_state
 495              	.LBB47:
 496              	.LBB43:
 173:lwIP/src/core/udp.c ****         return 1;
 497              		.loc 1 173 7 is_stmt 1 view .LVU168
 173:lwIP/src/core/udp.c ****         return 1;
 498              		.loc 1 173 11 is_stmt 0 view .LVU169
 499 0150 0029     		cmp	r1, #0
 500 0152 A8D0     		beq	.L16
 173:lwIP/src/core/udp.c ****         return 1;
 501              		.loc 1 173 41 view .LVU170
ARM GAS  /tmp/cctoFbTf.s 			page 36


 502 0154 9142     		cmp	r1, r2
 503 0156 A6D0     		beq	.L16
 504              	.LVL26:
 173:lwIP/src/core/udp.c ****         return 1;
 505              		.loc 1 173 41 view .LVU171
 506              	.LBE43:
 507              	.LBE47:
 306:lwIP/src/core/udp.c ****   }
 508              		.loc 1 306 5 is_stmt 1 view .LVU172
 253:lwIP/src/core/udp.c ****     /* print the PCB local and remote address */
 509              		.loc 1 253 37 view .LVU173
 253:lwIP/src/core/udp.c ****     /* print the PCB local and remote address */
 510              		.loc 1 253 41 is_stmt 0 view .LVU174
 511 0158 E168     		ldr	r1, [r4, #12]
 512              	.LVL27:
 253:lwIP/src/core/udp.c ****     /* print the PCB local and remote address */
 513              		.loc 1 253 24 is_stmt 1 view .LVU175
 514 015a A646     		mov	lr, r4
 253:lwIP/src/core/udp.c ****     /* print the PCB local and remote address */
 515              		.loc 1 253 3 is_stmt 0 view .LVU176
 516 015c 0029     		cmp	r1, #0
 517 015e 84D1     		bne	.L30
 518              	.L71:
 309:lwIP/src/core/udp.c ****     pcb = uncon_pcb;
 519              		.loc 1 309 3 is_stmt 1 view .LVU177
 310:lwIP/src/core/udp.c ****   }
 520              		.loc 1 310 5 view .LVU178
 521              	.LVL28:
 314:lwIP/src/core/udp.c ****     for_us = 1;
 522              		.loc 1 314 3 view .LVU179
 314:lwIP/src/core/udp.c ****     for_us = 1;
 523              		.loc 1 314 6 is_stmt 0 view .LVU180
 524 0160 53B1     		cbz	r3, .L28
 314:lwIP/src/core/udp.c ****     for_us = 1;
 525              		.loc 1 314 6 view .LVU181
 526 0162 1C46     		mov	r4, r3
 527              	.LVL29:
 314:lwIP/src/core/udp.c ****     for_us = 1;
 528              		.loc 1 314 6 view .LVU182
 529 0164 BDE7     		b	.L19
 530              	.LVL30:
 531              	.L69:
 207:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 532              		.loc 1 207 3 is_stmt 1 discriminator 1 view .LVU183
 533 0166 1248     		ldr	r0, .L74+16
 534              	.LVL31:
 207:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 535              		.loc 1 207 3 is_stmt 0 discriminator 1 view .LVU184
 536 0168 FFF7FEFF 		bl	printf
 537              	.LVL32:
 538              	.L8:
 207:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 539              		.loc 1 207 3 is_stmt 1 discriminator 1 view .LVU185
 207:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 540              		.loc 1 207 3 discriminator 1 view .LVU186
 207:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 541              		.loc 1 207 3 discriminator 1 view .LVU187
ARM GAS  /tmp/cctoFbTf.s 			page 37


 207:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 542              		.loc 1 207 3 discriminator 1 view .LVU188
 207:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 543              		.loc 1 207 3 discriminator 1 view .LVU189
 207:lwIP/src/core/udp.c ****   LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 544              		.loc 1 207 3 discriminator 1 view .LVU190
 545 016c FEE7     		b	.L8
 546              	.LVL33:
 547              	.L70:
 208:lwIP/src/core/udp.c **** 
 548              		.loc 1 208 3 discriminator 1 view .LVU191
 549 016e 1148     		ldr	r0, .L74+20
 550              	.LVL34:
 208:lwIP/src/core/udp.c **** 
 551              		.loc 1 208 3 is_stmt 0 discriminator 1 view .LVU192
 552 0170 FFF7FEFF 		bl	printf
 553              	.LVL35:
 554              	.L10:
 208:lwIP/src/core/udp.c **** 
 555              		.loc 1 208 3 is_stmt 1 discriminator 2 view .LVU193
 208:lwIP/src/core/udp.c **** 
 556              		.loc 1 208 3 discriminator 2 view .LVU194
 208:lwIP/src/core/udp.c **** 
 557              		.loc 1 208 3 discriminator 2 view .LVU195
 208:lwIP/src/core/udp.c **** 
 558              		.loc 1 208 3 discriminator 2 view .LVU196
 208:lwIP/src/core/udp.c **** 
 559              		.loc 1 208 3 discriminator 2 view .LVU197
 208:lwIP/src/core/udp.c **** 
 560              		.loc 1 208 3 discriminator 2 view .LVU198
 561 0174 FEE7     		b	.L10
 562              	.L27:
 563              	.LVL36:
 564              	.L12:
 309:lwIP/src/core/udp.c ****     pcb = uncon_pcb;
 565              		.loc 1 309 3 view .LVU199
 310:lwIP/src/core/udp.c ****   }
 566              		.loc 1 310 5 view .LVU200
 314:lwIP/src/core/udp.c ****     for_us = 1;
 567              		.loc 1 314 3 view .LVU201
 568 0176 7269     		ldr	r2, [r6, #20]
 569              	.LVL37:
 570              	.L28:
 323:lwIP/src/core/udp.c ****       for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 571              		.loc 1 323 5 view .LVU202
 324:lwIP/src/core/udp.c ****     }
 572              		.loc 1 324 7 view .LVU203
 329:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
 573              		.loc 1 329 3 view .LVU204
 329:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
 574              		.loc 1 329 6 is_stmt 0 view .LVU205
 575 0178 3B68     		ldr	r3, [r7]
 576 017a 9342     		cmp	r3, r2
 577 017c E2D1     		bne	.L22
 578 017e 0024     		movs	r4, #0
 579 0180 AFE7     		b	.L19
 580              	.LVL38:
ARM GAS  /tmp/cctoFbTf.s 			page 38


 581              	.L72:
 271:lwIP/src/core/udp.c ****             /* uncon_pcb does not match the input netif, check this pcb */
 582              		.loc 1 271 11 is_stmt 1 view .LVU206
 271:lwIP/src/core/udp.c ****             /* uncon_pcb does not match the input netif, check this pcb */
 583              		.loc 1 271 54 is_stmt 0 view .LVU207
 584 0182 D7F800C0 		ldr	ip, [r7]
 271:lwIP/src/core/udp.c ****             /* uncon_pcb does not match the input netif, check this pcb */
 585              		.loc 1 271 14 view .LVU208
 586 0186 1868     		ldr	r0, [r3]
 587 0188 6045     		cmp	r0, ip
 588 018a 98D0     		beq	.L17
 273:lwIP/src/core/udp.c ****               /* better match */
 589              		.loc 1 273 13 is_stmt 1 view .LVU209
 273:lwIP/src/core/udp.c ****               /* better match */
 590              		.loc 1 273 16 is_stmt 0 view .LVU210
 591 018c 8C45     		cmp	ip, r1
 592 018e 08BF     		it	eq
 593 0190 2346     		moveq	r3, r4
 594              	.LVL39:
 273:lwIP/src/core/udp.c ****               /* better match */
 595              		.loc 1 273 16 view .LVU211
 596 0192 94E7     		b	.L17
 597              	.LVL40:
 598              	.L73:
 368:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 599              		.loc 1 368 7 is_stmt 1 discriminator 1 view .LVU212
 368:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 600              		.loc 1 368 7 discriminator 1 view .LVU213
 368:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 601              		.loc 1 368 7 discriminator 1 view .LVU214
 602 0194 0848     		ldr	r0, .L74+24
 603 0196 FFF7FEFF 		bl	puts
 604              	.LVL41:
 605              	.L25:
 368:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 606              		.loc 1 368 7 discriminator 3 view .LVU215
 368:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 607              		.loc 1 368 7 discriminator 3 view .LVU216
 368:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 608              		.loc 1 368 7 discriminator 3 view .LVU217
 368:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 609              		.loc 1 368 7 discriminator 3 view .LVU218
 368:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 610              		.loc 1 368 7 discriminator 3 view .LVU219
 368:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 611              		.loc 1 368 7 discriminator 3 view .LVU220
 612 019a FEE7     		b	.L25
 613              	.LVL42:
 614              	.L29:
 368:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 615              		.loc 1 368 7 is_stmt 0 discriminator 3 view .LVU221
 616 019c 2346     		mov	r3, r4
 617              	.LVL43:
 368:lwIP/src/core/udp.c ****       UDP_STATS_INC(udp.drop);
 618              		.loc 1 368 7 discriminator 3 view .LVU222
 619 019e 8EE7     		b	.L17
 620              	.L75:
ARM GAS  /tmp/cctoFbTf.s 			page 39


 621              		.align	2
 622              	.L74:
 623 01a0 00000000 		.word	ip_data
 624 01a4 00000000 		.word	udp_pcbs
 625 01a8 14000000 		.word	ip_data+20
 626 01ac 10000000 		.word	ip_data+16
 627 01b0 00000000 		.word	.LC0
 628 01b4 18000000 		.word	.LC1
 629 01b8 34000000 		.word	.LC2
 630              		.cfi_endproc
 631              	.LFE108:
 633              		.section	.rodata.udp_bind.str1.4,"aMS",%progbits,1
 634              		.align	2
 635              	.LC3:
 636 0000 7564705F 		.ascii	"udp_bind: invalid pcb\000"
 636      62696E64 
 636      3A20696E 
 636      76616C69 
 636      64207063 
 637              		.section	.text.udp_bind,"ax",%progbits
 638              		.align	1
 639              		.p2align 2,,3
 640              		.global	udp_bind
 641              		.syntax unified
 642              		.thumb
 643              		.thumb_func
 644              		.fpu fpv4-sp-d16
 646              	udp_bind:
 647              	.LVL44:
 648              	.LFB113:
 444:lwIP/src/core/udp.c **** 
 445:lwIP/src/core/udp.c **** /**
 446:lwIP/src/core/udp.c ****  * @ingroup udp_raw
 447:lwIP/src/core/udp.c ****  * Sends the pbuf p using UDP. The pbuf is not deallocated.
 448:lwIP/src/core/udp.c ****  *
 449:lwIP/src/core/udp.c ****  *
 450:lwIP/src/core/udp.c ****  * @param pcb UDP PCB used to send the data.
 451:lwIP/src/core/udp.c ****  * @param p chain of pbuf's to be sent.
 452:lwIP/src/core/udp.c ****  *
 453:lwIP/src/core/udp.c ****  * The datagram will be sent to the current remote_ip & remote_port
 454:lwIP/src/core/udp.c ****  * stored in pcb. If the pcb is not bound to a port, it will
 455:lwIP/src/core/udp.c ****  * automatically be bound to a random port.
 456:lwIP/src/core/udp.c ****  *
 457:lwIP/src/core/udp.c ****  * @return lwIP error code.
 458:lwIP/src/core/udp.c ****  * - ERR_OK. Successful. No error occurred.
 459:lwIP/src/core/udp.c ****  * - ERR_MEM. Out of memory.
 460:lwIP/src/core/udp.c ****  * - ERR_RTE. Could not find route to destination address.
 461:lwIP/src/core/udp.c ****  * - ERR_VAL. No PCB or PCB is dual-stack
 462:lwIP/src/core/udp.c ****  * - More errors could be returned by lower protocol layers.
 463:lwIP/src/core/udp.c ****  *
 464:lwIP/src/core/udp.c ****  * @see udp_disconnect() udp_sendto()
 465:lwIP/src/core/udp.c ****  */
 466:lwIP/src/core/udp.c **** err_t
 467:lwIP/src/core/udp.c **** udp_send(struct udp_pcb *pcb, struct pbuf *p)
 468:lwIP/src/core/udp.c **** {
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pcb", pcb != NULL, return ERR_ARG);
 470:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
ARM GAS  /tmp/cctoFbTf.s 			page 40


 471:lwIP/src/core/udp.c **** 
 472:lwIP/src/core/udp.c ****   if (IP_IS_ANY_TYPE_VAL(pcb->remote_ip)) {
 473:lwIP/src/core/udp.c ****     return ERR_VAL;
 474:lwIP/src/core/udp.c ****   }
 475:lwIP/src/core/udp.c **** 
 476:lwIP/src/core/udp.c ****   /* send to the packet using remote ip and port stored in the pcb */
 477:lwIP/src/core/udp.c ****   return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 478:lwIP/src/core/udp.c **** }
 479:lwIP/src/core/udp.c **** 
 480:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 481:lwIP/src/core/udp.c **** /** @ingroup udp_raw
 482:lwIP/src/core/udp.c ****  * Same as udp_send() but with checksum
 483:lwIP/src/core/udp.c ****  */
 484:lwIP/src/core/udp.c **** err_t
 485:lwIP/src/core/udp.c **** udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
 486:lwIP/src/core/udp.c ****                 u8_t have_chksum, u16_t chksum)
 487:lwIP/src/core/udp.c **** {
 488:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send_chksum: invalid pcb", pcb != NULL, return ERR_ARG);
 489:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send_chksum: invalid pbuf", p != NULL, return ERR_ARG);
 490:lwIP/src/core/udp.c **** 
 491:lwIP/src/core/udp.c ****   if (IP_IS_ANY_TYPE_VAL(pcb->remote_ip)) {
 492:lwIP/src/core/udp.c ****     return ERR_VAL;
 493:lwIP/src/core/udp.c ****   }
 494:lwIP/src/core/udp.c **** 
 495:lwIP/src/core/udp.c ****   /* send to the packet using remote ip and port stored in the pcb */
 496:lwIP/src/core/udp.c ****   return udp_sendto_chksum(pcb, p, &pcb->remote_ip, pcb->remote_port,
 497:lwIP/src/core/udp.c ****                            have_chksum, chksum);
 498:lwIP/src/core/udp.c **** }
 499:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 500:lwIP/src/core/udp.c **** 
 501:lwIP/src/core/udp.c **** /**
 502:lwIP/src/core/udp.c ****  * @ingroup udp_raw
 503:lwIP/src/core/udp.c ****  * Send data to a specified address using UDP.
 504:lwIP/src/core/udp.c ****  *
 505:lwIP/src/core/udp.c ****  * @param pcb UDP PCB used to send the data.
 506:lwIP/src/core/udp.c ****  * @param p chain of pbuf's to be sent.
 507:lwIP/src/core/udp.c ****  * @param dst_ip Destination IP address.
 508:lwIP/src/core/udp.c ****  * @param dst_port Destination UDP port.
 509:lwIP/src/core/udp.c ****  *
 510:lwIP/src/core/udp.c ****  * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
 511:lwIP/src/core/udp.c ****  *
 512:lwIP/src/core/udp.c ****  * If the PCB already has a remote address association, it will
 513:lwIP/src/core/udp.c ****  * be restored after the data is sent.
 514:lwIP/src/core/udp.c ****  *
 515:lwIP/src/core/udp.c ****  * @return lwIP error code (@see udp_send for possible error codes)
 516:lwIP/src/core/udp.c ****  *
 517:lwIP/src/core/udp.c ****  * @see udp_disconnect() udp_send()
 518:lwIP/src/core/udp.c ****  */
 519:lwIP/src/core/udp.c **** err_t
 520:lwIP/src/core/udp.c **** udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
 521:lwIP/src/core/udp.c ****            const ip_addr_t *dst_ip, u16_t dst_port)
 522:lwIP/src/core/udp.c **** {
 523:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 524:lwIP/src/core/udp.c ****   return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
 525:lwIP/src/core/udp.c **** }
 526:lwIP/src/core/udp.c **** 
 527:lwIP/src/core/udp.c **** /** @ingroup udp_raw
ARM GAS  /tmp/cctoFbTf.s 			page 41


 528:lwIP/src/core/udp.c ****  * Same as udp_sendto(), but with checksum */
 529:lwIP/src/core/udp.c **** err_t
 530:lwIP/src/core/udp.c **** udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
 531:lwIP/src/core/udp.c ****                   u16_t dst_port, u8_t have_chksum, u16_t chksum)
 532:lwIP/src/core/udp.c **** {
 533:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 534:lwIP/src/core/udp.c ****   struct netif *netif;
 535:lwIP/src/core/udp.c **** 
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pcb", pcb != NULL, return ERR_ARG);
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 538:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 539:lwIP/src/core/udp.c **** 
 540:lwIP/src/core/udp.c ****   if (!IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 541:lwIP/src/core/udp.c ****     return ERR_VAL;
 542:lwIP/src/core/udp.c ****   }
 543:lwIP/src/core/udp.c **** 
 544:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));
 545:lwIP/src/core/udp.c **** 
 546:lwIP/src/core/udp.c ****   if (pcb->netif_idx != NETIF_NO_INDEX) {
 547:lwIP/src/core/udp.c ****     netif = netif_get_by_index(pcb->netif_idx);
 548:lwIP/src/core/udp.c ****   } else {
 549:lwIP/src/core/udp.c **** #if LWIP_MULTICAST_TX_OPTIONS
 550:lwIP/src/core/udp.c ****     netif = NULL;
 551:lwIP/src/core/udp.c ****     if (ip_addr_ismulticast(dst_ip)) {
 552:lwIP/src/core/udp.c ****       /* For IPv6, the interface to use for packets with a multicast destination
 553:lwIP/src/core/udp.c ****        * is specified using an interface index. The same approach may be used for
 554:lwIP/src/core/udp.c ****        * IPv4 as well, in which case it overrides the IPv4 multicast override
 555:lwIP/src/core/udp.c ****        * address below. Here we have to look up the netif by going through the
 556:lwIP/src/core/udp.c ****        * list, but by doing so we skip a route lookup. If the interface index has
 557:lwIP/src/core/udp.c ****        * gone stale, we fall through and do the regular route lookup after all. */
 558:lwIP/src/core/udp.c ****       if (pcb->mcast_ifindex != NETIF_NO_INDEX) {
 559:lwIP/src/core/udp.c ****         netif = netif_get_by_index(pcb->mcast_ifindex);
 560:lwIP/src/core/udp.c ****       }
 561:lwIP/src/core/udp.c **** #if LWIP_IPV4
 562:lwIP/src/core/udp.c ****       else
 563:lwIP/src/core/udp.c **** #if LWIP_IPV6
 564:lwIP/src/core/udp.c ****         if (IP_IS_V4(dst_ip))
 565:lwIP/src/core/udp.c **** #endif /* LWIP_IPV6 */
 566:lwIP/src/core/udp.c ****         {
 567:lwIP/src/core/udp.c ****           /* IPv4 does not use source-based routing by default, so we use an
 568:lwIP/src/core/udp.c ****              administratively selected interface for multicast by default.
 569:lwIP/src/core/udp.c ****              However, this can be overridden by setting an interface address
 570:lwIP/src/core/udp.c ****              in pcb->mcast_ip4 that is used for routing. If this routing lookup
 571:lwIP/src/core/udp.c ****              fails, we try regular routing as though no override was set. */
 572:lwIP/src/core/udp.c ****           if (!ip4_addr_isany_val(pcb->mcast_ip4) &&
 573:lwIP/src/core/udp.c ****               !ip4_addr_cmp(&pcb->mcast_ip4, IP4_ADDR_BROADCAST)) {
 574:lwIP/src/core/udp.c ****             netif = ip4_route_src(ip_2_ip4(&pcb->local_ip), &pcb->mcast_ip4);
 575:lwIP/src/core/udp.c ****           }
 576:lwIP/src/core/udp.c ****         }
 577:lwIP/src/core/udp.c **** #endif /* LWIP_IPV4 */
 578:lwIP/src/core/udp.c ****     }
 579:lwIP/src/core/udp.c **** 
 580:lwIP/src/core/udp.c ****     if (netif == NULL)
 581:lwIP/src/core/udp.c **** #endif /* LWIP_MULTICAST_TX_OPTIONS */
 582:lwIP/src/core/udp.c ****     {
 583:lwIP/src/core/udp.c ****       /* find the outgoing network interface for this packet */
 584:lwIP/src/core/udp.c ****       netif = ip_route(&pcb->local_ip, dst_ip);
ARM GAS  /tmp/cctoFbTf.s 			page 42


 585:lwIP/src/core/udp.c ****     }
 586:lwIP/src/core/udp.c ****   }
 587:lwIP/src/core/udp.c **** 
 588:lwIP/src/core/udp.c ****   /* no outgoing network interface could be found? */
 589:lwIP/src/core/udp.c ****   if (netif == NULL) {
 590:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
 591:lwIP/src/core/udp.c ****     ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
 592:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("\n"));
 593:lwIP/src/core/udp.c ****     UDP_STATS_INC(udp.rterr);
 594:lwIP/src/core/udp.c ****     return ERR_RTE;
 595:lwIP/src/core/udp.c ****   }
 596:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 597:lwIP/src/core/udp.c ****   return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
 598:lwIP/src/core/udp.c **** #else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 599:lwIP/src/core/udp.c ****   return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 600:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 601:lwIP/src/core/udp.c **** }
 602:lwIP/src/core/udp.c **** 
 603:lwIP/src/core/udp.c **** /**
 604:lwIP/src/core/udp.c ****  * @ingroup udp_raw
 605:lwIP/src/core/udp.c ****  * Send data to a specified address using UDP.
 606:lwIP/src/core/udp.c ****  * The netif used for sending can be specified.
 607:lwIP/src/core/udp.c ****  *
 608:lwIP/src/core/udp.c ****  * This function exists mainly for DHCP, to be able to send UDP packets
 609:lwIP/src/core/udp.c ****  * on a netif that is still down.
 610:lwIP/src/core/udp.c ****  *
 611:lwIP/src/core/udp.c ****  * @param pcb UDP PCB used to send the data.
 612:lwIP/src/core/udp.c ****  * @param p chain of pbuf's to be sent.
 613:lwIP/src/core/udp.c ****  * @param dst_ip Destination IP address.
 614:lwIP/src/core/udp.c ****  * @param dst_port Destination UDP port.
 615:lwIP/src/core/udp.c ****  * @param netif the netif used for sending.
 616:lwIP/src/core/udp.c ****  *
 617:lwIP/src/core/udp.c ****  * dst_ip & dst_port are expected to be in the same byte order as in the pcb.
 618:lwIP/src/core/udp.c ****  *
 619:lwIP/src/core/udp.c ****  * @return lwIP error code (@see udp_send for possible error codes)
 620:lwIP/src/core/udp.c ****  *
 621:lwIP/src/core/udp.c ****  * @see udp_disconnect() udp_send()
 622:lwIP/src/core/udp.c ****  */
 623:lwIP/src/core/udp.c **** err_t
 624:lwIP/src/core/udp.c **** udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
 625:lwIP/src/core/udp.c ****               const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
 626:lwIP/src/core/udp.c **** {
 627:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 628:lwIP/src/core/udp.c ****   return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
 629:lwIP/src/core/udp.c **** }
 630:lwIP/src/core/udp.c **** 
 631:lwIP/src/core/udp.c **** /** Same as udp_sendto_if(), but with checksum */
 632:lwIP/src/core/udp.c **** err_t
 633:lwIP/src/core/udp.c **** udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
 634:lwIP/src/core/udp.c ****                      u16_t dst_port, struct netif *netif, u8_t have_chksum,
 635:lwIP/src/core/udp.c ****                      u16_t chksum)
 636:lwIP/src/core/udp.c **** {
 637:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 638:lwIP/src/core/udp.c ****   const ip_addr_t *src_ip;
 639:lwIP/src/core/udp.c **** 
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
ARM GAS  /tmp/cctoFbTf.s 			page 43


 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 643:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 644:lwIP/src/core/udp.c **** 
 645:lwIP/src/core/udp.c ****   if (!IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 646:lwIP/src/core/udp.c ****     return ERR_VAL;
 647:lwIP/src/core/udp.c ****   }
 648:lwIP/src/core/udp.c **** 
 649:lwIP/src/core/udp.c ****   /* PCB local address is IP_ANY_ADDR or multicast? */
 650:lwIP/src/core/udp.c **** #if LWIP_IPV6
 651:lwIP/src/core/udp.c ****   if (IP_IS_V6(dst_ip)) {
 652:lwIP/src/core/udp.c ****     if (ip6_addr_isany(ip_2_ip6(&pcb->local_ip)) ||
 653:lwIP/src/core/udp.c ****         ip6_addr_ismulticast(ip_2_ip6(&pcb->local_ip))) {
 654:lwIP/src/core/udp.c ****       src_ip = ip6_select_source_address(netif, ip_2_ip6(dst_ip));
 655:lwIP/src/core/udp.c ****       if (src_ip == NULL) {
 656:lwIP/src/core/udp.c ****         /* No suitable source address was found. */
 657:lwIP/src/core/udp.c ****         return ERR_RTE;
 658:lwIP/src/core/udp.c ****       }
 659:lwIP/src/core/udp.c ****     } else {
 660:lwIP/src/core/udp.c ****       /* use UDP PCB local IPv6 address as source address, if still valid. */
 661:lwIP/src/core/udp.c ****       if (netif_get_ip6_addr_match(netif, ip_2_ip6(&pcb->local_ip)) < 0) {
 662:lwIP/src/core/udp.c ****         /* Address isn't valid anymore. */
 663:lwIP/src/core/udp.c ****         return ERR_RTE;
 664:lwIP/src/core/udp.c ****       }
 665:lwIP/src/core/udp.c ****       src_ip = &pcb->local_ip;
 666:lwIP/src/core/udp.c ****     }
 667:lwIP/src/core/udp.c ****   }
 668:lwIP/src/core/udp.c **** #endif /* LWIP_IPV6 */
 669:lwIP/src/core/udp.c **** #if LWIP_IPV4 && LWIP_IPV6
 670:lwIP/src/core/udp.c ****   else
 671:lwIP/src/core/udp.c **** #endif /* LWIP_IPV4 && LWIP_IPV6 */
 672:lwIP/src/core/udp.c **** #if LWIP_IPV4
 673:lwIP/src/core/udp.c ****     if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 674:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 675:lwIP/src/core/udp.c ****       /* if the local_ip is any or multicast
 676:lwIP/src/core/udp.c ****        * use the outgoing network interface IP address as source address */
 677:lwIP/src/core/udp.c ****       src_ip = netif_ip_addr4(netif);
 678:lwIP/src/core/udp.c ****     } else {
 679:lwIP/src/core/udp.c ****       /* check if UDP PCB local IP address is correct
 680:lwIP/src/core/udp.c ****        * this could be an old address if netif->ip_addr has changed */
 681:lwIP/src/core/udp.c ****       if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 682:lwIP/src/core/udp.c ****         /* local_ip doesn't match, drop the packet */
 683:lwIP/src/core/udp.c ****         return ERR_RTE;
 684:lwIP/src/core/udp.c ****       }
 685:lwIP/src/core/udp.c ****       /* use UDP PCB local IP address as source address */
 686:lwIP/src/core/udp.c ****       src_ip = &pcb->local_ip;
 687:lwIP/src/core/udp.c ****     }
 688:lwIP/src/core/udp.c **** #endif /* LWIP_IPV4 */
 689:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 690:lwIP/src/core/udp.c ****   return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
 691:lwIP/src/core/udp.c **** #else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 692:lwIP/src/core/udp.c ****   return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
 693:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 694:lwIP/src/core/udp.c **** }
 695:lwIP/src/core/udp.c **** 
 696:lwIP/src/core/udp.c **** /** @ingroup udp_raw
 697:lwIP/src/core/udp.c ****  * Same as @ref udp_sendto_if, but with source address */
 698:lwIP/src/core/udp.c **** err_t
ARM GAS  /tmp/cctoFbTf.s 			page 44


 699:lwIP/src/core/udp.c **** udp_sendto_if_src(struct udp_pcb *pcb, struct pbuf *p,
 700:lwIP/src/core/udp.c ****                   const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *sr
 701:lwIP/src/core/udp.c **** {
 702:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 703:lwIP/src/core/udp.c ****   return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0, src_ip);
 704:lwIP/src/core/udp.c **** }
 705:lwIP/src/core/udp.c **** 
 706:lwIP/src/core/udp.c **** /** Same as udp_sendto_if_src(), but with checksum */
 707:lwIP/src/core/udp.c **** err_t
 708:lwIP/src/core/udp.c **** udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
 709:lwIP/src/core/udp.c ****                          u16_t dst_port, struct netif *netif, u8_t have_chksum,
 710:lwIP/src/core/udp.c ****                          u16_t chksum, const ip_addr_t *src_ip)
 711:lwIP/src/core/udp.c **** {
 712:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 713:lwIP/src/core/udp.c ****   struct udp_hdr *udphdr;
 714:lwIP/src/core/udp.c ****   err_t err;
 715:lwIP/src/core/udp.c ****   struct pbuf *q; /* q will be sent down the stack */
 716:lwIP/src/core/udp.c ****   u8_t ip_proto;
 717:lwIP/src/core/udp.c ****   u8_t ttl;
 718:lwIP/src/core/udp.c **** 
 719:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 720:lwIP/src/core/udp.c **** 
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 725:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 726:lwIP/src/core/udp.c **** 
 727:lwIP/src/core/udp.c ****   if (!IP_ADDR_PCB_VERSION_MATCH(pcb, src_ip) ||
 728:lwIP/src/core/udp.c ****       !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 729:lwIP/src/core/udp.c ****     return ERR_VAL;
 730:lwIP/src/core/udp.c ****   }
 731:lwIP/src/core/udp.c **** 
 732:lwIP/src/core/udp.c **** #if LWIP_IPV4 && IP_SOF_BROADCAST
 733:lwIP/src/core/udp.c ****   /* broadcast filter? */
 734:lwIP/src/core/udp.c ****   if (!ip_get_option(pcb, SOF_BROADCAST) &&
 735:lwIP/src/core/udp.c **** #if LWIP_IPV6
 736:lwIP/src/core/udp.c ****       IP_IS_V4(dst_ip) &&
 737:lwIP/src/core/udp.c **** #endif /* LWIP_IPV6 */
 738:lwIP/src/core/udp.c ****       ip_addr_isbroadcast(dst_ip, netif)) {
 739:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
 740:lwIP/src/core/udp.c ****                 ("udp_sendto_if: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
 741:lwIP/src/core/udp.c ****     return ERR_VAL;
 742:lwIP/src/core/udp.c ****   }
 743:lwIP/src/core/udp.c **** #endif /* LWIP_IPV4 && IP_SOF_BROADCAST */
 744:lwIP/src/core/udp.c **** 
 745:lwIP/src/core/udp.c ****   /* if the PCB is not yet bound to a port, bind it here */
 746:lwIP/src/core/udp.c ****   if (pcb->local_port == 0) {
 747:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 748:lwIP/src/core/udp.c ****     err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 749:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
 750:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind
 751:lwIP/src/core/udp.c ****       return err;
 752:lwIP/src/core/udp.c ****     }
 753:lwIP/src/core/udp.c ****   }
 754:lwIP/src/core/udp.c **** 
 755:lwIP/src/core/udp.c ****   /* packet too large to add a UDP header without causing an overflow? */
ARM GAS  /tmp/cctoFbTf.s 			page 45


 756:lwIP/src/core/udp.c ****   if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
 757:lwIP/src/core/udp.c ****     return ERR_MEM;
 758:lwIP/src/core/udp.c ****   }
 759:lwIP/src/core/udp.c ****   /* not enough space to add an UDP header to first pbuf in given p chain? */
 760:lwIP/src/core/udp.c ****   if (pbuf_add_header(p, UDP_HLEN)) {
 761:lwIP/src/core/udp.c ****     /* allocate header in a separate new pbuf */
 762:lwIP/src/core/udp.c ****     q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 763:lwIP/src/core/udp.c ****     /* new header pbuf could not be allocated? */
 764:lwIP/src/core/udp.c ****     if (q == NULL) {
 765:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not alloca
 766:lwIP/src/core/udp.c ****       return ERR_MEM;
 767:lwIP/src/core/udp.c ****     }
 768:lwIP/src/core/udp.c ****     if (p->tot_len != 0) {
 769:lwIP/src/core/udp.c ****       /* chain header q in front of given pbuf p (only if p contains data) */
 770:lwIP/src/core/udp.c ****       pbuf_chain(q, p);
 771:lwIP/src/core/udp.c ****     }
 772:lwIP/src/core/udp.c ****     /* first pbuf q points to header pbuf */
 773:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG,
 774:lwIP/src/core/udp.c ****                 ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
 775:lwIP/src/core/udp.c ****   } else {
 776:lwIP/src/core/udp.c ****     /* adding space for header within p succeeded */
 777:lwIP/src/core/udp.c ****     /* first pbuf q equals given pbuf */
 778:lwIP/src/core/udp.c ****     q = p;
 779:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
 780:lwIP/src/core/udp.c ****   }
 781:lwIP/src/core/udp.c ****   LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 782:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 783:lwIP/src/core/udp.c ****   /* q now represents the packet to be sent */
 784:lwIP/src/core/udp.c ****   udphdr = (struct udp_hdr *)q->payload;
 785:lwIP/src/core/udp.c ****   udphdr->src = lwip_htons(pcb->local_port);
 786:lwIP/src/core/udp.c ****   udphdr->dest = lwip_htons(dst_port);
 787:lwIP/src/core/udp.c ****   /* in UDP, 0 checksum means 'no checksum' */
 788:lwIP/src/core/udp.c ****   udphdr->chksum = 0x0000;
 789:lwIP/src/core/udp.c **** 
 790:lwIP/src/core/udp.c ****   /* Multicast Loop? */
 791:lwIP/src/core/udp.c **** #if LWIP_MULTICAST_TX_OPTIONS
 792:lwIP/src/core/udp.c ****   if (((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) && ip_addr_ismulticast(dst_ip)) {
 793:lwIP/src/core/udp.c ****     q->flags |= PBUF_FLAG_MCASTLOOP;
 794:lwIP/src/core/udp.c ****   }
 795:lwIP/src/core/udp.c **** #endif /* LWIP_MULTICAST_TX_OPTIONS */
 796:lwIP/src/core/udp.c **** 
 797:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %"U16_F"\n", q->tot_len));
 798:lwIP/src/core/udp.c **** 
 799:lwIP/src/core/udp.c **** #if LWIP_UDPLITE
 800:lwIP/src/core/udp.c ****   /* UDP Lite protocol? */
 801:lwIP/src/core/udp.c ****   if (pcb->flags & UDP_FLAGS_UDPLITE) {
 802:lwIP/src/core/udp.c ****     u16_t chklen, chklen_hdr;
 803:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %"U16_F"\n", q->tot_len));
 804:lwIP/src/core/udp.c ****     /* set UDP message length in UDP header */
 805:lwIP/src/core/udp.c ****     chklen_hdr = chklen = pcb->chksum_len_tx;
 806:lwIP/src/core/udp.c ****     if ((chklen < sizeof(struct udp_hdr)) || (chklen > q->tot_len)) {
 807:lwIP/src/core/udp.c ****       if (chklen != 0) {
 808:lwIP/src/core/udp.c ****         LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE pcb->chksum_len is illegal: %"U16_F"\n", chklen
 809:lwIP/src/core/udp.c ****       }
 810:lwIP/src/core/udp.c ****       /* For UDP-Lite, checksum length of 0 means checksum
 811:lwIP/src/core/udp.c ****          over the complete packet. (See RFC 3828 chap. 3.1)
 812:lwIP/src/core/udp.c ****          At least the UDP-Lite header must be covered by the
ARM GAS  /tmp/cctoFbTf.s 			page 46


 813:lwIP/src/core/udp.c ****          checksum, therefore, if chksum_len has an illegal
 814:lwIP/src/core/udp.c ****          value, we generate the checksum over the complete
 815:lwIP/src/core/udp.c ****          packet to be safe. */
 816:lwIP/src/core/udp.c ****       chklen_hdr = 0;
 817:lwIP/src/core/udp.c ****       chklen = q->tot_len;
 818:lwIP/src/core/udp.c ****     }
 819:lwIP/src/core/udp.c ****     udphdr->len = lwip_htons(chklen_hdr);
 820:lwIP/src/core/udp.c ****     /* calculate checksum */
 821:lwIP/src/core/udp.c **** #if CHECKSUM_GEN_UDP
 822:lwIP/src/core/udp.c ****     IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
 823:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 824:lwIP/src/core/udp.c ****       if (have_chksum) {
 825:lwIP/src/core/udp.c ****         chklen = UDP_HLEN;
 826:lwIP/src/core/udp.c ****       }
 827:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
 828:lwIP/src/core/udp.c ****       udphdr->chksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDPLITE,
 829:lwIP/src/core/udp.c ****                        q->tot_len, chklen, src_ip, dst_ip);
 830:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 831:lwIP/src/core/udp.c ****       if (have_chksum) {
 832:lwIP/src/core/udp.c ****         u32_t acc;
 833:lwIP/src/core/udp.c ****         acc = udphdr->chksum + (u16_t)~(chksum);
 834:lwIP/src/core/udp.c ****         udphdr->chksum = FOLD_U32T(acc);
 835:lwIP/src/core/udp.c ****       }
 836:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
 837:lwIP/src/core/udp.c **** 
 838:lwIP/src/core/udp.c ****       /* chksum zero must become 0xffff, as zero means 'no checksum' */
 839:lwIP/src/core/udp.c ****       if (udphdr->chksum == 0x0000) {
 840:lwIP/src/core/udp.c ****         udphdr->chksum = 0xffff;
 841:lwIP/src/core/udp.c ****       }
 842:lwIP/src/core/udp.c ****     }
 843:lwIP/src/core/udp.c **** #endif /* CHECKSUM_GEN_UDP */
 844:lwIP/src/core/udp.c **** 
 845:lwIP/src/core/udp.c ****     ip_proto = IP_PROTO_UDPLITE;
 846:lwIP/src/core/udp.c ****   } else
 847:lwIP/src/core/udp.c **** #endif /* LWIP_UDPLITE */
 848:lwIP/src/core/udp.c ****   {      /* UDP */
 849:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
 850:lwIP/src/core/udp.c ****     udphdr->len = lwip_htons(q->tot_len);
 851:lwIP/src/core/udp.c ****     /* calculate checksum */
 852:lwIP/src/core/udp.c **** #if CHECKSUM_GEN_UDP
 853:lwIP/src/core/udp.c ****     IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
 854:lwIP/src/core/udp.c ****       /* Checksum is mandatory over IPv6. */
 855:lwIP/src/core/udp.c ****       if (IP_IS_V6(dst_ip) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 856:lwIP/src/core/udp.c ****         u16_t udpchksum;
 857:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 858:lwIP/src/core/udp.c ****         if (have_chksum) {
 859:lwIP/src/core/udp.c ****           u32_t acc;
 860:lwIP/src/core/udp.c ****           udpchksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDP,
 861:lwIP/src/core/udp.c ****                                                q->tot_len, UDP_HLEN, src_ip, dst_ip);
 862:lwIP/src/core/udp.c ****           acc = udpchksum + (u16_t)~(chksum);
 863:lwIP/src/core/udp.c ****           udpchksum = FOLD_U32T(acc);
 864:lwIP/src/core/udp.c ****         } else
 865:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY */
 866:lwIP/src/core/udp.c ****         {
 867:lwIP/src/core/udp.c ****           udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q->tot_len,
 868:lwIP/src/core/udp.c ****                                        src_ip, dst_ip);
 869:lwIP/src/core/udp.c ****         }
ARM GAS  /tmp/cctoFbTf.s 			page 47


 870:lwIP/src/core/udp.c **** 
 871:lwIP/src/core/udp.c ****         /* chksum zero must become 0xffff, as zero means 'no checksum' */
 872:lwIP/src/core/udp.c ****         if (udpchksum == 0x0000) {
 873:lwIP/src/core/udp.c ****           udpchksum = 0xffff;
 874:lwIP/src/core/udp.c ****         }
 875:lwIP/src/core/udp.c ****         udphdr->chksum = udpchksum;
 876:lwIP/src/core/udp.c ****       }
 877:lwIP/src/core/udp.c ****     }
 878:lwIP/src/core/udp.c **** #endif /* CHECKSUM_GEN_UDP */
 879:lwIP/src/core/udp.c ****     ip_proto = IP_PROTO_UDP;
 880:lwIP/src/core/udp.c ****   }
 881:lwIP/src/core/udp.c **** 
 882:lwIP/src/core/udp.c ****   /* Determine TTL to use */
 883:lwIP/src/core/udp.c **** #if LWIP_MULTICAST_TX_OPTIONS
 884:lwIP/src/core/udp.c ****   ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
 885:lwIP/src/core/udp.c **** #else /* LWIP_MULTICAST_TX_OPTIONS */
 886:lwIP/src/core/udp.c ****   ttl = pcb->ttl;
 887:lwIP/src/core/udp.c **** #endif /* LWIP_MULTICAST_TX_OPTIONS */
 888:lwIP/src/core/udp.c **** 
 889:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
 890:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
 891:lwIP/src/core/udp.c ****   /* output to IP */
 892:lwIP/src/core/udp.c ****   NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 893:lwIP/src/core/udp.c ****   err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 894:lwIP/src/core/udp.c ****   NETIF_RESET_HINTS(netif);
 895:lwIP/src/core/udp.c **** 
 896:lwIP/src/core/udp.c ****   /* @todo: must this be increased even if error occurred? */
 897:lwIP/src/core/udp.c ****   MIB2_STATS_INC(mib2.udpoutdatagrams);
 898:lwIP/src/core/udp.c **** 
 899:lwIP/src/core/udp.c ****   /* did we chain a separate header pbuf earlier? */
 900:lwIP/src/core/udp.c ****   if (q != p) {
 901:lwIP/src/core/udp.c ****     /* free the header pbuf */
 902:lwIP/src/core/udp.c ****     pbuf_free(q);
 903:lwIP/src/core/udp.c ****     q = NULL;
 904:lwIP/src/core/udp.c ****     /* p is still referenced by the caller, and will live on */
 905:lwIP/src/core/udp.c ****   }
 906:lwIP/src/core/udp.c **** 
 907:lwIP/src/core/udp.c ****   UDP_STATS_INC(udp.xmit);
 908:lwIP/src/core/udp.c ****   return err;
 909:lwIP/src/core/udp.c **** }
 910:lwIP/src/core/udp.c **** 
 911:lwIP/src/core/udp.c **** /**
 912:lwIP/src/core/udp.c ****  * @ingroup udp_raw
 913:lwIP/src/core/udp.c ****  * Bind an UDP PCB.
 914:lwIP/src/core/udp.c ****  * 
 915:lwIP/src/core/udp.c ****  * @param pcb UDP PCB to be bound with a local address ipaddr and port.
 916:lwIP/src/core/udp.c ****  * @param ipaddr local IP address to bind with. Use IP_ANY_TYPE to
 917:lwIP/src/core/udp.c ****  * bind to all local interfaces.
 918:lwIP/src/core/udp.c ****  * @param port local UDP port to bind with. Use 0 to automatically bind
 919:lwIP/src/core/udp.c ****  * to a random port between UDP_LOCAL_PORT_RANGE_START and
 920:lwIP/src/core/udp.c ****  * UDP_LOCAL_PORT_RANGE_END.
 921:lwIP/src/core/udp.c ****  *
 922:lwIP/src/core/udp.c ****  * ipaddr & port are expected to be in the same byte order as in the pcb.
 923:lwIP/src/core/udp.c ****  *
 924:lwIP/src/core/udp.c ****  * @return lwIP error code.
 925:lwIP/src/core/udp.c ****  * - ERR_OK. Successful. No error occurred.
 926:lwIP/src/core/udp.c ****  * - ERR_USE. The specified ipaddr and port are already bound to by
ARM GAS  /tmp/cctoFbTf.s 			page 48


 927:lwIP/src/core/udp.c ****  * another UDP PCB.
 928:lwIP/src/core/udp.c ****  *
 929:lwIP/src/core/udp.c ****  * @see udp_disconnect()
 930:lwIP/src/core/udp.c ****  */
 931:lwIP/src/core/udp.c **** err_t
 932:lwIP/src/core/udp.c **** udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
 933:lwIP/src/core/udp.c **** {
 649              		.loc 1 933 1 is_stmt 1 view -0
 650              		.cfi_startproc
 651              		@ args = 0, pretend = 0, frame = 0
 652              		@ frame_needed = 0, uses_anonymous_args = 0
 934:lwIP/src/core/udp.c ****   struct udp_pcb *ipcb;
 653              		.loc 1 934 3 view .LVU224
 935:lwIP/src/core/udp.c ****   u8_t rebind;
 654              		.loc 1 935 3 view .LVU225
 936:lwIP/src/core/udp.c **** #if LWIP_IPV6 && LWIP_IPV6_SCOPES
 937:lwIP/src/core/udp.c ****   ip_addr_t zoned_ipaddr;
 938:lwIP/src/core/udp.c **** #endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
 939:lwIP/src/core/udp.c **** 
 940:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 655              		.loc 1 940 28 view .LVU226
 941:lwIP/src/core/udp.c **** 
 942:lwIP/src/core/udp.c **** #if LWIP_IPV4
 943:lwIP/src/core/udp.c ****   /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
 944:lwIP/src/core/udp.c ****   if (ipaddr == NULL) {
 656              		.loc 1 944 3 view .LVU227
 933:lwIP/src/core/udp.c ****   struct udp_pcb *ipcb;
 657              		.loc 1 933 1 is_stmt 0 view .LVU228
 658 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 659              	.LCFI8:
 660              		.cfi_def_cfa_offset 24
 661              		.cfi_offset 4, -24
 662              		.cfi_offset 5, -20
 663              		.cfi_offset 6, -16
 664              		.cfi_offset 7, -12
 665              		.cfi_offset 8, -8
 666              		.cfi_offset 14, -4
 945:lwIP/src/core/udp.c ****     ipaddr = IP4_ADDR_ANY;
 667              		.loc 1 945 12 view .LVU229
 668 0004 334D     		ldr	r5, .L116
 669 0006 0029     		cmp	r1, #0
 670 0008 18BF     		it	ne
 671 000a 0D46     		movne	r5, r1
 672              	.LVL45:
 946:lwIP/src/core/udp.c ****   }
 947:lwIP/src/core/udp.c **** #else /* LWIP_IPV4 */
 948:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 949:lwIP/src/core/udp.c **** #endif /* LWIP_IPV4 */
 950:lwIP/src/core/udp.c **** 
 951:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 673              		.loc 1 951 3 is_stmt 1 view .LVU230
 674              		.loc 1 951 3 view .LVU231
 675 000c 0028     		cmp	r0, #0
 676 000e 5CD0     		beq	.L114
 677              		.loc 1 951 3 discriminator 2 view .LVU232
 952:lwIP/src/core/udp.c **** 
 953:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
ARM GAS  /tmp/cctoFbTf.s 			page 49


 678              		.loc 1 953 66 discriminator 2 view .LVU233
 954:lwIP/src/core/udp.c ****   ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
 679              		.loc 1 954 58 discriminator 2 view .LVU234
 955:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));
 680              		.loc 1 955 74 discriminator 2 view .LVU235
 956:lwIP/src/core/udp.c **** 
 957:lwIP/src/core/udp.c ****   rebind = 0;
 681              		.loc 1 957 3 discriminator 2 view .LVU236
 682              	.LVL46:
 958:lwIP/src/core/udp.c ****   /* Check for double bind and rebind of the same pcb */
 959:lwIP/src/core/udp.c ****   for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 683              		.loc 1 959 3 discriminator 2 view .LVU237
 684              		.loc 1 959 13 is_stmt 0 discriminator 2 view .LVU238
 685 0010 314F     		ldr	r7, .L116+4
 686 0012 0446     		mov	r4, r0
 687 0014 3868     		ldr	r0, [r7]
 688              	.LVL47:
 689              		.loc 1 959 25 is_stmt 1 discriminator 2 view .LVU239
 690              		.loc 1 959 3 is_stmt 0 discriminator 2 view .LVU240
 691 0016 0028     		cmp	r0, #0
 692 0018 2FD0     		beq	.L80
 960:lwIP/src/core/udp.c ****     /* is this UDP PCB already on active list? */
 961:lwIP/src/core/udp.c ****     if (pcb == ipcb) {
 693              		.loc 1 961 5 is_stmt 1 view .LVU241
 694              		.loc 1 961 8 is_stmt 0 view .LVU242
 695 001a 8442     		cmp	r4, r0
 696 001c 50D0     		beq	.L98
 697 001e 0146     		mov	r1, r0
 698 0020 01E0     		b	.L82
 699              	.LVL48:
 700              	.L83:
 701              		.loc 1 961 8 view .LVU243
 702 0022 8C42     		cmp	r4, r1
 703 0024 4CD0     		beq	.L98
 704              	.L82:
 705              		.loc 1 961 5 is_stmt 1 discriminator 2 view .LVU244
 959:lwIP/src/core/udp.c ****     /* is this UDP PCB already on active list? */
 706              		.loc 1 959 39 discriminator 2 view .LVU245
 959:lwIP/src/core/udp.c ****     /* is this UDP PCB already on active list? */
 707              		.loc 1 959 44 is_stmt 0 discriminator 2 view .LVU246
 708 0026 C968     		ldr	r1, [r1, #12]
 709              	.LVL49:
 959:lwIP/src/core/udp.c ****     /* is this UDP PCB already on active list? */
 710              		.loc 1 959 25 is_stmt 1 discriminator 2 view .LVU247
 959:lwIP/src/core/udp.c ****     /* is this UDP PCB already on active list? */
 711              		.loc 1 959 3 is_stmt 0 discriminator 2 view .LVU248
 712 0028 0029     		cmp	r1, #0
 713 002a FAD1     		bne	.L83
 714              	.LVL50:
 715              	.L81:
 962:lwIP/src/core/udp.c ****       rebind = 1;
 963:lwIP/src/core/udp.c ****       break;
 964:lwIP/src/core/udp.c ****     }
 965:lwIP/src/core/udp.c ****   }
 966:lwIP/src/core/udp.c **** 
 967:lwIP/src/core/udp.c **** #if LWIP_IPV6 && LWIP_IPV6_SCOPES
 968:lwIP/src/core/udp.c ****   /* If the given IP address should have a zone but doesn't, assign one now.
ARM GAS  /tmp/cctoFbTf.s 			page 50


 969:lwIP/src/core/udp.c ****    * This is legacy support: scope-aware callers should always provide properly
 970:lwIP/src/core/udp.c ****    * zoned source addresses. Do the zone selection before the address-in-use
 971:lwIP/src/core/udp.c ****    * check below; as such we have to make a temporary copy of the address. */
 972:lwIP/src/core/udp.c ****   if (IP_IS_V6(ipaddr) && ip6_addr_lacks_zone(ip_2_ip6(ipaddr), IP6_UNKNOWN)) {
 973:lwIP/src/core/udp.c ****     ip_addr_copy(zoned_ipaddr, *ipaddr);
 974:lwIP/src/core/udp.c ****     ip6_addr_select_zone(ip_2_ip6(&zoned_ipaddr), ip_2_ip6(&zoned_ipaddr));
 975:lwIP/src/core/udp.c ****     ipaddr = &zoned_ipaddr;
 976:lwIP/src/core/udp.c ****   }
 977:lwIP/src/core/udp.c **** #endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
 978:lwIP/src/core/udp.c **** 
 979:lwIP/src/core/udp.c ****   /* no port specified? */
 980:lwIP/src/core/udp.c ****   if (port == 0) {
 716              		.loc 1 980 3 is_stmt 1 view .LVU249
 717              		.loc 1 980 6 is_stmt 0 view .LVU250
 718 002c 42B3     		cbz	r2, .L95
 719 002e 2E68     		ldr	r6, [r5]
 720 0030 0346     		mov	r3, r0
 721 0032 01E0     		b	.L93
 722              	.LVL51:
 723              	.L92:
 981:lwIP/src/core/udp.c ****     port = udp_new_port();
 982:lwIP/src/core/udp.c ****     if (port == 0) {
 983:lwIP/src/core/udp.c ****       /* no more ports available in local range */
 984:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
 985:lwIP/src/core/udp.c ****       return ERR_USE;
 986:lwIP/src/core/udp.c ****     }
 987:lwIP/src/core/udp.c ****   } else {
 988:lwIP/src/core/udp.c ****     for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 724              		.loc 1 988 46 discriminator 2 view .LVU251
 725 0034 DB68     		ldr	r3, [r3, #12]
 726              	.LVL52:
 727              		.loc 1 988 27 is_stmt 1 discriminator 2 view .LVU252
 728              		.loc 1 988 5 is_stmt 0 discriminator 2 view .LVU253
 729 0036 93B1     		cbz	r3, .L91
 730              	.LVL53:
 731              	.L93:
 989:lwIP/src/core/udp.c ****       if (pcb != ipcb) {
 732              		.loc 1 989 7 is_stmt 1 view .LVU254
 990:lwIP/src/core/udp.c ****         /* By default, we don't allow to bind to a port that any other udp
 991:lwIP/src/core/udp.c ****            PCB is already bound to, unless *all* PCBs with that port have tha
 992:lwIP/src/core/udp.c ****            REUSEADDR flag set. */
 993:lwIP/src/core/udp.c **** #if SO_REUSE
 994:lwIP/src/core/udp.c ****         if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 995:lwIP/src/core/udp.c ****             !ip_get_option(ipcb, SOF_REUSEADDR))
 996:lwIP/src/core/udp.c **** #endif /* SO_REUSE */
 997:lwIP/src/core/udp.c ****         {
 998:lwIP/src/core/udp.c ****           /* port matches that of PCB in list and REUSEADDR not set -> reject */
 999:lwIP/src/core/udp.c ****           if ((ipcb->local_port == port) &&
 733              		.loc 1 999 11 view .LVU255
 988:lwIP/src/core/udp.c ****       if (pcb != ipcb) {
 734              		.loc 1 988 41 view .LVU256
 989:lwIP/src/core/udp.c ****       if (pcb != ipcb) {
 735              		.loc 1 989 10 is_stmt 0 view .LVU257
 736 0038 9C42     		cmp	r4, r3
 737 003a FBD0     		beq	.L92
 738              		.loc 1 999 14 view .LVU258
 739 003c 5D8A     		ldrh	r5, [r3, #18]
ARM GAS  /tmp/cctoFbTf.s 			page 51


 740 003e 9542     		cmp	r5, r2
 741 0040 F8D1     		bne	.L92
1000:lwIP/src/core/udp.c ****               /* IP address matches or any IP used? */
1001:lwIP/src/core/udp.c ****               (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
 742              		.loc 1 1001 16 discriminator 1 view .LVU259
 743 0042 1D68     		ldr	r5, [r3]
1002:lwIP/src/core/udp.c ****               ip_addr_isany(&ipcb->local_ip))) {
 744              		.loc 1 1002 15 discriminator 1 view .LVU260
 745 0044 002D     		cmp	r5, #0
 746 0046 18BF     		it	ne
 747 0048 B542     		cmpne	r5, r6
 748 004a 01D0     		beq	.L100
 749 004c 002E     		cmp	r6, #0
 750 004e F1D1     		bne	.L92
 751              	.L100:
 985:lwIP/src/core/udp.c ****     }
 752              		.loc 1 985 14 view .LVU261
 753 0050 6FF00700 		mvn	r0, #7
1003:lwIP/src/core/udp.c ****             /* other PCB already binds to this local IP and port */
1004:lwIP/src/core/udp.c ****             LWIP_DEBUGF(UDP_DEBUG,
1005:lwIP/src/core/udp.c ****                         ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
1006:lwIP/src/core/udp.c ****             return ERR_USE;
1007:lwIP/src/core/udp.c ****           }
1008:lwIP/src/core/udp.c ****         }
1009:lwIP/src/core/udp.c ****       }
1010:lwIP/src/core/udp.c ****     }
1011:lwIP/src/core/udp.c ****   }
1012:lwIP/src/core/udp.c **** 
1013:lwIP/src/core/udp.c ****   ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
1014:lwIP/src/core/udp.c **** 
1015:lwIP/src/core/udp.c ****   pcb->local_port = port;
1016:lwIP/src/core/udp.c ****   mib2_udp_bind(pcb);
1017:lwIP/src/core/udp.c ****   /* pcb not active yet? */
1018:lwIP/src/core/udp.c ****   if (rebind == 0) {
1019:lwIP/src/core/udp.c ****     /* place the PCB on the active list if not already there */
1020:lwIP/src/core/udp.c ****     pcb->next = udp_pcbs;
1021:lwIP/src/core/udp.c ****     udp_pcbs = pcb;
1022:lwIP/src/core/udp.c ****   }
1023:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
1024:lwIP/src/core/udp.c ****   ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, pcb->local_ip);
1025:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port))
1026:lwIP/src/core/udp.c ****   return ERR_OK;
1027:lwIP/src/core/udp.c **** }
 754              		.loc 1 1027 1 view .LVU262
 755 0054 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 756              	.LVL54:
 757              	.L86:
 758              		.loc 1 1027 1 view .LVU263
 759 0058 2E68     		ldr	r6, [r5]
 760 005a ACF80020 		strh	r2, [ip]	@ movhi
 761              	.LBB50:
 762              	.LBB51:
 118:lwIP/src/core/udp.c **** }
 763              		.loc 1 118 3 is_stmt 1 view .LVU264
 764              	.LVL55:
 118:lwIP/src/core/udp.c **** }
 765              		.loc 1 118 3 is_stmt 0 view .LVU265
ARM GAS  /tmp/cctoFbTf.s 			page 52


 766              	.LBE51:
 767              	.LBE50:
 982:lwIP/src/core/udp.c ****       /* no more ports available in local range */
 768              		.loc 1 982 5 is_stmt 1 view .LVU266
 769              	.L91:
1013:lwIP/src/core/udp.c **** 
 770              		.loc 1 1013 3 view .LVU267
1013:lwIP/src/core/udp.c **** 
 771              		.loc 1 1013 3 is_stmt 0 view .LVU268
 772 005e 2660     		str	r6, [r4]
1015:lwIP/src/core/udp.c ****   mib2_udp_bind(pcb);
 773              		.loc 1 1015 3 is_stmt 1 view .LVU269
1015:lwIP/src/core/udp.c ****   mib2_udp_bind(pcb);
 774              		.loc 1 1015 19 is_stmt 0 view .LVU270
 775 0060 6282     		strh	r2, [r4, #18]	@ movhi
1016:lwIP/src/core/udp.c ****   /* pcb not active yet? */
 776              		.loc 1 1016 21 is_stmt 1 view .LVU271
1018:lwIP/src/core/udp.c ****     /* place the PCB on the active list if not already there */
 777              		.loc 1 1018 3 view .LVU272
1018:lwIP/src/core/udp.c ****     /* place the PCB on the active list if not already there */
 778              		.loc 1 1018 6 is_stmt 0 view .LVU273
 779 0062 29B1     		cbz	r1, .L94
1026:lwIP/src/core/udp.c **** }
 780              		.loc 1 1026 10 view .LVU274
 781 0064 0020     		movs	r0, #0
 782              	.LVL56:
 783              	.L111:
 784              		.loc 1 1027 1 view .LVU275
 785 0066 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 786              	.LVL57:
 787              	.L115:
 788              		.loc 1 1027 1 view .LVU276
 789 006a 2B68     		ldr	r3, [r5]
 790              	.LVL58:
1013:lwIP/src/core/udp.c **** 
 791              		.loc 1 1013 3 is_stmt 1 view .LVU277
1015:lwIP/src/core/udp.c ****   mib2_udp_bind(pcb);
 792              		.loc 1 1015 19 is_stmt 0 view .LVU278
 793 006c 6282     		strh	r2, [r4, #18]	@ movhi
1013:lwIP/src/core/udp.c **** 
 794              		.loc 1 1013 3 view .LVU279
 795 006e 2360     		str	r3, [r4]
1015:lwIP/src/core/udp.c ****   mib2_udp_bind(pcb);
 796              		.loc 1 1015 3 is_stmt 1 view .LVU280
1016:lwIP/src/core/udp.c ****   /* pcb not active yet? */
 797              		.loc 1 1016 21 view .LVU281
1018:lwIP/src/core/udp.c ****     /* place the PCB on the active list if not already there */
 798              		.loc 1 1018 3 view .LVU282
 799              	.LVL59:
 800              	.L94:
1020:lwIP/src/core/udp.c ****     udp_pcbs = pcb;
 801              		.loc 1 1020 5 view .LVU283
1020:lwIP/src/core/udp.c ****     udp_pcbs = pcb;
 802              		.loc 1 1020 15 is_stmt 0 view .LVU284
 803 0070 E060     		str	r0, [r4, #12]
1021:lwIP/src/core/udp.c ****   }
 804              		.loc 1 1021 5 is_stmt 1 view .LVU285
ARM GAS  /tmp/cctoFbTf.s 			page 53


1026:lwIP/src/core/udp.c **** }
 805              		.loc 1 1026 10 is_stmt 0 view .LVU286
 806 0072 0020     		movs	r0, #0
1021:lwIP/src/core/udp.c ****   }
 807              		.loc 1 1021 14 view .LVU287
 808 0074 3C60     		str	r4, [r7]
 809              		.loc 1 1027 1 view .LVU288
 810 0076 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 811              	.LVL60:
 812              	.L80:
 980:lwIP/src/core/udp.c ****     port = udp_new_port();
 813              		.loc 1 980 3 is_stmt 1 view .LVU289
 980:lwIP/src/core/udp.c ****     port = udp_new_port();
 814              		.loc 1 980 6 is_stmt 0 view .LVU290
 815 007a 002A     		cmp	r2, #0
 816 007c F5D1     		bne	.L115
 957:lwIP/src/core/udp.c ****   /* Check for double bind and rebind of the same pcb */
 817              		.loc 1 957 10 view .LVU291
 818 007e 0146     		mov	r1, r0
 819              	.LVL61:
 820              	.L95:
 957:lwIP/src/core/udp.c ****   /* Check for double bind and rebind of the same pcb */
 821              		.loc 1 957 10 view .LVU292
 822 0080 DFF85CC0 		ldr	ip, .L116+12
 823 0084 4FF48046 		mov	r6, #16384
 824              	.LBB54:
 825              	.LBB52:
 106:lwIP/src/core/udp.c ****     udp_port = UDP_LOCAL_PORT_RANGE_START;
 826              		.loc 1 106 6 view .LVU293
 827 0088 4FF6FF78 		movw	r8, #65535
 828 008c BCF80020 		ldrh	r2, [ip]
 829              	.LVL62:
 830              	.L84:
 103:lwIP/src/core/udp.c **** 
 831              		.loc 1 103 3 is_stmt 1 view .LVU294
 106:lwIP/src/core/udp.c ****     udp_port = UDP_LOCAL_PORT_RANGE_START;
 832              		.loc 1 106 3 view .LVU295
 106:lwIP/src/core/udp.c ****     udp_port = UDP_LOCAL_PORT_RANGE_START;
 833              		.loc 1 106 6 is_stmt 0 view .LVU296
 834 0090 4245     		cmp	r2, r8
 835 0092 17D0     		beq	.L99
 106:lwIP/src/core/udp.c ****     udp_port = UDP_LOCAL_PORT_RANGE_START;
 836              		.loc 1 106 15 view .LVU297
 837 0094 0132     		adds	r2, r2, #1
 838 0096 92B2     		uxth	r2, r2
 839              	.L85:
 110:lwIP/src/core/udp.c ****     if (pcb->local_port == udp_port) {
 840              		.loc 1 110 3 is_stmt 1 view .LVU298
 841              	.LVL63:
 110:lwIP/src/core/udp.c ****     if (pcb->local_port == udp_port) {
 842              		.loc 1 110 24 view .LVU299
 110:lwIP/src/core/udp.c ****     if (pcb->local_port == udp_port) {
 843              		.loc 1 110 3 is_stmt 0 view .LVU300
 844 0098 0028     		cmp	r0, #0
 845 009a DDD0     		beq	.L86
 846 009c 0346     		mov	r3, r0
 847 009e 02E0     		b	.L89
ARM GAS  /tmp/cctoFbTf.s 			page 54


 848              	.LVL64:
 849              	.L87:
 110:lwIP/src/core/udp.c ****     if (pcb->local_port == udp_port) {
 850              		.loc 1 110 41 view .LVU301
 851 00a0 DB68     		ldr	r3, [r3, #12]
 852              	.LVL65:
 110:lwIP/src/core/udp.c ****     if (pcb->local_port == udp_port) {
 853              		.loc 1 110 24 is_stmt 1 view .LVU302
 110:lwIP/src/core/udp.c ****     if (pcb->local_port == udp_port) {
 854              		.loc 1 110 3 is_stmt 0 view .LVU303
 855 00a2 002B     		cmp	r3, #0
 856 00a4 D8D0     		beq	.L86
 857              	.L89:
 111:lwIP/src/core/udp.c ****       if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 858              		.loc 1 111 5 is_stmt 1 view .LVU304
 110:lwIP/src/core/udp.c ****     if (pcb->local_port == udp_port) {
 859              		.loc 1 110 37 view .LVU305
 111:lwIP/src/core/udp.c ****       if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 860              		.loc 1 111 8 is_stmt 0 view .LVU306
 861 00a6 B3F812E0 		ldrh	lr, [r3, #18]
 862 00aa 9645     		cmp	lr, r2
 863 00ac F8D1     		bne	.L87
 112:lwIP/src/core/udp.c ****         return 0;
 864              		.loc 1 112 7 is_stmt 1 view .LVU307
 865 00ae 013E     		subs	r6, r6, #1
 866 00b0 B6B2     		uxth	r6, r6
 112:lwIP/src/core/udp.c ****         return 0;
 867              		.loc 1 112 10 is_stmt 0 view .LVU308
 868 00b2 002E     		cmp	r6, #0
 869 00b4 ECD1     		bne	.L84
 870              	.LBE52:
 871              	.LBE54:
 985:lwIP/src/core/udp.c ****     }
 872              		.loc 1 985 14 view .LVU309
 873 00b6 6FF00700 		mvn	r0, #7
 874 00ba ACF80020 		strh	r2, [ip]	@ movhi
 875 00be D2E7     		b	.L111
 876              	.LVL66:
 877              	.L98:
 962:lwIP/src/core/udp.c ****       break;
 878              		.loc 1 962 14 view .LVU310
 879 00c0 0121     		movs	r1, #1
 880 00c2 B3E7     		b	.L81
 881              	.LVL67:
 882              	.L99:
 883              	.LBB55:
 884              	.LBB53:
 107:lwIP/src/core/udp.c ****   }
 885              		.loc 1 107 14 view .LVU311
 886 00c4 4FF44042 		mov	r2, #49152
 887 00c8 E6E7     		b	.L85
 888              	.LVL68:
 889              	.L114:
 107:lwIP/src/core/udp.c ****   }
 890              		.loc 1 107 14 view .LVU312
 891              	.LBE53:
 892              	.LBE55:
ARM GAS  /tmp/cctoFbTf.s 			page 55


 951:lwIP/src/core/udp.c **** 
 893              		.loc 1 951 3 is_stmt 1 discriminator 1 view .LVU313
 894 00ca 0448     		ldr	r0, .L116+8
 895              	.LVL69:
 951:lwIP/src/core/udp.c **** 
 896              		.loc 1 951 3 is_stmt 0 discriminator 1 view .LVU314
 897 00cc FFF7FEFF 		bl	printf
 898              	.LVL70:
 899              	.L79:
 951:lwIP/src/core/udp.c **** 
 900              		.loc 1 951 3 is_stmt 1 discriminator 1 view .LVU315
 951:lwIP/src/core/udp.c **** 
 901              		.loc 1 951 3 discriminator 1 view .LVU316
 951:lwIP/src/core/udp.c **** 
 902              		.loc 1 951 3 discriminator 1 view .LVU317
 951:lwIP/src/core/udp.c **** 
 903              		.loc 1 951 3 discriminator 1 view .LVU318
 951:lwIP/src/core/udp.c **** 
 904              		.loc 1 951 3 discriminator 1 view .LVU319
 951:lwIP/src/core/udp.c **** 
 905              		.loc 1 951 3 discriminator 1 view .LVU320
 906 00d0 FEE7     		b	.L79
 907              	.L117:
 908 00d2 00BF     		.align	2
 909              	.L116:
 910 00d4 00000000 		.word	ip_addr_any
 911 00d8 00000000 		.word	udp_pcbs
 912 00dc 00000000 		.word	.LC3
 913 00e0 00000000 		.word	.LANCHOR0
 914              		.cfi_endproc
 915              	.LFE113:
 917              		.section	.rodata.udp_sendto_if_src.str1.4,"aMS",%progbits,1
 918              		.align	2
 919              	.LC4:
 920 0000 7564705F 		.ascii	"udp_sendto_if_src: invalid pcb\000"
 920      73656E64 
 920      746F5F69 
 920      665F7372 
 920      633A2069 
 921 001f 00       		.align	2
 922              	.LC5:
 923 0020 7564705F 		.ascii	"udp_sendto_if_src: invalid pbuf\000"
 923      73656E64 
 923      746F5F69 
 923      665F7372 
 923      633A2069 
 924              		.align	2
 925              	.LC6:
 926 0040 7564705F 		.ascii	"udp_sendto_if_src: invalid dst_ip\000"
 926      73656E64 
 926      746F5F69 
 926      665F7372 
 926      633A2069 
 927 0062 0000     		.align	2
 928              	.LC7:
 929 0064 7564705F 		.ascii	"udp_sendto_if_src: invalid src_ip\000"
 929      73656E64 
ARM GAS  /tmp/cctoFbTf.s 			page 56


 929      746F5F69 
 929      665F7372 
 929      633A2069 
 930 0086 0000     		.align	2
 931              	.LC8:
 932 0088 7564705F 		.ascii	"udp_sendto_if_src: invalid netif\000"
 932      73656E64 
 932      746F5F69 
 932      665F7372 
 932      633A2069 
 933 00a9 000000   		.align	2
 934              	.LC9:
 935 00ac 63686563 		.ascii	"check that first pbuf can hold struct udp_hdr\000"
 935      6B207468 
 935      61742066 
 935      69727374 
 935      20706275 
 936              		.section	.text.udp_sendto_if_src,"ax",%progbits
 937              		.align	1
 938              		.p2align 2,,3
 939              		.global	udp_sendto_if_src
 940              		.syntax unified
 941              		.thumb
 942              		.thumb_func
 943              		.fpu fpv4-sp-d16
 945              	udp_sendto_if_src:
 946              	.LVL71:
 947              	.LFB112:
 701:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 948              		.loc 1 701 1 view -0
 949              		.cfi_startproc
 950              		@ args = 8, pretend = 0, frame = 0
 951              		@ frame_needed = 0, uses_anonymous_args = 0
 713:lwIP/src/core/udp.c ****   err_t err;
 952              		.loc 1 713 3 view .LVU322
 714:lwIP/src/core/udp.c ****   struct pbuf *q; /* q will be sent down the stack */
 953              		.loc 1 714 3 view .LVU323
 715:lwIP/src/core/udp.c ****   u8_t ip_proto;
 954              		.loc 1 715 3 view .LVU324
 716:lwIP/src/core/udp.c ****   u8_t ttl;
 955              		.loc 1 716 3 view .LVU325
 717:lwIP/src/core/udp.c **** 
 956              		.loc 1 717 3 view .LVU326
 719:lwIP/src/core/udp.c **** 
 957              		.loc 1 719 28 view .LVU327
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 958              		.loc 1 721 3 view .LVU328
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 959              		.loc 1 721 3 view .LVU329
 701:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 960              		.loc 1 701 1 is_stmt 0 view .LVU330
 961 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 962              	.LCFI9:
 963              		.cfi_def_cfa_offset 36
 964              		.cfi_offset 4, -36
 965              		.cfi_offset 5, -32
 966              		.cfi_offset 6, -28
ARM GAS  /tmp/cctoFbTf.s 			page 57


 967              		.cfi_offset 7, -24
 968              		.cfi_offset 8, -20
 969              		.cfi_offset 9, -16
 970              		.cfi_offset 10, -12
 971              		.cfi_offset 11, -8
 972              		.cfi_offset 14, -4
 973 0004 85B0     		sub	sp, sp, #20
 974              	.LCFI10:
 975              		.cfi_def_cfa_offset 56
 701:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 976              		.loc 1 701 1 view .LVU331
 977 0006 DDE90EBA 		ldrd	fp, r10, [sp, #56]
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 978              		.loc 1 721 3 view .LVU332
 979 000a 0028     		cmp	r0, #0
 980 000c 52D0     		beq	.L148
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 981              		.loc 1 721 3 is_stmt 1 discriminator 2 view .LVU333
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 982              		.loc 1 722 3 discriminator 2 view .LVU334
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 983              		.loc 1 722 3 discriminator 2 view .LVU335
 984 000e 0D46     		mov	r5, r1
 985 0010 0029     		cmp	r1, #0
 986 0012 53D0     		beq	.L149
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 987              		.loc 1 722 3 discriminator 2 view .LVU336
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 988              		.loc 1 723 3 discriminator 2 view .LVU337
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 989              		.loc 1 723 3 discriminator 2 view .LVU338
 990 0014 9046     		mov	r8, r2
 991 0016 002A     		cmp	r2, #0
 992 0018 44D0     		beq	.L150
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 993              		.loc 1 723 3 discriminator 2 view .LVU339
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 994              		.loc 1 724 3 discriminator 2 view .LVU340
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 995              		.loc 1 724 3 discriminator 2 view .LVU341
 996 001a BAF1000F 		cmp	r10, #0
 997 001e 3DD0     		beq	.L151
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 998              		.loc 1 724 3 discriminator 2 view .LVU342
 725:lwIP/src/core/udp.c **** 
 999              		.loc 1 725 3 discriminator 2 view .LVU343
 725:lwIP/src/core/udp.c **** 
 1000              		.loc 1 725 3 discriminator 2 view .LVU344
 1001 0020 BBF1000F 		cmp	fp, #0
 1002 0024 64D0     		beq	.L152
 725:lwIP/src/core/udp.c **** 
 1003              		.loc 1 725 3 view .LVU345
 727:lwIP/src/core/udp.c ****       !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 1004              		.loc 1 727 3 view .LVU346
 746:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 1005              		.loc 1 746 3 view .LVU347
 746:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
ARM GAS  /tmp/cctoFbTf.s 			page 58


 1006              		.loc 1 746 6 is_stmt 0 view .LVU348
 1007 0026 428A     		ldrh	r2, [r0, #18]
 1008              	.LVL72:
 746:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 1009              		.loc 1 746 6 view .LVU349
 1010 0028 9946     		mov	r9, r3
 1011 002a 0646     		mov	r6, r0
 1012 002c 002A     		cmp	r2, #0
 1013 002e 58D0     		beq	.L129
 1014              	.LVL73:
 1015              	.L133:
 1016              	.LBB65:
 1017              	.LBI65:
 699:lwIP/src/core/udp.c ****                   const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *sr
 1018              		.loc 1 699 1 is_stmt 1 view .LVU350
 1019              	.LBB66:
 756:lwIP/src/core/udp.c ****     return ERR_MEM;
 1020              		.loc 1 756 3 view .LVU351
 756:lwIP/src/core/udp.c ****     return ERR_MEM;
 1021              		.loc 1 756 6 is_stmt 0 view .LVU352
 1022 0030 2A89     		ldrh	r2, [r5, #8]
 1023 0032 4FF6F773 		movw	r3, #65527
 1024 0036 9A42     		cmp	r2, r3
 1025 0038 6CD8     		bhi	.L130
 760:lwIP/src/core/udp.c ****     /* allocate header in a separate new pbuf */
 1026              		.loc 1 760 3 is_stmt 1 view .LVU353
 760:lwIP/src/core/udp.c ****     /* allocate header in a separate new pbuf */
 1027              		.loc 1 760 7 is_stmt 0 view .LVU354
 1028 003a 0821     		movs	r1, #8
 1029 003c 2846     		mov	r0, r5
 1030 003e FFF7FEFF 		bl	pbuf_add_header
 1031              	.LVL74:
 760:lwIP/src/core/udp.c ****     /* allocate header in a separate new pbuf */
 1032              		.loc 1 760 6 view .LVU355
 1033 0042 0028     		cmp	r0, #0
 1034 0044 3ED1     		bne	.L153
 1035 0046 2C46     		mov	r4, r5
 1036              	.L134:
 1037              	.LVL75:
 779:lwIP/src/core/udp.c ****   }
 1038              		.loc 1 779 85 is_stmt 1 view .LVU356
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 1039              		.loc 1 781 3 view .LVU357
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 1040              		.loc 1 781 3 view .LVU358
 1041 0048 6389     		ldrh	r3, [r4, #10]
 1042 004a 072B     		cmp	r3, #7
 1043 004c 2ED9     		bls	.L154
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 1044              		.loc 1 781 3 view .LVU359
 784:lwIP/src/core/udp.c ****   udphdr->src = lwip_htons(pcb->local_port);
 1045              		.loc 1 784 3 view .LVU360
 1046              	.LBB67:
 1047              	.LBB68:
 1048              		.loc 2 937 19 is_stmt 0 view .LVU361
 1049 004e 738A     		ldrh	r3, [r6, #18]
 1050              	.LBE68:
ARM GAS  /tmp/cctoFbTf.s 			page 59


 1051              	.LBE67:
 788:lwIP/src/core/udp.c **** 
 1052              		.loc 1 788 18 view .LVU362
 1053 0050 0021     		movs	r1, #0
 850:lwIP/src/core/udp.c ****     /* calculate checksum */
 1054              		.loc 1 850 19 view .LVU363
 1055 0052 2289     		ldrh	r2, [r4, #8]
 1056              	.LBB70:
 1057              	.LBB71:
 1058              		.loc 2 937 19 view .LVU364
 1059 0054 99FA99F9 		rev16	r9, r9
 1060              	.LVL76:
 1061              		.loc 2 937 19 view .LVU365
 1062              	.LBE71:
 1063              	.LBE70:
 784:lwIP/src/core/udp.c ****   udphdr->src = lwip_htons(pcb->local_port);
 1064              		.loc 1 784 10 view .LVU366
 1065 0058 6768     		ldr	r7, [r4, #4]
 1066              	.LVL77:
 785:lwIP/src/core/udp.c ****   udphdr->dest = lwip_htons(dst_port);
 1067              		.loc 1 785 3 is_stmt 1 view .LVU367
 1068              	.LBB73:
 1069              	.LBI67:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1070              		.loc 2 934 30 view .LVU368
 1071              	.LBB69:
 1072              		.loc 2 937 3 view .LVU369
 1073              		.loc 2 937 19 is_stmt 0 view .LVU370
 1074 005a 5BBA     		rev16	r3, r3
 1075              	.LBE69:
 1076              	.LBE73:
 1077              	.LBB74:
 1078              	.LBB75:
 1079 005c 50BA     		rev16	r0, r2
 1080              	.LBE75:
 1081              	.LBE74:
 786:lwIP/src/core/udp.c ****   /* in UDP, 0 checksum means 'no checksum' */
 1082              		.loc 1 786 16 view .LVU371
 1083 005e A7F80290 		strh	r9, [r7, #2]	@ unaligned
 785:lwIP/src/core/udp.c ****   udphdr->dest = lwip_htons(dst_port);
 1084              		.loc 1 785 15 view .LVU372
 1085 0062 3B80     		strh	r3, [r7]	@ unaligned
 786:lwIP/src/core/udp.c ****   /* in UDP, 0 checksum means 'no checksum' */
 1086              		.loc 1 786 3 is_stmt 1 view .LVU373
 1087              	.LVL78:
 1088              	.LBB77:
 1089              	.LBI70:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1090              		.loc 2 934 30 view .LVU374
 1091              	.LBB72:
 1092              		.loc 2 937 3 view .LVU375
 1093              		.loc 2 937 3 is_stmt 0 view .LVU376
 1094              	.LBE72:
 1095              	.LBE77:
 788:lwIP/src/core/udp.c **** 
 1096              		.loc 1 788 3 is_stmt 1 view .LVU377
 850:lwIP/src/core/udp.c ****     /* calculate checksum */
ARM GAS  /tmp/cctoFbTf.s 			page 60


 1097              		.loc 1 850 17 is_stmt 0 view .LVU378
 1098 0064 B880     		strh	r0, [r7, #4]	@ unaligned
 788:lwIP/src/core/udp.c **** 
 1099              		.loc 1 788 18 view .LVU379
 1100 0066 B971     		strb	r1, [r7, #6]
 1101 0068 F971     		strb	r1, [r7, #7]
 797:lwIP/src/core/udp.c **** 
 1102              		.loc 1 797 90 is_stmt 1 view .LVU380
 849:lwIP/src/core/udp.c ****     udphdr->len = lwip_htons(q->tot_len);
 1103              		.loc 1 849 83 view .LVU381
 850:lwIP/src/core/udp.c ****     /* calculate checksum */
 1104              		.loc 1 850 5 view .LVU382
 1105              	.LVL79:
 1106              	.LBB78:
 1107              	.LBI74:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1108              		.loc 2 934 30 view .LVU383
 1109              	.LBB76:
 1110              		.loc 2 937 3 view .LVU384
 1111              		.loc 2 937 3 is_stmt 0 view .LVU385
 1112              	.LBE76:
 1113              	.LBE78:
 855:lwIP/src/core/udp.c ****         u16_t udpchksum;
 1114              		.loc 1 855 7 is_stmt 1 view .LVU386
 855:lwIP/src/core/udp.c ****         u16_t udpchksum;
 1115              		.loc 1 855 10 is_stmt 0 view .LVU387
 1116 006a 337C     		ldrb	r3, [r6, #16]	@ zero_extendqisi2
 1117 006c DB07     		lsls	r3, r3, #31
 1118 006e 43D5     		bpl	.L155
 1119              	.L137:
 879:lwIP/src/core/udp.c ****   }
 1120              		.loc 1 879 5 is_stmt 1 view .LVU388
 1121              	.LVL80:
 886:lwIP/src/core/udp.c **** #endif /* LWIP_MULTICAST_TX_OPTIONS */
 1122              		.loc 1 886 3 view .LVU389
 889:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
 1123              		.loc 1 889 84 view .LVU390
 890:lwIP/src/core/udp.c ****   /* output to IP */
 1124              		.loc 1 890 92 view .LVU391
 892:lwIP/src/core/udp.c ****   err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 1125              		.loc 1 892 46 view .LVU392
 893:lwIP/src/core/udp.c ****   NETIF_RESET_HINTS(netif);
 1126              		.loc 1 893 3 view .LVU393
 893:lwIP/src/core/udp.c ****   NETIF_RESET_HINTS(netif);
 1127              		.loc 1 893 9 is_stmt 0 view .LVU394
 1128 0070 CDF808B0 		str	fp, [sp, #8]
 1129              	.LVL81:
 893:lwIP/src/core/udp.c ****   NETIF_RESET_HINTS(netif);
 1130              		.loc 1 893 9 view .LVU395
 1131 0074 1120     		movs	r0, #17
 1132 0076 B37A     		ldrb	r3, [r6, #10]	@ zero_extendqisi2
 1133 0078 4246     		mov	r2, r8
 1134 007a 5146     		mov	r1, r10
 1135 007c CDE90030 		strd	r3, r0, [sp]
 1136 0080 2046     		mov	r0, r4
 1137 0082 F37A     		ldrb	r3, [r6, #11]	@ zero_extendqisi2
 1138 0084 FFF7FEFF 		bl	ip4_output_if_src
ARM GAS  /tmp/cctoFbTf.s 			page 61


 1139              	.LVL82:
 900:lwIP/src/core/udp.c ****     /* free the header pbuf */
 1140              		.loc 1 900 6 view .LVU396
 1141 0088 A542     		cmp	r5, r4
 893:lwIP/src/core/udp.c ****   NETIF_RESET_HINTS(netif);
 1142              		.loc 1 893 9 view .LVU397
 1143 008a 0746     		mov	r7, r0
 1144              	.LVL83:
 894:lwIP/src/core/udp.c **** 
 1145              		.loc 1 894 27 is_stmt 1 view .LVU398
 897:lwIP/src/core/udp.c **** 
 1146              		.loc 1 897 39 view .LVU399
 900:lwIP/src/core/udp.c ****     /* free the header pbuf */
 1147              		.loc 1 900 3 view .LVU400
 900:lwIP/src/core/udp.c ****     /* free the header pbuf */
 1148              		.loc 1 900 6 is_stmt 0 view .LVU401
 1149 008c 02D0     		beq	.L132
 902:lwIP/src/core/udp.c ****     q = NULL;
 1150              		.loc 1 902 5 is_stmt 1 view .LVU402
 1151 008e 2046     		mov	r0, r4
 1152 0090 FFF7FEFF 		bl	pbuf_free
 1153              	.LVL84:
 903:lwIP/src/core/udp.c ****     /* p is still referenced by the caller, and will live on */
 1154              		.loc 1 903 5 view .LVU403
 1155              	.L132:
 903:lwIP/src/core/udp.c ****     /* p is still referenced by the caller, and will live on */
 1156              		.loc 1 903 5 is_stmt 0 view .LVU404
 1157              	.LBE66:
 1158              	.LBE65:
 909:lwIP/src/core/udp.c **** 
 1159              		.loc 1 909 1 view .LVU405
 1160 0094 3846     		mov	r0, r7
 1161 0096 05B0     		add	sp, sp, #20
 1162              	.LCFI11:
 1163              		.cfi_remember_state
 1164              		.cfi_def_cfa_offset 36
 1165              		@ sp needed
 1166 0098 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1167              	.LVL85:
 1168              	.L151:
 1169              	.LCFI12:
 1170              		.cfi_restore_state
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 1171              		.loc 1 724 3 is_stmt 1 discriminator 1 view .LVU406
 1172 009c 1F48     		ldr	r0, .L156
 1173              	.LVL86:
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 1174              		.loc 1 724 3 is_stmt 0 discriminator 1 view .LVU407
 1175 009e FFF7FEFF 		bl	printf
 1176              	.LVL87:
 1177              	.L126:
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 1178              		.loc 1 724 3 is_stmt 1 discriminator 4 view .LVU408
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 1179              		.loc 1 724 3 discriminator 4 view .LVU409
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 1180              		.loc 1 724 3 discriminator 4 view .LVU410
ARM GAS  /tmp/cctoFbTf.s 			page 62


 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 1181              		.loc 1 724 3 discriminator 4 view .LVU411
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 1182              		.loc 1 724 3 discriminator 4 view .LVU412
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 1183              		.loc 1 724 3 discriminator 4 view .LVU413
 1184 00a2 FEE7     		b	.L126
 1185              	.LVL88:
 1186              	.L150:
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 1187              		.loc 1 723 3 discriminator 1 view .LVU414
 1188 00a4 1E48     		ldr	r0, .L156+4
 1189              	.LVL89:
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 1190              		.loc 1 723 3 is_stmt 0 discriminator 1 view .LVU415
 1191 00a6 FFF7FEFF 		bl	printf
 1192              	.LVL90:
 1193              	.L124:
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 1194              		.loc 1 723 3 is_stmt 1 discriminator 3 view .LVU416
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 1195              		.loc 1 723 3 discriminator 3 view .LVU417
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 1196              		.loc 1 723 3 discriminator 3 view .LVU418
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 1197              		.loc 1 723 3 discriminator 3 view .LVU419
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 1198              		.loc 1 723 3 discriminator 3 view .LVU420
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 1199              		.loc 1 723 3 discriminator 3 view .LVU421
 1200 00aa FEE7     		b	.L124
 1201              	.LVL91:
 1202              	.L154:
 1203              	.LBB83:
 1204              	.LBB80:
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 1205              		.loc 1 781 3 view .LVU422
 1206 00ac 1D48     		ldr	r0, .L156+8
 1207 00ae FFF7FEFF 		bl	printf
 1208              	.LVL92:
 1209              	.L136:
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 1210              		.loc 1 781 3 view .LVU423
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 1211              		.loc 1 781 3 view .LVU424
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 1212              		.loc 1 781 3 view .LVU425
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 1213              		.loc 1 781 3 view .LVU426
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 1214              		.loc 1 781 3 view .LVU427
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 1215              		.loc 1 781 3 view .LVU428
 1216 00b2 FEE7     		b	.L136
 1217              	.LVL93:
 1218              	.L148:
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
ARM GAS  /tmp/cctoFbTf.s 			page 63


 1219              		.loc 1 781 3 is_stmt 0 view .LVU429
 1220              	.LBE80:
 1221              	.LBE83:
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 1222              		.loc 1 721 3 is_stmt 1 discriminator 1 view .LVU430
 1223 00b4 1C48     		ldr	r0, .L156+12
 1224              	.LVL94:
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 1225              		.loc 1 721 3 is_stmt 0 discriminator 1 view .LVU431
 1226 00b6 FFF7FEFF 		bl	printf
 1227              	.LVL95:
 1228              	.L120:
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 1229              		.loc 1 721 3 is_stmt 1 discriminator 1 view .LVU432
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 1230              		.loc 1 721 3 discriminator 1 view .LVU433
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 1231              		.loc 1 721 3 discriminator 1 view .LVU434
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 1232              		.loc 1 721 3 discriminator 1 view .LVU435
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 1233              		.loc 1 721 3 discriminator 1 view .LVU436
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 1234              		.loc 1 721 3 discriminator 1 view .LVU437
 1235 00ba FEE7     		b	.L120
 1236              	.LVL96:
 1237              	.L149:
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1238              		.loc 1 722 3 discriminator 1 view .LVU438
 1239 00bc 1B48     		ldr	r0, .L156+16
 1240              	.LVL97:
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1241              		.loc 1 722 3 is_stmt 0 discriminator 1 view .LVU439
 1242 00be FFF7FEFF 		bl	printf
 1243              	.LVL98:
 1244              	.L122:
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1245              		.loc 1 722 3 is_stmt 1 discriminator 2 view .LVU440
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1246              		.loc 1 722 3 discriminator 2 view .LVU441
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1247              		.loc 1 722 3 discriminator 2 view .LVU442
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1248              		.loc 1 722 3 discriminator 2 view .LVU443
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1249              		.loc 1 722 3 discriminator 2 view .LVU444
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1250              		.loc 1 722 3 discriminator 2 view .LVU445
 1251 00c2 FEE7     		b	.L122
 1252              	.LVL99:
 1253              	.L153:
 1254              	.LBB84:
 1255              	.LBB81:
 762:lwIP/src/core/udp.c ****     /* new header pbuf could not be allocated? */
 1256              		.loc 1 762 5 view .LVU446
 762:lwIP/src/core/udp.c ****     /* new header pbuf could not be allocated? */
 1257              		.loc 1 762 9 is_stmt 0 view .LVU447
ARM GAS  /tmp/cctoFbTf.s 			page 64


 1258 00c4 4FF42072 		mov	r2, #640
 1259 00c8 0821     		movs	r1, #8
 1260 00ca 2220     		movs	r0, #34
 1261 00cc FFF7FEFF 		bl	pbuf_alloc
 1262              	.LVL100:
 764:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not alloca
 1263              		.loc 1 764 5 is_stmt 1 view .LVU448
 764:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not alloca
 1264              		.loc 1 764 8 is_stmt 0 view .LVU449
 1265 00d0 0446     		mov	r4, r0
 1266 00d2 F8B1     		cbz	r0, .L130
 768:lwIP/src/core/udp.c ****       /* chain header q in front of given pbuf p (only if p contains data) */
 1267              		.loc 1 768 5 is_stmt 1 view .LVU450
 768:lwIP/src/core/udp.c ****       /* chain header q in front of given pbuf p (only if p contains data) */
 1268              		.loc 1 768 8 is_stmt 0 view .LVU451
 1269 00d4 2B89     		ldrh	r3, [r5, #8]
 1270 00d6 002B     		cmp	r3, #0
 1271 00d8 B6D0     		beq	.L134
 770:lwIP/src/core/udp.c ****     }
 1272              		.loc 1 770 7 is_stmt 1 view .LVU452
 1273 00da 2946     		mov	r1, r5
 1274 00dc FFF7FEFF 		bl	pbuf_chain
 1275              	.LVL101:
 770:lwIP/src/core/udp.c ****     }
 1276              		.loc 1 770 7 is_stmt 0 view .LVU453
 1277 00e0 B2E7     		b	.L134
 1278              	.LVL102:
 1279              	.L129:
 770:lwIP/src/core/udp.c ****     }
 1280              		.loc 1 770 7 view .LVU454
 1281              	.LBE81:
 1282              	.LBE84:
 747:lwIP/src/core/udp.c ****     err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 1283              		.loc 1 747 98 is_stmt 1 view .LVU455
 748:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
 1284              		.loc 1 748 5 view .LVU456
 748:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
 1285              		.loc 1 748 11 is_stmt 0 view .LVU457
 1286 00e2 0146     		mov	r1, r0
 1287              	.LVL103:
 748:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
 1288              		.loc 1 748 11 view .LVU458
 1289 00e4 FFF7FEFF 		bl	udp_bind
 1290              	.LVL104:
 749:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind
 1291              		.loc 1 749 5 is_stmt 1 view .LVU459
 749:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind
 1292              		.loc 1 749 8 is_stmt 0 view .LVU460
 1293 00e8 0746     		mov	r7, r0
 1294 00ea 0028     		cmp	r0, #0
 1295 00ec A0D0     		beq	.L133
 1296 00ee D1E7     		b	.L132
 1297              	.LVL105:
 1298              	.L152:
 725:lwIP/src/core/udp.c **** 
 1299              		.loc 1 725 3 is_stmt 1 discriminator 1 view .LVU461
 1300 00f0 0F48     		ldr	r0, .L156+20
ARM GAS  /tmp/cctoFbTf.s 			page 65


 1301              	.LVL106:
 725:lwIP/src/core/udp.c **** 
 1302              		.loc 1 725 3 is_stmt 0 discriminator 1 view .LVU462
 1303 00f2 FFF7FEFF 		bl	printf
 1304              	.LVL107:
 1305              	.L128:
 725:lwIP/src/core/udp.c **** 
 1306              		.loc 1 725 3 is_stmt 1 discriminator 5 view .LVU463
 725:lwIP/src/core/udp.c **** 
 1307              		.loc 1 725 3 discriminator 5 view .LVU464
 725:lwIP/src/core/udp.c **** 
 1308              		.loc 1 725 3 discriminator 5 view .LVU465
 725:lwIP/src/core/udp.c **** 
 1309              		.loc 1 725 3 discriminator 5 view .LVU466
 725:lwIP/src/core/udp.c **** 
 1310              		.loc 1 725 3 discriminator 5 view .LVU467
 725:lwIP/src/core/udp.c **** 
 1311              		.loc 1 725 3 discriminator 5 view .LVU468
 1312 00f6 FEE7     		b	.L128
 1313              	.LVL108:
 1314              	.L155:
 1315              	.LBB85:
 1316              	.LBB82:
 1317              	.LBB79:
 856:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 1318              		.loc 1 856 9 view .LVU469
 867:lwIP/src/core/udp.c ****                                        src_ip, dst_ip);
 1319              		.loc 1 867 11 view .LVU470
 867:lwIP/src/core/udp.c ****                                        src_ip, dst_ip);
 1320              		.loc 1 867 23 is_stmt 0 view .LVU471
 1321 00f8 5346     		mov	r3, r10
 1322 00fa 1121     		movs	r1, #17
 1323 00fc 2046     		mov	r0, r4
 1324 00fe CDF80080 		str	r8, [sp]
 1325 0102 FFF7FEFF 		bl	ip_chksum_pseudo
 1326              	.LVL109:
 872:lwIP/src/core/udp.c ****           udpchksum = 0xffff;
 1327              		.loc 1 872 9 is_stmt 1 view .LVU472
 873:lwIP/src/core/udp.c ****         }
 1328              		.loc 1 873 21 is_stmt 0 view .LVU473
 1329 0106 4FF6FF73 		movw	r3, #65535
 1330              	.LVL110:
 875:lwIP/src/core/udp.c ****       }
 1331              		.loc 1 875 9 is_stmt 1 view .LVU474
 875:lwIP/src/core/udp.c ****       }
 1332              		.loc 1 875 24 is_stmt 0 view .LVU475
 1333 010a 0028     		cmp	r0, #0
 1334 010c 08BF     		it	eq
 1335 010e 1846     		moveq	r0, r3
 1336              	.LVL111:
 875:lwIP/src/core/udp.c ****       }
 1337              		.loc 1 875 24 view .LVU476
 1338 0110 F880     		strh	r0, [r7, #6]	@ unaligned
 1339 0112 ADE7     		b	.L137
 1340              	.LVL112:
 1341              	.L130:
 875:lwIP/src/core/udp.c ****       }
ARM GAS  /tmp/cctoFbTf.s 			page 66


 1342              		.loc 1 875 24 view .LVU477
 1343              	.LBE79:
 757:lwIP/src/core/udp.c ****   }
 1344              		.loc 1 757 12 view .LVU478
 1345 0114 4FF0FF37 		mov	r7, #-1
 1346 0118 BCE7     		b	.L132
 1347              	.L157:
 1348 011a 00BF     		.align	2
 1349              	.L156:
 1350 011c 64000000 		.word	.LC7
 1351 0120 40000000 		.word	.LC6
 1352 0124 AC000000 		.word	.LC9
 1353 0128 00000000 		.word	.LC4
 1354 012c 20000000 		.word	.LC5
 1355 0130 88000000 		.word	.LC8
 1356              	.LBE82:
 1357              	.LBE85:
 1358              		.cfi_endproc
 1359              	.LFE112:
 1361              		.section	.rodata.udp_sendto.str1.4,"aMS",%progbits,1
 1362              		.align	2
 1363              	.LC10:
 1364 0000 7564705F 		.ascii	"udp_sendto: invalid pcb\000"
 1364      73656E64 
 1364      746F3A20 
 1364      696E7661 
 1364      6C696420 
 1365              		.align	2
 1366              	.LC11:
 1367 0018 7564705F 		.ascii	"udp_sendto: invalid pbuf\000"
 1367      73656E64 
 1367      746F3A20 
 1367      696E7661 
 1367      6C696420 
 1368 0031 000000   		.align	2
 1369              	.LC12:
 1370 0034 7564705F 		.ascii	"udp_sendto: invalid dst_ip\000"
 1370      73656E64 
 1370      746F3A20 
 1370      696E7661 
 1370      6C696420 
 1371              		.section	.text.udp_sendto,"ax",%progbits
 1372              		.align	1
 1373              		.p2align 2,,3
 1374              		.global	udp_sendto
 1375              		.syntax unified
 1376              		.thumb
 1377              		.thumb_func
 1378              		.fpu fpv4-sp-d16
 1380              	udp_sendto:
 1381              	.LVL113:
 1382              	.LFB110:
 522:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 1383              		.loc 1 522 1 is_stmt 1 view -0
 1384              		.cfi_startproc
 1385              		@ args = 0, pretend = 0, frame = 0
 1386              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cctoFbTf.s 			page 67


 534:lwIP/src/core/udp.c **** 
 1387              		.loc 1 534 3 view .LVU480
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1388              		.loc 1 536 3 view .LVU481
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1389              		.loc 1 536 3 view .LVU482
 522:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 1390              		.loc 1 522 1 is_stmt 0 view .LVU483
 1391 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1392              	.LCFI13:
 1393              		.cfi_def_cfa_offset 20
 1394              		.cfi_offset 4, -20
 1395              		.cfi_offset 5, -16
 1396              		.cfi_offset 6, -12
 1397              		.cfi_offset 7, -8
 1398              		.cfi_offset 14, -4
 1399 0002 83B0     		sub	sp, sp, #12
 1400              	.LCFI14:
 1401              		.cfi_def_cfa_offset 32
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1402              		.loc 1 536 3 view .LVU484
 1403 0004 20B3     		cbz	r0, .L177
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1404              		.loc 1 536 3 is_stmt 1 discriminator 2 view .LVU485
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1405              		.loc 1 537 3 discriminator 2 view .LVU486
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1406              		.loc 1 537 3 discriminator 2 view .LVU487
 1407 0006 0E46     		mov	r6, r1
 1408 0008 31B3     		cbz	r1, .L178
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1409              		.loc 1 537 3 discriminator 2 view .LVU488
 538:lwIP/src/core/udp.c **** 
 1410              		.loc 1 538 3 discriminator 2 view .LVU489
 538:lwIP/src/core/udp.c **** 
 1411              		.loc 1 538 3 discriminator 2 view .LVU490
 1412 000a 1546     		mov	r5, r2
 1413 000c 42B3     		cbz	r2, .L179
 1414              	.LVL114:
 538:lwIP/src/core/udp.c **** 
 1415              		.loc 1 538 3 is_stmt 0 discriminator 2 view .LVU491
 1416 000e 0446     		mov	r4, r0
 1417              	.LBB92:
 1418              	.LBB93:
 546:lwIP/src/core/udp.c ****     netif = netif_get_by_index(pcb->netif_idx);
 1419              		.loc 1 546 10 view .LVU492
 1420 0010 007A     		ldrb	r0, [r0, #8]	@ zero_extendqisi2
 1421              	.LVL115:
 546:lwIP/src/core/udp.c ****     netif = netif_get_by_index(pcb->netif_idx);
 1422              		.loc 1 546 10 view .LVU493
 1423 0012 1F46     		mov	r7, r3
 1424              	.LVL116:
 546:lwIP/src/core/udp.c ****     netif = netif_get_by_index(pcb->netif_idx);
 1425              		.loc 1 546 10 view .LVU494
 1426              	.LBE93:
 1427              	.LBI92:
 520:lwIP/src/core/udp.c ****            const ip_addr_t *dst_ip, u16_t dst_port)
ARM GAS  /tmp/cctoFbTf.s 			page 68


 1428              		.loc 1 520 1 is_stmt 1 view .LVU495
 1429              	.LBB102:
 538:lwIP/src/core/udp.c **** 
 1430              		.loc 1 538 3 view .LVU496
 540:lwIP/src/core/udp.c ****     return ERR_VAL;
 1431              		.loc 1 540 3 view .LVU497
 544:lwIP/src/core/udp.c **** 
 1432              		.loc 1 544 58 view .LVU498
 546:lwIP/src/core/udp.c ****     netif = netif_get_by_index(pcb->netif_idx);
 1433              		.loc 1 546 3 view .LVU499
 546:lwIP/src/core/udp.c ****     netif = netif_get_by_index(pcb->netif_idx);
 1434              		.loc 1 546 6 is_stmt 0 view .LVU500
 1435 0014 B0B1     		cbz	r0, .L165
 547:lwIP/src/core/udp.c ****   } else {
 1436              		.loc 1 547 5 is_stmt 1 view .LVU501
 547:lwIP/src/core/udp.c ****   } else {
 1437              		.loc 1 547 13 is_stmt 0 view .LVU502
 1438 0016 FFF7FEFF 		bl	netif_get_by_index
 1439              	.LVL117:
 1440              	.L166:
 589:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
 1441              		.loc 1 589 3 is_stmt 1 view .LVU503
 589:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
 1442              		.loc 1 589 6 is_stmt 0 view .LVU504
 1443 001a 28B3     		cbz	r0, .L172
 599:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1444              		.loc 1 599 3 is_stmt 1 view .LVU505
 1445              	.LVL118:
 1446              	.LBB94:
 1447              	.LBI94:
 624:lwIP/src/core/udp.c ****               const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
 1448              		.loc 1 624 1 view .LVU506
 1449              	.LBB95:
 638:lwIP/src/core/udp.c **** 
 1450              		.loc 1 638 3 view .LVU507
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 1451              		.loc 1 640 3 view .LVU508
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 1452              		.loc 1 640 3 view .LVU509
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 1453              		.loc 1 640 3 view .LVU510
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1454              		.loc 1 641 3 view .LVU511
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1455              		.loc 1 641 3 view .LVU512
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1456              		.loc 1 641 3 view .LVU513
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 1457              		.loc 1 642 3 view .LVU514
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 1458              		.loc 1 642 3 view .LVU515
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 1459              		.loc 1 642 3 view .LVU516
 643:lwIP/src/core/udp.c **** 
 1460              		.loc 1 643 3 view .LVU517
 643:lwIP/src/core/udp.c **** 
 1461              		.loc 1 643 3 view .LVU518
ARM GAS  /tmp/cctoFbTf.s 			page 69


 1462              	.LBB96:
 1463              	.LBI96:
 624:lwIP/src/core/udp.c ****               const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
 1464              		.loc 1 624 1 view .LVU519
 1465              	.LBB97:
 643:lwIP/src/core/udp.c **** 
 1466              		.loc 1 643 3 view .LVU520
 645:lwIP/src/core/udp.c ****     return ERR_VAL;
 1467              		.loc 1 645 3 view .LVU521
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1468              		.loc 1 673 5 view .LVU522
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1469              		.loc 1 673 9 is_stmt 0 view .LVU523
 1470 001c 2368     		ldr	r3, [r4]
 1471 001e ABB1     		cbz	r3, .L168
 674:lwIP/src/core/udp.c ****       /* if the local_ip is any or multicast
 1472              		.loc 1 674 9 view .LVU524
 1473 0020 03F0F002 		and	r2, r3, #240
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1474              		.loc 1 673 50 view .LVU525
 1475 0024 E02A     		cmp	r2, #224
 1476 0026 11D0     		beq	.L168
 681:lwIP/src/core/udp.c ****         /* local_ip doesn't match, drop the packet */
 1477              		.loc 1 681 7 is_stmt 1 view .LVU526
 681:lwIP/src/core/udp.c ****         /* local_ip doesn't match, drop the packet */
 1478              		.loc 1 681 10 is_stmt 0 view .LVU527
 1479 0028 0268     		ldr	r2, [r0]
 1480 002a 9342     		cmp	r3, r2
 1481 002c 1CD1     		bne	.L172
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1482              		.loc 1 673 9 view .LVU528
 1483 002e 2346     		mov	r3, r4
 1484              	.L170:
 1485              	.LVL119:
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1486              		.loc 1 692 3 is_stmt 1 view .LVU529
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1487              		.loc 1 692 10 is_stmt 0 view .LVU530
 1488 0030 0193     		str	r3, [sp, #4]
 1489 0032 2A46     		mov	r2, r5
 1490 0034 0090     		str	r0, [sp]
 1491 0036 3B46     		mov	r3, r7
 1492              	.LVL120:
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1493              		.loc 1 692 10 view .LVU531
 1494 0038 3146     		mov	r1, r6
 1495 003a 2046     		mov	r0, r4
 1496              	.LVL121:
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1497              		.loc 1 692 10 view .LVU532
 1498 003c FFF7FEFF 		bl	udp_sendto_if_src
 1499              	.LVL122:
 1500              	.L167:
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1501              		.loc 1 692 10 view .LVU533
 1502              	.LBE97:
 1503              	.LBE96:
ARM GAS  /tmp/cctoFbTf.s 			page 70


 1504              	.LBE95:
 1505              	.LBE94:
 1506              	.LBE102:
 1507              	.LBE92:
 601:lwIP/src/core/udp.c **** 
 1508              		.loc 1 601 1 view .LVU534
 1509 0040 03B0     		add	sp, sp, #12
 1510              	.LCFI15:
 1511              		.cfi_remember_state
 1512              		.cfi_def_cfa_offset 20
 1513              		@ sp needed
 1514 0042 F0BD     		pop	{r4, r5, r6, r7, pc}
 1515              	.LVL123:
 1516              	.L165:
 1517              	.LCFI16:
 1518              		.cfi_restore_state
 1519              	.LBB105:
 1520              	.LBB103:
 584:lwIP/src/core/udp.c ****     }
 1521              		.loc 1 584 7 is_stmt 1 view .LVU535
 584:lwIP/src/core/udp.c ****     }
 1522              		.loc 1 584 15 is_stmt 0 view .LVU536
 1523 0044 1046     		mov	r0, r2
 1524 0046 FFF7FEFF 		bl	ip4_route
 1525              	.LVL124:
 584:lwIP/src/core/udp.c ****     }
 1526              		.loc 1 584 15 view .LVU537
 1527 004a E6E7     		b	.L166
 1528              	.LVL125:
 1529              	.L168:
 1530              	.LBB101:
 1531              	.LBB100:
 1532              	.LBB99:
 1533              	.LBB98:
 677:lwIP/src/core/udp.c ****     } else {
 1534              		.loc 1 677 7 is_stmt 1 view .LVU538
 677:lwIP/src/core/udp.c ****     } else {
 1535              		.loc 1 677 14 is_stmt 0 view .LVU539
 1536 004c 0346     		mov	r3, r0
 1537              	.LVL126:
 677:lwIP/src/core/udp.c ****     } else {
 1538              		.loc 1 677 14 view .LVU540
 1539 004e EFE7     		b	.L170
 1540              	.LVL127:
 1541              	.L177:
 677:lwIP/src/core/udp.c ****     } else {
 1542              		.loc 1 677 14 view .LVU541
 1543              	.LBE98:
 1544              	.LBE99:
 1545              	.LBE100:
 1546              	.LBE101:
 1547              	.LBE103:
 1548              	.LBE105:
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1549              		.loc 1 536 3 is_stmt 1 discriminator 1 view .LVU542
 1550 0050 0748     		ldr	r0, .L180
 1551              	.LVL128:
ARM GAS  /tmp/cctoFbTf.s 			page 71


 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1552              		.loc 1 536 3 is_stmt 0 discriminator 1 view .LVU543
 1553 0052 FFF7FEFF 		bl	printf
 1554              	.LVL129:
 1555              	.L160:
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1556              		.loc 1 536 3 is_stmt 1 discriminator 1 view .LVU544
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1557              		.loc 1 536 3 discriminator 1 view .LVU545
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1558              		.loc 1 536 3 discriminator 1 view .LVU546
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1559              		.loc 1 536 3 discriminator 1 view .LVU547
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1560              		.loc 1 536 3 discriminator 1 view .LVU548
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1561              		.loc 1 536 3 discriminator 1 view .LVU549
 1562 0056 FEE7     		b	.L160
 1563              	.LVL130:
 1564              	.L178:
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1565              		.loc 1 537 3 discriminator 1 view .LVU550
 1566 0058 0648     		ldr	r0, .L180+4
 1567              	.LVL131:
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1568              		.loc 1 537 3 is_stmt 0 discriminator 1 view .LVU551
 1569 005a FFF7FEFF 		bl	printf
 1570              	.LVL132:
 1571              	.L162:
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1572              		.loc 1 537 3 is_stmt 1 discriminator 2 view .LVU552
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1573              		.loc 1 537 3 discriminator 2 view .LVU553
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1574              		.loc 1 537 3 discriminator 2 view .LVU554
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1575              		.loc 1 537 3 discriminator 2 view .LVU555
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1576              		.loc 1 537 3 discriminator 2 view .LVU556
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1577              		.loc 1 537 3 discriminator 2 view .LVU557
 1578 005e FEE7     		b	.L162
 1579              	.LVL133:
 1580              	.L179:
 538:lwIP/src/core/udp.c **** 
 1581              		.loc 1 538 3 discriminator 1 view .LVU558
 1582 0060 0548     		ldr	r0, .L180+8
 1583              	.LVL134:
 538:lwIP/src/core/udp.c **** 
 1584              		.loc 1 538 3 is_stmt 0 discriminator 1 view .LVU559
 1585 0062 FFF7FEFF 		bl	printf
 1586              	.LVL135:
 1587              	.L164:
 538:lwIP/src/core/udp.c **** 
 1588              		.loc 1 538 3 is_stmt 1 discriminator 3 view .LVU560
 538:lwIP/src/core/udp.c **** 
 1589              		.loc 1 538 3 discriminator 3 view .LVU561
ARM GAS  /tmp/cctoFbTf.s 			page 72


 538:lwIP/src/core/udp.c **** 
 1590              		.loc 1 538 3 discriminator 3 view .LVU562
 538:lwIP/src/core/udp.c **** 
 1591              		.loc 1 538 3 discriminator 3 view .LVU563
 538:lwIP/src/core/udp.c **** 
 1592              		.loc 1 538 3 discriminator 3 view .LVU564
 538:lwIP/src/core/udp.c **** 
 1593              		.loc 1 538 3 discriminator 3 view .LVU565
 1594 0066 FEE7     		b	.L164
 1595              	.LVL136:
 1596              	.L172:
 1597              	.LBB106:
 1598              	.LBB104:
 594:lwIP/src/core/udp.c ****   }
 1599              		.loc 1 594 12 is_stmt 0 view .LVU566
 1600 0068 6FF00300 		mvn	r0, #3
 1601              	.LVL137:
 594:lwIP/src/core/udp.c ****   }
 1602              		.loc 1 594 12 view .LVU567
 1603 006c E8E7     		b	.L167
 1604              	.L181:
 1605 006e 00BF     		.align	2
 1606              	.L180:
 1607 0070 00000000 		.word	.LC10
 1608 0074 18000000 		.word	.LC11
 1609 0078 34000000 		.word	.LC12
 1610              	.LBE104:
 1611              	.LBE106:
 1612              		.cfi_endproc
 1613              	.LFE110:
 1615              		.section	.rodata.udp_send.str1.4,"aMS",%progbits,1
 1616              		.align	2
 1617              	.LC13:
 1618 0000 7564705F 		.ascii	"udp_send: invalid pcb\000"
 1618      73656E64 
 1618      3A20696E 
 1618      76616C69 
 1618      64207063 
 1619 0016 0000     		.align	2
 1620              	.LC14:
 1621 0018 7564705F 		.ascii	"udp_send: invalid pbuf\000"
 1621      73656E64 
 1621      3A20696E 
 1621      76616C69 
 1621      64207062 
 1622              		.section	.text.udp_send,"ax",%progbits
 1623              		.align	1
 1624              		.p2align 2,,3
 1625              		.global	udp_send
 1626              		.syntax unified
 1627              		.thumb
 1628              		.thumb_func
 1629              		.fpu fpv4-sp-d16
 1631              	udp_send:
 1632              	.LVL138:
 1633              	.LFB109:
 468:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pcb", pcb != NULL, return ERR_ARG);
ARM GAS  /tmp/cctoFbTf.s 			page 73


 1634              		.loc 1 468 1 is_stmt 1 view -0
 1635              		.cfi_startproc
 1636              		@ args = 0, pretend = 0, frame = 0
 1637              		@ frame_needed = 0, uses_anonymous_args = 0
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1638              		.loc 1 469 3 view .LVU569
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1639              		.loc 1 469 3 view .LVU570
 468:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pcb", pcb != NULL, return ERR_ARG);
 1640              		.loc 1 468 1 is_stmt 0 view .LVU571
 1641 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1642              	.LCFI17:
 1643              		.cfi_def_cfa_offset 20
 1644              		.cfi_offset 4, -20
 1645              		.cfi_offset 5, -16
 1646              		.cfi_offset 6, -12
 1647              		.cfi_offset 7, -8
 1648              		.cfi_offset 14, -4
 1649 0002 83B0     		sub	sp, sp, #12
 1650              	.LCFI18:
 1651              		.cfi_def_cfa_offset 32
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1652              		.loc 1 469 3 view .LVU572
 1653 0004 E0B1     		cbz	r0, .L199
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1654              		.loc 1 469 3 is_stmt 1 discriminator 2 view .LVU573
 470:lwIP/src/core/udp.c **** 
 1655              		.loc 1 470 3 discriminator 2 view .LVU574
 470:lwIP/src/core/udp.c **** 
 1656              		.loc 1 470 3 discriminator 2 view .LVU575
 1657 0006 0D46     		mov	r5, r1
 1658 0008 91B1     		cbz	r1, .L200
 470:lwIP/src/core/udp.c **** 
 1659              		.loc 1 470 3 view .LVU576
 472:lwIP/src/core/udp.c ****     return ERR_VAL;
 1660              		.loc 1 472 3 view .LVU577
 477:lwIP/src/core/udp.c **** }
 1661              		.loc 1 477 3 view .LVU578
 1662 000a 0446     		mov	r4, r0
 1663              	.LBB115:
 1664              	.LBB116:
 1665              	.LBB117:
 1666              	.LBB118:
 546:lwIP/src/core/udp.c ****     netif = netif_get_by_index(pcb->netif_idx);
 1667              		.loc 1 546 10 is_stmt 0 view .LVU579
 1668 000c 007A     		ldrb	r0, [r0, #8]	@ zero_extendqisi2
 1669              	.LVL139:
 546:lwIP/src/core/udp.c ****     netif = netif_get_by_index(pcb->netif_idx);
 1670              		.loc 1 546 10 view .LVU580
 1671              	.LBE118:
 1672              	.LBE117:
 1673              	.LBE116:
 1674              	.LBE115:
 477:lwIP/src/core/udp.c **** }
 1675              		.loc 1 477 29 view .LVU581
 1676 000e 261D     		adds	r6, r4, #4
 477:lwIP/src/core/udp.c **** }
ARM GAS  /tmp/cctoFbTf.s 			page 74


 1677              		.loc 1 477 10 view .LVU582
 1678 0010 A78A     		ldrh	r7, [r4, #20]
 1679              	.LVL140:
 1680              	.LBB139:
 1681              	.LBI115:
 520:lwIP/src/core/udp.c ****            const ip_addr_t *dst_ip, u16_t dst_port)
 1682              		.loc 1 520 1 is_stmt 1 view .LVU583
 1683              	.LBB135:
 534:lwIP/src/core/udp.c **** 
 1684              		.loc 1 534 3 view .LVU584
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1685              		.loc 1 536 3 view .LVU585
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1686              		.loc 1 536 3 view .LVU586
 536:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 1687              		.loc 1 536 3 view .LVU587
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1688              		.loc 1 537 3 view .LVU588
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1689              		.loc 1 537 3 view .LVU589
 537:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1690              		.loc 1 537 3 view .LVU590
 538:lwIP/src/core/udp.c **** 
 1691              		.loc 1 538 3 view .LVU591
 538:lwIP/src/core/udp.c **** 
 1692              		.loc 1 538 3 view .LVU592
 1693              	.LBB131:
 1694              	.LBI117:
 520:lwIP/src/core/udp.c ****            const ip_addr_t *dst_ip, u16_t dst_port)
 1695              		.loc 1 520 1 view .LVU593
 1696              	.LBB127:
 538:lwIP/src/core/udp.c **** 
 1697              		.loc 1 538 3 view .LVU594
 540:lwIP/src/core/udp.c ****     return ERR_VAL;
 1698              		.loc 1 540 3 view .LVU595
 544:lwIP/src/core/udp.c **** 
 1699              		.loc 1 544 58 view .LVU596
 546:lwIP/src/core/udp.c ****     netif = netif_get_by_index(pcb->netif_idx);
 1700              		.loc 1 546 3 view .LVU597
 546:lwIP/src/core/udp.c ****     netif = netif_get_by_index(pcb->netif_idx);
 1701              		.loc 1 546 6 is_stmt 0 view .LVU598
 1702 0012 88B1     		cbz	r0, .L187
 547:lwIP/src/core/udp.c ****   } else {
 1703              		.loc 1 547 5 is_stmt 1 view .LVU599
 547:lwIP/src/core/udp.c ****   } else {
 1704              		.loc 1 547 13 is_stmt 0 view .LVU600
 1705 0014 FFF7FEFF 		bl	netif_get_by_index
 1706              	.LVL141:
 1707              	.L188:
 589:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
 1708              		.loc 1 589 3 is_stmt 1 view .LVU601
 589:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
 1709              		.loc 1 589 6 is_stmt 0 view .LVU602
 1710 0018 08B3     		cbz	r0, .L194
 599:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1711              		.loc 1 599 3 is_stmt 1 view .LVU603
 1712              	.LVL142:
ARM GAS  /tmp/cctoFbTf.s 			page 75


 1713              	.LBB119:
 1714              	.LBI119:
 624:lwIP/src/core/udp.c ****               const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
 1715              		.loc 1 624 1 view .LVU604
 1716              	.LBB120:
 638:lwIP/src/core/udp.c **** 
 1717              		.loc 1 638 3 view .LVU605
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 1718              		.loc 1 640 3 view .LVU606
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 1719              		.loc 1 640 3 view .LVU607
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 1720              		.loc 1 640 3 view .LVU608
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1721              		.loc 1 641 3 view .LVU609
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1722              		.loc 1 641 3 view .LVU610
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1723              		.loc 1 641 3 view .LVU611
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 1724              		.loc 1 642 3 view .LVU612
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 1725              		.loc 1 642 3 view .LVU613
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 1726              		.loc 1 642 3 view .LVU614
 643:lwIP/src/core/udp.c **** 
 1727              		.loc 1 643 3 view .LVU615
 643:lwIP/src/core/udp.c **** 
 1728              		.loc 1 643 3 view .LVU616
 1729              	.LBB121:
 1730              	.LBI121:
 624:lwIP/src/core/udp.c ****               const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
 1731              		.loc 1 624 1 view .LVU617
 1732              	.LBB122:
 643:lwIP/src/core/udp.c **** 
 1733              		.loc 1 643 3 view .LVU618
 645:lwIP/src/core/udp.c ****     return ERR_VAL;
 1734              		.loc 1 645 3 view .LVU619
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1735              		.loc 1 673 5 view .LVU620
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1736              		.loc 1 673 9 is_stmt 0 view .LVU621
 1737 001a 2168     		ldr	r1, [r4]
 1738 001c A1B1     		cbz	r1, .L190
 674:lwIP/src/core/udp.c ****       /* if the local_ip is any or multicast
 1739              		.loc 1 674 9 view .LVU622
 1740 001e 01F0F003 		and	r3, r1, #240
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1741              		.loc 1 673 50 view .LVU623
 1742 0022 E02B     		cmp	r3, #224
 1743 0024 10D0     		beq	.L190
 681:lwIP/src/core/udp.c ****         /* local_ip doesn't match, drop the packet */
 1744              		.loc 1 681 7 is_stmt 1 view .LVU624
 681:lwIP/src/core/udp.c ****         /* local_ip doesn't match, drop the packet */
 1745              		.loc 1 681 10 is_stmt 0 view .LVU625
 1746 0026 0368     		ldr	r3, [r0]
 1747 0028 9942     		cmp	r1, r3
ARM GAS  /tmp/cctoFbTf.s 			page 76


 1748 002a 18D1     		bne	.L194
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1749              		.loc 1 673 9 view .LVU626
 1750 002c 2246     		mov	r2, r4
 1751 002e 0CE0     		b	.L192
 1752              	.LVL143:
 1753              	.L200:
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1754              		.loc 1 673 9 view .LVU627
 1755              	.LBE122:
 1756              	.LBE121:
 1757              	.LBE120:
 1758              	.LBE119:
 1759              	.LBE127:
 1760              	.LBE131:
 1761              	.LBE135:
 1762              	.LBE139:
 470:lwIP/src/core/udp.c **** 
 1763              		.loc 1 470 3 is_stmt 1 discriminator 1 view .LVU628
 1764 0030 0C48     		ldr	r0, .L201
 1765              	.LVL144:
 470:lwIP/src/core/udp.c **** 
 1766              		.loc 1 470 3 is_stmt 0 discriminator 1 view .LVU629
 1767 0032 FFF7FEFF 		bl	printf
 1768              	.LVL145:
 1769              	.L186:
 470:lwIP/src/core/udp.c **** 
 1770              		.loc 1 470 3 is_stmt 1 discriminator 2 view .LVU630
 470:lwIP/src/core/udp.c **** 
 1771              		.loc 1 470 3 discriminator 2 view .LVU631
 470:lwIP/src/core/udp.c **** 
 1772              		.loc 1 470 3 discriminator 2 view .LVU632
 470:lwIP/src/core/udp.c **** 
 1773              		.loc 1 470 3 discriminator 2 view .LVU633
 470:lwIP/src/core/udp.c **** 
 1774              		.loc 1 470 3 discriminator 2 view .LVU634
 470:lwIP/src/core/udp.c **** 
 1775              		.loc 1 470 3 discriminator 2 view .LVU635
 1776 0036 FEE7     		b	.L186
 1777              	.LVL146:
 1778              	.L187:
 1779              	.LBB140:
 1780              	.LBB136:
 1781              	.LBB132:
 1782              	.LBB128:
 584:lwIP/src/core/udp.c ****     }
 1783              		.loc 1 584 7 view .LVU636
 584:lwIP/src/core/udp.c ****     }
 1784              		.loc 1 584 15 is_stmt 0 view .LVU637
 1785 0038 3046     		mov	r0, r6
 1786 003a FFF7FEFF 		bl	ip4_route
 1787              	.LVL147:
 584:lwIP/src/core/udp.c ****     }
 1788              		.loc 1 584 15 view .LVU638
 1789 003e EBE7     		b	.L188
 1790              	.LVL148:
 1791              	.L199:
ARM GAS  /tmp/cctoFbTf.s 			page 77


 584:lwIP/src/core/udp.c ****     }
 1792              		.loc 1 584 15 view .LVU639
 1793              	.LBE128:
 1794              	.LBE132:
 1795              	.LBE136:
 1796              	.LBE140:
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1797              		.loc 1 469 3 is_stmt 1 discriminator 1 view .LVU640
 1798 0040 0948     		ldr	r0, .L201+4
 1799              	.LVL149:
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1800              		.loc 1 469 3 is_stmt 0 discriminator 1 view .LVU641
 1801 0042 FFF7FEFF 		bl	printf
 1802              	.LVL150:
 1803              	.L184:
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1804              		.loc 1 469 3 is_stmt 1 discriminator 1 view .LVU642
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1805              		.loc 1 469 3 discriminator 1 view .LVU643
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1806              		.loc 1 469 3 discriminator 1 view .LVU644
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1807              		.loc 1 469 3 discriminator 1 view .LVU645
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1808              		.loc 1 469 3 discriminator 1 view .LVU646
 469:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_send: invalid pbuf", p != NULL, return ERR_ARG);
 1809              		.loc 1 469 3 discriminator 1 view .LVU647
 1810 0046 FEE7     		b	.L184
 1811              	.LVL151:
 1812              	.L190:
 1813              	.LBB141:
 1814              	.LBB137:
 1815              	.LBB133:
 1816              	.LBB129:
 1817              	.LBB126:
 1818              	.LBB125:
 1819              	.LBB124:
 1820              	.LBB123:
 677:lwIP/src/core/udp.c ****     } else {
 1821              		.loc 1 677 7 view .LVU648
 677:lwIP/src/core/udp.c ****     } else {
 1822              		.loc 1 677 14 is_stmt 0 view .LVU649
 1823 0048 0246     		mov	r2, r0
 1824              	.LVL152:
 1825              	.L192:
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1826              		.loc 1 692 3 is_stmt 1 view .LVU650
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1827              		.loc 1 692 10 is_stmt 0 view .LVU651
 1828 004a 0192     		str	r2, [sp, #4]
 1829 004c 3B46     		mov	r3, r7
 1830 004e 0090     		str	r0, [sp]
 1831 0050 3246     		mov	r2, r6
 1832              	.LVL153:
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1833              		.loc 1 692 10 view .LVU652
 1834 0052 2946     		mov	r1, r5
ARM GAS  /tmp/cctoFbTf.s 			page 78


 1835 0054 2046     		mov	r0, r4
 1836              	.LVL154:
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1837              		.loc 1 692 10 view .LVU653
 1838 0056 FFF7FEFF 		bl	udp_sendto_if_src
 1839              	.LVL155:
 1840              	.L189:
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1841              		.loc 1 692 10 view .LVU654
 1842              	.LBE123:
 1843              	.LBE124:
 1844              	.LBE125:
 1845              	.LBE126:
 1846              	.LBE129:
 1847              	.LBE133:
 1848              	.LBE137:
 1849              	.LBE141:
 478:lwIP/src/core/udp.c **** 
 1850              		.loc 1 478 1 view .LVU655
 1851 005a 03B0     		add	sp, sp, #12
 1852              	.LCFI19:
 1853              		.cfi_remember_state
 1854              		.cfi_def_cfa_offset 20
 1855              		@ sp needed
 1856 005c F0BD     		pop	{r4, r5, r6, r7, pc}
 1857              	.LVL156:
 1858              	.L194:
 1859              	.LCFI20:
 1860              		.cfi_restore_state
 1861              	.LBB142:
 1862              	.LBB138:
 1863              	.LBB134:
 1864              	.LBB130:
 594:lwIP/src/core/udp.c ****   }
 1865              		.loc 1 594 12 view .LVU656
 1866 005e 6FF00300 		mvn	r0, #3
 1867              	.LVL157:
 594:lwIP/src/core/udp.c ****   }
 1868              		.loc 1 594 12 view .LVU657
 1869 0062 FAE7     		b	.L189
 1870              	.L202:
 1871              		.align	2
 1872              	.L201:
 1873 0064 18000000 		.word	.LC14
 1874 0068 00000000 		.word	.LC13
 1875              	.LBE130:
 1876              	.LBE134:
 1877              	.LBE138:
 1878              	.LBE142:
 1879              		.cfi_endproc
 1880              	.LFE109:
 1882              		.section	.rodata.udp_sendto_if.str1.4,"aMS",%progbits,1
 1883              		.align	2
 1884              	.LC15:
 1885 0000 7564705F 		.ascii	"udp_sendto_if: invalid pcb\000"
 1885      73656E64 
 1885      746F5F69 
ARM GAS  /tmp/cctoFbTf.s 			page 79


 1885      663A2069 
 1885      6E76616C 
 1886 001b 00       		.align	2
 1887              	.LC16:
 1888 001c 7564705F 		.ascii	"udp_sendto_if: invalid pbuf\000"
 1888      73656E64 
 1888      746F5F69 
 1888      663A2069 
 1888      6E76616C 
 1889              		.align	2
 1890              	.LC17:
 1891 0038 7564705F 		.ascii	"udp_sendto_if: invalid dst_ip\000"
 1891      73656E64 
 1891      746F5F69 
 1891      663A2069 
 1891      6E76616C 
 1892 0056 0000     		.align	2
 1893              	.LC18:
 1894 0058 7564705F 		.ascii	"udp_sendto_if: invalid netif\000"
 1894      73656E64 
 1894      746F5F69 
 1894      663A2069 
 1894      6E76616C 
 1895              		.section	.text.udp_sendto_if,"ax",%progbits
 1896              		.align	1
 1897              		.p2align 2,,3
 1898              		.global	udp_sendto_if
 1899              		.syntax unified
 1900              		.thumb
 1901              		.thumb_func
 1902              		.fpu fpv4-sp-d16
 1904              	udp_sendto_if:
 1905              	.LVL158:
 1906              	.LFB111:
 626:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 1907              		.loc 1 626 1 is_stmt 1 view -0
 1908              		.cfi_startproc
 1909              		@ args = 4, pretend = 0, frame = 0
 1910              		@ frame_needed = 0, uses_anonymous_args = 0
 638:lwIP/src/core/udp.c **** 
 1911              		.loc 1 638 3 view .LVU659
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 1912              		.loc 1 640 3 view .LVU660
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 1913              		.loc 1 640 3 view .LVU661
 626:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 1914              		.loc 1 626 1 is_stmt 0 view .LVU662
 1915 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1916              	.LCFI21:
 1917              		.cfi_def_cfa_offset 36
 1918              		.cfi_offset 4, -36
 1919              		.cfi_offset 5, -32
 1920              		.cfi_offset 6, -28
 1921              		.cfi_offset 7, -24
 1922              		.cfi_offset 8, -20
 1923              		.cfi_offset 9, -16
 1924              		.cfi_offset 10, -12
ARM GAS  /tmp/cctoFbTf.s 			page 80


 1925              		.cfi_offset 11, -8
 1926              		.cfi_offset 14, -4
 1927 0004 85B0     		sub	sp, sp, #20
 1928              	.LCFI22:
 1929              		.cfi_def_cfa_offset 56
 626:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
 1930              		.loc 1 626 1 view .LVU663
 1931 0006 DDF838A0 		ldr	r10, [sp, #56]
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 1932              		.loc 1 640 3 view .LVU664
 1933 000a 0028     		cmp	r0, #0
 1934 000c 5CD0     		beq	.L238
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 1935              		.loc 1 640 3 is_stmt 1 discriminator 2 view .LVU665
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1936              		.loc 1 641 3 discriminator 2 view .LVU666
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1937              		.loc 1 641 3 discriminator 2 view .LVU667
 1938 000e 0F46     		mov	r7, r1
 1939 0010 0029     		cmp	r1, #0
 1940 0012 5DD0     		beq	.L239
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 1941              		.loc 1 641 3 discriminator 2 view .LVU668
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 1942              		.loc 1 642 3 discriminator 2 view .LVU669
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 1943              		.loc 1 642 3 discriminator 2 view .LVU670
 1944 0014 9046     		mov	r8, r2
 1945 0016 002A     		cmp	r2, #0
 1946 0018 5ED0     		beq	.L240
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 1947              		.loc 1 642 3 discriminator 2 view .LVU671
 643:lwIP/src/core/udp.c **** 
 1948              		.loc 1 643 3 discriminator 2 view .LVU672
 643:lwIP/src/core/udp.c **** 
 1949              		.loc 1 643 3 discriminator 2 view .LVU673
 1950 001a BAF1000F 		cmp	r10, #0
 1951 001e 4FD0     		beq	.L241
 1952              	.LVL159:
 643:lwIP/src/core/udp.c **** 
 1953              		.loc 1 643 3 is_stmt 0 discriminator 2 view .LVU674
 1954 0020 9946     		mov	r9, r3
 1955              	.LVL160:
 1956              	.LBB156:
 1957              	.LBI156:
 624:lwIP/src/core/udp.c ****               const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
 1958              		.loc 1 624 1 is_stmt 1 view .LVU675
 1959              	.LBB157:
 643:lwIP/src/core/udp.c **** 
 1960              		.loc 1 643 3 view .LVU676
 645:lwIP/src/core/udp.c ****     return ERR_VAL;
 1961              		.loc 1 645 3 view .LVU677
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1962              		.loc 1 673 5 view .LVU678
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1963              		.loc 1 673 9 is_stmt 0 view .LVU679
 1964 0022 0368     		ldr	r3, [r0]
ARM GAS  /tmp/cctoFbTf.s 			page 81


 1965              	.LVL161:
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1966              		.loc 1 673 9 view .LVU680
 1967 0024 0446     		mov	r4, r0
 1968 0026 8BB1     		cbz	r3, .L212
 674:lwIP/src/core/udp.c ****       /* if the local_ip is any or multicast
 1969              		.loc 1 674 9 view .LVU681
 1970 0028 03F0F002 		and	r2, r3, #240
 1971              	.LVL162:
 673:lwIP/src/core/udp.c ****         ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 1972              		.loc 1 673 50 view .LVU682
 1973 002c E02A     		cmp	r2, #224
 1974 002e 0DD0     		beq	.L212
 681:lwIP/src/core/udp.c ****         /* local_ip doesn't match, drop the packet */
 1975              		.loc 1 681 7 is_stmt 1 view .LVU683
 681:lwIP/src/core/udp.c ****         /* local_ip doesn't match, drop the packet */
 1976              		.loc 1 681 10 is_stmt 0 view .LVU684
 1977 0030 DAF80020 		ldr	r2, [r10]
 1978 0034 9342     		cmp	r3, r2
 1979 0036 77D1     		bne	.L225
 1980              	.LBB158:
 1981              	.LBB159:
 746:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 1982              		.loc 1 746 6 view .LVU685
 1983 0038 628A     		ldrh	r2, [r4, #18]
 1984              	.LBE159:
 1985              	.LBE158:
 686:lwIP/src/core/udp.c ****     }
 1986              		.loc 1 686 14 view .LVU686
 1987 003a 8346     		mov	fp, r0
 1988              	.LVL163:
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 1989              		.loc 1 692 3 is_stmt 1 view .LVU687
 1990              	.LBB181:
 1991              	.LBI158:
 699:lwIP/src/core/udp.c ****                   const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *sr
 1992              		.loc 1 699 1 view .LVU688
 1993              	.LBB177:
 713:lwIP/src/core/udp.c ****   err_t err;
 1994              		.loc 1 713 3 view .LVU689
 714:lwIP/src/core/udp.c ****   struct pbuf *q; /* q will be sent down the stack */
 1995              		.loc 1 714 3 view .LVU690
 715:lwIP/src/core/udp.c ****   u8_t ip_proto;
 1996              		.loc 1 715 3 view .LVU691
 716:lwIP/src/core/udp.c ****   u8_t ttl;
 1997              		.loc 1 716 3 view .LVU692
 717:lwIP/src/core/udp.c **** 
 1998              		.loc 1 717 3 view .LVU693
 719:lwIP/src/core/udp.c **** 
 1999              		.loc 1 719 28 view .LVU694
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 2000              		.loc 1 721 3 view .LVU695
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 2001              		.loc 1 721 3 view .LVU696
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 2002              		.loc 1 721 3 view .LVU697
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
ARM GAS  /tmp/cctoFbTf.s 			page 82


 2003              		.loc 1 722 3 view .LVU698
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2004              		.loc 1 722 3 view .LVU699
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2005              		.loc 1 722 3 view .LVU700
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 2006              		.loc 1 723 3 view .LVU701
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 2007              		.loc 1 723 3 view .LVU702
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 2008              		.loc 1 723 3 view .LVU703
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 2009              		.loc 1 724 3 view .LVU704
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 2010              		.loc 1 724 3 view .LVU705
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 2011              		.loc 1 724 3 view .LVU706
 725:lwIP/src/core/udp.c **** 
 2012              		.loc 1 725 3 view .LVU707
 725:lwIP/src/core/udp.c **** 
 2013              		.loc 1 725 3 view .LVU708
 725:lwIP/src/core/udp.c **** 
 2014              		.loc 1 725 3 view .LVU709
 727:lwIP/src/core/udp.c ****       !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 2015              		.loc 1 727 3 view .LVU710
 746:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 2016              		.loc 1 746 3 view .LVU711
 746:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 2017              		.loc 1 746 6 is_stmt 0 view .LVU712
 2018 003c 52B9     		cbnz	r2, .L224
 2019              	.LVL164:
 2020              	.L242:
 747:lwIP/src/core/udp.c ****     err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 2021              		.loc 1 747 98 is_stmt 1 view .LVU713
 748:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
 2022              		.loc 1 748 5 view .LVU714
 748:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
 2023              		.loc 1 748 11 is_stmt 0 view .LVU715
 2024 003e 2146     		mov	r1, r4
 2025              	.LVL165:
 748:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
 2026              		.loc 1 748 11 view .LVU716
 2027 0040 2046     		mov	r0, r4
 2028              	.LVL166:
 748:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
 2029              		.loc 1 748 11 view .LVU717
 2030 0042 FFF7FEFF 		bl	udp_bind
 2031              	.LVL167:
 749:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind
 2032              		.loc 1 749 5 is_stmt 1 view .LVU718
 749:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind
 2033              		.loc 1 749 8 is_stmt 0 view .LVU719
 2034 0046 0646     		mov	r6, r0
 2035 0048 20B1     		cbz	r0, .L224
 2036 004a 35E0     		b	.L227
 2037              	.LVL168:
 2038              	.L212:
ARM GAS  /tmp/cctoFbTf.s 			page 83


 749:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind
 2039              		.loc 1 749 8 view .LVU720
 2040              	.LBE177:
 2041              	.LBE181:
 677:lwIP/src/core/udp.c ****     } else {
 2042              		.loc 1 677 7 is_stmt 1 view .LVU721
 2043              	.LBB182:
 2044              	.LBB178:
 746:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 2045              		.loc 1 746 6 is_stmt 0 view .LVU722
 2046 004c 628A     		ldrh	r2, [r4, #18]
 2047              	.LBE178:
 2048              	.LBE182:
 677:lwIP/src/core/udp.c ****     } else {
 2049              		.loc 1 677 14 view .LVU723
 2050 004e D346     		mov	fp, r10
 2051              	.LVL169:
 692:lwIP/src/core/udp.c **** #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
 2052              		.loc 1 692 3 is_stmt 1 view .LVU724
 2053              	.LBB183:
 699:lwIP/src/core/udp.c ****                   const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *sr
 2054              		.loc 1 699 1 view .LVU725
 2055              	.LBB179:
 713:lwIP/src/core/udp.c ****   err_t err;
 2056              		.loc 1 713 3 view .LVU726
 714:lwIP/src/core/udp.c ****   struct pbuf *q; /* q will be sent down the stack */
 2057              		.loc 1 714 3 view .LVU727
 715:lwIP/src/core/udp.c ****   u8_t ip_proto;
 2058              		.loc 1 715 3 view .LVU728
 716:lwIP/src/core/udp.c ****   u8_t ttl;
 2059              		.loc 1 716 3 view .LVU729
 717:lwIP/src/core/udp.c **** 
 2060              		.loc 1 717 3 view .LVU730
 719:lwIP/src/core/udp.c **** 
 2061              		.loc 1 719 28 view .LVU731
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 2062              		.loc 1 721 3 view .LVU732
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 2063              		.loc 1 721 3 view .LVU733
 721:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 2064              		.loc 1 721 3 view .LVU734
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2065              		.loc 1 722 3 view .LVU735
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2066              		.loc 1 722 3 view .LVU736
 722:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2067              		.loc 1 722 3 view .LVU737
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 2068              		.loc 1 723 3 view .LVU738
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 2069              		.loc 1 723 3 view .LVU739
 723:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 2070              		.loc 1 723 3 view .LVU740
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 2071              		.loc 1 724 3 view .LVU741
 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 2072              		.loc 1 724 3 view .LVU742
ARM GAS  /tmp/cctoFbTf.s 			page 84


 724:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 2073              		.loc 1 724 3 view .LVU743
 725:lwIP/src/core/udp.c **** 
 2074              		.loc 1 725 3 view .LVU744
 725:lwIP/src/core/udp.c **** 
 2075              		.loc 1 725 3 view .LVU745
 725:lwIP/src/core/udp.c **** 
 2076              		.loc 1 725 3 view .LVU746
 727:lwIP/src/core/udp.c ****       !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
 2077              		.loc 1 727 3 view .LVU747
 746:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 2078              		.loc 1 746 3 view .LVU748
 746:lwIP/src/core/udp.c ****     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
 2079              		.loc 1 746 6 is_stmt 0 view .LVU749
 2080 0050 002A     		cmp	r2, #0
 2081 0052 F4D0     		beq	.L242
 2082              	.LVL170:
 2083              	.L224:
 2084              	.LBB160:
 2085              	.LBI160:
 699:lwIP/src/core/udp.c ****                   const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *sr
 2086              		.loc 1 699 1 is_stmt 1 view .LVU750
 2087              	.LBB161:
 756:lwIP/src/core/udp.c ****     return ERR_MEM;
 2088              		.loc 1 756 3 view .LVU751
 756:lwIP/src/core/udp.c ****     return ERR_MEM;
 2089              		.loc 1 756 6 is_stmt 0 view .LVU752
 2090 0054 3A89     		ldrh	r2, [r7, #8]
 2091 0056 4FF6F773 		movw	r3, #65527
 2092 005a 9A42     		cmp	r2, r3
 2093 005c 61D8     		bhi	.L218
 760:lwIP/src/core/udp.c ****     /* allocate header in a separate new pbuf */
 2094              		.loc 1 760 3 is_stmt 1 view .LVU753
 760:lwIP/src/core/udp.c ****     /* allocate header in a separate new pbuf */
 2095              		.loc 1 760 7 is_stmt 0 view .LVU754
 2096 005e 0821     		movs	r1, #8
 2097 0060 3846     		mov	r0, r7
 2098 0062 FFF7FEFF 		bl	pbuf_add_header
 2099              	.LVL171:
 760:lwIP/src/core/udp.c ****     /* allocate header in a separate new pbuf */
 2100              		.loc 1 760 6 view .LVU755
 2101 0066 0028     		cmp	r0, #0
 2102 0068 3ED1     		bne	.L243
 2103 006a 3D46     		mov	r5, r7
 2104              	.L217:
 2105              	.LVL172:
 779:lwIP/src/core/udp.c ****   }
 2106              		.loc 1 779 85 is_stmt 1 view .LVU756
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 2107              		.loc 1 781 3 view .LVU757
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 2108              		.loc 1 781 3 view .LVU758
 2109 006c 6B89     		ldrh	r3, [r5, #10]
 2110 006e 072B     		cmp	r3, #7
 2111 0070 36D9     		bls	.L244
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 2112              		.loc 1 781 3 view .LVU759
ARM GAS  /tmp/cctoFbTf.s 			page 85


 784:lwIP/src/core/udp.c ****   udphdr->src = lwip_htons(pcb->local_port);
 2113              		.loc 1 784 3 view .LVU760
 2114              	.LBB162:
 2115              	.LBB163:
 2116              		.loc 2 937 19 is_stmt 0 view .LVU761
 2117 0072 638A     		ldrh	r3, [r4, #18]
 2118              	.LBE163:
 2119              	.LBE162:
 788:lwIP/src/core/udp.c **** 
 2120              		.loc 1 788 18 view .LVU762
 2121 0074 0021     		movs	r1, #0
 850:lwIP/src/core/udp.c ****     /* calculate checksum */
 2122              		.loc 1 850 19 view .LVU763
 2123 0076 2A89     		ldrh	r2, [r5, #8]
 2124              	.LBB165:
 2125              	.LBB166:
 2126              		.loc 2 937 19 view .LVU764
 2127 0078 99FA99F9 		rev16	r9, r9
 2128              	.LVL173:
 2129              		.loc 2 937 19 view .LVU765
 2130              	.LBE166:
 2131              	.LBE165:
 784:lwIP/src/core/udp.c ****   udphdr->src = lwip_htons(pcb->local_port);
 2132              		.loc 1 784 10 view .LVU766
 2133 007c 6E68     		ldr	r6, [r5, #4]
 2134              	.LVL174:
 785:lwIP/src/core/udp.c ****   udphdr->dest = lwip_htons(dst_port);
 2135              		.loc 1 785 3 is_stmt 1 view .LVU767
 2136              	.LBB168:
 2137              	.LBI162:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2138              		.loc 2 934 30 view .LVU768
 2139              	.LBB164:
 2140              		.loc 2 937 3 view .LVU769
 2141              		.loc 2 937 19 is_stmt 0 view .LVU770
 2142 007e 5BBA     		rev16	r3, r3
 2143              	.LBE164:
 2144              	.LBE168:
 2145              	.LBB169:
 2146              	.LBB170:
 2147 0080 50BA     		rev16	r0, r2
 2148              	.LBE170:
 2149              	.LBE169:
 786:lwIP/src/core/udp.c ****   /* in UDP, 0 checksum means 'no checksum' */
 2150              		.loc 1 786 16 view .LVU771
 2151 0082 A6F80290 		strh	r9, [r6, #2]	@ unaligned
 785:lwIP/src/core/udp.c ****   udphdr->dest = lwip_htons(dst_port);
 2152              		.loc 1 785 15 view .LVU772
 2153 0086 3380     		strh	r3, [r6]	@ unaligned
 786:lwIP/src/core/udp.c ****   /* in UDP, 0 checksum means 'no checksum' */
 2154              		.loc 1 786 3 is_stmt 1 view .LVU773
 2155              	.LVL175:
 2156              	.LBB172:
 2157              	.LBI165:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2158              		.loc 2 934 30 view .LVU774
 2159              	.LBB167:
ARM GAS  /tmp/cctoFbTf.s 			page 86


 2160              		.loc 2 937 3 view .LVU775
 2161              		.loc 2 937 3 is_stmt 0 view .LVU776
 2162              	.LBE167:
 2163              	.LBE172:
 788:lwIP/src/core/udp.c **** 
 2164              		.loc 1 788 3 is_stmt 1 view .LVU777
 850:lwIP/src/core/udp.c ****     /* calculate checksum */
 2165              		.loc 1 850 17 is_stmt 0 view .LVU778
 2166 0088 B080     		strh	r0, [r6, #4]	@ unaligned
 788:lwIP/src/core/udp.c **** 
 2167              		.loc 1 788 18 view .LVU779
 2168 008a B171     		strb	r1, [r6, #6]
 2169 008c F171     		strb	r1, [r6, #7]
 797:lwIP/src/core/udp.c **** 
 2170              		.loc 1 797 90 is_stmt 1 view .LVU780
 849:lwIP/src/core/udp.c ****     udphdr->len = lwip_htons(q->tot_len);
 2171              		.loc 1 849 83 view .LVU781
 850:lwIP/src/core/udp.c ****     /* calculate checksum */
 2172              		.loc 1 850 5 view .LVU782
 2173              	.LVL176:
 2174              	.LBB173:
 2175              	.LBI169:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2176              		.loc 2 934 30 view .LVU783
 2177              	.LBB171:
 2178              		.loc 2 937 3 view .LVU784
 2179              		.loc 2 937 3 is_stmt 0 view .LVU785
 2180              	.LBE171:
 2181              	.LBE173:
 855:lwIP/src/core/udp.c ****         u16_t udpchksum;
 2182              		.loc 1 855 7 is_stmt 1 view .LVU786
 855:lwIP/src/core/udp.c ****         u16_t udpchksum;
 2183              		.loc 1 855 10 is_stmt 0 view .LVU787
 2184 008e 237C     		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 2185 0090 DB07     		lsls	r3, r3, #31
 2186 0092 38D5     		bpl	.L245
 2187              	.L221:
 879:lwIP/src/core/udp.c ****   }
 2188              		.loc 1 879 5 is_stmt 1 view .LVU788
 2189              	.LVL177:
 886:lwIP/src/core/udp.c **** #endif /* LWIP_MULTICAST_TX_OPTIONS */
 2190              		.loc 1 886 3 view .LVU789
 889:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
 2191              		.loc 1 889 84 view .LVU790
 890:lwIP/src/core/udp.c ****   /* output to IP */
 2192              		.loc 1 890 92 view .LVU791
 892:lwIP/src/core/udp.c ****   err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 2193              		.loc 1 892 46 view .LVU792
 893:lwIP/src/core/udp.c ****   NETIF_RESET_HINTS(netif);
 2194              		.loc 1 893 3 view .LVU793
 893:lwIP/src/core/udp.c ****   NETIF_RESET_HINTS(netif);
 2195              		.loc 1 893 9 is_stmt 0 view .LVU794
 2196 0094 CDF808A0 		str	r10, [sp, #8]
 2197              	.LVL178:
 893:lwIP/src/core/udp.c ****   NETIF_RESET_HINTS(netif);
 2198              		.loc 1 893 9 view .LVU795
 2199 0098 1120     		movs	r0, #17
ARM GAS  /tmp/cctoFbTf.s 			page 87


 2200 009a A37A     		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 2201 009c 4246     		mov	r2, r8
 2202 009e 5946     		mov	r1, fp
 2203 00a0 CDE90030 		strd	r3, r0, [sp]
 2204 00a4 2846     		mov	r0, r5
 2205 00a6 E37A     		ldrb	r3, [r4, #11]	@ zero_extendqisi2
 2206 00a8 FFF7FEFF 		bl	ip4_output_if_src
 2207              	.LVL179:
 900:lwIP/src/core/udp.c ****     /* free the header pbuf */
 2208              		.loc 1 900 6 view .LVU796
 2209 00ac AF42     		cmp	r7, r5
 893:lwIP/src/core/udp.c ****   NETIF_RESET_HINTS(netif);
 2210              		.loc 1 893 9 view .LVU797
 2211 00ae 0646     		mov	r6, r0
 2212              	.LVL180:
 894:lwIP/src/core/udp.c **** 
 2213              		.loc 1 894 27 is_stmt 1 view .LVU798
 897:lwIP/src/core/udp.c **** 
 2214              		.loc 1 897 39 view .LVU799
 900:lwIP/src/core/udp.c ****     /* free the header pbuf */
 2215              		.loc 1 900 3 view .LVU800
 900:lwIP/src/core/udp.c ****     /* free the header pbuf */
 2216              		.loc 1 900 6 is_stmt 0 view .LVU801
 2217 00b0 02D0     		beq	.L227
 902:lwIP/src/core/udp.c ****     q = NULL;
 2218              		.loc 1 902 5 is_stmt 1 view .LVU802
 2219 00b2 2846     		mov	r0, r5
 2220 00b4 FFF7FEFF 		bl	pbuf_free
 2221              	.LVL181:
 903:lwIP/src/core/udp.c ****     /* p is still referenced by the caller, and will live on */
 2222              		.loc 1 903 5 view .LVU803
 2223              	.L227:
 903:lwIP/src/core/udp.c ****     /* p is still referenced by the caller, and will live on */
 2224              		.loc 1 903 5 is_stmt 0 view .LVU804
 2225              	.LBE161:
 2226              	.LBE160:
 2227              	.LBE179:
 2228              	.LBE183:
 2229              	.LBE157:
 2230              	.LBE156:
 694:lwIP/src/core/udp.c **** 
 2231              		.loc 1 694 1 view .LVU805
 2232 00b8 3046     		mov	r0, r6
 2233 00ba 05B0     		add	sp, sp, #20
 2234              	.LCFI23:
 2235              		.cfi_remember_state
 2236              		.cfi_def_cfa_offset 36
 2237              		@ sp needed
 2238 00bc BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2239              	.LVL182:
 2240              	.L241:
 2241              	.LCFI24:
 2242              		.cfi_restore_state
 643:lwIP/src/core/udp.c **** 
 2243              		.loc 1 643 3 is_stmt 1 discriminator 1 view .LVU806
 2244 00c0 1B48     		ldr	r0, .L246
 2245              	.LVL183:
ARM GAS  /tmp/cctoFbTf.s 			page 88


 643:lwIP/src/core/udp.c **** 
 2246              		.loc 1 643 3 is_stmt 0 discriminator 1 view .LVU807
 2247 00c2 FFF7FEFF 		bl	printf
 2248              	.LVL184:
 2249              	.L211:
 643:lwIP/src/core/udp.c **** 
 2250              		.loc 1 643 3 is_stmt 1 discriminator 4 view .LVU808
 643:lwIP/src/core/udp.c **** 
 2251              		.loc 1 643 3 discriminator 4 view .LVU809
 643:lwIP/src/core/udp.c **** 
 2252              		.loc 1 643 3 discriminator 4 view .LVU810
 643:lwIP/src/core/udp.c **** 
 2253              		.loc 1 643 3 discriminator 4 view .LVU811
 643:lwIP/src/core/udp.c **** 
 2254              		.loc 1 643 3 discriminator 4 view .LVU812
 643:lwIP/src/core/udp.c **** 
 2255              		.loc 1 643 3 discriminator 4 view .LVU813
 2256 00c6 FEE7     		b	.L211
 2257              	.LVL185:
 2258              	.L238:
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 2259              		.loc 1 640 3 discriminator 1 view .LVU814
 2260 00c8 1A48     		ldr	r0, .L246+4
 2261              	.LVL186:
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 2262              		.loc 1 640 3 is_stmt 0 discriminator 1 view .LVU815
 2263 00ca FFF7FEFF 		bl	printf
 2264              	.LVL187:
 2265              	.L205:
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 2266              		.loc 1 640 3 is_stmt 1 discriminator 1 view .LVU816
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 2267              		.loc 1 640 3 discriminator 1 view .LVU817
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 2268              		.loc 1 640 3 discriminator 1 view .LVU818
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 2269              		.loc 1 640 3 discriminator 1 view .LVU819
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 2270              		.loc 1 640 3 discriminator 1 view .LVU820
 640:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 2271              		.loc 1 640 3 discriminator 1 view .LVU821
 2272 00ce FEE7     		b	.L205
 2273              	.LVL188:
 2274              	.L239:
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2275              		.loc 1 641 3 discriminator 1 view .LVU822
 2276 00d0 1948     		ldr	r0, .L246+8
 2277              	.LVL189:
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2278              		.loc 1 641 3 is_stmt 0 discriminator 1 view .LVU823
 2279 00d2 FFF7FEFF 		bl	printf
 2280              	.LVL190:
 2281              	.L207:
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2282              		.loc 1 641 3 is_stmt 1 discriminator 2 view .LVU824
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2283              		.loc 1 641 3 discriminator 2 view .LVU825
ARM GAS  /tmp/cctoFbTf.s 			page 89


 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2284              		.loc 1 641 3 discriminator 2 view .LVU826
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2285              		.loc 1 641 3 discriminator 2 view .LVU827
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2286              		.loc 1 641 3 discriminator 2 view .LVU828
 641:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 2287              		.loc 1 641 3 discriminator 2 view .LVU829
 2288 00d6 FEE7     		b	.L207
 2289              	.LVL191:
 2290              	.L240:
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 2291              		.loc 1 642 3 discriminator 1 view .LVU830
 2292 00d8 1848     		ldr	r0, .L246+12
 2293              	.LVL192:
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 2294              		.loc 1 642 3 is_stmt 0 discriminator 1 view .LVU831
 2295 00da FFF7FEFF 		bl	printf
 2296              	.LVL193:
 2297              	.L209:
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 2298              		.loc 1 642 3 is_stmt 1 discriminator 3 view .LVU832
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 2299              		.loc 1 642 3 discriminator 3 view .LVU833
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 2300              		.loc 1 642 3 discriminator 3 view .LVU834
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 2301              		.loc 1 642 3 discriminator 3 view .LVU835
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 2302              		.loc 1 642 3 discriminator 3 view .LVU836
 642:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 2303              		.loc 1 642 3 discriminator 3 view .LVU837
 2304 00de FEE7     		b	.L209
 2305              	.LVL194:
 2306              	.L244:
 2307              	.LBB186:
 2308              	.LBB185:
 2309              	.LBB184:
 2310              	.LBB180:
 2311              	.LBB176:
 2312              	.LBB175:
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 2313              		.loc 1 781 3 view .LVU838
 2314 00e0 1748     		ldr	r0, .L246+16
 2315 00e2 FFF7FEFF 		bl	printf
 2316              	.LVL195:
 2317              	.L220:
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 2318              		.loc 1 781 3 view .LVU839
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 2319              		.loc 1 781 3 view .LVU840
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 2320              		.loc 1 781 3 view .LVU841
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 2321              		.loc 1 781 3 view .LVU842
 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 2322              		.loc 1 781 3 view .LVU843
ARM GAS  /tmp/cctoFbTf.s 			page 90


 781:lwIP/src/core/udp.c ****               (q->len >= sizeof(struct udp_hdr)));
 2323              		.loc 1 781 3 view .LVU844
 2324 00e6 FEE7     		b	.L220
 2325              	.LVL196:
 2326              	.L243:
 762:lwIP/src/core/udp.c ****     /* new header pbuf could not be allocated? */
 2327              		.loc 1 762 5 view .LVU845
 762:lwIP/src/core/udp.c ****     /* new header pbuf could not be allocated? */
 2328              		.loc 1 762 9 is_stmt 0 view .LVU846
 2329 00e8 4FF42072 		mov	r2, #640
 2330 00ec 0821     		movs	r1, #8
 2331 00ee 2220     		movs	r0, #34
 2332 00f0 FFF7FEFF 		bl	pbuf_alloc
 2333              	.LVL197:
 764:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not alloca
 2334              		.loc 1 764 5 is_stmt 1 view .LVU847
 764:lwIP/src/core/udp.c ****       LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not alloca
 2335              		.loc 1 764 8 is_stmt 0 view .LVU848
 2336 00f4 0546     		mov	r5, r0
 2337 00f6 A0B1     		cbz	r0, .L218
 768:lwIP/src/core/udp.c ****       /* chain header q in front of given pbuf p (only if p contains data) */
 2338              		.loc 1 768 5 is_stmt 1 view .LVU849
 768:lwIP/src/core/udp.c ****       /* chain header q in front of given pbuf p (only if p contains data) */
 2339              		.loc 1 768 8 is_stmt 0 view .LVU850
 2340 00f8 3B89     		ldrh	r3, [r7, #8]
 2341 00fa 002B     		cmp	r3, #0
 2342 00fc B6D0     		beq	.L217
 770:lwIP/src/core/udp.c ****     }
 2343              		.loc 1 770 7 is_stmt 1 view .LVU851
 2344 00fe 3946     		mov	r1, r7
 2345 0100 FFF7FEFF 		bl	pbuf_chain
 2346              	.LVL198:
 770:lwIP/src/core/udp.c ****     }
 2347              		.loc 1 770 7 is_stmt 0 view .LVU852
 2348 0104 B2E7     		b	.L217
 2349              	.LVL199:
 2350              	.L245:
 2351              	.LBB174:
 856:lwIP/src/core/udp.c **** #if LWIP_CHECKSUM_ON_COPY
 2352              		.loc 1 856 9 is_stmt 1 view .LVU853
 867:lwIP/src/core/udp.c ****                                        src_ip, dst_ip);
 2353              		.loc 1 867 11 view .LVU854
 867:lwIP/src/core/udp.c ****                                        src_ip, dst_ip);
 2354              		.loc 1 867 23 is_stmt 0 view .LVU855
 2355 0106 5B46     		mov	r3, fp
 2356 0108 1121     		movs	r1, #17
 2357 010a 2846     		mov	r0, r5
 2358 010c CDF80080 		str	r8, [sp]
 2359 0110 FFF7FEFF 		bl	ip_chksum_pseudo
 2360              	.LVL200:
 872:lwIP/src/core/udp.c ****           udpchksum = 0xffff;
 2361              		.loc 1 872 9 is_stmt 1 view .LVU856
 873:lwIP/src/core/udp.c ****         }
 2362              		.loc 1 873 21 is_stmt 0 view .LVU857
 2363 0114 4FF6FF73 		movw	r3, #65535
 2364              	.LVL201:
 875:lwIP/src/core/udp.c ****       }
ARM GAS  /tmp/cctoFbTf.s 			page 91


 2365              		.loc 1 875 9 is_stmt 1 view .LVU858
 875:lwIP/src/core/udp.c ****       }
 2366              		.loc 1 875 24 is_stmt 0 view .LVU859
 2367 0118 0028     		cmp	r0, #0
 2368 011a 08BF     		it	eq
 2369 011c 1846     		moveq	r0, r3
 2370              	.LVL202:
 875:lwIP/src/core/udp.c ****       }
 2371              		.loc 1 875 24 view .LVU860
 2372 011e F080     		strh	r0, [r6, #6]	@ unaligned
 2373 0120 B8E7     		b	.L221
 2374              	.LVL203:
 2375              	.L218:
 875:lwIP/src/core/udp.c ****       }
 2376              		.loc 1 875 24 view .LVU861
 2377              	.LBE174:
 757:lwIP/src/core/udp.c ****   }
 2378              		.loc 1 757 12 view .LVU862
 2379 0122 4FF0FF36 		mov	r6, #-1
 2380 0126 C7E7     		b	.L227
 2381              	.LVL204:
 2382              	.L225:
 757:lwIP/src/core/udp.c ****   }
 2383              		.loc 1 757 12 view .LVU863
 2384              	.LBE175:
 2385              	.LBE176:
 2386              	.LBE180:
 2387              	.LBE184:
 683:lwIP/src/core/udp.c ****       }
 2388              		.loc 1 683 16 view .LVU864
 2389 0128 6FF00306 		mvn	r6, #3
 2390              	.LVL205:
 683:lwIP/src/core/udp.c ****       }
 2391              		.loc 1 683 16 view .LVU865
 2392 012c C4E7     		b	.L227
 2393              	.L247:
 2394 012e 00BF     		.align	2
 2395              	.L246:
 2396 0130 58000000 		.word	.LC18
 2397 0134 00000000 		.word	.LC15
 2398 0138 1C000000 		.word	.LC16
 2399 013c 38000000 		.word	.LC17
 2400 0140 AC000000 		.word	.LC9
 2401              	.LBE185:
 2402              	.LBE186:
 2403              		.cfi_endproc
 2404              	.LFE111:
 2406              		.section	.text.udp_bind_netif,"ax",%progbits
 2407              		.align	1
 2408              		.p2align 2,,3
 2409              		.global	udp_bind_netif
 2410              		.syntax unified
 2411              		.thumb
 2412              		.thumb_func
 2413              		.fpu fpv4-sp-d16
 2415              	udp_bind_netif:
 2416              	.LVL206:
ARM GAS  /tmp/cctoFbTf.s 			page 92


 2417              	.LFB114:
1028:lwIP/src/core/udp.c **** 
1029:lwIP/src/core/udp.c **** /**
1030:lwIP/src/core/udp.c ****  * @ingroup udp_raw
1031:lwIP/src/core/udp.c ****  * Bind an UDP PCB to a specific netif.
1032:lwIP/src/core/udp.c ****  * After calling this function, all packets received via this PCB
1033:lwIP/src/core/udp.c ****  * are guaranteed to have come in via the specified netif, and all
1034:lwIP/src/core/udp.c ****  * outgoing packets will go out via the specified netif.
1035:lwIP/src/core/udp.c ****  *
1036:lwIP/src/core/udp.c ****  * @param pcb UDP PCB to be bound.
1037:lwIP/src/core/udp.c ****  * @param netif netif to bind udp pcb to. Can be NULL.
1038:lwIP/src/core/udp.c ****  *
1039:lwIP/src/core/udp.c ****  * @see udp_disconnect()
1040:lwIP/src/core/udp.c ****  */
1041:lwIP/src/core/udp.c **** void
1042:lwIP/src/core/udp.c **** udp_bind_netif(struct udp_pcb *pcb, const struct netif *netif)
1043:lwIP/src/core/udp.c **** {
 2418              		.loc 1 1043 1 is_stmt 1 view -0
 2419              		.cfi_startproc
 2420              		@ args = 0, pretend = 0, frame = 0
 2421              		@ frame_needed = 0, uses_anonymous_args = 0
 2422              		@ link register save eliminated.
1044:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 2423              		.loc 1 1044 28 view .LVU867
1045:lwIP/src/core/udp.c **** 
1046:lwIP/src/core/udp.c ****   if (netif != NULL) {
 2424              		.loc 1 1046 3 view .LVU868
 2425              		.loc 1 1046 6 is_stmt 0 view .LVU869
 2426 0000 19B1     		cbz	r1, .L249
1047:lwIP/src/core/udp.c ****     pcb->netif_idx = netif_get_index(netif);
 2427              		.loc 1 1047 5 is_stmt 1 view .LVU870
 2428              		.loc 1 1047 22 is_stmt 0 view .LVU871
 2429 0002 91F82810 		ldrb	r1, [r1, #40]	@ zero_extendqisi2
 2430              	.LVL207:
 2431              		.loc 1 1047 22 view .LVU872
 2432 0006 0131     		adds	r1, r1, #1
 2433 0008 C9B2     		uxtb	r1, r1
 2434              	.L249:
 2435 000a 0172     		strb	r1, [r0, #8]
1048:lwIP/src/core/udp.c ****   } else {
1049:lwIP/src/core/udp.c ****     pcb->netif_idx = NETIF_NO_INDEX;
1050:lwIP/src/core/udp.c ****   }
1051:lwIP/src/core/udp.c **** }
 2436              		.loc 1 1051 1 view .LVU873
 2437 000c 7047     		bx	lr
 2438              		.cfi_endproc
 2439              	.LFE114:
 2441              		.section	.rodata.udp_connect.str1.4,"aMS",%progbits,1
 2442              		.align	2
 2443              	.LC19:
 2444 0000 7564705F 		.ascii	"udp_connect: invalid pcb\000"
 2444      636F6E6E 
 2444      6563743A 
 2444      20696E76 
 2444      616C6964 
 2445 0019 000000   		.align	2
 2446              	.LC20:
ARM GAS  /tmp/cctoFbTf.s 			page 93


 2447 001c 7564705F 		.ascii	"udp_connect: invalid ipaddr\000"
 2447      636F6E6E 
 2447      6563743A 
 2447      20696E76 
 2447      616C6964 
 2448              		.section	.text.udp_connect,"ax",%progbits
 2449              		.align	1
 2450              		.p2align 2,,3
 2451              		.global	udp_connect
 2452              		.syntax unified
 2453              		.thumb
 2454              		.thumb_func
 2455              		.fpu fpv4-sp-d16
 2457              	udp_connect:
 2458              	.LVL208:
 2459              	.LFB115:
1052:lwIP/src/core/udp.c **** 
1053:lwIP/src/core/udp.c **** /**
1054:lwIP/src/core/udp.c ****  * @ingroup udp_raw
1055:lwIP/src/core/udp.c ****  * Sets the remote end of the pcb. This function does not generate any
1056:lwIP/src/core/udp.c ****  * network traffic, but only sets the remote address of the pcb.
1057:lwIP/src/core/udp.c ****  *
1058:lwIP/src/core/udp.c ****  * @param pcb UDP PCB to be connected with remote address ipaddr and port.
1059:lwIP/src/core/udp.c ****  * @param ipaddr remote IP address to connect with.
1060:lwIP/src/core/udp.c ****  * @param port remote UDP port to connect with.
1061:lwIP/src/core/udp.c ****  *
1062:lwIP/src/core/udp.c ****  * @return lwIP error code
1063:lwIP/src/core/udp.c ****  *
1064:lwIP/src/core/udp.c ****  * ipaddr & port are expected to be in the same byte order as in the pcb.
1065:lwIP/src/core/udp.c ****  *
1066:lwIP/src/core/udp.c ****  * The udp pcb is bound to a random local port if not already bound.
1067:lwIP/src/core/udp.c ****  *
1068:lwIP/src/core/udp.c ****  * @see udp_disconnect()
1069:lwIP/src/core/udp.c ****  */
1070:lwIP/src/core/udp.c **** err_t
1071:lwIP/src/core/udp.c **** udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
1072:lwIP/src/core/udp.c **** {
 2460              		.loc 1 1072 1 is_stmt 1 view -0
 2461              		.cfi_startproc
 2462              		@ args = 0, pretend = 0, frame = 0
 2463              		@ frame_needed = 0, uses_anonymous_args = 0
1073:lwIP/src/core/udp.c ****   struct udp_pcb *ipcb;
 2464              		.loc 1 1073 3 view .LVU875
1074:lwIP/src/core/udp.c **** 
1075:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 2465              		.loc 1 1075 28 view .LVU876
1076:lwIP/src/core/udp.c **** 
1077:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
 2466              		.loc 1 1077 3 view .LVU877
 2467              		.loc 1 1077 3 view .LVU878
1072:lwIP/src/core/udp.c ****   struct udp_pcb *ipcb;
 2468              		.loc 1 1072 1 is_stmt 0 view .LVU879
 2469 0000 70B5     		push	{r4, r5, r6, lr}
 2470              	.LCFI25:
 2471              		.cfi_def_cfa_offset 16
 2472              		.cfi_offset 4, -16
 2473              		.cfi_offset 5, -12
ARM GAS  /tmp/cctoFbTf.s 			page 94


 2474              		.cfi_offset 6, -8
 2475              		.cfi_offset 14, -4
 2476              		.loc 1 1077 3 view .LVU880
 2477 0002 40B3     		cbz	r0, .L266
 2478              		.loc 1 1077 3 is_stmt 1 discriminator 2 view .LVU881
1078:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 2479              		.loc 1 1078 3 discriminator 2 view .LVU882
 2480              		.loc 1 1078 3 discriminator 2 view .LVU883
 2481 0004 0D46     		mov	r5, r1
 2482 0006 11B3     		cbz	r1, .L267
 2483              		.loc 1 1078 3 discriminator 2 view .LVU884
1079:lwIP/src/core/udp.c **** 
1080:lwIP/src/core/udp.c ****   if (pcb->local_port == 0) {
 2484              		.loc 1 1080 3 discriminator 2 view .LVU885
 2485 0008 1646     		mov	r6, r2
 2486              		.loc 1 1080 6 is_stmt 0 discriminator 2 view .LVU886
 2487 000a 428A     		ldrh	r2, [r0, #18]
 2488              	.LVL209:
 2489              		.loc 1 1080 6 discriminator 2 view .LVU887
 2490 000c 0446     		mov	r4, r0
 2491 000e B2B1     		cbz	r2, .L256
 2492              	.LVL210:
 2493              	.L260:
1081:lwIP/src/core/udp.c ****     err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
1082:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
1083:lwIP/src/core/udp.c ****       return err;
1084:lwIP/src/core/udp.c ****     }
1085:lwIP/src/core/udp.c ****   }
1086:lwIP/src/core/udp.c **** 
1087:lwIP/src/core/udp.c ****   ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
 2494              		.loc 1 1087 3 is_stmt 1 view .LVU888
1088:lwIP/src/core/udp.c **** #if LWIP_IPV6 && LWIP_IPV6_SCOPES
1089:lwIP/src/core/udp.c ****   /* If the given IP address should have a zone but doesn't, assign one now,
1090:lwIP/src/core/udp.c ****    * using the bound address to make a more informed decision when possible. */
1091:lwIP/src/core/udp.c ****   if (IP_IS_V6(&pcb->remote_ip) &&
1092:lwIP/src/core/udp.c ****       ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNKNOWN)) {
1093:lwIP/src/core/udp.c ****     ip6_addr_select_zone(ip_2_ip6(&pcb->remote_ip), ip_2_ip6(&pcb->local_ip));
1094:lwIP/src/core/udp.c ****   }
1095:lwIP/src/core/udp.c **** #endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
1096:lwIP/src/core/udp.c **** 
1097:lwIP/src/core/udp.c ****   pcb->remote_port = port;
1098:lwIP/src/core/udp.c ****   pcb->flags |= UDP_FLAGS_CONNECTED;
 2495              		.loc 1 1098 14 is_stmt 0 view .LVU889
 2496 0010 237C     		ldrb	r3, [r4, #16]	@ zero_extendqisi2
1099:lwIP/src/core/udp.c **** 
1100:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_connect: connected to "));
1101:lwIP/src/core/udp.c ****   ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
1102:lwIP/src/core/udp.c ****                           pcb->remote_ip);
1103:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port)
1104:lwIP/src/core/udp.c **** 
1105:lwIP/src/core/udp.c ****   /* Insert UDP PCB into the list of active UDP PCBs. */
1106:lwIP/src/core/udp.c ****   for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 2497              		.loc 1 1106 13 view .LVU890
 2498 0012 134A     		ldr	r2, .L268
1087:lwIP/src/core/udp.c **** #if LWIP_IPV6 && LWIP_IPV6_SCOPES
 2499              		.loc 1 1087 3 view .LVU891
 2500 0014 2868     		ldr	r0, [r5]
ARM GAS  /tmp/cctoFbTf.s 			page 95


1098:lwIP/src/core/udp.c **** 
 2501              		.loc 1 1098 14 view .LVU892
 2502 0016 43F00403 		orr	r3, r3, #4
 2503              		.loc 1 1106 13 view .LVU893
 2504 001a 1168     		ldr	r1, [r2]
1087:lwIP/src/core/udp.c **** #if LWIP_IPV6 && LWIP_IPV6_SCOPES
 2505              		.loc 1 1087 3 view .LVU894
 2506 001c 6060     		str	r0, [r4, #4]
1097:lwIP/src/core/udp.c ****   pcb->flags |= UDP_FLAGS_CONNECTED;
 2507              		.loc 1 1097 3 is_stmt 1 view .LVU895
1097:lwIP/src/core/udp.c ****   pcb->flags |= UDP_FLAGS_CONNECTED;
 2508              		.loc 1 1097 20 is_stmt 0 view .LVU896
 2509 001e A682     		strh	r6, [r4, #20]	@ movhi
1098:lwIP/src/core/udp.c **** 
 2510              		.loc 1 1098 3 is_stmt 1 view .LVU897
1098:lwIP/src/core/udp.c **** 
 2511              		.loc 1 1098 14 is_stmt 0 view .LVU898
 2512 0020 2374     		strb	r3, [r4, #16]
1100:lwIP/src/core/udp.c ****   ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
 2513              		.loc 1 1100 91 is_stmt 1 view .LVU899
1102:lwIP/src/core/udp.c ****   LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port)
 2514              		.loc 1 1102 42 view .LVU900
1103:lwIP/src/core/udp.c **** 
 2515              		.loc 1 1103 101 view .LVU901
 2516              		.loc 1 1106 3 view .LVU902
 2517              	.LVL211:
 2518              		.loc 1 1106 25 view .LVU903
 2519              		.loc 1 1106 3 is_stmt 0 view .LVU904
 2520 0022 41B1     		cbz	r1, .L258
1107:lwIP/src/core/udp.c ****     if (pcb == ipcb) {
 2521              		.loc 1 1107 5 is_stmt 1 view .LVU905
 2522              		.loc 1 1107 8 is_stmt 0 view .LVU906
 2523 0024 8C42     		cmp	r4, r1
 2524 0026 10D0     		beq	.L264
 2525 0028 0B46     		mov	r3, r1
 2526 002a 01E0     		b	.L261
 2527              	.LVL212:
 2528              	.L262:
 2529              		.loc 1 1107 8 view .LVU907
 2530 002c 9C42     		cmp	r4, r3
 2531 002e 0CD0     		beq	.L264
 2532              	.L261:
 2533              		.loc 1 1107 5 is_stmt 1 discriminator 2 view .LVU908
1106:lwIP/src/core/udp.c ****     if (pcb == ipcb) {
 2534              		.loc 1 1106 39 discriminator 2 view .LVU909
1106:lwIP/src/core/udp.c ****     if (pcb == ipcb) {
 2535              		.loc 1 1106 44 is_stmt 0 discriminator 2 view .LVU910
 2536 0030 DB68     		ldr	r3, [r3, #12]
 2537              	.LVL213:
1106:lwIP/src/core/udp.c ****     if (pcb == ipcb) {
 2538              		.loc 1 1106 25 is_stmt 1 discriminator 2 view .LVU911
1106:lwIP/src/core/udp.c ****     if (pcb == ipcb) {
 2539              		.loc 1 1106 3 is_stmt 0 discriminator 2 view .LVU912
 2540 0032 002B     		cmp	r3, #0
 2541 0034 FAD1     		bne	.L262
 2542              	.LVL214:
 2543              	.L258:
ARM GAS  /tmp/cctoFbTf.s 			page 96


1108:lwIP/src/core/udp.c ****       /* already on the list, just return */
1109:lwIP/src/core/udp.c ****       return ERR_OK;
1110:lwIP/src/core/udp.c ****     }
1111:lwIP/src/core/udp.c ****   }
1112:lwIP/src/core/udp.c ****   /* PCB not yet on the list, add PCB now */
1113:lwIP/src/core/udp.c ****   pcb->next = udp_pcbs;
 2544              		.loc 1 1113 3 is_stmt 1 view .LVU913
1114:lwIP/src/core/udp.c ****   udp_pcbs = pcb;
1115:lwIP/src/core/udp.c ****   return ERR_OK;
 2545              		.loc 1 1115 10 is_stmt 0 view .LVU914
 2546 0036 0020     		movs	r0, #0
1113:lwIP/src/core/udp.c ****   udp_pcbs = pcb;
 2547              		.loc 1 1113 13 view .LVU915
 2548 0038 E160     		str	r1, [r4, #12]
1114:lwIP/src/core/udp.c ****   udp_pcbs = pcb;
 2549              		.loc 1 1114 3 is_stmt 1 view .LVU916
1114:lwIP/src/core/udp.c ****   udp_pcbs = pcb;
 2550              		.loc 1 1114 12 is_stmt 0 view .LVU917
 2551 003a 1460     		str	r4, [r2]
 2552              		.loc 1 1115 3 is_stmt 1 view .LVU918
1116:lwIP/src/core/udp.c **** }
 2553              		.loc 1 1116 1 is_stmt 0 view .LVU919
 2554 003c 70BD     		pop	{r4, r5, r6, pc}
 2555              	.LVL215:
 2556              	.L256:
 2557              	.LBB187:
1081:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
 2558              		.loc 1 1081 5 is_stmt 1 view .LVU920
1081:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
 2559              		.loc 1 1081 17 is_stmt 0 view .LVU921
 2560 003e 0146     		mov	r1, r0
 2561              	.LVL216:
1081:lwIP/src/core/udp.c ****     if (err != ERR_OK) {
 2562              		.loc 1 1081 17 view .LVU922
 2563 0040 FFF7FEFF 		bl	udp_bind
 2564              	.LVL217:
1082:lwIP/src/core/udp.c ****       return err;
 2565              		.loc 1 1082 5 is_stmt 1 view .LVU923
1082:lwIP/src/core/udp.c ****       return err;
 2566              		.loc 1 1082 8 is_stmt 0 view .LVU924
 2567 0044 0028     		cmp	r0, #0
 2568 0046 E3D0     		beq	.L260
 2569              	.LBE187:
 2570              		.loc 1 1116 1 view .LVU925
 2571 0048 70BD     		pop	{r4, r5, r6, pc}
 2572              	.LVL218:
 2573              	.L264:
1109:lwIP/src/core/udp.c ****     }
 2574              		.loc 1 1109 14 view .LVU926
 2575 004a 0020     		movs	r0, #0
 2576              		.loc 1 1116 1 view .LVU927
 2577 004c 70BD     		pop	{r4, r5, r6, pc}
 2578              	.LVL219:
 2579              	.L267:
1078:lwIP/src/core/udp.c **** 
 2580              		.loc 1 1078 3 is_stmt 1 discriminator 1 view .LVU928
 2581 004e 0548     		ldr	r0, .L268+4
ARM GAS  /tmp/cctoFbTf.s 			page 97


 2582              	.LVL220:
1078:lwIP/src/core/udp.c **** 
 2583              		.loc 1 1078 3 is_stmt 0 discriminator 1 view .LVU929
 2584 0050 FFF7FEFF 		bl	printf
 2585              	.LVL221:
 2586              	.L255:
1078:lwIP/src/core/udp.c **** 
 2587              		.loc 1 1078 3 is_stmt 1 discriminator 2 view .LVU930
1078:lwIP/src/core/udp.c **** 
 2588              		.loc 1 1078 3 discriminator 2 view .LVU931
1078:lwIP/src/core/udp.c **** 
 2589              		.loc 1 1078 3 discriminator 2 view .LVU932
1078:lwIP/src/core/udp.c **** 
 2590              		.loc 1 1078 3 discriminator 2 view .LVU933
1078:lwIP/src/core/udp.c **** 
 2591              		.loc 1 1078 3 discriminator 2 view .LVU934
1078:lwIP/src/core/udp.c **** 
 2592              		.loc 1 1078 3 discriminator 2 view .LVU935
 2593 0054 FEE7     		b	.L255
 2594              	.LVL222:
 2595              	.L266:
1077:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 2596              		.loc 1 1077 3 discriminator 1 view .LVU936
 2597 0056 0448     		ldr	r0, .L268+8
 2598              	.LVL223:
1077:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 2599              		.loc 1 1077 3 is_stmt 0 discriminator 1 view .LVU937
 2600 0058 FFF7FEFF 		bl	printf
 2601              	.LVL224:
 2602              	.L253:
1077:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 2603              		.loc 1 1077 3 is_stmt 1 discriminator 1 view .LVU938
1077:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 2604              		.loc 1 1077 3 discriminator 1 view .LVU939
1077:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 2605              		.loc 1 1077 3 discriminator 1 view .LVU940
1077:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 2606              		.loc 1 1077 3 discriminator 1 view .LVU941
1077:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 2607              		.loc 1 1077 3 discriminator 1 view .LVU942
1077:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 2608              		.loc 1 1077 3 discriminator 1 view .LVU943
 2609 005c FEE7     		b	.L253
 2610              	.L269:
 2611 005e 00BF     		.align	2
 2612              	.L268:
 2613 0060 00000000 		.word	udp_pcbs
 2614 0064 1C000000 		.word	.LC20
 2615 0068 00000000 		.word	.LC19
 2616              		.cfi_endproc
 2617              	.LFE115:
 2619              		.section	.rodata.udp_disconnect.str1.4,"aMS",%progbits,1
 2620              		.align	2
 2621              	.LC21:
 2622 0000 7564705F 		.ascii	"udp_disconnect: invalid pcb\000"
 2622      64697363 
 2622      6F6E6E65 
ARM GAS  /tmp/cctoFbTf.s 			page 98


 2622      63743A20 
 2622      696E7661 
 2623              		.section	.text.udp_disconnect,"ax",%progbits
 2624              		.align	1
 2625              		.p2align 2,,3
 2626              		.global	udp_disconnect
 2627              		.syntax unified
 2628              		.thumb
 2629              		.thumb_func
 2630              		.fpu fpv4-sp-d16
 2632              	udp_disconnect:
 2633              	.LVL225:
 2634              	.LFB116:
1117:lwIP/src/core/udp.c **** 
1118:lwIP/src/core/udp.c **** /**
1119:lwIP/src/core/udp.c ****  * @ingroup udp_raw
1120:lwIP/src/core/udp.c ****  * Remove the remote end of the pcb. This function does not generate
1121:lwIP/src/core/udp.c ****  * any network traffic, but only removes the remote address of the pcb.
1122:lwIP/src/core/udp.c ****  *
1123:lwIP/src/core/udp.c ****  * @param pcb the udp pcb to disconnect.
1124:lwIP/src/core/udp.c ****  */
1125:lwIP/src/core/udp.c **** void
1126:lwIP/src/core/udp.c **** udp_disconnect(struct udp_pcb *pcb)
1127:lwIP/src/core/udp.c **** {
 2635              		.loc 1 1127 1 view -0
 2636              		.cfi_startproc
 2637              		@ args = 0, pretend = 0, frame = 0
 2638              		@ frame_needed = 0, uses_anonymous_args = 0
1128:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 2639              		.loc 1 1128 28 view .LVU945
1129:lwIP/src/core/udp.c **** 
1130:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_disconnect: invalid pcb", pcb != NULL, return);
 2640              		.loc 1 1130 3 view .LVU946
 2641              		.loc 1 1130 3 view .LVU947
1127:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 2642              		.loc 1 1127 1 is_stmt 0 view .LVU948
 2643 0000 08B5     		push	{r3, lr}
 2644              	.LCFI26:
 2645              		.cfi_def_cfa_offset 8
 2646              		.cfi_offset 3, -8
 2647              		.cfi_offset 14, -4
 2648              		.loc 1 1130 3 view .LVU949
 2649 0002 40B1     		cbz	r0, .L274
 2650              		.loc 1 1130 3 is_stmt 1 discriminator 2 view .LVU950
1131:lwIP/src/core/udp.c **** 
1132:lwIP/src/core/udp.c ****   /* reset remote address association */
1133:lwIP/src/core/udp.c **** #if LWIP_IPV4 && LWIP_IPV6
1134:lwIP/src/core/udp.c ****   if (IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
1135:lwIP/src/core/udp.c ****     ip_addr_copy(pcb->remote_ip, *IP_ANY_TYPE);
1136:lwIP/src/core/udp.c ****   } else {
1137:lwIP/src/core/udp.c **** #endif
1138:lwIP/src/core/udp.c ****     ip_addr_set_any(IP_IS_V6_VAL(pcb->remote_ip), &pcb->remote_ip);
 2651              		.loc 1 1138 5 discriminator 2 view .LVU951
1139:lwIP/src/core/udp.c **** #if LWIP_IPV4 && LWIP_IPV6
1140:lwIP/src/core/udp.c ****   }
1141:lwIP/src/core/udp.c **** #endif
1142:lwIP/src/core/udp.c ****   pcb->remote_port = 0;
ARM GAS  /tmp/cctoFbTf.s 			page 99


1143:lwIP/src/core/udp.c ****   pcb->netif_idx = NETIF_NO_INDEX;
1144:lwIP/src/core/udp.c ****   /* mark PCB as unconnected */
1145:lwIP/src/core/udp.c ****   udp_clear_flags(pcb, UDP_FLAGS_CONNECTED);
 2652              		.loc 1 1145 3 is_stmt 0 discriminator 2 view .LVU952
 2653 0004 027C     		ldrb	r2, [r0, #16]	@ zero_extendqisi2
1138:lwIP/src/core/udp.c **** #if LWIP_IPV4 && LWIP_IPV6
 2654              		.loc 1 1138 5 discriminator 2 view .LVU953
 2655 0006 0023     		movs	r3, #0
 2656              		.loc 1 1145 3 discriminator 2 view .LVU954
 2657 0008 22F00402 		bic	r2, r2, #4
1138:lwIP/src/core/udp.c **** #if LWIP_IPV4 && LWIP_IPV6
 2658              		.loc 1 1138 5 discriminator 2 view .LVU955
 2659 000c 4360     		str	r3, [r0, #4]
1142:lwIP/src/core/udp.c ****   pcb->netif_idx = NETIF_NO_INDEX;
 2660              		.loc 1 1142 3 is_stmt 1 discriminator 2 view .LVU956
1142:lwIP/src/core/udp.c ****   pcb->netif_idx = NETIF_NO_INDEX;
 2661              		.loc 1 1142 20 is_stmt 0 discriminator 2 view .LVU957
 2662 000e 8382     		strh	r3, [r0, #20]	@ movhi
1143:lwIP/src/core/udp.c ****   /* mark PCB as unconnected */
 2663              		.loc 1 1143 3 is_stmt 1 discriminator 2 view .LVU958
 2664              		.loc 1 1145 3 is_stmt 0 discriminator 2 view .LVU959
 2665 0010 0274     		strb	r2, [r0, #16]
1143:lwIP/src/core/udp.c ****   /* mark PCB as unconnected */
 2666              		.loc 1 1143 18 discriminator 2 view .LVU960
 2667 0012 0372     		strb	r3, [r0, #8]
 2668              		.loc 1 1145 3 is_stmt 1 discriminator 2 view .LVU961
 2669              		.loc 1 1145 3 discriminator 2 view .LVU962
 2670              		.loc 1 1145 3 discriminator 2 view .LVU963
1146:lwIP/src/core/udp.c **** }
 2671              		.loc 1 1146 1 is_stmt 0 discriminator 2 view .LVU964
 2672 0014 08BD     		pop	{r3, pc}
 2673              	.L274:
1130:lwIP/src/core/udp.c **** 
 2674              		.loc 1 1130 3 is_stmt 1 discriminator 1 view .LVU965
 2675 0016 0248     		ldr	r0, .L275
 2676              	.LVL226:
1130:lwIP/src/core/udp.c **** 
 2677              		.loc 1 1130 3 is_stmt 0 discriminator 1 view .LVU966
 2678 0018 FFF7FEFF 		bl	printf
 2679              	.LVL227:
 2680              	.L272:
1130:lwIP/src/core/udp.c **** 
 2681              		.loc 1 1130 3 is_stmt 1 discriminator 1 view .LVU967
1130:lwIP/src/core/udp.c **** 
 2682              		.loc 1 1130 3 discriminator 1 view .LVU968
1130:lwIP/src/core/udp.c **** 
 2683              		.loc 1 1130 3 discriminator 1 view .LVU969
1130:lwIP/src/core/udp.c **** 
 2684              		.loc 1 1130 3 discriminator 1 view .LVU970
1130:lwIP/src/core/udp.c **** 
 2685              		.loc 1 1130 3 discriminator 1 view .LVU971
1130:lwIP/src/core/udp.c **** 
 2686              		.loc 1 1130 3 discriminator 1 view .LVU972
 2687 001c FEE7     		b	.L272
 2688              	.L276:
 2689 001e 00BF     		.align	2
 2690              	.L275:
ARM GAS  /tmp/cctoFbTf.s 			page 100


 2691 0020 00000000 		.word	.LC21
 2692              		.cfi_endproc
 2693              	.LFE116:
 2695              		.section	.rodata.udp_recv.str1.4,"aMS",%progbits,1
 2696              		.align	2
 2697              	.LC22:
 2698 0000 7564705F 		.ascii	"udp_recv: invalid pcb\000"
 2698      72656376 
 2698      3A20696E 
 2698      76616C69 
 2698      64207063 
 2699              		.section	.text.udp_recv,"ax",%progbits
 2700              		.align	1
 2701              		.p2align 2,,3
 2702              		.global	udp_recv
 2703              		.syntax unified
 2704              		.thumb
 2705              		.thumb_func
 2706              		.fpu fpv4-sp-d16
 2708              	udp_recv:
 2709              	.LVL228:
 2710              	.LFB117:
1147:lwIP/src/core/udp.c **** 
1148:lwIP/src/core/udp.c **** /**
1149:lwIP/src/core/udp.c ****  * @ingroup udp_raw
1150:lwIP/src/core/udp.c ****  * Set a receive callback for a UDP PCB.
1151:lwIP/src/core/udp.c ****  * This callback will be called when receiving a datagram for the pcb.
1152:lwIP/src/core/udp.c ****  *
1153:lwIP/src/core/udp.c ****  * @param pcb the pcb for which to set the recv callback
1154:lwIP/src/core/udp.c ****  * @param recv function pointer of the callback function
1155:lwIP/src/core/udp.c ****  * @param recv_arg additional argument to pass to the callback function
1156:lwIP/src/core/udp.c ****  */
1157:lwIP/src/core/udp.c **** void
1158:lwIP/src/core/udp.c **** udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
1159:lwIP/src/core/udp.c **** {
 2711              		.loc 1 1159 1 view -0
 2712              		.cfi_startproc
 2713              		@ args = 0, pretend = 0, frame = 0
 2714              		@ frame_needed = 0, uses_anonymous_args = 0
1160:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 2715              		.loc 1 1160 28 view .LVU974
1161:lwIP/src/core/udp.c **** 
1162:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
 2716              		.loc 1 1162 3 view .LVU975
 2717              		.loc 1 1162 3 view .LVU976
 2718 0000 10B1     		cbz	r0, .L283
 2719              		.loc 1 1162 3 discriminator 2 view .LVU977
1163:lwIP/src/core/udp.c **** 
1164:lwIP/src/core/udp.c ****   /* remember recv() callback and user data */
1165:lwIP/src/core/udp.c ****   pcb->recv = recv;
 2720              		.loc 1 1165 3 discriminator 2 view .LVU978
1166:lwIP/src/core/udp.c ****   pcb->recv_arg = recv_arg;
 2721              		.loc 1 1166 17 is_stmt 0 discriminator 2 view .LVU979
 2722 0002 C0E90612 		strd	r1, r2, [r0, #24]
 2723 0006 7047     		bx	lr
 2724              	.L283:
1162:lwIP/src/core/udp.c **** 
ARM GAS  /tmp/cctoFbTf.s 			page 101


 2725              		.loc 1 1162 3 is_stmt 1 discriminator 1 view .LVU980
 2726 0008 0248     		ldr	r0, .L284
 2727              	.LVL229:
1159:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 2728              		.loc 1 1159 1 is_stmt 0 discriminator 1 view .LVU981
 2729 000a 08B5     		push	{r3, lr}
 2730              	.LCFI27:
 2731              		.cfi_def_cfa_offset 8
 2732              		.cfi_offset 3, -8
 2733              		.cfi_offset 14, -4
1162:lwIP/src/core/udp.c **** 
 2734              		.loc 1 1162 3 discriminator 1 view .LVU982
 2735 000c FFF7FEFF 		bl	printf
 2736              	.LVL230:
 2737              	.L279:
1162:lwIP/src/core/udp.c **** 
 2738              		.loc 1 1162 3 is_stmt 1 discriminator 1 view .LVU983
1162:lwIP/src/core/udp.c **** 
 2739              		.loc 1 1162 3 discriminator 1 view .LVU984
1162:lwIP/src/core/udp.c **** 
 2740              		.loc 1 1162 3 discriminator 1 view .LVU985
1162:lwIP/src/core/udp.c **** 
 2741              		.loc 1 1162 3 discriminator 1 view .LVU986
1162:lwIP/src/core/udp.c **** 
 2742              		.loc 1 1162 3 discriminator 1 view .LVU987
1162:lwIP/src/core/udp.c **** 
 2743              		.loc 1 1162 3 discriminator 1 view .LVU988
 2744 0010 FEE7     		b	.L279
 2745              	.L285:
 2746 0012 00BF     		.align	2
 2747              	.L284:
 2748 0014 00000000 		.word	.LC22
 2749              		.cfi_endproc
 2750              	.LFE117:
 2752              		.section	.rodata.udp_remove.str1.4,"aMS",%progbits,1
 2753              		.align	2
 2754              	.LC23:
 2755 0000 7564705F 		.ascii	"udp_remove: invalid pcb\000"
 2755      72656D6F 
 2755      76653A20 
 2755      696E7661 
 2755      6C696420 
 2756              		.section	.text.udp_remove,"ax",%progbits
 2757              		.align	1
 2758              		.p2align 2,,3
 2759              		.global	udp_remove
 2760              		.syntax unified
 2761              		.thumb
 2762              		.thumb_func
 2763              		.fpu fpv4-sp-d16
 2765              	udp_remove:
 2766              	.LVL231:
 2767              	.LFB118:
1167:lwIP/src/core/udp.c **** }
1168:lwIP/src/core/udp.c **** 
1169:lwIP/src/core/udp.c **** /**
1170:lwIP/src/core/udp.c ****  * @ingroup udp_raw
ARM GAS  /tmp/cctoFbTf.s 			page 102


1171:lwIP/src/core/udp.c ****  * Removes and deallocates the pcb.  
1172:lwIP/src/core/udp.c ****  * 
1173:lwIP/src/core/udp.c ****  * @param pcb UDP PCB to be removed. The PCB is removed from the list of
1174:lwIP/src/core/udp.c ****  * UDP PCB's and the data structure is freed from memory.
1175:lwIP/src/core/udp.c ****  *
1176:lwIP/src/core/udp.c ****  * @see udp_new()
1177:lwIP/src/core/udp.c ****  */
1178:lwIP/src/core/udp.c **** void
1179:lwIP/src/core/udp.c **** udp_remove(struct udp_pcb *pcb)
1180:lwIP/src/core/udp.c **** {
 2768              		.loc 1 1180 1 view -0
 2769              		.cfi_startproc
 2770              		@ args = 0, pretend = 0, frame = 0
 2771              		@ frame_needed = 0, uses_anonymous_args = 0
1181:lwIP/src/core/udp.c ****   struct udp_pcb *pcb2;
 2772              		.loc 1 1181 3 view .LVU990
1182:lwIP/src/core/udp.c **** 
1183:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 2773              		.loc 1 1183 28 view .LVU991
1184:lwIP/src/core/udp.c **** 
1185:lwIP/src/core/udp.c ****   LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 2774              		.loc 1 1185 3 view .LVU992
 2775              		.loc 1 1185 3 view .LVU993
1180:lwIP/src/core/udp.c ****   struct udp_pcb *pcb2;
 2776              		.loc 1 1180 1 is_stmt 0 view .LVU994
 2777 0000 08B5     		push	{r3, lr}
 2778              	.LCFI28:
 2779              		.cfi_def_cfa_offset 8
 2780              		.cfi_offset 3, -8
 2781              		.cfi_offset 14, -4
 2782              		.loc 1 1185 3 view .LVU995
 2783 0002 C8B1     		cbz	r0, .L298
1186:lwIP/src/core/udp.c **** 
1187:lwIP/src/core/udp.c ****   mib2_udp_unbind(pcb);
1188:lwIP/src/core/udp.c ****   /* pcb to be removed is first in list? */
1189:lwIP/src/core/udp.c ****   if (udp_pcbs == pcb) {
 2784              		.loc 1 1189 16 discriminator 2 view .LVU996
 2785 0004 0E4A     		ldr	r2, .L301
 2786 0006 0146     		mov	r1, r0
1185:lwIP/src/core/udp.c **** 
 2787              		.loc 1 1185 3 is_stmt 1 discriminator 2 view .LVU997
1187:lwIP/src/core/udp.c ****   /* pcb to be removed is first in list? */
 2788              		.loc 1 1187 23 discriminator 2 view .LVU998
 2789              		.loc 1 1189 3 discriminator 2 view .LVU999
 2790              		.loc 1 1189 16 is_stmt 0 discriminator 2 view .LVU1000
 2791 0008 1368     		ldr	r3, [r2]
 2792              		.loc 1 1189 6 discriminator 2 view .LVU1001
 2793 000a 8342     		cmp	r3, r0
 2794 000c 06D0     		beq	.L299
 2795              	.L289:
1190:lwIP/src/core/udp.c ****     /* make list start at 2nd pcb */
1191:lwIP/src/core/udp.c ****     udp_pcbs = udp_pcbs->next;
1192:lwIP/src/core/udp.c ****     /* pcb not 1st in list */
1193:lwIP/src/core/udp.c ****   } else {
1194:lwIP/src/core/udp.c ****     for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
1195:lwIP/src/core/udp.c ****       /* find pcb in udp_pcbs list */
1196:lwIP/src/core/udp.c ****       if (pcb2->next != NULL && pcb2->next == pcb) {
ARM GAS  /tmp/cctoFbTf.s 			page 103


 2796              		.loc 1 1196 7 is_stmt 1 discriminator 1 view .LVU1002
 2797              	.LVL232:
1194:lwIP/src/core/udp.c ****       /* find pcb in udp_pcbs list */
 2798              		.loc 1 1194 27 discriminator 1 view .LVU1003
1194:lwIP/src/core/udp.c ****       /* find pcb in udp_pcbs list */
 2799              		.loc 1 1194 5 is_stmt 0 discriminator 1 view .LVU1004
 2800 000e 3BB1     		cbz	r3, .L290
 2801              		.loc 1 1196 15 view .LVU1005
 2802 0010 DA68     		ldr	r2, [r3, #12]
 2803              		.loc 1 1196 10 view .LVU1006
 2804 0012 2AB1     		cbz	r2, .L290
 2805              		.loc 1 1196 30 discriminator 1 view .LVU1007
 2806 0014 8A42     		cmp	r2, r1
 2807 0016 08D0     		beq	.L300
 2808 0018 1346     		mov	r3, r2
 2809              	.LVL233:
 2810              		.loc 1 1196 30 discriminator 1 view .LVU1008
 2811 001a F8E7     		b	.L289
 2812              	.L299:
1191:lwIP/src/core/udp.c ****     /* pcb not 1st in list */
 2813              		.loc 1 1191 5 is_stmt 1 view .LVU1009
1191:lwIP/src/core/udp.c ****     /* pcb not 1st in list */
 2814              		.loc 1 1191 14 is_stmt 0 view .LVU1010
 2815 001c C368     		ldr	r3, [r0, #12]
 2816 001e 1360     		str	r3, [r2]
 2817              	.L290:
1197:lwIP/src/core/udp.c ****         /* remove pcb from list */
1198:lwIP/src/core/udp.c ****         pcb2->next = pcb->next;
1199:lwIP/src/core/udp.c ****         break;
1200:lwIP/src/core/udp.c ****       }
1201:lwIP/src/core/udp.c ****     }
1202:lwIP/src/core/udp.c ****   }
1203:lwIP/src/core/udp.c ****   memp_free(MEMP_UDP_PCB, pcb);
 2818              		.loc 1 1203 3 is_stmt 1 view .LVU1011
 2819 0020 0020     		movs	r0, #0
 2820              	.LVL234:
1204:lwIP/src/core/udp.c **** }
 2821              		.loc 1 1204 1 is_stmt 0 view .LVU1012
 2822 0022 BDE80840 		pop	{r3, lr}
 2823              	.LCFI29:
 2824              		.cfi_remember_state
 2825              		.cfi_restore 14
 2826              		.cfi_restore 3
 2827              		.cfi_def_cfa_offset 0
1203:lwIP/src/core/udp.c **** }
 2828              		.loc 1 1203 3 view .LVU1013
 2829 0026 FFF7FEBF 		b	memp_free
 2830              	.LVL235:
 2831              	.L300:
 2832              	.LCFI30:
 2833              		.cfi_restore_state
1198:lwIP/src/core/udp.c ****         break;
 2834              		.loc 1 1198 9 is_stmt 1 view .LVU1014
1198:lwIP/src/core/udp.c ****         break;
 2835              		.loc 1 1198 25 is_stmt 0 view .LVU1015
 2836 002a CA68     		ldr	r2, [r1, #12]
1203:lwIP/src/core/udp.c **** }
ARM GAS  /tmp/cctoFbTf.s 			page 104


 2837              		.loc 1 1203 3 view .LVU1016
 2838 002c 0020     		movs	r0, #0
 2839              	.LVL236:
1198:lwIP/src/core/udp.c ****         break;
 2840              		.loc 1 1198 20 view .LVU1017
 2841 002e DA60     		str	r2, [r3, #12]
1199:lwIP/src/core/udp.c ****       }
 2842              		.loc 1 1199 9 is_stmt 1 view .LVU1018
 2843              	.LVL237:
1203:lwIP/src/core/udp.c **** }
 2844              		.loc 1 1203 3 view .LVU1019
 2845              		.loc 1 1204 1 is_stmt 0 view .LVU1020
 2846 0030 BDE80840 		pop	{r3, lr}
 2847              	.LCFI31:
 2848              		.cfi_remember_state
 2849              		.cfi_restore 14
 2850              		.cfi_restore 3
 2851              		.cfi_def_cfa_offset 0
1203:lwIP/src/core/udp.c **** }
 2852              		.loc 1 1203 3 view .LVU1021
 2853 0034 FFF7FEBF 		b	memp_free
 2854              	.LVL238:
 2855              	.L298:
 2856              	.LCFI32:
 2857              		.cfi_restore_state
1185:lwIP/src/core/udp.c **** 
 2858              		.loc 1 1185 3 is_stmt 1 discriminator 1 view .LVU1022
 2859 0038 0248     		ldr	r0, .L301+4
 2860              	.LVL239:
1185:lwIP/src/core/udp.c **** 
 2861              		.loc 1 1185 3 is_stmt 0 discriminator 1 view .LVU1023
 2862 003a FFF7FEFF 		bl	printf
 2863              	.LVL240:
 2864              	.L288:
1185:lwIP/src/core/udp.c **** 
 2865              		.loc 1 1185 3 is_stmt 1 discriminator 1 view .LVU1024
1185:lwIP/src/core/udp.c **** 
 2866              		.loc 1 1185 3 discriminator 1 view .LVU1025
1185:lwIP/src/core/udp.c **** 
 2867              		.loc 1 1185 3 discriminator 1 view .LVU1026
1185:lwIP/src/core/udp.c **** 
 2868              		.loc 1 1185 3 discriminator 1 view .LVU1027
1185:lwIP/src/core/udp.c **** 
 2869              		.loc 1 1185 3 discriminator 1 view .LVU1028
1185:lwIP/src/core/udp.c **** 
 2870              		.loc 1 1185 3 discriminator 1 view .LVU1029
 2871 003e FEE7     		b	.L288
 2872              	.L302:
 2873              		.align	2
 2874              	.L301:
 2875 0040 00000000 		.word	udp_pcbs
 2876 0044 00000000 		.word	.LC23
 2877              		.cfi_endproc
 2878              	.LFE118:
 2880              		.section	.text.udp_new,"ax",%progbits
 2881              		.align	1
 2882              		.p2align 2,,3
ARM GAS  /tmp/cctoFbTf.s 			page 105


 2883              		.global	udp_new
 2884              		.syntax unified
 2885              		.thumb
 2886              		.thumb_func
 2887              		.fpu fpv4-sp-d16
 2889              	udp_new:
 2890              	.LFB119:
1205:lwIP/src/core/udp.c **** 
1206:lwIP/src/core/udp.c **** /**
1207:lwIP/src/core/udp.c ****  * @ingroup udp_raw
1208:lwIP/src/core/udp.c ****  * Creates a new UDP pcb which can be used for UDP communication. The
1209:lwIP/src/core/udp.c ****  * pcb is not active until it has either been bound to a local address
1210:lwIP/src/core/udp.c ****  * or connected to a remote address.
1211:lwIP/src/core/udp.c ****  *
1212:lwIP/src/core/udp.c ****  * @return The UDP PCB which was created. NULL if the PCB data structure
1213:lwIP/src/core/udp.c ****  * could not be allocated.
1214:lwIP/src/core/udp.c ****  *
1215:lwIP/src/core/udp.c ****  * @see udp_remove()
1216:lwIP/src/core/udp.c ****  */
1217:lwIP/src/core/udp.c **** struct udp_pcb *
1218:lwIP/src/core/udp.c **** udp_new(void)
1219:lwIP/src/core/udp.c **** {
 2891              		.loc 1 1219 1 view -0
 2892              		.cfi_startproc
 2893              		@ args = 0, pretend = 0, frame = 0
 2894              		@ frame_needed = 0, uses_anonymous_args = 0
1220:lwIP/src/core/udp.c ****   struct udp_pcb *pcb;
 2895              		.loc 1 1220 3 view .LVU1031
1221:lwIP/src/core/udp.c **** 
1222:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 2896              		.loc 1 1222 28 view .LVU1032
1223:lwIP/src/core/udp.c **** 
1224:lwIP/src/core/udp.c ****   pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 2897              		.loc 1 1224 3 view .LVU1033
1219:lwIP/src/core/udp.c ****   struct udp_pcb *pcb;
 2898              		.loc 1 1219 1 is_stmt 0 view .LVU1034
 2899 0000 10B5     		push	{r4, lr}
 2900              	.LCFI33:
 2901              		.cfi_def_cfa_offset 8
 2902              		.cfi_offset 4, -8
 2903              		.cfi_offset 14, -4
 2904              		.loc 1 1224 27 view .LVU1035
 2905 0002 0020     		movs	r0, #0
 2906 0004 FFF7FEFF 		bl	memp_malloc
 2907              	.LVL241:
1225:lwIP/src/core/udp.c ****   /* could allocate UDP PCB? */
1226:lwIP/src/core/udp.c ****   if (pcb != NULL) {
 2908              		.loc 1 1226 3 is_stmt 1 view .LVU1036
 2909              		.loc 1 1226 6 is_stmt 0 view .LVU1037
 2910 0008 0446     		mov	r4, r0
 2911 000a 28B1     		cbz	r0, .L303
1227:lwIP/src/core/udp.c ****     /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
1228:lwIP/src/core/udp.c ****      * which means checksum is generated over the whole datagram per default
1229:lwIP/src/core/udp.c ****      * (recommended as default by RFC 3828). */
1230:lwIP/src/core/udp.c ****     /* initialize PCB to all zeroes */
1231:lwIP/src/core/udp.c ****     memset(pcb, 0, sizeof(struct udp_pcb));
 2912              		.loc 1 1231 5 is_stmt 1 view .LVU1038
ARM GAS  /tmp/cctoFbTf.s 			page 106


 2913 000c 2022     		movs	r2, #32
 2914 000e 0021     		movs	r1, #0
 2915 0010 FFF7FEFF 		bl	memset
 2916              	.LVL242:
1232:lwIP/src/core/udp.c ****     pcb->ttl = UDP_TTL;
 2917              		.loc 1 1232 5 view .LVU1039
 2918              		.loc 1 1232 14 is_stmt 0 view .LVU1040
 2919 0014 FF23     		movs	r3, #255
 2920 0016 E372     		strb	r3, [r4, #11]
1233:lwIP/src/core/udp.c **** #if LWIP_MULTICAST_TX_OPTIONS
1234:lwIP/src/core/udp.c ****     udp_set_multicast_ttl(pcb, UDP_TTL);
1235:lwIP/src/core/udp.c **** #endif /* LWIP_MULTICAST_TX_OPTIONS */
1236:lwIP/src/core/udp.c ****   }
1237:lwIP/src/core/udp.c ****   return pcb;
 2921              		.loc 1 1237 3 is_stmt 1 view .LVU1041
 2922              	.L303:
1238:lwIP/src/core/udp.c **** }
 2923              		.loc 1 1238 1 is_stmt 0 view .LVU1042
 2924 0018 2046     		mov	r0, r4
 2925 001a 10BD     		pop	{r4, pc}
 2926              		.loc 1 1238 1 view .LVU1043
 2927              		.cfi_endproc
 2928              	.LFE119:
 2930              		.section	.text.udp_new_ip_type,"ax",%progbits
 2931              		.align	1
 2932              		.p2align 2,,3
 2933              		.global	udp_new_ip_type
 2934              		.syntax unified
 2935              		.thumb
 2936              		.thumb_func
 2937              		.fpu fpv4-sp-d16
 2939              	udp_new_ip_type:
 2940              	.LVL243:
 2941              	.LFB120:
1239:lwIP/src/core/udp.c **** 
1240:lwIP/src/core/udp.c **** /**
1241:lwIP/src/core/udp.c ****  * @ingroup udp_raw
1242:lwIP/src/core/udp.c ****  * Create a UDP PCB for specific IP type.
1243:lwIP/src/core/udp.c ****  * The pcb is not active until it has either been bound to a local address
1244:lwIP/src/core/udp.c ****  * or connected to a remote address.
1245:lwIP/src/core/udp.c ****  * 
1246:lwIP/src/core/udp.c ****  * @param type IP address type, see @ref lwip_ip_addr_type definitions.
1247:lwIP/src/core/udp.c ****  * If you want to listen to IPv4 and IPv6 (dual-stack) packets,
1248:lwIP/src/core/udp.c ****  * supply @ref IPADDR_TYPE_ANY as argument and bind to @ref IP_ANY_TYPE.
1249:lwIP/src/core/udp.c ****  * @return The UDP PCB which was created. NULL if the PCB data structure
1250:lwIP/src/core/udp.c ****  * could not be allocated.
1251:lwIP/src/core/udp.c ****  *
1252:lwIP/src/core/udp.c ****  * @see udp_remove()
1253:lwIP/src/core/udp.c ****  */
1254:lwIP/src/core/udp.c **** struct udp_pcb *
1255:lwIP/src/core/udp.c **** udp_new_ip_type(u8_t type)
1256:lwIP/src/core/udp.c **** {
 2942              		.loc 1 1256 1 is_stmt 1 view -0
 2943              		.cfi_startproc
 2944              		@ args = 0, pretend = 0, frame = 0
 2945              		@ frame_needed = 0, uses_anonymous_args = 0
1257:lwIP/src/core/udp.c ****   struct udp_pcb *pcb;
ARM GAS  /tmp/cctoFbTf.s 			page 107


 2946              		.loc 1 1257 3 view .LVU1045
1258:lwIP/src/core/udp.c **** 
1259:lwIP/src/core/udp.c ****   LWIP_ASSERT_CORE_LOCKED();
 2947              		.loc 1 1259 28 view .LVU1046
1260:lwIP/src/core/udp.c **** 
1261:lwIP/src/core/udp.c ****   pcb = udp_new();
 2948              		.loc 1 1261 3 view .LVU1047
 2949              	.LBB190:
 2950              	.LBI190:
1218:lwIP/src/core/udp.c **** {
 2951              		.loc 1 1218 1 view .LVU1048
 2952              	.LBB191:
1220:lwIP/src/core/udp.c **** 
 2953              		.loc 1 1220 3 view .LVU1049
1222:lwIP/src/core/udp.c **** 
 2954              		.loc 1 1222 28 view .LVU1050
1224:lwIP/src/core/udp.c ****   /* could allocate UDP PCB? */
 2955              		.loc 1 1224 3 view .LVU1051
 2956              	.LBE191:
 2957              	.LBE190:
1256:lwIP/src/core/udp.c ****   struct udp_pcb *pcb;
 2958              		.loc 1 1256 1 is_stmt 0 view .LVU1052
 2959 0000 10B5     		push	{r4, lr}
 2960              	.LCFI34:
 2961              		.cfi_def_cfa_offset 8
 2962              		.cfi_offset 4, -8
 2963              		.cfi_offset 14, -4
 2964              	.LBB193:
 2965              	.LBB192:
1224:lwIP/src/core/udp.c ****   /* could allocate UDP PCB? */
 2966              		.loc 1 1224 27 view .LVU1053
 2967 0002 0020     		movs	r0, #0
 2968              	.LVL244:
1224:lwIP/src/core/udp.c ****   /* could allocate UDP PCB? */
 2969              		.loc 1 1224 27 view .LVU1054
 2970 0004 FFF7FEFF 		bl	memp_malloc
 2971              	.LVL245:
1226:lwIP/src/core/udp.c ****     /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
 2972              		.loc 1 1226 3 is_stmt 1 view .LVU1055
1226:lwIP/src/core/udp.c ****     /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
 2973              		.loc 1 1226 6 is_stmt 0 view .LVU1056
 2974 0008 0446     		mov	r4, r0
 2975 000a 28B1     		cbz	r0, .L309
1231:lwIP/src/core/udp.c ****     pcb->ttl = UDP_TTL;
 2976              		.loc 1 1231 5 is_stmt 1 view .LVU1057
 2977 000c 2022     		movs	r2, #32
 2978 000e 0021     		movs	r1, #0
 2979 0010 FFF7FEFF 		bl	memset
 2980              	.LVL246:
1232:lwIP/src/core/udp.c **** #if LWIP_MULTICAST_TX_OPTIONS
 2981              		.loc 1 1232 5 view .LVU1058
1232:lwIP/src/core/udp.c **** #if LWIP_MULTICAST_TX_OPTIONS
 2982              		.loc 1 1232 14 is_stmt 0 view .LVU1059
 2983 0014 FF23     		movs	r3, #255
 2984 0016 E372     		strb	r3, [r4, #11]
1237:lwIP/src/core/udp.c **** }
 2985              		.loc 1 1237 3 is_stmt 1 view .LVU1060
ARM GAS  /tmp/cctoFbTf.s 			page 108


 2986              	.LVL247:
1237:lwIP/src/core/udp.c **** }
 2987              		.loc 1 1237 3 is_stmt 0 view .LVU1061
 2988              	.LBE192:
 2989              	.LBE193:
1262:lwIP/src/core/udp.c **** #if LWIP_IPV4 && LWIP_IPV6
1263:lwIP/src/core/udp.c ****   if (pcb != NULL) {
1264:lwIP/src/core/udp.c ****     IP_SET_TYPE_VAL(pcb->local_ip,  type);
1265:lwIP/src/core/udp.c ****     IP_SET_TYPE_VAL(pcb->remote_ip, type);
1266:lwIP/src/core/udp.c ****   }
1267:lwIP/src/core/udp.c **** #else
1268:lwIP/src/core/udp.c ****   LWIP_UNUSED_ARG(type);
 2990              		.loc 1 1268 3 is_stmt 1 view .LVU1062
1269:lwIP/src/core/udp.c **** #endif /* LWIP_IPV4 && LWIP_IPV6 */
1270:lwIP/src/core/udp.c ****   return pcb;
 2991              		.loc 1 1270 3 view .LVU1063
 2992              	.L309:
1271:lwIP/src/core/udp.c **** }
 2993              		.loc 1 1271 1 is_stmt 0 view .LVU1064
 2994 0018 2046     		mov	r0, r4
 2995 001a 10BD     		pop	{r4, pc}
 2996              		.cfi_endproc
 2997              	.LFE120:
 2999              		.section	.text.udp_netif_ip_addr_changed,"ax",%progbits
 3000              		.align	1
 3001              		.p2align 2,,3
 3002              		.global	udp_netif_ip_addr_changed
 3003              		.syntax unified
 3004              		.thumb
 3005              		.thumb_func
 3006              		.fpu fpv4-sp-d16
 3008              	udp_netif_ip_addr_changed:
 3009              	.LVL248:
 3010              	.LFB121:
1272:lwIP/src/core/udp.c **** 
1273:lwIP/src/core/udp.c **** /** This function is called from netif.c when address is changed
1274:lwIP/src/core/udp.c ****  *
1275:lwIP/src/core/udp.c ****  * @param old_addr IP address of the netif before change
1276:lwIP/src/core/udp.c ****  * @param new_addr IP address of the netif after change
1277:lwIP/src/core/udp.c ****  */
1278:lwIP/src/core/udp.c **** void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
1279:lwIP/src/core/udp.c **** {
 3011              		.loc 1 1279 1 is_stmt 1 view -0
 3012              		.cfi_startproc
 3013              		@ args = 0, pretend = 0, frame = 0
 3014              		@ frame_needed = 0, uses_anonymous_args = 0
 3015              		@ link register save eliminated.
1280:lwIP/src/core/udp.c ****   struct udp_pcb *upcb;
 3016              		.loc 1 1280 3 view .LVU1066
1281:lwIP/src/core/udp.c **** 
1282:lwIP/src/core/udp.c ****   if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 3017              		.loc 1 1282 3 view .LVU1067
 3018              		.loc 1 1282 6 is_stmt 0 view .LVU1068
 3019 0000 10B1     		cbz	r0, .L340
 3020              		.loc 1 1282 8 discriminator 1 view .LVU1069
 3021 0002 0268     		ldr	r2, [r0]
 3022              		.loc 1 1282 32 discriminator 1 view .LVU1070
ARM GAS  /tmp/cctoFbTf.s 			page 109


 3023 0004 01B1     		cbz	r1, .L340
 3024 0006 02B9     		cbnz	r2, .L342
 3025              	.L340:
 3026 0008 7047     		bx	lr
 3027              	.L342:
 3028              		.loc 1 1282 35 discriminator 3 view .LVU1071
 3029 000a 0B68     		ldr	r3, [r1]
 3030 000c 002B     		cmp	r3, #0
 3031 000e FBD0     		beq	.L340
1283:lwIP/src/core/udp.c ****     for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 3032              		.loc 1 1283 5 is_stmt 1 view .LVU1072
 3033              		.loc 1 1283 15 is_stmt 0 view .LVU1073
 3034 0010 0A4B     		ldr	r3, .L344
 3035 0012 1B68     		ldr	r3, [r3]
 3036              	.LVL249:
 3037              		.loc 1 1283 27 is_stmt 1 view .LVU1074
 3038              		.loc 1 1283 5 is_stmt 0 view .LVU1075
 3039 0014 002B     		cmp	r3, #0
 3040 0016 F7D0     		beq	.L340
1279:lwIP/src/core/udp.c ****   struct udp_pcb *upcb;
 3041              		.loc 1 1279 1 view .LVU1076
 3042 0018 10B4     		push	{r4}
 3043              	.LCFI35:
 3044              		.cfi_def_cfa_offset 4
 3045              		.cfi_offset 4, -4
 3046              	.L319:
1284:lwIP/src/core/udp.c ****       /* PCB bound to current local interface address? */
1285:lwIP/src/core/udp.c ****       if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 3047              		.loc 1 1285 7 is_stmt 1 view .LVU1077
1283:lwIP/src/core/udp.c ****       /* PCB bound to current local interface address? */
 3048              		.loc 1 1283 41 view .LVU1078
 3049              		.loc 1 1285 10 is_stmt 0 view .LVU1079
 3050 001a 1C68     		ldr	r4, [r3]
 3051 001c 9442     		cmp	r4, r2
 3052 001e 05D0     		beq	.L343
1283:lwIP/src/core/udp.c ****       /* PCB bound to current local interface address? */
 3053              		.loc 1 1283 46 discriminator 2 view .LVU1080
 3054 0020 DB68     		ldr	r3, [r3, #12]
 3055              	.LVL250:
1283:lwIP/src/core/udp.c ****       /* PCB bound to current local interface address? */
 3056              		.loc 1 1283 27 is_stmt 1 discriminator 2 view .LVU1081
1283:lwIP/src/core/udp.c ****       /* PCB bound to current local interface address? */
 3057              		.loc 1 1283 5 is_stmt 0 discriminator 2 view .LVU1082
 3058 0022 002B     		cmp	r3, #0
 3059 0024 F9D1     		bne	.L319
 3060              	.L315:
1286:lwIP/src/core/udp.c ****         /* The PCB is bound to the old ipaddr and
1287:lwIP/src/core/udp.c ****          * is set to bound to the new one instead */
1288:lwIP/src/core/udp.c ****         ip_addr_copy(upcb->local_ip, *new_addr);
1289:lwIP/src/core/udp.c ****       }
1290:lwIP/src/core/udp.c ****     }
1291:lwIP/src/core/udp.c ****   }
1292:lwIP/src/core/udp.c **** }
 3061              		.loc 1 1292 1 view .LVU1083
 3062 0026 5DF8044B 		ldr	r4, [sp], #4
 3063              	.LCFI36:
 3064              		.cfi_remember_state
ARM GAS  /tmp/cctoFbTf.s 			page 110


 3065              		.cfi_restore 4
 3066              		.cfi_def_cfa_offset 0
 3067 002a 7047     		bx	lr
 3068              	.L343:
 3069              	.LCFI37:
 3070              		.cfi_restore_state
1288:lwIP/src/core/udp.c ****       }
 3071              		.loc 1 1288 9 is_stmt 1 view .LVU1084
 3072 002c 0A68     		ldr	r2, [r1]
 3073 002e 1A60     		str	r2, [r3]
1283:lwIP/src/core/udp.c ****       /* PCB bound to current local interface address? */
 3074              		.loc 1 1283 41 view .LVU1085
1283:lwIP/src/core/udp.c ****       /* PCB bound to current local interface address? */
 3075              		.loc 1 1283 46 is_stmt 0 view .LVU1086
 3076 0030 DB68     		ldr	r3, [r3, #12]
 3077              	.LVL251:
1283:lwIP/src/core/udp.c ****       /* PCB bound to current local interface address? */
 3078              		.loc 1 1283 27 is_stmt 1 view .LVU1087
1283:lwIP/src/core/udp.c ****       /* PCB bound to current local interface address? */
 3079              		.loc 1 1283 5 is_stmt 0 view .LVU1088
 3080 0032 002B     		cmp	r3, #0
 3081 0034 F7D0     		beq	.L315
 3082 0036 0268     		ldr	r2, [r0]
 3083 0038 EFE7     		b	.L319
 3084              	.L345:
 3085 003a 00BF     		.align	2
 3086              	.L344:
 3087 003c 00000000 		.word	udp_pcbs
 3088              		.cfi_endproc
 3089              	.LFE121:
 3091              		.comm	udp_pcbs,4,4
 3092              		.section	.data.udp_port,"aw"
 3093              		.align	1
 3094              		.set	.LANCHOR0,. + 0
 3097              	udp_port:
 3098 0000 00C0     		.short	-16384
 3099              		.text
 3100              	.Letext0:
 3101              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
 3102              		.file 4 "/usr/arm-none-eabi/include/sys/lock.h"
 3103              		.file 5 "/usr/arm-none-eabi/include/sys/_types.h"
 3104              		.file 6 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h"
 3105              		.file 7 "/usr/arm-none-eabi/include/sys/reent.h"
 3106              		.file 8 "/usr/arm-none-eabi/include/stdlib.h"
 3107              		.file 9 "/usr/arm-none-eabi/include/sys/_stdint.h"
 3108              		.file 10 "lwIP/src/include/lwip/arch.h"
 3109              		.file 11 "/usr/arm-none-eabi/include/ctype.h"
 3110              		.file 12 "lwIP/src/include/lwip/err.h"
 3111              		.file 13 "lwIP/src/include/lwip/pbuf.h"
 3112              		.file 14 "lwIP/src/include/lwip/ip4_addr.h"
 3113              		.file 15 "lwIP/src/include/lwip/ip_addr.h"
 3114              		.file 16 "lwIP/src/include/lwip/memp.h"
 3115              		.file 17 "lwIP/src/include/lwip/priv/memp_priv.h"
 3116              		.file 18 "lwIP/src/include/lwip/netif.h"
 3117              		.file 19 "lwIP/src/include/lwip/prot/ip4.h"
 3118              		.file 20 "lwIP/src/include/lwip/ip.h"
 3119              		.file 21 "lwIP/src/include/lwip/prot/udp.h"
ARM GAS  /tmp/cctoFbTf.s 			page 111


 3120              		.file 22 "lwIP/src/include/lwip/udp.h"
 3121              		.file 23 "/usr/arm-none-eabi/include/stdio.h"
 3122              		.file 24 "lwIP/src/include/lwip/ip4.h"
 3123              		.file 25 "lwIP/src/include/lwip/inet_chksum.h"
 3124              		.file 26 "lwIP/src/include/lwip/icmp.h"
 3125              		.file 27 "<built-in>"
ARM GAS  /tmp/cctoFbTf.s 			page 112


DEFINED SYMBOLS
                            *ABS*:0000000000000000 udp.c
     /tmp/cctoFbTf.s:18     .text.udp_init:0000000000000000 $t
     /tmp/cctoFbTf.s:27     .text.udp_init:0000000000000000 udp_init
     /tmp/cctoFbTf.s:56     .text.udp_init:0000000000000010 $d
     /tmp/cctoFbTf.s:62     .rodata.udp_input.str1.4:0000000000000000 $d
     /tmp/cctoFbTf.s:72     .text.udp_input:0000000000000000 $t
     /tmp/cctoFbTf.s:80     .text.udp_input:0000000000000000 udp_input
     /tmp/cctoFbTf.s:623    .text.udp_input:00000000000001a0 $d
                            *COM*:0000000000000004 udp_pcbs
     /tmp/cctoFbTf.s:634    .rodata.udp_bind.str1.4:0000000000000000 $d
     /tmp/cctoFbTf.s:638    .text.udp_bind:0000000000000000 $t
     /tmp/cctoFbTf.s:646    .text.udp_bind:0000000000000000 udp_bind
     /tmp/cctoFbTf.s:910    .text.udp_bind:00000000000000d4 $d
     /tmp/cctoFbTf.s:918    .rodata.udp_sendto_if_src.str1.4:0000000000000000 $d
     /tmp/cctoFbTf.s:937    .text.udp_sendto_if_src:0000000000000000 $t
     /tmp/cctoFbTf.s:945    .text.udp_sendto_if_src:0000000000000000 udp_sendto_if_src
     /tmp/cctoFbTf.s:1350   .text.udp_sendto_if_src:000000000000011c $d
     /tmp/cctoFbTf.s:1362   .rodata.udp_sendto.str1.4:0000000000000000 $d
     /tmp/cctoFbTf.s:1372   .text.udp_sendto:0000000000000000 $t
     /tmp/cctoFbTf.s:1380   .text.udp_sendto:0000000000000000 udp_sendto
     /tmp/cctoFbTf.s:1607   .text.udp_sendto:0000000000000070 $d
     /tmp/cctoFbTf.s:1616   .rodata.udp_send.str1.4:0000000000000000 $d
     /tmp/cctoFbTf.s:1623   .text.udp_send:0000000000000000 $t
     /tmp/cctoFbTf.s:1631   .text.udp_send:0000000000000000 udp_send
     /tmp/cctoFbTf.s:1873   .text.udp_send:0000000000000064 $d
     /tmp/cctoFbTf.s:1883   .rodata.udp_sendto_if.str1.4:0000000000000000 $d
     /tmp/cctoFbTf.s:1896   .text.udp_sendto_if:0000000000000000 $t
     /tmp/cctoFbTf.s:1904   .text.udp_sendto_if:0000000000000000 udp_sendto_if
     /tmp/cctoFbTf.s:2396   .text.udp_sendto_if:0000000000000130 $d
     /tmp/cctoFbTf.s:2407   .text.udp_bind_netif:0000000000000000 $t
     /tmp/cctoFbTf.s:2415   .text.udp_bind_netif:0000000000000000 udp_bind_netif
     /tmp/cctoFbTf.s:2442   .rodata.udp_connect.str1.4:0000000000000000 $d
     /tmp/cctoFbTf.s:2449   .text.udp_connect:0000000000000000 $t
     /tmp/cctoFbTf.s:2457   .text.udp_connect:0000000000000000 udp_connect
     /tmp/cctoFbTf.s:2613   .text.udp_connect:0000000000000060 $d
     /tmp/cctoFbTf.s:2620   .rodata.udp_disconnect.str1.4:0000000000000000 $d
     /tmp/cctoFbTf.s:2624   .text.udp_disconnect:0000000000000000 $t
     /tmp/cctoFbTf.s:2632   .text.udp_disconnect:0000000000000000 udp_disconnect
     /tmp/cctoFbTf.s:2691   .text.udp_disconnect:0000000000000020 $d
     /tmp/cctoFbTf.s:2696   .rodata.udp_recv.str1.4:0000000000000000 $d
     /tmp/cctoFbTf.s:2700   .text.udp_recv:0000000000000000 $t
     /tmp/cctoFbTf.s:2708   .text.udp_recv:0000000000000000 udp_recv
     /tmp/cctoFbTf.s:2748   .text.udp_recv:0000000000000014 $d
     /tmp/cctoFbTf.s:2753   .rodata.udp_remove.str1.4:0000000000000000 $d
     /tmp/cctoFbTf.s:2757   .text.udp_remove:0000000000000000 $t
     /tmp/cctoFbTf.s:2765   .text.udp_remove:0000000000000000 udp_remove
     /tmp/cctoFbTf.s:2875   .text.udp_remove:0000000000000040 $d
     /tmp/cctoFbTf.s:2881   .text.udp_new:0000000000000000 $t
     /tmp/cctoFbTf.s:2889   .text.udp_new:0000000000000000 udp_new
     /tmp/cctoFbTf.s:2931   .text.udp_new_ip_type:0000000000000000 $t
     /tmp/cctoFbTf.s:2939   .text.udp_new_ip_type:0000000000000000 udp_new_ip_type
     /tmp/cctoFbTf.s:3000   .text.udp_netif_ip_addr_changed:0000000000000000 $t
     /tmp/cctoFbTf.s:3008   .text.udp_netif_ip_addr_changed:0000000000000000 udp_netif_ip_addr_changed
     /tmp/cctoFbTf.s:3087   .text.udp_netif_ip_addr_changed:000000000000003c $d
     /tmp/cctoFbTf.s:3093   .data.udp_port:0000000000000000 $d
     /tmp/cctoFbTf.s:3097   .data.udp_port:0000000000000000 udp_port
ARM GAS  /tmp/cctoFbTf.s 			page 113



UNDEFINED SYMBOLS
rand
ip4_addr_isbroadcast_u32
ip_chksum_pseudo
pbuf_remove_header
pbuf_header_force
icmp_dest_unreach
pbuf_free
printf
puts
ip_data
ip_addr_any
pbuf_add_header
ip4_output_if_src
pbuf_alloc
pbuf_chain
netif_get_by_index
ip4_route
memp_free
memp_malloc
memset
