ARM GAS  /tmp/ccHPvcAz.s 			page 1


   1              		.cpu cortex-m7
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"ip4_frag.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.ipfrag_free_pbuf_custom.str1.4,"aMS",%progbits,1
  18              		.align	2
  19              	.LC0:
  20 0000 70637220 		.ascii	"pcr != NULL\000"
  20      213D204E 
  20      554C4C00 
  21              		.section	.text.ipfrag_free_pbuf_custom,"ax",%progbits
  22              		.align	1
  23              		.p2align 2,,3
  24              		.arch armv7e-m
  25              		.syntax unified
  26              		.thumb
  27              		.thumb_func
  28              		.fpu fpv4-sp-d16
  30              	ipfrag_free_pbuf_custom:
  31              	.LVL0:
  32              	.LFB114:
  33              		.file 1 "lwIP/src/core/ipv4/ip4_frag.c"
   1:lwIP/src/core/ipv4/ip4_frag.c **** /**
   2:lwIP/src/core/ipv4/ip4_frag.c ****  * @file
   3:lwIP/src/core/ipv4/ip4_frag.c ****  * This is the IPv4 packet segmentation and reassembly implementation.
   4:lwIP/src/core/ipv4/ip4_frag.c ****  *
   5:lwIP/src/core/ipv4/ip4_frag.c ****  */
   6:lwIP/src/core/ipv4/ip4_frag.c **** 
   7:lwIP/src/core/ipv4/ip4_frag.c **** /*
   8:lwIP/src/core/ipv4/ip4_frag.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
   9:lwIP/src/core/ipv4/ip4_frag.c ****  * All rights reserved.
  10:lwIP/src/core/ipv4/ip4_frag.c ****  *
  11:lwIP/src/core/ipv4/ip4_frag.c ****  * Redistribution and use in source and binary forms, with or without modification,
  12:lwIP/src/core/ipv4/ip4_frag.c ****  * are permitted provided that the following conditions are met:
  13:lwIP/src/core/ipv4/ip4_frag.c ****  *
  14:lwIP/src/core/ipv4/ip4_frag.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  15:lwIP/src/core/ipv4/ip4_frag.c ****  *    this list of conditions and the following disclaimer.
  16:lwIP/src/core/ipv4/ip4_frag.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  17:lwIP/src/core/ipv4/ip4_frag.c ****  *    this list of conditions and the following disclaimer in the documentation
  18:lwIP/src/core/ipv4/ip4_frag.c ****  *    and/or other materials provided with the distribution.
  19:lwIP/src/core/ipv4/ip4_frag.c ****  * 3. The name of the author may not be used to endorse or promote products
  20:lwIP/src/core/ipv4/ip4_frag.c ****  *    derived from this software without specific prior written permission.
  21:lwIP/src/core/ipv4/ip4_frag.c ****  *
  22:lwIP/src/core/ipv4/ip4_frag.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  23:lwIP/src/core/ipv4/ip4_frag.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
ARM GAS  /tmp/ccHPvcAz.s 			page 2


  24:lwIP/src/core/ipv4/ip4_frag.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  25:lwIP/src/core/ipv4/ip4_frag.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  26:lwIP/src/core/ipv4/ip4_frag.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  27:lwIP/src/core/ipv4/ip4_frag.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:lwIP/src/core/ipv4/ip4_frag.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:lwIP/src/core/ipv4/ip4_frag.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  30:lwIP/src/core/ipv4/ip4_frag.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  31:lwIP/src/core/ipv4/ip4_frag.c ****  * OF SUCH DAMAGE.
  32:lwIP/src/core/ipv4/ip4_frag.c ****  *
  33:lwIP/src/core/ipv4/ip4_frag.c ****  * This file is part of the lwIP TCP/IP stack.
  34:lwIP/src/core/ipv4/ip4_frag.c ****  *
  35:lwIP/src/core/ipv4/ip4_frag.c ****  * Author: Jani Monoses <jani@iv.ro>
  36:lwIP/src/core/ipv4/ip4_frag.c ****  *         Simon Goldschmidt
  37:lwIP/src/core/ipv4/ip4_frag.c ****  * original reassembly code by Adam Dunkels <adam@sics.se>
  38:lwIP/src/core/ipv4/ip4_frag.c ****  *
  39:lwIP/src/core/ipv4/ip4_frag.c ****  */
  40:lwIP/src/core/ipv4/ip4_frag.c **** 
  41:lwIP/src/core/ipv4/ip4_frag.c **** #include "lwip/opt.h"
  42:lwIP/src/core/ipv4/ip4_frag.c **** 
  43:lwIP/src/core/ipv4/ip4_frag.c **** #if LWIP_IPV4
  44:lwIP/src/core/ipv4/ip4_frag.c **** 
  45:lwIP/src/core/ipv4/ip4_frag.c **** #include "lwip/ip4_frag.h"
  46:lwIP/src/core/ipv4/ip4_frag.c **** #include "lwip/def.h"
  47:lwIP/src/core/ipv4/ip4_frag.c **** #include "lwip/inet_chksum.h"
  48:lwIP/src/core/ipv4/ip4_frag.c **** #include "lwip/netif.h"
  49:lwIP/src/core/ipv4/ip4_frag.c **** #include "lwip/stats.h"
  50:lwIP/src/core/ipv4/ip4_frag.c **** #include "lwip/icmp.h"
  51:lwIP/src/core/ipv4/ip4_frag.c **** 
  52:lwIP/src/core/ipv4/ip4_frag.c **** #include <string.h>
  53:lwIP/src/core/ipv4/ip4_frag.c **** 
  54:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASSEMBLY
  55:lwIP/src/core/ipv4/ip4_frag.c **** /**
  56:lwIP/src/core/ipv4/ip4_frag.c ****  * The IP reassembly code currently has the following limitations:
  57:lwIP/src/core/ipv4/ip4_frag.c ****  * - IP header options are not supported
  58:lwIP/src/core/ipv4/ip4_frag.c ****  * - fragments must not overlap (e.g. due to different routes),
  59:lwIP/src/core/ipv4/ip4_frag.c ****  *   currently, overlapping or duplicate fragments are thrown away
  60:lwIP/src/core/ipv4/ip4_frag.c ****  *   if IP_REASS_CHECK_OVERLAP=1 (the default)!
  61:lwIP/src/core/ipv4/ip4_frag.c ****  *
  62:lwIP/src/core/ipv4/ip4_frag.c ****  * @todo: work with IP header options
  63:lwIP/src/core/ipv4/ip4_frag.c ****  */
  64:lwIP/src/core/ipv4/ip4_frag.c **** 
  65:lwIP/src/core/ipv4/ip4_frag.c **** /** Setting this to 0, you can turn off checking the fragments for overlapping
  66:lwIP/src/core/ipv4/ip4_frag.c ****  * regions. The code gets a little smaller. Only use this if you know that
  67:lwIP/src/core/ipv4/ip4_frag.c ****  * overlapping won't occur on your network! */
  68:lwIP/src/core/ipv4/ip4_frag.c **** #ifndef IP_REASS_CHECK_OVERLAP
  69:lwIP/src/core/ipv4/ip4_frag.c **** #define IP_REASS_CHECK_OVERLAP 1
  70:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_CHECK_OVERLAP */
  71:lwIP/src/core/ipv4/ip4_frag.c **** 
  72:lwIP/src/core/ipv4/ip4_frag.c **** /** Set to 0 to prevent freeing the oldest datagram when the reassembly buffer is
  73:lwIP/src/core/ipv4/ip4_frag.c ****  * full (IP_REASS_MAX_PBUFS pbufs are enqueued). The code gets a little smaller.
  74:lwIP/src/core/ipv4/ip4_frag.c ****  * Datagrams will be freed by timeout only. Especially useful when MEMP_NUM_REASSDATA
  75:lwIP/src/core/ipv4/ip4_frag.c ****  * is set to 1, so one datagram can be reassembled at a time, only. */
  76:lwIP/src/core/ipv4/ip4_frag.c **** #ifndef IP_REASS_FREE_OLDEST
  77:lwIP/src/core/ipv4/ip4_frag.c **** #define IP_REASS_FREE_OLDEST 1
  78:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_FREE_OLDEST */
  79:lwIP/src/core/ipv4/ip4_frag.c **** 
  80:lwIP/src/core/ipv4/ip4_frag.c **** #define IP_REASS_FLAG_LASTFRAG 0x01
ARM GAS  /tmp/ccHPvcAz.s 			page 3


  81:lwIP/src/core/ipv4/ip4_frag.c **** 
  82:lwIP/src/core/ipv4/ip4_frag.c **** #define IP_REASS_VALIDATE_TELEGRAM_FINISHED  1
  83:lwIP/src/core/ipv4/ip4_frag.c **** #define IP_REASS_VALIDATE_PBUF_QUEUED        0
  84:lwIP/src/core/ipv4/ip4_frag.c **** #define IP_REASS_VALIDATE_PBUF_DROPPED       -1
  85:lwIP/src/core/ipv4/ip4_frag.c **** 
  86:lwIP/src/core/ipv4/ip4_frag.c **** /** This is a helper struct which holds the starting
  87:lwIP/src/core/ipv4/ip4_frag.c ****  * offset and the ending offset of this fragment to
  88:lwIP/src/core/ipv4/ip4_frag.c ****  * easily chain the fragments.
  89:lwIP/src/core/ipv4/ip4_frag.c ****  * It has the same packing requirements as the IP header, since it replaces
  90:lwIP/src/core/ipv4/ip4_frag.c ****  * the IP header in memory in incoming fragments (after copying it) to keep
  91:lwIP/src/core/ipv4/ip4_frag.c ****  * track of the various fragments. (-> If the IP header doesn't need packing,
  92:lwIP/src/core/ipv4/ip4_frag.c ****  * this struct doesn't need packing, too.)
  93:lwIP/src/core/ipv4/ip4_frag.c ****  */
  94:lwIP/src/core/ipv4/ip4_frag.c **** #ifdef PACK_STRUCT_USE_INCLUDES
  95:lwIP/src/core/ipv4/ip4_frag.c **** #  include "arch/bpstruct.h"
  96:lwIP/src/core/ipv4/ip4_frag.c **** #endif
  97:lwIP/src/core/ipv4/ip4_frag.c **** PACK_STRUCT_BEGIN
  98:lwIP/src/core/ipv4/ip4_frag.c **** struct ip_reass_helper {
  99:lwIP/src/core/ipv4/ip4_frag.c ****   PACK_STRUCT_FIELD(struct pbuf *next_pbuf);
 100:lwIP/src/core/ipv4/ip4_frag.c ****   PACK_STRUCT_FIELD(u16_t start);
 101:lwIP/src/core/ipv4/ip4_frag.c ****   PACK_STRUCT_FIELD(u16_t end);
 102:lwIP/src/core/ipv4/ip4_frag.c **** } PACK_STRUCT_STRUCT;
 103:lwIP/src/core/ipv4/ip4_frag.c **** PACK_STRUCT_END
 104:lwIP/src/core/ipv4/ip4_frag.c **** #ifdef PACK_STRUCT_USE_INCLUDES
 105:lwIP/src/core/ipv4/ip4_frag.c **** #  include "arch/epstruct.h"
 106:lwIP/src/core/ipv4/ip4_frag.c **** #endif
 107:lwIP/src/core/ipv4/ip4_frag.c **** 
 108:lwIP/src/core/ipv4/ip4_frag.c **** #define IP_ADDRESSES_AND_ID_MATCH(iphdrA, iphdrB)  \
 109:lwIP/src/core/ipv4/ip4_frag.c ****   (ip4_addr_cmp(&(iphdrA)->src, &(iphdrB)->src) && \
 110:lwIP/src/core/ipv4/ip4_frag.c ****    ip4_addr_cmp(&(iphdrA)->dest, &(iphdrB)->dest) && \
 111:lwIP/src/core/ipv4/ip4_frag.c ****    IPH_ID(iphdrA) == IPH_ID(iphdrB)) ? 1 : 0
 112:lwIP/src/core/ipv4/ip4_frag.c **** 
 113:lwIP/src/core/ipv4/ip4_frag.c **** /* global variables */
 114:lwIP/src/core/ipv4/ip4_frag.c **** static struct ip_reassdata *reassdatagrams;
 115:lwIP/src/core/ipv4/ip4_frag.c **** static u16_t ip_reass_pbufcount;
 116:lwIP/src/core/ipv4/ip4_frag.c **** 
 117:lwIP/src/core/ipv4/ip4_frag.c **** /* function prototypes */
 118:lwIP/src/core/ipv4/ip4_frag.c **** static void ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev);
 119:lwIP/src/core/ipv4/ip4_frag.c **** static int ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev);
 120:lwIP/src/core/ipv4/ip4_frag.c **** 
 121:lwIP/src/core/ipv4/ip4_frag.c **** /**
 122:lwIP/src/core/ipv4/ip4_frag.c ****  * Reassembly timer base function
 123:lwIP/src/core/ipv4/ip4_frag.c ****  * for both NO_SYS == 0 and 1 (!).
 124:lwIP/src/core/ipv4/ip4_frag.c ****  *
 125:lwIP/src/core/ipv4/ip4_frag.c ****  * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 126:lwIP/src/core/ipv4/ip4_frag.c ****  */
 127:lwIP/src/core/ipv4/ip4_frag.c **** void
 128:lwIP/src/core/ipv4/ip4_frag.c **** ip_reass_tmr(void)
 129:lwIP/src/core/ipv4/ip4_frag.c **** {
 130:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reassdata *r, *prev = NULL;
 131:lwIP/src/core/ipv4/ip4_frag.c **** 
 132:lwIP/src/core/ipv4/ip4_frag.c ****   r = reassdatagrams;
 133:lwIP/src/core/ipv4/ip4_frag.c ****   while (r != NULL) {
 134:lwIP/src/core/ipv4/ip4_frag.c ****     /* Decrement the timer. Once it reaches 0,
 135:lwIP/src/core/ipv4/ip4_frag.c ****      * clean up the incomplete fragment assembly */
 136:lwIP/src/core/ipv4/ip4_frag.c ****     if (r->timer > 0) {
 137:lwIP/src/core/ipv4/ip4_frag.c ****       r->timer--;
ARM GAS  /tmp/ccHPvcAz.s 			page 4


 138:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n", (u16_t)r->timer));
 139:lwIP/src/core/ipv4/ip4_frag.c ****       prev = r;
 140:lwIP/src/core/ipv4/ip4_frag.c ****       r = r->next;
 141:lwIP/src/core/ipv4/ip4_frag.c ****     } else {
 142:lwIP/src/core/ipv4/ip4_frag.c ****       /* reassembly timed out */
 143:lwIP/src/core/ipv4/ip4_frag.c ****       struct ip_reassdata *tmp;
 144:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
 145:lwIP/src/core/ipv4/ip4_frag.c ****       tmp = r;
 146:lwIP/src/core/ipv4/ip4_frag.c ****       /* get the next pointer before freeing */
 147:lwIP/src/core/ipv4/ip4_frag.c ****       r = r->next;
 148:lwIP/src/core/ipv4/ip4_frag.c ****       /* free the helper struct and all enqueued pbufs */
 149:lwIP/src/core/ipv4/ip4_frag.c ****       ip_reass_free_complete_datagram(tmp, prev);
 150:lwIP/src/core/ipv4/ip4_frag.c ****     }
 151:lwIP/src/core/ipv4/ip4_frag.c ****   }
 152:lwIP/src/core/ipv4/ip4_frag.c **** }
 153:lwIP/src/core/ipv4/ip4_frag.c **** 
 154:lwIP/src/core/ipv4/ip4_frag.c **** /**
 155:lwIP/src/core/ipv4/ip4_frag.c ****  * Free a datagram (struct ip_reassdata) and all its pbufs.
 156:lwIP/src/core/ipv4/ip4_frag.c ****  * Updates the total count of enqueued pbufs (ip_reass_pbufcount),
 157:lwIP/src/core/ipv4/ip4_frag.c ****  * SNMP counters and sends an ICMP time exceeded packet.
 158:lwIP/src/core/ipv4/ip4_frag.c ****  *
 159:lwIP/src/core/ipv4/ip4_frag.c ****  * @param ipr datagram to free
 160:lwIP/src/core/ipv4/ip4_frag.c ****  * @param prev the previous datagram in the linked list
 161:lwIP/src/core/ipv4/ip4_frag.c ****  * @return the number of pbufs freed
 162:lwIP/src/core/ipv4/ip4_frag.c ****  */
 163:lwIP/src/core/ipv4/ip4_frag.c **** static int
 164:lwIP/src/core/ipv4/ip4_frag.c **** ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
 165:lwIP/src/core/ipv4/ip4_frag.c **** {
 166:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t pbufs_freed = 0;
 167:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t clen;
 168:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *p;
 169:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reass_helper *iprh;
 170:lwIP/src/core/ipv4/ip4_frag.c **** 
 171:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("prev != ipr", prev != ipr);
 172:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 173:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 174:lwIP/src/core/ipv4/ip4_frag.c ****   }
 175:lwIP/src/core/ipv4/ip4_frag.c **** 
 176:lwIP/src/core/ipv4/ip4_frag.c ****   MIB2_STATS_INC(mib2.ipreasmfails);
 177:lwIP/src/core/ipv4/ip4_frag.c **** #if LWIP_ICMP
 178:lwIP/src/core/ipv4/ip4_frag.c ****   iprh = (struct ip_reass_helper *)ipr->p->payload;
 179:lwIP/src/core/ipv4/ip4_frag.c ****   if (iprh->start == 0) {
 180:lwIP/src/core/ipv4/ip4_frag.c ****     /* The first fragment was received, send ICMP time exceeded. */
 181:lwIP/src/core/ipv4/ip4_frag.c ****     /* First, de-queue the first pbuf from r->p. */
 182:lwIP/src/core/ipv4/ip4_frag.c ****     p = ipr->p;
 183:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->p = iprh->next_pbuf;
 184:lwIP/src/core/ipv4/ip4_frag.c ****     /* Then, copy the original header into it. */
 185:lwIP/src/core/ipv4/ip4_frag.c ****     SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 186:lwIP/src/core/ipv4/ip4_frag.c ****     icmp_time_exceeded(p, ICMP_TE_FRAG);
 187:lwIP/src/core/ipv4/ip4_frag.c ****     clen = pbuf_clen(p);
 188:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 189:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 190:lwIP/src/core/ipv4/ip4_frag.c ****     pbuf_free(p);
 191:lwIP/src/core/ipv4/ip4_frag.c ****   }
 192:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* LWIP_ICMP */
 193:lwIP/src/core/ipv4/ip4_frag.c **** 
 194:lwIP/src/core/ipv4/ip4_frag.c ****   /* First, free all received pbufs.  The individual pbufs need to be released
ARM GAS  /tmp/ccHPvcAz.s 			page 5


 195:lwIP/src/core/ipv4/ip4_frag.c ****      separately as they have not yet been chained */
 196:lwIP/src/core/ipv4/ip4_frag.c ****   p = ipr->p;
 197:lwIP/src/core/ipv4/ip4_frag.c ****   while (p != NULL) {
 198:lwIP/src/core/ipv4/ip4_frag.c ****     struct pbuf *pcur;
 199:lwIP/src/core/ipv4/ip4_frag.c ****     iprh = (struct ip_reass_helper *)p->payload;
 200:lwIP/src/core/ipv4/ip4_frag.c ****     pcur = p;
 201:lwIP/src/core/ipv4/ip4_frag.c ****     /* get the next pointer before freeing */
 202:lwIP/src/core/ipv4/ip4_frag.c ****     p = iprh->next_pbuf;
 203:lwIP/src/core/ipv4/ip4_frag.c ****     clen = pbuf_clen(pcur);
 204:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 205:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 206:lwIP/src/core/ipv4/ip4_frag.c ****     pbuf_free(pcur);
 207:lwIP/src/core/ipv4/ip4_frag.c ****   }
 208:lwIP/src/core/ipv4/ip4_frag.c ****   /* Then, unchain the struct ip_reassdata from the list and free it. */
 209:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_dequeue_datagram(ipr, prev);
 210:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("ip_reass_pbufcount >= pbufs_freed", ip_reass_pbufcount >= pbufs_freed);
 211:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 212:lwIP/src/core/ipv4/ip4_frag.c **** 
 213:lwIP/src/core/ipv4/ip4_frag.c ****   return pbufs_freed;
 214:lwIP/src/core/ipv4/ip4_frag.c **** }
 215:lwIP/src/core/ipv4/ip4_frag.c **** 
 216:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_FREE_OLDEST
 217:lwIP/src/core/ipv4/ip4_frag.c **** /**
 218:lwIP/src/core/ipv4/ip4_frag.c ****  * Free the oldest datagram to make room for enqueueing new fragments.
 219:lwIP/src/core/ipv4/ip4_frag.c ****  * The datagram 'fraghdr' belongs to is not freed!
 220:lwIP/src/core/ipv4/ip4_frag.c ****  *
 221:lwIP/src/core/ipv4/ip4_frag.c ****  * @param fraghdr IP header of the current fragment
 222:lwIP/src/core/ipv4/ip4_frag.c ****  * @param pbufs_needed number of pbufs needed to enqueue
 223:lwIP/src/core/ipv4/ip4_frag.c ****  *        (used for freeing other datagrams if not enough space)
 224:lwIP/src/core/ipv4/ip4_frag.c ****  * @return the number of pbufs freed
 225:lwIP/src/core/ipv4/ip4_frag.c ****  */
 226:lwIP/src/core/ipv4/ip4_frag.c **** static int
 227:lwIP/src/core/ipv4/ip4_frag.c **** ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
 228:lwIP/src/core/ipv4/ip4_frag.c **** {
 229:lwIP/src/core/ipv4/ip4_frag.c ****   /* @todo Can't we simply remove the last datagram in the
 230:lwIP/src/core/ipv4/ip4_frag.c ****    *       linked list behind reassdatagrams?
 231:lwIP/src/core/ipv4/ip4_frag.c ****    */
 232:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reassdata *r, *oldest, *prev, *oldest_prev;
 233:lwIP/src/core/ipv4/ip4_frag.c ****   int pbufs_freed = 0, pbufs_freed_current;
 234:lwIP/src/core/ipv4/ip4_frag.c ****   int other_datagrams;
 235:lwIP/src/core/ipv4/ip4_frag.c **** 
 236:lwIP/src/core/ipv4/ip4_frag.c ****   /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
 237:lwIP/src/core/ipv4/ip4_frag.c ****    * but don't free the datagram that 'fraghdr' belongs to! */
 238:lwIP/src/core/ipv4/ip4_frag.c ****   do {
 239:lwIP/src/core/ipv4/ip4_frag.c ****     oldest = NULL;
 240:lwIP/src/core/ipv4/ip4_frag.c ****     prev = NULL;
 241:lwIP/src/core/ipv4/ip4_frag.c ****     oldest_prev = NULL;
 242:lwIP/src/core/ipv4/ip4_frag.c ****     other_datagrams = 0;
 243:lwIP/src/core/ipv4/ip4_frag.c ****     r = reassdatagrams;
 244:lwIP/src/core/ipv4/ip4_frag.c ****     while (r != NULL) {
 245:lwIP/src/core/ipv4/ip4_frag.c ****       if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 246:lwIP/src/core/ipv4/ip4_frag.c ****         /* Not the same datagram as fraghdr */
 247:lwIP/src/core/ipv4/ip4_frag.c ****         other_datagrams++;
 248:lwIP/src/core/ipv4/ip4_frag.c ****         if (oldest == NULL) {
 249:lwIP/src/core/ipv4/ip4_frag.c ****           oldest = r;
 250:lwIP/src/core/ipv4/ip4_frag.c ****           oldest_prev = prev;
 251:lwIP/src/core/ipv4/ip4_frag.c ****         } else if (r->timer <= oldest->timer) {
ARM GAS  /tmp/ccHPvcAz.s 			page 6


 252:lwIP/src/core/ipv4/ip4_frag.c ****           /* older than the previous oldest */
 253:lwIP/src/core/ipv4/ip4_frag.c ****           oldest = r;
 254:lwIP/src/core/ipv4/ip4_frag.c ****           oldest_prev = prev;
 255:lwIP/src/core/ipv4/ip4_frag.c ****         }
 256:lwIP/src/core/ipv4/ip4_frag.c ****       }
 257:lwIP/src/core/ipv4/ip4_frag.c ****       if (r->next != NULL) {
 258:lwIP/src/core/ipv4/ip4_frag.c ****         prev = r;
 259:lwIP/src/core/ipv4/ip4_frag.c ****       }
 260:lwIP/src/core/ipv4/ip4_frag.c ****       r = r->next;
 261:lwIP/src/core/ipv4/ip4_frag.c ****     }
 262:lwIP/src/core/ipv4/ip4_frag.c ****     if (oldest != NULL) {
 263:lwIP/src/core/ipv4/ip4_frag.c ****       pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
 264:lwIP/src/core/ipv4/ip4_frag.c ****       pbufs_freed += pbufs_freed_current;
 265:lwIP/src/core/ipv4/ip4_frag.c ****     }
 266:lwIP/src/core/ipv4/ip4_frag.c ****   } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 267:lwIP/src/core/ipv4/ip4_frag.c ****   return pbufs_freed;
 268:lwIP/src/core/ipv4/ip4_frag.c **** }
 269:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_FREE_OLDEST */
 270:lwIP/src/core/ipv4/ip4_frag.c **** 
 271:lwIP/src/core/ipv4/ip4_frag.c **** /**
 272:lwIP/src/core/ipv4/ip4_frag.c ****  * Enqueues a new fragment into the fragment queue
 273:lwIP/src/core/ipv4/ip4_frag.c ****  * @param fraghdr points to the new fragments IP hdr
 274:lwIP/src/core/ipv4/ip4_frag.c ****  * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough sp
 275:lwIP/src/core/ipv4/ip4_frag.c ****  * @return A pointer to the queue location into which the fragment was enqueued
 276:lwIP/src/core/ipv4/ip4_frag.c ****  */
 277:lwIP/src/core/ipv4/ip4_frag.c **** static struct ip_reassdata *
 278:lwIP/src/core/ipv4/ip4_frag.c **** ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
 279:lwIP/src/core/ipv4/ip4_frag.c **** {
 280:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reassdata *ipr;
 281:lwIP/src/core/ipv4/ip4_frag.c **** #if ! IP_REASS_FREE_OLDEST
 282:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_UNUSED_ARG(clen);
 283:lwIP/src/core/ipv4/ip4_frag.c **** #endif
 284:lwIP/src/core/ipv4/ip4_frag.c **** 
 285:lwIP/src/core/ipv4/ip4_frag.c ****   /* No matching previous fragment found, allocate a new reassdata struct */
 286:lwIP/src/core/ipv4/ip4_frag.c ****   ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 287:lwIP/src/core/ipv4/ip4_frag.c ****   if (ipr == NULL) {
 288:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_FREE_OLDEST
 289:lwIP/src/core/ipv4/ip4_frag.c ****     if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 290:lwIP/src/core/ipv4/ip4_frag.c ****       ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 291:lwIP/src/core/ipv4/ip4_frag.c ****     }
 292:lwIP/src/core/ipv4/ip4_frag.c ****     if (ipr == NULL)
 293:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_FREE_OLDEST */
 294:lwIP/src/core/ipv4/ip4_frag.c ****     {
 295:lwIP/src/core/ipv4/ip4_frag.c ****       IPFRAG_STATS_INC(ip_frag.memerr);
 296:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("Failed to alloc reassdata struct\n"));
 297:lwIP/src/core/ipv4/ip4_frag.c ****       return NULL;
 298:lwIP/src/core/ipv4/ip4_frag.c ****     }
 299:lwIP/src/core/ipv4/ip4_frag.c ****   }
 300:lwIP/src/core/ipv4/ip4_frag.c ****   memset(ipr, 0, sizeof(struct ip_reassdata));
 301:lwIP/src/core/ipv4/ip4_frag.c ****   ipr->timer = IP_REASS_MAXAGE;
 302:lwIP/src/core/ipv4/ip4_frag.c **** 
 303:lwIP/src/core/ipv4/ip4_frag.c ****   /* enqueue the new structure to the front of the list */
 304:lwIP/src/core/ipv4/ip4_frag.c ****   ipr->next = reassdatagrams;
 305:lwIP/src/core/ipv4/ip4_frag.c ****   reassdatagrams = ipr;
 306:lwIP/src/core/ipv4/ip4_frag.c ****   /* copy the ip header for later tests and input */
 307:lwIP/src/core/ipv4/ip4_frag.c ****   /* @todo: no ip options supported? */
 308:lwIP/src/core/ipv4/ip4_frag.c ****   SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
ARM GAS  /tmp/ccHPvcAz.s 			page 7


 309:lwIP/src/core/ipv4/ip4_frag.c ****   return ipr;
 310:lwIP/src/core/ipv4/ip4_frag.c **** }
 311:lwIP/src/core/ipv4/ip4_frag.c **** 
 312:lwIP/src/core/ipv4/ip4_frag.c **** /**
 313:lwIP/src/core/ipv4/ip4_frag.c ****  * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 314:lwIP/src/core/ipv4/ip4_frag.c ****  * @param ipr points to the queue entry to dequeue
 315:lwIP/src/core/ipv4/ip4_frag.c ****  */
 316:lwIP/src/core/ipv4/ip4_frag.c **** static void
 317:lwIP/src/core/ipv4/ip4_frag.c **** ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
 318:lwIP/src/core/ipv4/ip4_frag.c **** {
 319:lwIP/src/core/ipv4/ip4_frag.c ****   /* dequeue the reass struct  */
 320:lwIP/src/core/ipv4/ip4_frag.c ****   if (reassdatagrams == ipr) {
 321:lwIP/src/core/ipv4/ip4_frag.c ****     /* it was the first in the list */
 322:lwIP/src/core/ipv4/ip4_frag.c ****     reassdatagrams = ipr->next;
 323:lwIP/src/core/ipv4/ip4_frag.c ****   } else {
 324:lwIP/src/core/ipv4/ip4_frag.c ****     /* it wasn't the first, so it must have a valid 'prev' */
 325:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("sanity check linked list", prev != NULL);
 326:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 327:lwIP/src/core/ipv4/ip4_frag.c ****   }
 328:lwIP/src/core/ipv4/ip4_frag.c **** 
 329:lwIP/src/core/ipv4/ip4_frag.c ****   /* now we can free the ip_reassdata struct */
 330:lwIP/src/core/ipv4/ip4_frag.c ****   memp_free(MEMP_REASSDATA, ipr);
 331:lwIP/src/core/ipv4/ip4_frag.c **** }
 332:lwIP/src/core/ipv4/ip4_frag.c **** 
 333:lwIP/src/core/ipv4/ip4_frag.c **** /**
 334:lwIP/src/core/ipv4/ip4_frag.c ****  * Chain a new pbuf into the pbuf list that composes the datagram.  The pbuf list
 335:lwIP/src/core/ipv4/ip4_frag.c ****  * will grow over time as  new pbufs are rx.
 336:lwIP/src/core/ipv4/ip4_frag.c ****  * Also checks that the datagram passes basic continuity checks (if the last
 337:lwIP/src/core/ipv4/ip4_frag.c ****  * fragment was received at least once).
 338:lwIP/src/core/ipv4/ip4_frag.c ****  * @param ipr points to the reassembly state
 339:lwIP/src/core/ipv4/ip4_frag.c ****  * @param new_p points to the pbuf for the current fragment
 340:lwIP/src/core/ipv4/ip4_frag.c ****  * @param is_last is 1 if this pbuf has MF==0 (ipr->flags not updated yet)
 341:lwIP/src/core/ipv4/ip4_frag.c ****  * @return see IP_REASS_VALIDATE_* defines
 342:lwIP/src/core/ipv4/ip4_frag.c ****  */
 343:lwIP/src/core/ipv4/ip4_frag.c **** static int
 344:lwIP/src/core/ipv4/ip4_frag.c **** ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p, int is
 345:lwIP/src/core/ipv4/ip4_frag.c **** {
 346:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev = NULL;
 347:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *q;
 348:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t offset, len;
 349:lwIP/src/core/ipv4/ip4_frag.c ****   u8_t hlen;
 350:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_hdr *fraghdr;
 351:lwIP/src/core/ipv4/ip4_frag.c ****   int valid = 1;
 352:lwIP/src/core/ipv4/ip4_frag.c **** 
 353:lwIP/src/core/ipv4/ip4_frag.c ****   /* Extract length and fragment offset from current fragment */
 354:lwIP/src/core/ipv4/ip4_frag.c ****   fraghdr = (struct ip_hdr *)new_p->payload;
 355:lwIP/src/core/ipv4/ip4_frag.c ****   len = lwip_ntohs(IPH_LEN(fraghdr));
 356:lwIP/src/core/ipv4/ip4_frag.c ****   hlen = IPH_HL_BYTES(fraghdr);
 357:lwIP/src/core/ipv4/ip4_frag.c ****   if (hlen > len) {
 358:lwIP/src/core/ipv4/ip4_frag.c ****     /* invalid datagram */
 359:lwIP/src/core/ipv4/ip4_frag.c ****     return IP_REASS_VALIDATE_PBUF_DROPPED;
 360:lwIP/src/core/ipv4/ip4_frag.c ****   }
 361:lwIP/src/core/ipv4/ip4_frag.c ****   len = (u16_t)(len - hlen);
 362:lwIP/src/core/ipv4/ip4_frag.c ****   offset = IPH_OFFSET_BYTES(fraghdr);
 363:lwIP/src/core/ipv4/ip4_frag.c **** 
 364:lwIP/src/core/ipv4/ip4_frag.c ****   /* overwrite the fragment's ip header from the pbuf with our helper struct,
 365:lwIP/src/core/ipv4/ip4_frag.c ****    * and setup the embedded helper structure. */
ARM GAS  /tmp/ccHPvcAz.s 			page 8


 366:lwIP/src/core/ipv4/ip4_frag.c ****   /* make sure the struct ip_reass_helper fits into the IP header */
 367:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
 368:lwIP/src/core/ipv4/ip4_frag.c ****               sizeof(struct ip_reass_helper) <= IP_HLEN);
 369:lwIP/src/core/ipv4/ip4_frag.c ****   iprh = (struct ip_reass_helper *)new_p->payload;
 370:lwIP/src/core/ipv4/ip4_frag.c ****   iprh->next_pbuf = NULL;
 371:lwIP/src/core/ipv4/ip4_frag.c ****   iprh->start = offset;
 372:lwIP/src/core/ipv4/ip4_frag.c ****   iprh->end = (u16_t)(offset + len);
 373:lwIP/src/core/ipv4/ip4_frag.c ****   if (iprh->end < offset) {
 374:lwIP/src/core/ipv4/ip4_frag.c ****     /* u16_t overflow, cannot handle this */
 375:lwIP/src/core/ipv4/ip4_frag.c ****     return IP_REASS_VALIDATE_PBUF_DROPPED;
 376:lwIP/src/core/ipv4/ip4_frag.c ****   }
 377:lwIP/src/core/ipv4/ip4_frag.c **** 
 378:lwIP/src/core/ipv4/ip4_frag.c ****   /* Iterate through until we either get to the end of the list (append),
 379:lwIP/src/core/ipv4/ip4_frag.c ****    * or we find one with a larger offset (insert). */
 380:lwIP/src/core/ipv4/ip4_frag.c ****   for (q = ipr->p; q != NULL;) {
 381:lwIP/src/core/ipv4/ip4_frag.c ****     iprh_tmp = (struct ip_reass_helper *)q->payload;
 382:lwIP/src/core/ipv4/ip4_frag.c ****     if (iprh->start < iprh_tmp->start) {
 383:lwIP/src/core/ipv4/ip4_frag.c ****       /* the new pbuf should be inserted before this */
 384:lwIP/src/core/ipv4/ip4_frag.c ****       iprh->next_pbuf = q;
 385:lwIP/src/core/ipv4/ip4_frag.c ****       if (iprh_prev != NULL) {
 386:lwIP/src/core/ipv4/ip4_frag.c ****         /* not the fragment with the lowest offset */
 387:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_CHECK_OVERLAP
 388:lwIP/src/core/ipv4/ip4_frag.c ****         if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 389:lwIP/src/core/ipv4/ip4_frag.c ****           /* fragment overlaps with previous or following, throw away */
 390:lwIP/src/core/ipv4/ip4_frag.c ****           return IP_REASS_VALIDATE_PBUF_DROPPED;
 391:lwIP/src/core/ipv4/ip4_frag.c ****         }
 392:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_CHECK_OVERLAP */
 393:lwIP/src/core/ipv4/ip4_frag.c ****         iprh_prev->next_pbuf = new_p;
 394:lwIP/src/core/ipv4/ip4_frag.c ****         if (iprh_prev->end != iprh->start) {
 395:lwIP/src/core/ipv4/ip4_frag.c ****           /* There is a fragment missing between the current
 396:lwIP/src/core/ipv4/ip4_frag.c ****            * and the previous fragment */
 397:lwIP/src/core/ipv4/ip4_frag.c ****           valid = 0;
 398:lwIP/src/core/ipv4/ip4_frag.c ****         }
 399:lwIP/src/core/ipv4/ip4_frag.c ****       } else {
 400:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_CHECK_OVERLAP
 401:lwIP/src/core/ipv4/ip4_frag.c ****         if (iprh->end > iprh_tmp->start) {
 402:lwIP/src/core/ipv4/ip4_frag.c ****           /* fragment overlaps with following, throw away */
 403:lwIP/src/core/ipv4/ip4_frag.c ****           return IP_REASS_VALIDATE_PBUF_DROPPED;
 404:lwIP/src/core/ipv4/ip4_frag.c ****         }
 405:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_CHECK_OVERLAP */
 406:lwIP/src/core/ipv4/ip4_frag.c ****         /* fragment with the lowest offset */
 407:lwIP/src/core/ipv4/ip4_frag.c ****         ipr->p = new_p;
 408:lwIP/src/core/ipv4/ip4_frag.c ****       }
 409:lwIP/src/core/ipv4/ip4_frag.c ****       break;
 410:lwIP/src/core/ipv4/ip4_frag.c ****     } else if (iprh->start == iprh_tmp->start) {
 411:lwIP/src/core/ipv4/ip4_frag.c ****       /* received the same datagram twice: no need to keep the datagram */
 412:lwIP/src/core/ipv4/ip4_frag.c ****       return IP_REASS_VALIDATE_PBUF_DROPPED;
 413:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_CHECK_OVERLAP
 414:lwIP/src/core/ipv4/ip4_frag.c ****     } else if (iprh->start < iprh_tmp->end) {
 415:lwIP/src/core/ipv4/ip4_frag.c ****       /* overlap: no need to keep the new datagram */
 416:lwIP/src/core/ipv4/ip4_frag.c ****       return IP_REASS_VALIDATE_PBUF_DROPPED;
 417:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_CHECK_OVERLAP */
 418:lwIP/src/core/ipv4/ip4_frag.c ****     } else {
 419:lwIP/src/core/ipv4/ip4_frag.c ****       /* Check if the fragments received so far have no holes. */
 420:lwIP/src/core/ipv4/ip4_frag.c ****       if (iprh_prev != NULL) {
 421:lwIP/src/core/ipv4/ip4_frag.c ****         if (iprh_prev->end != iprh_tmp->start) {
 422:lwIP/src/core/ipv4/ip4_frag.c ****           /* There is a fragment missing between the current
ARM GAS  /tmp/ccHPvcAz.s 			page 9


 423:lwIP/src/core/ipv4/ip4_frag.c ****            * and the previous fragment */
 424:lwIP/src/core/ipv4/ip4_frag.c ****           valid = 0;
 425:lwIP/src/core/ipv4/ip4_frag.c ****         }
 426:lwIP/src/core/ipv4/ip4_frag.c ****       }
 427:lwIP/src/core/ipv4/ip4_frag.c ****     }
 428:lwIP/src/core/ipv4/ip4_frag.c ****     q = iprh_tmp->next_pbuf;
 429:lwIP/src/core/ipv4/ip4_frag.c ****     iprh_prev = iprh_tmp;
 430:lwIP/src/core/ipv4/ip4_frag.c ****   }
 431:lwIP/src/core/ipv4/ip4_frag.c **** 
 432:lwIP/src/core/ipv4/ip4_frag.c ****   /* If q is NULL, then we made it to the end of the list. Determine what to do now */
 433:lwIP/src/core/ipv4/ip4_frag.c ****   if (q == NULL) {
 434:lwIP/src/core/ipv4/ip4_frag.c ****     if (iprh_prev != NULL) {
 435:lwIP/src/core/ipv4/ip4_frag.c ****       /* this is (for now), the fragment with the highest offset:
 436:lwIP/src/core/ipv4/ip4_frag.c ****        * chain it to the last fragment */
 437:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_CHECK_OVERLAP
 438:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 439:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_CHECK_OVERLAP */
 440:lwIP/src/core/ipv4/ip4_frag.c ****       iprh_prev->next_pbuf = new_p;
 441:lwIP/src/core/ipv4/ip4_frag.c ****       if (iprh_prev->end != iprh->start) {
 442:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 443:lwIP/src/core/ipv4/ip4_frag.c ****       }
 444:lwIP/src/core/ipv4/ip4_frag.c ****     } else {
 445:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_CHECK_OVERLAP
 446:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_ASSERT("no previous fragment, this must be the first fragment!",
 447:lwIP/src/core/ipv4/ip4_frag.c ****                   ipr->p == NULL);
 448:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_CHECK_OVERLAP */
 449:lwIP/src/core/ipv4/ip4_frag.c ****       /* this is the first fragment we ever received for this ip datagram */
 450:lwIP/src/core/ipv4/ip4_frag.c ****       ipr->p = new_p;
 451:lwIP/src/core/ipv4/ip4_frag.c ****     }
 452:lwIP/src/core/ipv4/ip4_frag.c ****   }
 453:lwIP/src/core/ipv4/ip4_frag.c **** 
 454:lwIP/src/core/ipv4/ip4_frag.c ****   /* At this point, the validation part begins: */
 455:lwIP/src/core/ipv4/ip4_frag.c ****   /* If we already received the last fragment */
 456:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
 457:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 458:lwIP/src/core/ipv4/ip4_frag.c ****     if (valid) {
 459:lwIP/src/core/ipv4/ip4_frag.c ****       /* then check if the rest of the fragments is here */
 460:lwIP/src/core/ipv4/ip4_frag.c ****       /* Check if the queue starts with the first datagram */
 461:lwIP/src/core/ipv4/ip4_frag.c ****       if ((ipr->p == NULL) || (((struct ip_reass_helper *)ipr->p->payload)->start != 0)) {
 462:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 463:lwIP/src/core/ipv4/ip4_frag.c ****       } else {
 464:lwIP/src/core/ipv4/ip4_frag.c ****         /* and check that there are no holes after this datagram */
 465:lwIP/src/core/ipv4/ip4_frag.c ****         iprh_prev = iprh;
 466:lwIP/src/core/ipv4/ip4_frag.c ****         q = iprh->next_pbuf;
 467:lwIP/src/core/ipv4/ip4_frag.c ****         while (q != NULL) {
 468:lwIP/src/core/ipv4/ip4_frag.c ****           iprh = (struct ip_reass_helper *)q->payload;
 469:lwIP/src/core/ipv4/ip4_frag.c ****           if (iprh_prev->end != iprh->start) {
 470:lwIP/src/core/ipv4/ip4_frag.c ****             valid = 0;
 471:lwIP/src/core/ipv4/ip4_frag.c ****             break;
 472:lwIP/src/core/ipv4/ip4_frag.c ****           }
 473:lwIP/src/core/ipv4/ip4_frag.c ****           iprh_prev = iprh;
 474:lwIP/src/core/ipv4/ip4_frag.c ****           q = iprh->next_pbuf;
 475:lwIP/src/core/ipv4/ip4_frag.c ****         }
 476:lwIP/src/core/ipv4/ip4_frag.c ****         /* if still valid, all fragments are received
 477:lwIP/src/core/ipv4/ip4_frag.c ****          * (because to the MF==0 already arrived */
 478:lwIP/src/core/ipv4/ip4_frag.c ****         if (valid) {
 479:lwIP/src/core/ipv4/ip4_frag.c ****           LWIP_ASSERT("sanity check", ipr->p != NULL);
ARM GAS  /tmp/ccHPvcAz.s 			page 10


 480:lwIP/src/core/ipv4/ip4_frag.c ****           LWIP_ASSERT("sanity check",
 481:lwIP/src/core/ipv4/ip4_frag.c ****                       ((struct ip_reass_helper *)ipr->p->payload) != iprh);
 482:lwIP/src/core/ipv4/ip4_frag.c ****           LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
 483:lwIP/src/core/ipv4/ip4_frag.c ****                       iprh->next_pbuf == NULL);
 484:lwIP/src/core/ipv4/ip4_frag.c ****         }
 485:lwIP/src/core/ipv4/ip4_frag.c ****       }
 486:lwIP/src/core/ipv4/ip4_frag.c ****     }
 487:lwIP/src/core/ipv4/ip4_frag.c ****     /* If valid is 0 here, there are some fragments missing in the middle
 488:lwIP/src/core/ipv4/ip4_frag.c ****      * (since MF == 0 has already arrived). Such datagrams simply time out if
 489:lwIP/src/core/ipv4/ip4_frag.c ****      * no more fragments are received... */
 490:lwIP/src/core/ipv4/ip4_frag.c ****     return valid ? IP_REASS_VALIDATE_TELEGRAM_FINISHED : IP_REASS_VALIDATE_PBUF_QUEUED;
 491:lwIP/src/core/ipv4/ip4_frag.c ****   }
 492:lwIP/src/core/ipv4/ip4_frag.c ****   /* If we come here, not all fragments were received, yet! */
 493:lwIP/src/core/ipv4/ip4_frag.c ****   return IP_REASS_VALIDATE_PBUF_QUEUED; /* not yet valid! */
 494:lwIP/src/core/ipv4/ip4_frag.c **** }
 495:lwIP/src/core/ipv4/ip4_frag.c **** 
 496:lwIP/src/core/ipv4/ip4_frag.c **** /**
 497:lwIP/src/core/ipv4/ip4_frag.c ****  * Reassembles incoming IP fragments into an IP datagram.
 498:lwIP/src/core/ipv4/ip4_frag.c ****  *
 499:lwIP/src/core/ipv4/ip4_frag.c ****  * @param p points to a pbuf chain of the fragment
 500:lwIP/src/core/ipv4/ip4_frag.c ****  * @return NULL if reassembly is incomplete, ? otherwise
 501:lwIP/src/core/ipv4/ip4_frag.c ****  */
 502:lwIP/src/core/ipv4/ip4_frag.c **** struct pbuf *
 503:lwIP/src/core/ipv4/ip4_frag.c **** ip4_reass(struct pbuf *p)
 504:lwIP/src/core/ipv4/ip4_frag.c **** {
 505:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *r;
 506:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_hdr *fraghdr;
 507:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reassdata *ipr;
 508:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reass_helper *iprh;
 509:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t offset, len, clen;
 510:lwIP/src/core/ipv4/ip4_frag.c ****   u8_t hlen;
 511:lwIP/src/core/ipv4/ip4_frag.c ****   int valid;
 512:lwIP/src/core/ipv4/ip4_frag.c ****   int is_last;
 513:lwIP/src/core/ipv4/ip4_frag.c **** 
 514:lwIP/src/core/ipv4/ip4_frag.c ****   IPFRAG_STATS_INC(ip_frag.recv);
 515:lwIP/src/core/ipv4/ip4_frag.c ****   MIB2_STATS_INC(mib2.ipreasmreqds);
 516:lwIP/src/core/ipv4/ip4_frag.c **** 
 517:lwIP/src/core/ipv4/ip4_frag.c ****   fraghdr = (struct ip_hdr *)p->payload;
 518:lwIP/src/core/ipv4/ip4_frag.c **** 
 519:lwIP/src/core/ipv4/ip4_frag.c ****   if (IPH_HL_BYTES(fraghdr) != IP_HLEN) {
 520:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: IP options currently not supported!\n"));
 521:lwIP/src/core/ipv4/ip4_frag.c ****     IPFRAG_STATS_INC(ip_frag.err);
 522:lwIP/src/core/ipv4/ip4_frag.c ****     goto nullreturn;
 523:lwIP/src/core/ipv4/ip4_frag.c ****   }
 524:lwIP/src/core/ipv4/ip4_frag.c **** 
 525:lwIP/src/core/ipv4/ip4_frag.c ****   offset = IPH_OFFSET_BYTES(fraghdr);
 526:lwIP/src/core/ipv4/ip4_frag.c ****   len = lwip_ntohs(IPH_LEN(fraghdr));
 527:lwIP/src/core/ipv4/ip4_frag.c ****   hlen = IPH_HL_BYTES(fraghdr);
 528:lwIP/src/core/ipv4/ip4_frag.c ****   if (hlen > len) {
 529:lwIP/src/core/ipv4/ip4_frag.c ****     /* invalid datagram */
 530:lwIP/src/core/ipv4/ip4_frag.c ****     goto nullreturn;
 531:lwIP/src/core/ipv4/ip4_frag.c ****   }
 532:lwIP/src/core/ipv4/ip4_frag.c ****   len = (u16_t)(len - hlen);
 533:lwIP/src/core/ipv4/ip4_frag.c **** 
 534:lwIP/src/core/ipv4/ip4_frag.c ****   /* Check if we are allowed to enqueue more datagrams. */
 535:lwIP/src/core/ipv4/ip4_frag.c ****   clen = pbuf_clen(p);
 536:lwIP/src/core/ipv4/ip4_frag.c ****   if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
ARM GAS  /tmp/ccHPvcAz.s 			page 11


 537:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_FREE_OLDEST
 538:lwIP/src/core/ipv4/ip4_frag.c ****     if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 539:lwIP/src/core/ipv4/ip4_frag.c ****         ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 540:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_FREE_OLDEST */
 541:lwIP/src/core/ipv4/ip4_frag.c ****     {
 542:lwIP/src/core/ipv4/ip4_frag.c ****       /* No datagram could be freed and still too many pbufs enqueued */
 543:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
 544:lwIP/src/core/ipv4/ip4_frag.c ****                                    ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
 545:lwIP/src/core/ipv4/ip4_frag.c ****       IPFRAG_STATS_INC(ip_frag.memerr);
 546:lwIP/src/core/ipv4/ip4_frag.c ****       /* @todo: send ICMP time exceeded here? */
 547:lwIP/src/core/ipv4/ip4_frag.c ****       /* drop this pbuf */
 548:lwIP/src/core/ipv4/ip4_frag.c ****       goto nullreturn;
 549:lwIP/src/core/ipv4/ip4_frag.c ****     }
 550:lwIP/src/core/ipv4/ip4_frag.c ****   }
 551:lwIP/src/core/ipv4/ip4_frag.c **** 
 552:lwIP/src/core/ipv4/ip4_frag.c ****   /* Look for the datagram the fragment belongs to in the current datagram queue,
 553:lwIP/src/core/ipv4/ip4_frag.c ****    * remembering the previous in the queue for later dequeueing. */
 554:lwIP/src/core/ipv4/ip4_frag.c ****   for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 555:lwIP/src/core/ipv4/ip4_frag.c ****     /* Check if the incoming fragment matches the one currently present
 556:lwIP/src/core/ipv4/ip4_frag.c ****        in the reassembly buffer. If so, we proceed with copying the
 557:lwIP/src/core/ipv4/ip4_frag.c ****        fragment into the buffer. */
 558:lwIP/src/core/ipv4/ip4_frag.c ****     if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 559:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: matching previous fragment ID=%"X16_F"\n",
 560:lwIP/src/core/ipv4/ip4_frag.c ****                                    lwip_ntohs(IPH_ID(fraghdr))));
 561:lwIP/src/core/ipv4/ip4_frag.c ****       IPFRAG_STATS_INC(ip_frag.cachehit);
 562:lwIP/src/core/ipv4/ip4_frag.c ****       break;
 563:lwIP/src/core/ipv4/ip4_frag.c ****     }
 564:lwIP/src/core/ipv4/ip4_frag.c ****   }
 565:lwIP/src/core/ipv4/ip4_frag.c **** 
 566:lwIP/src/core/ipv4/ip4_frag.c ****   if (ipr == NULL) {
 567:lwIP/src/core/ipv4/ip4_frag.c ****     /* Enqueue a new datagram into the datagram queue */
 568:lwIP/src/core/ipv4/ip4_frag.c ****     ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 569:lwIP/src/core/ipv4/ip4_frag.c ****     /* Bail if unable to enqueue */
 570:lwIP/src/core/ipv4/ip4_frag.c ****     if (ipr == NULL) {
 571:lwIP/src/core/ipv4/ip4_frag.c ****       goto nullreturn;
 572:lwIP/src/core/ipv4/ip4_frag.c ****     }
 573:lwIP/src/core/ipv4/ip4_frag.c ****   } else {
 574:lwIP/src/core/ipv4/ip4_frag.c ****     if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 575:lwIP/src/core/ipv4/ip4_frag.c ****         ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 576:lwIP/src/core/ipv4/ip4_frag.c ****       /* ipr->iphdr is not the header from the first fragment, but fraghdr is
 577:lwIP/src/core/ipv4/ip4_frag.c ****        * -> copy fraghdr into ipr->iphdr since we want to have the header
 578:lwIP/src/core/ipv4/ip4_frag.c ****        * of the first fragment (for ICMP time exceeded and later, for copying
 579:lwIP/src/core/ipv4/ip4_frag.c ****        * all options, if supported)*/
 580:lwIP/src/core/ipv4/ip4_frag.c ****       SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 581:lwIP/src/core/ipv4/ip4_frag.c ****     }
 582:lwIP/src/core/ipv4/ip4_frag.c ****   }
 583:lwIP/src/core/ipv4/ip4_frag.c **** 
 584:lwIP/src/core/ipv4/ip4_frag.c ****   /* At this point, we have either created a new entry or pointing
 585:lwIP/src/core/ipv4/ip4_frag.c ****    * to an existing one */
 586:lwIP/src/core/ipv4/ip4_frag.c **** 
 587:lwIP/src/core/ipv4/ip4_frag.c ****   /* check for 'no more fragments', and update queue entry*/
 588:lwIP/src/core/ipv4/ip4_frag.c ****   is_last = (IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0;
 589:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 590:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 591:lwIP/src/core/ipv4/ip4_frag.c ****     if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
 592:lwIP/src/core/ipv4/ip4_frag.c ****       /* u16_t overflow, cannot handle this */
 593:lwIP/src/core/ipv4/ip4_frag.c ****       goto nullreturn_ipr;
ARM GAS  /tmp/ccHPvcAz.s 			page 12


 594:lwIP/src/core/ipv4/ip4_frag.c ****     }
 595:lwIP/src/core/ipv4/ip4_frag.c ****   }
 596:lwIP/src/core/ipv4/ip4_frag.c ****   /* find the right place to insert this pbuf */
 597:lwIP/src/core/ipv4/ip4_frag.c ****   /* @todo: trim pbufs if fragments are overlapping */
 598:lwIP/src/core/ipv4/ip4_frag.c ****   valid = ip_reass_chain_frag_into_datagram_and_validate(ipr, p, is_last);
 599:lwIP/src/core/ipv4/ip4_frag.c ****   if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
 600:lwIP/src/core/ipv4/ip4_frag.c ****     goto nullreturn_ipr;
 601:lwIP/src/core/ipv4/ip4_frag.c ****   }
 602:lwIP/src/core/ipv4/ip4_frag.c ****   /* if we come here, the pbuf has been enqueued */
 603:lwIP/src/core/ipv4/ip4_frag.c **** 
 604:lwIP/src/core/ipv4/ip4_frag.c ****   /* Track the current number of pbufs current 'in-flight', in order to limit
 605:lwIP/src/core/ipv4/ip4_frag.c ****      the number of fragments that may be enqueued at any one time
 606:lwIP/src/core/ipv4/ip4_frag.c ****      (overflow checked by testing against IP_REASS_MAX_PBUFS) */
 607:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount + clen);
 608:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 609:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 610:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->datagram_len = datagram_len;
 611:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 612:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG,
 613:lwIP/src/core/ipv4/ip4_frag.c ****                 ("ip4_reass: last fragment seen, total len %"S16_F"\n",
 614:lwIP/src/core/ipv4/ip4_frag.c ****                  ipr->datagram_len));
 615:lwIP/src/core/ipv4/ip4_frag.c ****   }
 616:lwIP/src/core/ipv4/ip4_frag.c **** 
 617:lwIP/src/core/ipv4/ip4_frag.c ****   if (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) {
 618:lwIP/src/core/ipv4/ip4_frag.c ****     struct ip_reassdata *ipr_prev;
 619:lwIP/src/core/ipv4/ip4_frag.c ****     /* the totally last fragment (flag more fragments = 0) was received at least
 620:lwIP/src/core/ipv4/ip4_frag.c ****      * once AND all fragments are received */
 621:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(ipr->datagram_len + IP_HLEN);
 622:lwIP/src/core/ipv4/ip4_frag.c **** 
 623:lwIP/src/core/ipv4/ip4_frag.c ****     /* save the second pbuf before copying the header over the pointer */
 624:lwIP/src/core/ipv4/ip4_frag.c ****     r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
 625:lwIP/src/core/ipv4/ip4_frag.c **** 
 626:lwIP/src/core/ipv4/ip4_frag.c ****     /* copy the original ip header back to the first pbuf */
 627:lwIP/src/core/ipv4/ip4_frag.c ****     fraghdr = (struct ip_hdr *)(ipr->p->payload);
 628:lwIP/src/core/ipv4/ip4_frag.c ****     SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 629:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
 630:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_OFFSET_SET(fraghdr, 0);
 631:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_CHKSUM_SET(fraghdr, 0);
 632:lwIP/src/core/ipv4/ip4_frag.c ****     /* @todo: do we need to set/calculate the correct checksum? */
 633:lwIP/src/core/ipv4/ip4_frag.c **** #if CHECKSUM_GEN_IP
 634:lwIP/src/core/ipv4/ip4_frag.c ****     IF__NETIF_CHECKSUM_ENABLED(ip_current_input_netif(), NETIF_CHECKSUM_GEN_IP) {
 635:lwIP/src/core/ipv4/ip4_frag.c ****       IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 636:lwIP/src/core/ipv4/ip4_frag.c ****     }
 637:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* CHECKSUM_GEN_IP */
 638:lwIP/src/core/ipv4/ip4_frag.c **** 
 639:lwIP/src/core/ipv4/ip4_frag.c ****     p = ipr->p;
 640:lwIP/src/core/ipv4/ip4_frag.c **** 
 641:lwIP/src/core/ipv4/ip4_frag.c ****     /* chain together the pbufs contained within the reass_data list. */
 642:lwIP/src/core/ipv4/ip4_frag.c ****     while (r != NULL) {
 643:lwIP/src/core/ipv4/ip4_frag.c ****       iprh = (struct ip_reass_helper *)r->payload;
 644:lwIP/src/core/ipv4/ip4_frag.c **** 
 645:lwIP/src/core/ipv4/ip4_frag.c ****       /* hide the ip header for every succeeding fragment */
 646:lwIP/src/core/ipv4/ip4_frag.c ****       pbuf_remove_header(r, IP_HLEN);
 647:lwIP/src/core/ipv4/ip4_frag.c ****       pbuf_cat(p, r);
 648:lwIP/src/core/ipv4/ip4_frag.c ****       r = iprh->next_pbuf;
 649:lwIP/src/core/ipv4/ip4_frag.c ****     }
 650:lwIP/src/core/ipv4/ip4_frag.c **** 
ARM GAS  /tmp/ccHPvcAz.s 			page 13


 651:lwIP/src/core/ipv4/ip4_frag.c ****     /* find the previous entry in the linked list */
 652:lwIP/src/core/ipv4/ip4_frag.c ****     if (ipr == reassdatagrams) {
 653:lwIP/src/core/ipv4/ip4_frag.c ****       ipr_prev = NULL;
 654:lwIP/src/core/ipv4/ip4_frag.c ****     } else {
 655:lwIP/src/core/ipv4/ip4_frag.c ****       for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 656:lwIP/src/core/ipv4/ip4_frag.c ****         if (ipr_prev->next == ipr) {
 657:lwIP/src/core/ipv4/ip4_frag.c ****           break;
 658:lwIP/src/core/ipv4/ip4_frag.c ****         }
 659:lwIP/src/core/ipv4/ip4_frag.c ****       }
 660:lwIP/src/core/ipv4/ip4_frag.c ****     }
 661:lwIP/src/core/ipv4/ip4_frag.c **** 
 662:lwIP/src/core/ipv4/ip4_frag.c ****     /* release the sources allocate for the fragment queue entry */
 663:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, ipr_prev);
 664:lwIP/src/core/ipv4/ip4_frag.c **** 
 665:lwIP/src/core/ipv4/ip4_frag.c ****     /* and adjust the number of pbufs currently queued for reassembly. */
 666:lwIP/src/core/ipv4/ip4_frag.c ****     clen = pbuf_clen(p);
 667:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= clen);
 668:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 669:lwIP/src/core/ipv4/ip4_frag.c **** 
 670:lwIP/src/core/ipv4/ip4_frag.c ****     MIB2_STATS_INC(mib2.ipreasmoks);
 671:lwIP/src/core/ipv4/ip4_frag.c **** 
 672:lwIP/src/core/ipv4/ip4_frag.c ****     /* Return the pbuf chain */
 673:lwIP/src/core/ipv4/ip4_frag.c ****     return p;
 674:lwIP/src/core/ipv4/ip4_frag.c ****   }
 675:lwIP/src/core/ipv4/ip4_frag.c ****   /* the datagram is not (yet?) reassembled completely */
 676:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
 677:lwIP/src/core/ipv4/ip4_frag.c ****   return NULL;
 678:lwIP/src/core/ipv4/ip4_frag.c **** 
 679:lwIP/src/core/ipv4/ip4_frag.c **** nullreturn_ipr:
 680:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("ipr != NULL", ipr != NULL);
 681:lwIP/src/core/ipv4/ip4_frag.c ****   if (ipr->p == NULL) {
 682:lwIP/src/core/ipv4/ip4_frag.c ****     /* dropped pbuf after creating a new datagram entry: remove the entry, too */
 683:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("not firstalthough just enqueued", ipr == reassdatagrams);
 684:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, NULL);
 685:lwIP/src/core/ipv4/ip4_frag.c ****   }
 686:lwIP/src/core/ipv4/ip4_frag.c **** 
 687:lwIP/src/core/ipv4/ip4_frag.c **** nullreturn:
 688:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: nullreturn\n"));
 689:lwIP/src/core/ipv4/ip4_frag.c ****   IPFRAG_STATS_INC(ip_frag.drop);
 690:lwIP/src/core/ipv4/ip4_frag.c ****   pbuf_free(p);
 691:lwIP/src/core/ipv4/ip4_frag.c ****   return NULL;
 692:lwIP/src/core/ipv4/ip4_frag.c **** }
 693:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASSEMBLY */
 694:lwIP/src/core/ipv4/ip4_frag.c **** 
 695:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_FRAG
 696:lwIP/src/core/ipv4/ip4_frag.c **** #if !LWIP_NETIF_TX_SINGLE_PBUF
 697:lwIP/src/core/ipv4/ip4_frag.c **** /** Allocate a new struct pbuf_custom_ref */
 698:lwIP/src/core/ipv4/ip4_frag.c **** static struct pbuf_custom_ref *
 699:lwIP/src/core/ipv4/ip4_frag.c **** ip_frag_alloc_pbuf_custom_ref(void)
 700:lwIP/src/core/ipv4/ip4_frag.c **** {
 701:lwIP/src/core/ipv4/ip4_frag.c ****   return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
 702:lwIP/src/core/ipv4/ip4_frag.c **** }
 703:lwIP/src/core/ipv4/ip4_frag.c **** 
 704:lwIP/src/core/ipv4/ip4_frag.c **** /** Free a struct pbuf_custom_ref */
 705:lwIP/src/core/ipv4/ip4_frag.c **** static void
 706:lwIP/src/core/ipv4/ip4_frag.c **** ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref *p)
 707:lwIP/src/core/ipv4/ip4_frag.c **** {
ARM GAS  /tmp/ccHPvcAz.s 			page 14


 708:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("p != NULL", p != NULL);
 709:lwIP/src/core/ipv4/ip4_frag.c ****   memp_free(MEMP_FRAG_PBUF, p);
 710:lwIP/src/core/ipv4/ip4_frag.c **** }
 711:lwIP/src/core/ipv4/ip4_frag.c **** 
 712:lwIP/src/core/ipv4/ip4_frag.c **** /** Free-callback function to free a 'struct pbuf_custom_ref', called by
 713:lwIP/src/core/ipv4/ip4_frag.c ****  * pbuf_free. */
 714:lwIP/src/core/ipv4/ip4_frag.c **** static void
 715:lwIP/src/core/ipv4/ip4_frag.c **** ipfrag_free_pbuf_custom(struct pbuf *p)
 716:lwIP/src/core/ipv4/ip4_frag.c **** {
  34              		.loc 1 716 1 view -0
  35              		.cfi_startproc
  36              		@ args = 0, pretend = 0, frame = 0
  37              		@ frame_needed = 0, uses_anonymous_args = 0
 717:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
  38              		.loc 1 717 3 view .LVU1
 718:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("pcr != NULL", pcr != NULL);
  39              		.loc 1 718 3 view .LVU2
  40              		.loc 1 718 3 view .LVU3
 716:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
  41              		.loc 1 716 1 is_stmt 0 view .LVU4
  42 0000 10B5     		push	{r4, lr}
  43              	.LCFI0:
  44              		.cfi_def_cfa_offset 8
  45              		.cfi_offset 4, -8
  46              		.cfi_offset 14, -4
  47              		.loc 1 718 3 view .LVU5
  48 0002 50B1     		cbz	r0, .L10
  49              		.loc 1 718 3 is_stmt 1 discriminator 2 view .LVU6
 719:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
  50              		.loc 1 719 3 discriminator 2 view .LVU7
  51              		.loc 1 719 3 discriminator 2 view .LVU8
  52              		.loc 1 719 3 discriminator 2 view .LVU9
 720:lwIP/src/core/ipv4/ip4_frag.c ****   if (pcr->original != NULL) {
  53              		.loc 1 720 3 discriminator 2 view .LVU10
  54 0004 0446     		mov	r4, r0
  55              		.loc 1 720 10 is_stmt 0 discriminator 2 view .LVU11
  56 0006 4069     		ldr	r0, [r0, #20]
  57              	.LVL1:
  58              		.loc 1 720 6 discriminator 2 view .LVU12
  59 0008 08B1     		cbz	r0, .L4
 721:lwIP/src/core/ipv4/ip4_frag.c ****     pbuf_free(pcr->original);
  60              		.loc 1 721 5 is_stmt 1 view .LVU13
  61 000a FFF7FEFF 		bl	pbuf_free
  62              	.LVL2:
  63              	.L4:
 722:lwIP/src/core/ipv4/ip4_frag.c ****   }
 723:lwIP/src/core/ipv4/ip4_frag.c ****   ip_frag_free_pbuf_custom_ref(pcr);
  64              		.loc 1 723 3 view .LVU14
  65              	.LBB42:
  66              	.LBI42:
 706:lwIP/src/core/ipv4/ip4_frag.c **** {
  67              		.loc 1 706 1 view .LVU15
  68              	.LBB43:
 708:lwIP/src/core/ipv4/ip4_frag.c ****   memp_free(MEMP_FRAG_PBUF, p);
  69              		.loc 1 708 3 view .LVU16
 708:lwIP/src/core/ipv4/ip4_frag.c ****   memp_free(MEMP_FRAG_PBUF, p);
  70              		.loc 1 708 3 view .LVU17
ARM GAS  /tmp/ccHPvcAz.s 			page 15


 708:lwIP/src/core/ipv4/ip4_frag.c ****   memp_free(MEMP_FRAG_PBUF, p);
  71              		.loc 1 708 3 view .LVU18
 709:lwIP/src/core/ipv4/ip4_frag.c **** }
  72              		.loc 1 709 3 view .LVU19
  73 000e 2146     		mov	r1, r4
  74 0010 0520     		movs	r0, #5
  75              	.LBE43:
  76              	.LBE42:
 724:lwIP/src/core/ipv4/ip4_frag.c **** }
  77              		.loc 1 724 1 is_stmt 0 view .LVU20
  78 0012 BDE81040 		pop	{r4, lr}
  79              	.LCFI1:
  80              		.cfi_remember_state
  81              		.cfi_restore 14
  82              		.cfi_restore 4
  83              		.cfi_def_cfa_offset 0
  84              	.LVL3:
  85              	.LBB45:
  86              	.LBB44:
 709:lwIP/src/core/ipv4/ip4_frag.c **** }
  87              		.loc 1 709 3 view .LVU21
  88 0016 FFF7FEBF 		b	memp_free
  89              	.LVL4:
  90              	.L10:
  91              	.LCFI2:
  92              		.cfi_restore_state
 709:lwIP/src/core/ipv4/ip4_frag.c **** }
  93              		.loc 1 709 3 view .LVU22
  94              	.LBE44:
  95              	.LBE45:
 718:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
  96              		.loc 1 718 3 is_stmt 1 discriminator 1 view .LVU23
  97 001a 0248     		ldr	r0, .L11
  98              	.LVL5:
 718:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
  99              		.loc 1 718 3 is_stmt 0 discriminator 1 view .LVU24
 100 001c FFF7FEFF 		bl	printf
 101              	.LVL6:
 102              	.L3:
 718:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
 103              		.loc 1 718 3 is_stmt 1 discriminator 1 view .LVU25
 718:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
 104              		.loc 1 718 3 discriminator 1 view .LVU26
 718:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
 105              		.loc 1 718 3 discriminator 1 view .LVU27
 718:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
 106              		.loc 1 718 3 discriminator 1 view .LVU28
 718:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
 107              		.loc 1 718 3 discriminator 1 view .LVU29
 718:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
 108              		.loc 1 718 3 discriminator 1 view .LVU30
 109 0020 FEE7     		b	.L3
 110              	.L12:
 111 0022 00BF     		.align	2
 112              	.L11:
 113 0024 00000000 		.word	.LC0
 114              		.cfi_endproc
ARM GAS  /tmp/ccHPvcAz.s 			page 16


 115              	.LFE114:
 117              		.section	.rodata.ip_reass_free_complete_datagram.part.0.str1.4,"aMS",%progbits,1
 118              		.align	2
 119              	.LC1:
 120 0000 70627566 		.ascii	"pbufs_freed + clen <= 0xffff\000"
 120      735F6672 
 120      65656420 
 120      2B20636C 
 120      656E203C 
 121 001d 000000   		.align	2
 122              	.LC2:
 123 0020 73616E69 		.ascii	"sanity check linked list\000"
 123      74792063 
 123      6865636B 
 123      206C696E 
 123      6B656420 
 124 0039 000000   		.align	2
 125              	.LC3:
 126 003c 69705F72 		.ascii	"ip_reass_pbufcount >= pbufs_freed\000"
 126      65617373 
 126      5F706275 
 126      66636F75 
 126      6E74203E 
 127              		.section	.text.ip_reass_free_complete_datagram.part.0,"ax",%progbits
 128              		.align	1
 129              		.p2align 2,,3
 130              		.syntax unified
 131              		.thumb
 132              		.thumb_func
 133              		.fpu fpv4-sp-d16
 135              	ip_reass_free_complete_datagram.part.0:
 136              	.LVL7:
 137              	.LFB117:
 164:lwIP/src/core/ipv4/ip4_frag.c **** {
 138              		.loc 1 164 1 view -0
 139              		.cfi_startproc
 140              		@ args = 0, pretend = 0, frame = 0
 141              		@ frame_needed = 0, uses_anonymous_args = 0
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 142              		.loc 1 173 5 view .LVU32
 176:lwIP/src/core/ipv4/ip4_frag.c **** #if LWIP_ICMP
 143              		.loc 1 176 36 view .LVU33
 178:lwIP/src/core/ipv4/ip4_frag.c ****   if (iprh->start == 0) {
 144              		.loc 1 178 3 view .LVU34
 164:lwIP/src/core/ipv4/ip4_frag.c **** {
 145              		.loc 1 164 1 is_stmt 0 view .LVU35
 146 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 147              	.LCFI3:
 148              		.cfi_def_cfa_offset 24
 149              		.cfi_offset 4, -24
 150              		.cfi_offset 5, -20
 151              		.cfi_offset 6, -16
 152              		.cfi_offset 7, -12
 153              		.cfi_offset 8, -8
 154              		.cfi_offset 14, -4
 178:lwIP/src/core/ipv4/ip4_frag.c ****   if (iprh->start == 0) {
 155              		.loc 1 178 39 view .LVU36
ARM GAS  /tmp/ccHPvcAz.s 			page 17


 156 0004 4568     		ldr	r5, [r0, #4]
 164:lwIP/src/core/ipv4/ip4_frag.c **** {
 157              		.loc 1 164 1 view .LVU37
 158 0006 0446     		mov	r4, r0
 159 0008 8846     		mov	r8, r1
 178:lwIP/src/core/ipv4/ip4_frag.c ****   if (iprh->start == 0) {
 160              		.loc 1 178 8 view .LVU38
 161 000a 6B68     		ldr	r3, [r5, #4]
 162              	.LVL8:
 179:lwIP/src/core/ipv4/ip4_frag.c ****     /* The first fragment was received, send ICMP time exceeded. */
 163              		.loc 1 179 3 is_stmt 1 view .LVU39
 179:lwIP/src/core/ipv4/ip4_frag.c ****     /* The first fragment was received, send ICMP time exceeded. */
 164              		.loc 1 179 6 is_stmt 0 view .LVU40
 165 000c 9A88     		ldrh	r2, [r3, #4]	@ unaligned
 166 000e 1F68     		ldr	r7, [r3]	@ unaligned
 167 0010 62B3     		cbz	r2, .L33
 166:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t clen;
 168              		.loc 1 166 9 view .LVU41
 169 0012 0026     		movs	r6, #0
 170 0014 04E0     		b	.L18
 171              	.LVL9:
 172              	.L16:
 173              	.LBB49:
 206:lwIP/src/core/ipv4/ip4_frag.c ****   }
 174              		.loc 1 206 5 view .LVU42
 175 0016 FFF7FEFF 		bl	pbuf_free
 176              	.LVL10:
 206:lwIP/src/core/ipv4/ip4_frag.c ****   }
 177              		.loc 1 206 5 view .LVU43
 178              	.LBE49:
 197:lwIP/src/core/ipv4/ip4_frag.c ****     struct pbuf *pcur;
 179              		.loc 1 197 9 is_stmt 1 view .LVU44
 180 001a 87B1     		cbz	r7, .L15
 197:lwIP/src/core/ipv4/ip4_frag.c ****     struct pbuf *pcur;
 181              		.loc 1 197 9 is_stmt 0 view .LVU45
 182 001c 7B68     		ldr	r3, [r7, #4]
 183 001e 1F68     		ldr	r7, [r3]	@ unaligned
 184              	.LVL11:
 185              	.L18:
 186              	.LBB50:
 198:lwIP/src/core/ipv4/ip4_frag.c ****     iprh = (struct ip_reass_helper *)p->payload;
 187              		.loc 1 198 5 is_stmt 1 view .LVU46
 199:lwIP/src/core/ipv4/ip4_frag.c ****     pcur = p;
 188              		.loc 1 199 5 view .LVU47
 200:lwIP/src/core/ipv4/ip4_frag.c ****     /* get the next pointer before freeing */
 189              		.loc 1 200 5 view .LVU48
 202:lwIP/src/core/ipv4/ip4_frag.c ****     clen = pbuf_clen(pcur);
 190              		.loc 1 202 5 view .LVU49
 203:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 191              		.loc 1 203 5 view .LVU50
 203:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 192              		.loc 1 203 12 is_stmt 0 view .LVU51
 193 0020 2846     		mov	r0, r5
 194 0022 FFF7FEFF 		bl	pbuf_clen
 195              	.LVL12:
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 196              		.loc 1 204 5 is_stmt 1 view .LVU52
ARM GAS  /tmp/ccHPvcAz.s 			page 18


 205:lwIP/src/core/ipv4/ip4_frag.c ****     pbuf_free(pcur);
 197              		.loc 1 205 5 view .LVU53
 203:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 198              		.loc 1 203 12 is_stmt 0 view .LVU54
 199 0026 0346     		mov	r3, r0
 200              	.LVL13:
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 201              		.loc 1 204 5 is_stmt 1 view .LVU55
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 202              		.loc 1 204 5 view .LVU56
 206:lwIP/src/core/ipv4/ip4_frag.c ****   }
 203              		.loc 1 206 5 is_stmt 0 view .LVU57
 204 0028 2846     		mov	r0, r5
 205              	.LBE50:
 197:lwIP/src/core/ipv4/ip4_frag.c ****     struct pbuf *pcur;
 206              		.loc 1 197 9 view .LVU58
 207 002a 3D46     		mov	r5, r7
 208              	.LVL14:
 209              	.LBB51:
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 210              		.loc 1 204 5 view .LVU59
 211 002c 1E44     		add	r6, r6, r3
 212 002e B6F5803F 		cmp	r6, #65536
 205:lwIP/src/core/ipv4/ip4_frag.c ****     pbuf_free(pcur);
 213              		.loc 1 205 17 view .LVU60
 214 0032 B6B2     		uxth	r6, r6
 215              	.LVL15:
 206:lwIP/src/core/ipv4/ip4_frag.c ****   }
 216              		.loc 1 206 5 is_stmt 1 view .LVU61
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 217              		.loc 1 204 5 is_stmt 0 view .LVU62
 218 0034 EFDB     		blt	.L16
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 219              		.loc 1 204 5 is_stmt 1 view .LVU63
 220 0036 2448     		ldr	r0, .L37
 221              	.LVL16:
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 222              		.loc 1 204 5 is_stmt 0 view .LVU64
 223 0038 FFF7FEFF 		bl	printf
 224              	.LVL17:
 225              	.L17:
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 226              		.loc 1 204 5 is_stmt 1 view .LVU65
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 227              		.loc 1 204 5 view .LVU66
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 228              		.loc 1 204 5 view .LVU67
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 229              		.loc 1 204 5 view .LVU68
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 230              		.loc 1 204 5 view .LVU69
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 231              		.loc 1 204 5 view .LVU70
 232 003c FEE7     		b	.L17
 233              	.L15:
 204:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 234              		.loc 1 204 5 is_stmt 0 view .LVU71
ARM GAS  /tmp/ccHPvcAz.s 			page 19


 235              	.LBE51:
 209:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ASSERT("ip_reass_pbufcount >= pbufs_freed", ip_reass_pbufcount >= pbufs_freed);
 236              		.loc 1 209 3 is_stmt 1 view .LVU72
 237              	.LVL18:
 238              	.LBB52:
 239              	.LBI52:
 317:lwIP/src/core/ipv4/ip4_frag.c **** {
 240              		.loc 1 317 1 view .LVU73
 241              	.LBB53:
 320:lwIP/src/core/ipv4/ip4_frag.c ****     /* it was the first in the list */
 242              		.loc 1 320 3 view .LVU74
 320:lwIP/src/core/ipv4/ip4_frag.c ****     /* it was the first in the list */
 243              		.loc 1 320 22 is_stmt 0 view .LVU75
 244 003e 234B     		ldr	r3, .L37+4
 320:lwIP/src/core/ipv4/ip4_frag.c ****     /* it was the first in the list */
 245              		.loc 1 320 6 view .LVU76
 246 0040 1A68     		ldr	r2, [r3]
 247 0042 9442     		cmp	r4, r2
 248 0044 38D0     		beq	.L34
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 249              		.loc 1 325 5 is_stmt 1 view .LVU77
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 250              		.loc 1 325 5 view .LVU78
 251 0046 B8F1000F 		cmp	r8, #0
 252 004a 31D0     		beq	.L35
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 253              		.loc 1 325 5 view .LVU79
 326:lwIP/src/core/ipv4/ip4_frag.c ****   }
 254              		.loc 1 326 5 view .LVU80
 326:lwIP/src/core/ipv4/ip4_frag.c ****   }
 255              		.loc 1 326 21 is_stmt 0 view .LVU81
 256 004c 2368     		ldr	r3, [r4]
 326:lwIP/src/core/ipv4/ip4_frag.c ****   }
 257              		.loc 1 326 16 view .LVU82
 258 004e C8F80030 		str	r3, [r8]
 259              	.L20:
 330:lwIP/src/core/ipv4/ip4_frag.c **** }
 260              		.loc 1 330 3 is_stmt 1 view .LVU83
 261 0052 2146     		mov	r1, r4
 262 0054 0420     		movs	r0, #4
 263 0056 FFF7FEFF 		bl	memp_free
 264              	.LVL19:
 330:lwIP/src/core/ipv4/ip4_frag.c **** }
 265              		.loc 1 330 3 is_stmt 0 view .LVU84
 266              	.LBE53:
 267              	.LBE52:
 210:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 268              		.loc 1 210 3 is_stmt 1 view .LVU85
 210:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 269              		.loc 1 210 3 view .LVU86
 270 005a 1D4A     		ldr	r2, .L37+8
 271 005c 1388     		ldrh	r3, [r2]
 272 005e B342     		cmp	r3, r6
 273 0060 2DD3     		bcc	.L36
 210:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 274              		.loc 1 210 3 view .LVU87
 211:lwIP/src/core/ipv4/ip4_frag.c **** 
ARM GAS  /tmp/ccHPvcAz.s 			page 20


 275              		.loc 1 211 3 view .LVU88
 211:lwIP/src/core/ipv4/ip4_frag.c **** 
 276              		.loc 1 211 24 is_stmt 0 view .LVU89
 277 0062 9B1B     		subs	r3, r3, r6
 214:lwIP/src/core/ipv4/ip4_frag.c **** 
 278              		.loc 1 214 1 view .LVU90
 279 0064 3046     		mov	r0, r6
 211:lwIP/src/core/ipv4/ip4_frag.c **** 
 280              		.loc 1 211 22 view .LVU91
 281 0066 1380     		strh	r3, [r2]	@ movhi
 213:lwIP/src/core/ipv4/ip4_frag.c **** }
 282              		.loc 1 213 3 is_stmt 1 view .LVU92
 214:lwIP/src/core/ipv4/ip4_frag.c **** 
 283              		.loc 1 214 1 is_stmt 0 view .LVU93
 284 0068 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 285              	.LVL20:
 286              	.L33:
 182:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->p = iprh->next_pbuf;
 287              		.loc 1 182 5 is_stmt 1 view .LVU94
 183:lwIP/src/core/ipv4/ip4_frag.c ****     /* Then, copy the original header into it. */
 288              		.loc 1 183 5 view .LVU95
 185:lwIP/src/core/ipv4/ip4_frag.c ****     icmp_time_exceeded(p, ICMP_TE_FRAG);
 289              		.loc 1 185 5 is_stmt 0 view .LVU96
 290 006c 0246     		mov	r2, r0
 183:lwIP/src/core/ipv4/ip4_frag.c ****     /* Then, copy the original header into it. */
 291              		.loc 1 183 12 view .LVU97
 292 006e 4760     		str	r7, [r0, #4]
 185:lwIP/src/core/ipv4/ip4_frag.c ****     icmp_time_exceeded(p, ICMP_TE_FRAG);
 293              		.loc 1 185 5 is_stmt 1 view .LVU98
 186:lwIP/src/core/ipv4/ip4_frag.c ****     clen = pbuf_clen(p);
 294              		.loc 1 186 5 is_stmt 0 view .LVU99
 295 0070 0121     		movs	r1, #1
 296              	.LVL21:
 186:lwIP/src/core/ipv4/ip4_frag.c ****     clen = pbuf_clen(p);
 297              		.loc 1 186 5 view .LVU100
 298 0072 2846     		mov	r0, r5
 299              	.LVL22:
 185:lwIP/src/core/ipv4/ip4_frag.c ****     icmp_time_exceeded(p, ICMP_TE_FRAG);
 300              		.loc 1 185 5 view .LVU101
 301 0074 52F8086F 		ldr	r6, [r2, #8]!	@ unaligned
 302 0078 D2F804E0 		ldr	lr, [r2, #4]	@ unaligned
 303 007c D2F808C0 		ldr	ip, [r2, #8]	@ unaligned
 304 0080 D768     		ldr	r7, [r2, #12]	@ unaligned
 305 0082 1E60     		str	r6, [r3]	@ unaligned
 306 0084 C3F804E0 		str	lr, [r3, #4]	@ unaligned
 307 0088 C3F808C0 		str	ip, [r3, #8]	@ unaligned
 308 008c DF60     		str	r7, [r3, #12]	@ unaligned
 309 008e 1669     		ldr	r6, [r2, #16]	@ unaligned
 310 0090 1E61     		str	r6, [r3, #16]	@ unaligned
 186:lwIP/src/core/ipv4/ip4_frag.c ****     clen = pbuf_clen(p);
 311              		.loc 1 186 5 is_stmt 1 view .LVU102
 312 0092 FFF7FEFF 		bl	icmp_time_exceeded
 313              	.LVL23:
 187:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 314              		.loc 1 187 5 view .LVU103
 187:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 315              		.loc 1 187 12 is_stmt 0 view .LVU104
ARM GAS  /tmp/ccHPvcAz.s 			page 21


 316 0096 2846     		mov	r0, r5
 317 0098 FFF7FEFF 		bl	pbuf_clen
 318              	.LVL24:
 319 009c 0646     		mov	r6, r0
 190:lwIP/src/core/ipv4/ip4_frag.c ****   }
 320              		.loc 1 190 5 view .LVU105
 321 009e 2846     		mov	r0, r5
 322              	.LVL25:
 188:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 323              		.loc 1 188 5 is_stmt 1 view .LVU106
 188:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 324              		.loc 1 188 5 view .LVU107
 188:lwIP/src/core/ipv4/ip4_frag.c ****     pbufs_freed = (u16_t)(pbufs_freed + clen);
 325              		.loc 1 188 5 view .LVU108
 189:lwIP/src/core/ipv4/ip4_frag.c ****     pbuf_free(p);
 326              		.loc 1 189 5 view .LVU109
 190:lwIP/src/core/ipv4/ip4_frag.c ****   }
 327              		.loc 1 190 5 view .LVU110
 328 00a0 FFF7FEFF 		bl	pbuf_free
 329              	.LVL26:
 196:lwIP/src/core/ipv4/ip4_frag.c ****   while (p != NULL) {
 330              		.loc 1 196 3 view .LVU111
 196:lwIP/src/core/ipv4/ip4_frag.c ****   while (p != NULL) {
 331              		.loc 1 196 5 is_stmt 0 view .LVU112
 332 00a4 6568     		ldr	r5, [r4, #4]
 333              	.LVL27:
 197:lwIP/src/core/ipv4/ip4_frag.c ****     struct pbuf *pcur;
 334              		.loc 1 197 3 is_stmt 1 view .LVU113
 197:lwIP/src/core/ipv4/ip4_frag.c ****     struct pbuf *pcur;
 335              		.loc 1 197 9 view .LVU114
 336 00a6 002D     		cmp	r5, #0
 337 00a8 C9D0     		beq	.L15
 338 00aa 6B68     		ldr	r3, [r5, #4]
 339 00ac 1F68     		ldr	r7, [r3]	@ unaligned
 340 00ae B7E7     		b	.L18
 341              	.LVL28:
 342              	.L35:
 343              	.LBB55:
 344              	.LBB54:
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 345              		.loc 1 325 5 view .LVU115
 346 00b0 0848     		ldr	r0, .L37+12
 347 00b2 FFF7FEFF 		bl	printf
 348              	.LVL29:
 349              	.L22:
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 350              		.loc 1 325 5 view .LVU116
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 351              		.loc 1 325 5 view .LVU117
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 352              		.loc 1 325 5 view .LVU118
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 353              		.loc 1 325 5 view .LVU119
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 354              		.loc 1 325 5 view .LVU120
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 355              		.loc 1 325 5 view .LVU121
ARM GAS  /tmp/ccHPvcAz.s 			page 22


 356 00b6 FEE7     		b	.L22
 357              	.L34:
 322:lwIP/src/core/ipv4/ip4_frag.c ****   } else {
 358              		.loc 1 322 5 view .LVU122
 322:lwIP/src/core/ipv4/ip4_frag.c ****   } else {
 359              		.loc 1 322 20 is_stmt 0 view .LVU123
 360 00b8 2268     		ldr	r2, [r4]
 361 00ba 1A60     		str	r2, [r3]
 362 00bc C9E7     		b	.L20
 363              	.LVL30:
 364              	.L36:
 322:lwIP/src/core/ipv4/ip4_frag.c ****   } else {
 365              		.loc 1 322 20 view .LVU124
 366              	.LBE54:
 367              	.LBE55:
 210:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 368              		.loc 1 210 3 is_stmt 1 view .LVU125
 369 00be 0648     		ldr	r0, .L37+16
 370 00c0 FFF7FEFF 		bl	printf
 371              	.LVL31:
 372              	.L24:
 210:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 373              		.loc 1 210 3 view .LVU126
 210:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 374              		.loc 1 210 3 view .LVU127
 210:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 375              		.loc 1 210 3 view .LVU128
 210:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 376              		.loc 1 210 3 view .LVU129
 210:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 377              		.loc 1 210 3 view .LVU130
 210:lwIP/src/core/ipv4/ip4_frag.c ****   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 378              		.loc 1 210 3 view .LVU131
 379 00c4 FEE7     		b	.L24
 380              	.L38:
 381 00c6 00BF     		.align	2
 382              	.L37:
 383 00c8 00000000 		.word	.LC1
 384 00cc 00000000 		.word	.LANCHOR0
 385 00d0 00000000 		.word	.LANCHOR1
 386 00d4 20000000 		.word	.LC2
 387 00d8 3C000000 		.word	.LC3
 388              		.cfi_endproc
 389              	.LFE117:
 391              		.section	.rodata.ip_reass_remove_oldest_datagram.str1.4,"aMS",%progbits,1
 392              		.align	2
 393              	.LC4:
 394 0000 70726576 		.ascii	"prev != ipr\000"
 394      20213D20 
 394      69707200 
 395              		.align	2
 396              	.LC5:
 397 000c 70726576 		.ascii	"prev->next == ipr\000"
 397      2D3E6E65 
 397      7874203D 
 397      3D206970 
 397      7200
ARM GAS  /tmp/ccHPvcAz.s 			page 23


 398              		.section	.text.ip_reass_remove_oldest_datagram,"ax",%progbits
 399              		.align	1
 400              		.p2align 2,,3
 401              		.syntax unified
 402              		.thumb
 403              		.thumb_func
 404              		.fpu fpv4-sp-d16
 406              	ip_reass_remove_oldest_datagram:
 407              	.LVL32:
 408              	.LFB107:
 228:lwIP/src/core/ipv4/ip4_frag.c ****   /* @todo Can't we simply remove the last datagram in the
 409              		.loc 1 228 1 view -0
 410              		.cfi_startproc
 411              		@ args = 0, pretend = 0, frame = 0
 412              		@ frame_needed = 0, uses_anonymous_args = 0
 232:lwIP/src/core/ipv4/ip4_frag.c ****   int pbufs_freed = 0, pbufs_freed_current;
 413              		.loc 1 232 3 view .LVU133
 233:lwIP/src/core/ipv4/ip4_frag.c ****   int other_datagrams;
 414              		.loc 1 233 3 view .LVU134
 228:lwIP/src/core/ipv4/ip4_frag.c ****   /* @todo Can't we simply remove the last datagram in the
 415              		.loc 1 228 1 is_stmt 0 view .LVU135
 416 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 417              	.LCFI4:
 418              		.cfi_def_cfa_offset 32
 419              		.cfi_offset 3, -32
 420              		.cfi_offset 4, -28
 421              		.cfi_offset 5, -24
 422              		.cfi_offset 6, -20
 423              		.cfi_offset 7, -16
 424              		.cfi_offset 8, -12
 425              		.cfi_offset 9, -8
 426              		.cfi_offset 14, -4
 233:lwIP/src/core/ipv4/ip4_frag.c ****   int other_datagrams;
 427              		.loc 1 233 7 view .LVU136
 428 0004 4FF00008 		mov	r8, #0
 429 0008 DFF88C90 		ldr	r9, .L69+8
 228:lwIP/src/core/ipv4/ip4_frag.c ****   /* @todo Can't we simply remove the last datagram in the
 430              		.loc 1 228 1 view .LVU137
 431 000c 0646     		mov	r6, r0
 432 000e 0F46     		mov	r7, r1
 433              	.LVL33:
 434              	.L49:
 234:lwIP/src/core/ipv4/ip4_frag.c **** 
 435              		.loc 1 234 3 is_stmt 1 view .LVU138
 238:lwIP/src/core/ipv4/ip4_frag.c ****     oldest = NULL;
 436              		.loc 1 238 3 view .LVU139
 239:lwIP/src/core/ipv4/ip4_frag.c ****     prev = NULL;
 437              		.loc 1 239 5 view .LVU140
 240:lwIP/src/core/ipv4/ip4_frag.c ****     oldest_prev = NULL;
 438              		.loc 1 240 5 view .LVU141
 241:lwIP/src/core/ipv4/ip4_frag.c ****     other_datagrams = 0;
 439              		.loc 1 241 5 view .LVU142
 242:lwIP/src/core/ipv4/ip4_frag.c ****     r = reassdatagrams;
 440              		.loc 1 242 5 view .LVU143
 243:lwIP/src/core/ipv4/ip4_frag.c ****     while (r != NULL) {
 441              		.loc 1 243 5 view .LVU144
 243:lwIP/src/core/ipv4/ip4_frag.c ****     while (r != NULL) {
ARM GAS  /tmp/ccHPvcAz.s 			page 24


 442              		.loc 1 243 7 is_stmt 0 view .LVU145
 443 0010 D9F80030 		ldr	r3, [r9]
 444              	.LVL34:
 244:lwIP/src/core/ipv4/ip4_frag.c ****       if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 445              		.loc 1 244 5 is_stmt 1 view .LVU146
 244:lwIP/src/core/ipv4/ip4_frag.c ****       if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 446              		.loc 1 244 11 view .LVU147
 447 0014 4BB3     		cbz	r3, .L39
 242:lwIP/src/core/ipv4/ip4_frag.c ****     r = reassdatagrams;
 448              		.loc 1 242 21 is_stmt 0 view .LVU148
 449 0016 0025     		movs	r5, #0
 245:lwIP/src/core/ipv4/ip4_frag.c ****         /* Not the same datagram as fraghdr */
 450              		.loc 1 245 12 view .LVU149
 451 0018 D6F80CC0 		ldr	ip, [r6, #12]	@ unaligned
 241:lwIP/src/core/ipv4/ip4_frag.c ****     other_datagrams = 0;
 452              		.loc 1 241 17 view .LVU150
 453 001c 2946     		mov	r1, r5
 240:lwIP/src/core/ipv4/ip4_frag.c ****     oldest_prev = NULL;
 454              		.loc 1 240 10 view .LVU151
 455 001e 2846     		mov	r0, r5
 239:lwIP/src/core/ipv4/ip4_frag.c ****     prev = NULL;
 456              		.loc 1 239 12 view .LVU152
 457 0020 2C46     		mov	r4, r5
 458              	.LVL35:
 459              	.L43:
 245:lwIP/src/core/ipv4/ip4_frag.c ****         /* Not the same datagram as fraghdr */
 460              		.loc 1 245 7 is_stmt 1 view .LVU153
 247:lwIP/src/core/ipv4/ip4_frag.c ****         if (oldest == NULL) {
 461              		.loc 1 247 9 view .LVU154
 251:lwIP/src/core/ipv4/ip4_frag.c ****           /* older than the previous oldest */
 462              		.loc 1 251 16 view .LVU155
 245:lwIP/src/core/ipv4/ip4_frag.c ****         /* Not the same datagram as fraghdr */
 463              		.loc 1 245 10 is_stmt 0 view .LVU156
 464 0022 5A69     		ldr	r2, [r3, #20]
 465 0024 6245     		cmp	r2, ip
 466 0026 23D0     		beq	.L67
 467              	.L41:
 247:lwIP/src/core/ipv4/ip4_frag.c ****         if (oldest == NULL) {
 468              		.loc 1 247 24 view .LVU157
 469 0028 0135     		adds	r5, r5, #1
 470              	.LVL36:
 248:lwIP/src/core/ipv4/ip4_frag.c ****           oldest = r;
 471              		.loc 1 248 9 is_stmt 1 view .LVU158
 248:lwIP/src/core/ipv4/ip4_frag.c ****           oldest = r;
 472              		.loc 1 248 12 is_stmt 0 view .LVU159
 473 002a 24B1     		cbz	r4, .L53
 251:lwIP/src/core/ipv4/ip4_frag.c ****           /* older than the previous oldest */
 474              		.loc 1 251 19 view .LVU160
 475 002c 93F81FE0 		ldrb	lr, [r3, #31]	@ zero_extendqisi2
 476 0030 E27F     		ldrb	r2, [r4, #31]	@ zero_extendqisi2
 477 0032 9645     		cmp	lr, r2
 478 0034 01D8     		bhi	.L42
 479              	.L53:
 251:lwIP/src/core/ipv4/ip4_frag.c ****           /* older than the previous oldest */
 480              		.loc 1 251 19 view .LVU161
 481 0036 0146     		mov	r1, r0
 482 0038 1C46     		mov	r4, r3
ARM GAS  /tmp/ccHPvcAz.s 			page 25


 483              	.LVL37:
 484              	.L42:
 257:lwIP/src/core/ipv4/ip4_frag.c ****         prev = r;
 485              		.loc 1 257 7 is_stmt 1 view .LVU162
 257:lwIP/src/core/ipv4/ip4_frag.c ****         prev = r;
 486              		.loc 1 257 12 is_stmt 0 view .LVU163
 487 003a 1A68     		ldr	r2, [r3]
 488              	.LVL38:
 257:lwIP/src/core/ipv4/ip4_frag.c ****         prev = r;
 489              		.loc 1 257 12 view .LVU164
 490 003c 1846     		mov	r0, r3
 491 003e 1346     		mov	r3, r2
 492              	.LVL39:
 257:lwIP/src/core/ipv4/ip4_frag.c ****         prev = r;
 493              		.loc 1 257 10 view .LVU165
 494 0040 002A     		cmp	r2, #0
 495 0042 EED1     		bne	.L43
 496              	.LVL40:
 244:lwIP/src/core/ipv4/ip4_frag.c ****       if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 497              		.loc 1 244 11 is_stmt 1 view .LVU166
 262:lwIP/src/core/ipv4/ip4_frag.c ****       pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
 498              		.loc 1 262 5 view .LVU167
 262:lwIP/src/core/ipv4/ip4_frag.c ****       pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
 499              		.loc 1 262 8 is_stmt 0 view .LVU168
 500 0044 6CB1     		cbz	r4, .L52
 263:lwIP/src/core/ipv4/ip4_frag.c ****       pbufs_freed += pbufs_freed_current;
 501              		.loc 1 263 7 is_stmt 1 view .LVU169
 502              	.LVL41:
 503              	.LBB58:
 504              	.LBI58:
 164:lwIP/src/core/ipv4/ip4_frag.c **** {
 505              		.loc 1 164 1 view .LVU170
 506              	.LBB59:
 166:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t clen;
 507              		.loc 1 166 3 view .LVU171
 167:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *p;
 508              		.loc 1 167 3 view .LVU172
 168:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reass_helper *iprh;
 509              		.loc 1 168 3 view .LVU173
 169:lwIP/src/core/ipv4/ip4_frag.c **** 
 510              		.loc 1 169 3 view .LVU174
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 511              		.loc 1 171 3 view .LVU175
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 512              		.loc 1 171 3 view .LVU176
 513 0046 8C42     		cmp	r4, r1
 514 0048 1DD0     		beq	.L68
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 515              		.loc 1 171 3 view .LVU177
 172:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 516              		.loc 1 172 3 view .LVU178
 172:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 517              		.loc 1 172 6 is_stmt 0 view .LVU179
 518 004a 31B1     		cbz	r1, .L47
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 519              		.loc 1 173 5 is_stmt 1 view .LVU180
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
ARM GAS  /tmp/ccHPvcAz.s 			page 26


 520              		.loc 1 173 5 view .LVU181
 521 004c 0B68     		ldr	r3, [r1]
 522 004e 9C42     		cmp	r4, r3
 523 0050 03D0     		beq	.L47
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 524              		.loc 1 173 5 view .LVU182
 525 0052 0F48     		ldr	r0, .L69
 526              	.LVL42:
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 527              		.loc 1 173 5 is_stmt 0 view .LVU183
 528 0054 FFF7FEFF 		bl	printf
 529              	.LVL43:
 530              	.L48:
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 531              		.loc 1 173 5 is_stmt 1 view .LVU184
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 532              		.loc 1 173 5 view .LVU185
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 533              		.loc 1 173 5 view .LVU186
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 534              		.loc 1 173 5 view .LVU187
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 535              		.loc 1 173 5 view .LVU188
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 536              		.loc 1 173 5 view .LVU189
 537 0058 FEE7     		b	.L48
 538              	.LVL44:
 539              	.L47:
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 540              		.loc 1 173 5 is_stmt 0 view .LVU190
 541 005a 2046     		mov	r0, r4
 542              	.LVL45:
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 543              		.loc 1 173 5 view .LVU191
 544 005c FFF7FEFF 		bl	ip_reass_free_complete_datagram.part.0
 545              	.LVL46:
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 546              		.loc 1 173 5 view .LVU192
 547              	.LBE59:
 548              	.LBE58:
 264:lwIP/src/core/ipv4/ip4_frag.c ****     }
 549              		.loc 1 264 7 is_stmt 1 view .LVU193
 264:lwIP/src/core/ipv4/ip4_frag.c ****     }
 550              		.loc 1 264 19 is_stmt 0 view .LVU194
 551 0060 8044     		add	r8, r8, r0
 552              	.LVL47:
 553              	.L52:
 266:lwIP/src/core/ipv4/ip4_frag.c ****   return pbufs_freed;
 554              		.loc 1 266 11 is_stmt 1 view .LVU195
 266:lwIP/src/core/ipv4/ip4_frag.c ****   return pbufs_freed;
 555              		.loc 1 266 3 is_stmt 0 view .LVU196
 556 0062 B845     		cmp	r8, r7
 557 0064 01DA     		bge	.L39
 266:lwIP/src/core/ipv4/ip4_frag.c ****   return pbufs_freed;
 558              		.loc 1 266 3 view .LVU197
 559 0066 012D     		cmp	r5, #1
 560 0068 D2DC     		bgt	.L49
ARM GAS  /tmp/ccHPvcAz.s 			page 27


 561              	.LVL48:
 562              	.L39:
 268:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_FREE_OLDEST */
 563              		.loc 1 268 1 view .LVU198
 564 006a 4046     		mov	r0, r8
 565 006c BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 566              	.LVL49:
 567              	.L67:
 245:lwIP/src/core/ipv4/ip4_frag.c ****         /* Not the same datagram as fraghdr */
 568              		.loc 1 245 12 discriminator 1 view .LVU199
 569 0070 D6F810E0 		ldr	lr, [r6, #16]	@ unaligned
 570 0074 9A69     		ldr	r2, [r3, #24]
 571 0076 7245     		cmp	r2, lr
 572 0078 D6D1     		bne	.L41
 245:lwIP/src/core/ipv4/ip4_frag.c ****         /* Not the same datagram as fraghdr */
 573              		.loc 1 245 11 discriminator 2 view .LVU200
 574 007a B3F80CE0 		ldrh	lr, [r3, #12]
 575 007e B288     		ldrh	r2, [r6, #4]	@ unaligned
 576 0080 9645     		cmp	lr, r2
 577 0082 D1D1     		bne	.L41
 578 0084 D9E7     		b	.L42
 579              	.LVL50:
 580              	.L68:
 581              	.LBB61:
 582              	.LBB60:
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 583              		.loc 1 171 3 is_stmt 1 view .LVU201
 584 0086 0348     		ldr	r0, .L69+4
 585              	.LVL51:
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 586              		.loc 1 171 3 is_stmt 0 view .LVU202
 587 0088 FFF7FEFF 		bl	printf
 588              	.LVL52:
 589              	.L46:
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 590              		.loc 1 171 3 is_stmt 1 view .LVU203
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 591              		.loc 1 171 3 view .LVU204
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 592              		.loc 1 171 3 view .LVU205
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 593              		.loc 1 171 3 view .LVU206
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 594              		.loc 1 171 3 view .LVU207
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 595              		.loc 1 171 3 view .LVU208
 596 008c FEE7     		b	.L46
 597              	.L70:
 598 008e 00BF     		.align	2
 599              	.L69:
 600 0090 0C000000 		.word	.LC5
 601 0094 00000000 		.word	.LC4
 602 0098 00000000 		.word	.LANCHOR0
 603              	.LBE60:
 604              	.LBE61:
 605              		.cfi_endproc
 606              	.LFE107:
ARM GAS  /tmp/ccHPvcAz.s 			page 28


 608              		.section	.text.ip_reass_tmr,"ax",%progbits
 609              		.align	1
 610              		.p2align 2,,3
 611              		.global	ip_reass_tmr
 612              		.syntax unified
 613              		.thumb
 614              		.thumb_func
 615              		.fpu fpv4-sp-d16
 617              	ip_reass_tmr:
 618              	.LFB105:
 129:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reassdata *r, *prev = NULL;
 619              		.loc 1 129 1 view -0
 620              		.cfi_startproc
 621              		@ args = 0, pretend = 0, frame = 0
 622              		@ frame_needed = 0, uses_anonymous_args = 0
 130:lwIP/src/core/ipv4/ip4_frag.c **** 
 623              		.loc 1 130 3 view .LVU210
 624              	.LVL53:
 132:lwIP/src/core/ipv4/ip4_frag.c ****   while (r != NULL) {
 625              		.loc 1 132 3 view .LVU211
 129:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reassdata *r, *prev = NULL;
 626              		.loc 1 129 1 is_stmt 0 view .LVU212
 627 0000 38B5     		push	{r3, r4, r5, lr}
 628              	.LCFI5:
 629              		.cfi_def_cfa_offset 16
 630              		.cfi_offset 3, -16
 631              		.cfi_offset 4, -12
 632              		.cfi_offset 5, -8
 633              		.cfi_offset 14, -4
 132:lwIP/src/core/ipv4/ip4_frag.c ****   while (r != NULL) {
 634              		.loc 1 132 5 view .LVU213
 635 0002 114B     		ldr	r3, .L87
 636 0004 1C68     		ldr	r4, [r3]
 637              	.LVL54:
 133:lwIP/src/core/ipv4/ip4_frag.c ****     /* Decrement the timer. Once it reaches 0,
 638              		.loc 1 133 3 is_stmt 1 view .LVU214
 133:lwIP/src/core/ipv4/ip4_frag.c ****     /* Decrement the timer. Once it reaches 0,
 639              		.loc 1 133 9 view .LVU215
 640 0006 4CB1     		cbz	r4, .L71
 130:lwIP/src/core/ipv4/ip4_frag.c **** 
 641              		.loc 1 130 28 is_stmt 0 view .LVU216
 642 0008 0025     		movs	r5, #0
 643              	.LVL55:
 644              	.L72:
 136:lwIP/src/core/ipv4/ip4_frag.c ****       r->timer--;
 645              		.loc 1 136 5 is_stmt 1 view .LVU217
 137:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n", (u16_t)r->timer));
 646              		.loc 1 137 7 view .LVU218
 136:lwIP/src/core/ipv4/ip4_frag.c ****       r->timer--;
 647              		.loc 1 136 10 is_stmt 0 view .LVU219
 648 000a E27F     		ldrb	r2, [r4, #31]	@ zero_extendqisi2
 649 000c 2346     		mov	r3, r4
 650 000e 2468     		ldr	r4, [r4]
 651              	.LVL56:
 137:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n", (u16_t)r->timer));
 652              		.loc 1 137 15 view .LVU220
 653 0010 511E     		subs	r1, r2, #1
ARM GAS  /tmp/ccHPvcAz.s 			page 29


 136:lwIP/src/core/ipv4/ip4_frag.c ****       r->timer--;
 654              		.loc 1 136 8 view .LVU221
 655 0012 22B1     		cbz	r2, .L73
 656 0014 1D46     		mov	r5, r3
 657              	.LVL57:
 137:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n", (u16_t)r->timer));
 658              		.loc 1 137 15 view .LVU222
 659 0016 D977     		strb	r1, [r3, #31]
 138:lwIP/src/core/ipv4/ip4_frag.c ****       prev = r;
 660              		.loc 1 138 91 is_stmt 1 view .LVU223
 139:lwIP/src/core/ipv4/ip4_frag.c ****       r = r->next;
 661              		.loc 1 139 7 view .LVU224
 662              	.LVL58:
 140:lwIP/src/core/ipv4/ip4_frag.c ****     } else {
 663              		.loc 1 140 7 view .LVU225
 133:lwIP/src/core/ipv4/ip4_frag.c ****     /* Decrement the timer. Once it reaches 0,
 664              		.loc 1 133 9 view .LVU226
 665 0018 002C     		cmp	r4, #0
 666 001a F6D1     		bne	.L72
 667              	.LVL59:
 668              	.L71:
 152:lwIP/src/core/ipv4/ip4_frag.c **** 
 669              		.loc 1 152 1 is_stmt 0 view .LVU227
 670 001c 38BD     		pop	{r3, r4, r5, pc}
 671              	.LVL60:
 672              	.L73:
 673              	.LBB65:
 143:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
 674              		.loc 1 143 7 is_stmt 1 view .LVU228
 144:lwIP/src/core/ipv4/ip4_frag.c ****       tmp = r;
 675              		.loc 1 144 71 view .LVU229
 145:lwIP/src/core/ipv4/ip4_frag.c ****       /* get the next pointer before freeing */
 676              		.loc 1 145 7 view .LVU230
 147:lwIP/src/core/ipv4/ip4_frag.c ****       /* free the helper struct and all enqueued pbufs */
 677              		.loc 1 147 7 view .LVU231
 149:lwIP/src/core/ipv4/ip4_frag.c ****     }
 678              		.loc 1 149 7 view .LVU232
 679              	.LBB66:
 680              	.LBI66:
 164:lwIP/src/core/ipv4/ip4_frag.c **** {
 681              		.loc 1 164 1 view .LVU233
 682              	.LBB67:
 166:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t clen;
 683              		.loc 1 166 3 view .LVU234
 167:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *p;
 684              		.loc 1 167 3 view .LVU235
 168:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reass_helper *iprh;
 685              		.loc 1 168 3 view .LVU236
 169:lwIP/src/core/ipv4/ip4_frag.c **** 
 686              		.loc 1 169 3 view .LVU237
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 687              		.loc 1 171 3 view .LVU238
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 688              		.loc 1 171 3 view .LVU239
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 689              		.loc 1 171 3 view .LVU240
 172:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
ARM GAS  /tmp/ccHPvcAz.s 			page 30


 690              		.loc 1 172 3 view .LVU241
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 691              		.loc 1 173 5 view .LVU242
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 692              		.loc 1 173 5 view .LVU243
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 693              		.loc 1 171 3 is_stmt 0 view .LVU244
 694 001e 9D42     		cmp	r5, r3
 695 0020 2946     		mov	r1, r5
 696 0022 1846     		mov	r0, r3
 697 0024 0CD0     		beq	.L86
 698              	.LVL61:
 172:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 699              		.loc 1 172 6 view .LVU245
 700 0026 35B1     		cbz	r5, .L77
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 701              		.loc 1 173 5 view .LVU246
 702 0028 2A68     		ldr	r2, [r5]
 703 002a 9A42     		cmp	r2, r3
 704 002c 03D0     		beq	.L77
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 705              		.loc 1 173 5 is_stmt 1 view .LVU247
 706 002e 0748     		ldr	r0, .L87+4
 707              	.LVL62:
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 708              		.loc 1 173 5 is_stmt 0 view .LVU248
 709 0030 FFF7FEFF 		bl	printf
 710              	.LVL63:
 711              	.L78:
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 712              		.loc 1 173 5 is_stmt 1 view .LVU249
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 713              		.loc 1 173 5 view .LVU250
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 714              		.loc 1 173 5 view .LVU251
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 715              		.loc 1 173 5 view .LVU252
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 716              		.loc 1 173 5 view .LVU253
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 717              		.loc 1 173 5 view .LVU254
 718 0034 FEE7     		b	.L78
 719              	.LVL64:
 720              	.L77:
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 721              		.loc 1 173 5 is_stmt 0 view .LVU255
 722 0036 FFF7FEFF 		bl	ip_reass_free_complete_datagram.part.0
 723              	.LVL65:
 173:lwIP/src/core/ipv4/ip4_frag.c ****   }
 724              		.loc 1 173 5 view .LVU256
 725              	.LBE67:
 726              	.LBE66:
 727              	.LBE65:
 133:lwIP/src/core/ipv4/ip4_frag.c ****     /* Decrement the timer. Once it reaches 0,
 728              		.loc 1 133 9 is_stmt 1 view .LVU257
 729 003a 002C     		cmp	r4, #0
 730 003c E5D1     		bne	.L72
ARM GAS  /tmp/ccHPvcAz.s 			page 31


 731 003e EDE7     		b	.L71
 732              	.LVL66:
 733              	.L86:
 734              	.LBB70:
 735              	.LBB69:
 736              	.LBB68:
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 737              		.loc 1 171 3 view .LVU258
 738 0040 0348     		ldr	r0, .L87+8
 739              	.LVL67:
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 740              		.loc 1 171 3 is_stmt 0 view .LVU259
 741 0042 FFF7FEFF 		bl	printf
 742              	.LVL68:
 743              	.L76:
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 744              		.loc 1 171 3 is_stmt 1 view .LVU260
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 745              		.loc 1 171 3 view .LVU261
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 746              		.loc 1 171 3 view .LVU262
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 747              		.loc 1 171 3 view .LVU263
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 748              		.loc 1 171 3 view .LVU264
 171:lwIP/src/core/ipv4/ip4_frag.c ****   if (prev != NULL) {
 749              		.loc 1 171 3 view .LVU265
 750 0046 FEE7     		b	.L76
 751              	.L88:
 752              		.align	2
 753              	.L87:
 754 0048 00000000 		.word	.LANCHOR0
 755 004c 0C000000 		.word	.LC5
 756 0050 00000000 		.word	.LC4
 757              	.LBE68:
 758              	.LBE69:
 759              	.LBE70:
 760              		.cfi_endproc
 761              	.LFE105:
 763              		.section	.rodata.ip4_reass.str1.4,"aMS",%progbits,1
 764              		.align	2
 765              	.LC6:
 766 0000 73616E69 		.ascii	"sanity check\000"
 766      74792063 
 766      6865636B 
 766      00
 767 000d 000000   		.align	2
 768              	.LC7:
 769 0010 69705F72 		.ascii	"ip_reass_pbufcount >= clen\000"
 769      65617373 
 769      5F706275 
 769      66636F75 
 769      6E74203E 
 770 002b 00       		.align	2
 771              	.LC8:
 772 002c 6E6F7420 		.ascii	"not firstalthough just enqueued\000"
 772      66697273 
ARM GAS  /tmp/ccHPvcAz.s 			page 32


 772      74616C74 
 772      686F7567 
 772      68206A75 
 773              		.section	.text.ip4_reass,"ax",%progbits
 774              		.align	1
 775              		.p2align 2,,3
 776              		.global	ip4_reass
 777              		.syntax unified
 778              		.thumb
 779              		.thumb_func
 780              		.fpu fpv4-sp-d16
 782              	ip4_reass:
 783              	.LVL69:
 784              	.LFB111:
 504:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *r;
 785              		.loc 1 504 1 view -0
 786              		.cfi_startproc
 787              		@ args = 0, pretend = 0, frame = 24
 788              		@ frame_needed = 0, uses_anonymous_args = 0
 505:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_hdr *fraghdr;
 789              		.loc 1 505 3 view .LVU267
 506:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reassdata *ipr;
 790              		.loc 1 506 3 view .LVU268
 507:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_reass_helper *iprh;
 791              		.loc 1 507 3 view .LVU269
 508:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t offset, len, clen;
 792              		.loc 1 508 3 view .LVU270
 509:lwIP/src/core/ipv4/ip4_frag.c ****   u8_t hlen;
 793              		.loc 1 509 3 view .LVU271
 510:lwIP/src/core/ipv4/ip4_frag.c ****   int valid;
 794              		.loc 1 510 3 view .LVU272
 511:lwIP/src/core/ipv4/ip4_frag.c ****   int is_last;
 795              		.loc 1 511 3 view .LVU273
 512:lwIP/src/core/ipv4/ip4_frag.c **** 
 796              		.loc 1 512 3 view .LVU274
 514:lwIP/src/core/ipv4/ip4_frag.c ****   MIB2_STATS_INC(mib2.ipreasmreqds);
 797              		.loc 1 514 33 view .LVU275
 515:lwIP/src/core/ipv4/ip4_frag.c **** 
 798              		.loc 1 515 36 view .LVU276
 517:lwIP/src/core/ipv4/ip4_frag.c **** 
 799              		.loc 1 517 3 view .LVU277
 504:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *r;
 800              		.loc 1 504 1 is_stmt 0 view .LVU278
 801 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 802              	.LCFI6:
 803              		.cfi_def_cfa_offset 36
 804              		.cfi_offset 4, -36
 805              		.cfi_offset 5, -32
 806              		.cfi_offset 6, -28
 807              		.cfi_offset 7, -24
 808              		.cfi_offset 8, -20
 809              		.cfi_offset 9, -16
 810              		.cfi_offset 10, -12
 811              		.cfi_offset 11, -8
 812              		.cfi_offset 14, -4
 517:lwIP/src/core/ipv4/ip4_frag.c **** 
 813              		.loc 1 517 11 view .LVU279
ARM GAS  /tmp/ccHPvcAz.s 			page 33


 814 0004 D0F804A0 		ldr	r10, [r0, #4]
 815              	.LVL70:
 519:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: IP options currently not supported!\n"));
 816              		.loc 1 519 3 is_stmt 1 view .LVU280
 504:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *r;
 817              		.loc 1 504 1 is_stmt 0 view .LVU281
 818 0008 87B0     		sub	sp, sp, #28
 819              	.LCFI7:
 820              		.cfi_def_cfa_offset 64
 504:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *r;
 821              		.loc 1 504 1 view .LVU282
 822 000a 0746     		mov	r7, r0
 519:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: IP options currently not supported!\n"));
 823              		.loc 1 519 7 view .LVU283
 824 000c 9AF80030 		ldrb	r3, [r10]	@ zero_extendqisi2
 825 0010 03F00F03 		and	r3, r3, #15
 519:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: IP options currently not supported!\n"));
 826              		.loc 1 519 6 view .LVU284
 827 0014 052B     		cmp	r3, #5
 828 0016 40F0BB80 		bne	.L91
 525:lwIP/src/core/ipv4/ip4_frag.c ****   len = lwip_ntohs(IPH_LEN(fraghdr));
 829              		.loc 1 525 3 is_stmt 1 view .LVU285
 830              	.LVL71:
 831              	.LBB96:
 832              	.LBI96:
 833              		.file 2 "STM32_XPD/CMSIS/Include/cmsis_gcc.h"
   1:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /*
   8:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  10:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  12:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  16:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  *
  18:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
  24:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  25:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  28:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
ARM GAS  /tmp/ccHPvcAz.s 			page 34


  32:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  34:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  38:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
  39:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  43:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  46:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  49:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  55:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  58:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  61:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  64:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  67:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  70:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  78:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  86:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
ARM GAS  /tmp/ccHPvcAz.s 			page 35


  89:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
  94:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 102:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 110:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 113:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 116:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 117:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 118:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   @{
 122:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 123:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 124:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 125:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 129:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 131:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 133:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 134:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 135:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 136:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 140:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 142:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 144:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 145:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccHPvcAz.s 			page 36


 146:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 147:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 151:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 153:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 155:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 158:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 159:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 160:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 162:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 166:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 168:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 170:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 173:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 174:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 175:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 176:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 177:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 181:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 183:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 185:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 186:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 187:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 189:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 193:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 195:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 197:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 198:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 199:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 200:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 201:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
ARM GAS  /tmp/ccHPvcAz.s 			page 37


 203:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 205:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 207:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 209:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 212:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 213:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 214:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 215:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 219:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 221:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 223:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 226:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 227:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 228:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 229:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 233:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 235:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 237:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 240:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 241:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 242:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 243:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 247:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 249:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 251:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 254:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 255:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 256:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 258:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
ARM GAS  /tmp/ccHPvcAz.s 			page 38


 260:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 262:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 264:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 266:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 269:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 270:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 271:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 272:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 273:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 277:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 279:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 281:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 282:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 283:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 285:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 289:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 291:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 293:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 294:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 295:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 296:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 297:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 301:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 303:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 305:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 308:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 309:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 310:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 312:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 316:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
ARM GAS  /tmp/ccHPvcAz.s 			page 39


 317:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 318:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 320:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 323:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 324:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 325:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 326:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 327:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 331:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 333:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 335:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 336:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 337:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 339:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 343:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 345:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 347:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 348:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 349:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 350:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 352:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 356:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 358:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 360:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 363:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 364:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 365:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 366:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 370:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 372:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/ccHPvcAz.s 			page 40


 374:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 375:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 376:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 377:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 378:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 382:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 384:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 386:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 389:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 390:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 391:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 393:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 397:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 399:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 401:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 404:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 405:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 406:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 407:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 408:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 412:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 414:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 416:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 417:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 418:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 420:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 424:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 426:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 428:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 429:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 430:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccHPvcAz.s 			page 41


 431:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 435:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 439:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 441:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 443:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 444:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 445:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 446:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 450:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 452:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 454:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 455:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 456:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 457:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 461:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 463:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 465:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 468:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 469:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 470:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 472:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 476:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 478:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 480:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 483:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 484:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 485:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 486:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 487:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
ARM GAS  /tmp/ccHPvcAz.s 			page 42


 488:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 491:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 493:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 495:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 496:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 497:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 499:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 503:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 505:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 507:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 508:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 509:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 510:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 511:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 516:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 518:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 520:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 521:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 522:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 523:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 527:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 529:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 531:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 534:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 535:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 536:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 538:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 542:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 544:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
ARM GAS  /tmp/ccHPvcAz.s 			page 43


 545:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 546:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 549:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 550:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 551:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 552:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 553:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 557:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 559:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 561:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 562:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 563:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 565:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 569:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 571:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 573:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 574:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 575:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 579:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 580:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 583:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 584:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   
 589:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 592:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 594:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 599:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
ARM GAS  /tmp/ccHPvcAz.s 			page 44


 602:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 603:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 604:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 605:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 607:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 611:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 614:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 616:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 620:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 624:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 625:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 626:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 627:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 628:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 629:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   
 634:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 637:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 639:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 644:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 646:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 647:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 648:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 649:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 651:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 655:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 658:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
ARM GAS  /tmp/ccHPvcAz.s 			page 45


 659:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 660:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 664:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 666:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 667:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 668:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 669:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 670:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 671:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 676:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 679:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 681:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 686:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 689:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 690:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 691:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 692:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 693:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 695:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 699:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 702:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 704:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 708:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 712:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 713:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 714:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 715:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccHPvcAz.s 			page 46


 716:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 717:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 722:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 725:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 727:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 732:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 734:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 735:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 736:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 737:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 739:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 743:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 746:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 748:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 752:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 754:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 755:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 756:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 757:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 760:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 761:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 762:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 766:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 768:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
ARM GAS  /tmp/ccHPvcAz.s 			page 47


 773:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 776:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 778:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 781:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 782:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 784:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 785:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 786:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 787:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 788:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 792:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 794:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 802:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 804:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 805:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 807:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 808:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 809:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 810:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 812:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 813:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   @{
 817:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** */
 818:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 819:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 827:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
ARM GAS  /tmp/ccHPvcAz.s 			page 48


 830:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 831:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 832:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 833:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 836:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 838:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 839:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 842:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 844:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 845:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 846:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 850:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 852:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 853:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 854:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 857:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 859:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 860:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 861:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 866:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 868:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 870:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 871:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 872:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 873:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 877:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 879:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 881:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 882:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 883:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 884:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 885:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 886:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
ARM GAS  /tmp/ccHPvcAz.s 			page 49


 887:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 888:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 890:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 892:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 893:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 894:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 895:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 899:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 900:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 901:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 902:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 903:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 904:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #else
 905:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 906:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 907:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 909:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #endif
 910:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 911:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 912:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 913:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 914:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 917:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 918:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 919:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 921:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 922:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 923:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 924:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return result;
 925:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** }
 926:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 927:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** 
 928:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** /**
 929:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 933:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****  */
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 834              		.loc 2 934 30 view .LVU286
 835              	.LBB97:
 935:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 936:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:STM32_XPD/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 836              		.loc 2 937 3 view .LVU287
 837              		.loc 2 937 3 is_stmt 0 view .LVU288
 838              	.LBE97:
 839              	.LBE96:
ARM GAS  /tmp/ccHPvcAz.s 			page 50


 526:lwIP/src/core/ipv4/ip4_frag.c ****   hlen = IPH_HL_BYTES(fraghdr);
 840              		.loc 1 526 3 is_stmt 1 view .LVU289
 841              	.LBB99:
 842              	.LBI99:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 843              		.loc 2 934 30 view .LVU290
 844              	.LBB100:
 845              		.loc 2 937 3 view .LVU291
 846              	.LBE100:
 847              	.LBE99:
 526:lwIP/src/core/ipv4/ip4_frag.c ****   hlen = IPH_HL_BYTES(fraghdr);
 848              		.loc 1 526 9 is_stmt 0 view .LVU292
 849 001a BAF80230 		ldrh	r3, [r10, #2]	@ unaligned
 850              	.LBB102:
 851              	.LBB101:
 852              		.loc 2 937 19 view .LVU293
 853 001e 5BBA     		rev16	r3, r3
 854 0020 9BB2     		uxth	r3, r3
 855              	.LVL72:
 856              		.loc 2 937 19 view .LVU294
 857              	.LBE101:
 858              	.LBE102:
 527:lwIP/src/core/ipv4/ip4_frag.c ****   if (hlen > len) {
 859              		.loc 1 527 3 is_stmt 1 view .LVU295
 528:lwIP/src/core/ipv4/ip4_frag.c ****     /* invalid datagram */
 860              		.loc 1 528 3 view .LVU296
 528:lwIP/src/core/ipv4/ip4_frag.c ****     /* invalid datagram */
 861              		.loc 1 528 6 is_stmt 0 view .LVU297
 862 0022 132B     		cmp	r3, #19
 863 0024 40F2B480 		bls	.L91
 532:lwIP/src/core/ipv4/ip4_frag.c **** 
 864              		.loc 1 532 7 view .LVU298
 865 0028 143B     		subs	r3, r3, #20
 866              	.LVL73:
 536:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_FREE_OLDEST
 867              		.loc 1 536 27 view .LVU299
 868 002a A74D     		ldr	r5, .L201
 525:lwIP/src/core/ipv4/ip4_frag.c ****   len = lwip_ntohs(IPH_LEN(fraghdr));
 869              		.loc 1 525 12 view .LVU300
 870 002c BAF80690 		ldrh	r9, [r10, #6]	@ unaligned
 532:lwIP/src/core/ipv4/ip4_frag.c **** 
 871              		.loc 1 532 3 is_stmt 1 view .LVU301
 532:lwIP/src/core/ipv4/ip4_frag.c **** 
 872              		.loc 1 532 7 is_stmt 0 view .LVU302
 873 0030 9BB2     		uxth	r3, r3
 874              	.LVL74:
 532:lwIP/src/core/ipv4/ip4_frag.c **** 
 875              		.loc 1 532 7 view .LVU303
 876 0032 0293     		str	r3, [sp, #8]
 877              	.LVL75:
 535:lwIP/src/core/ipv4/ip4_frag.c ****   if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 878              		.loc 1 535 3 is_stmt 1 view .LVU304
 535:lwIP/src/core/ipv4/ip4_frag.c ****   if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 879              		.loc 1 535 10 is_stmt 0 view .LVU305
 880 0034 FFF7FEFF 		bl	pbuf_clen
 881              	.LVL76:
 536:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_FREE_OLDEST
ARM GAS  /tmp/ccHPvcAz.s 			page 51


 882              		.loc 1 536 27 view .LVU306
 883 0038 2B88     		ldrh	r3, [r5]
 535:lwIP/src/core/ipv4/ip4_frag.c ****   if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 884              		.loc 1 535 10 view .LVU307
 885 003a 0646     		mov	r6, r0
 886              	.LVL77:
 536:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_FREE_OLDEST
 887              		.loc 1 536 3 is_stmt 1 view .LVU308
 536:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_FREE_OLDEST
 888              		.loc 1 536 27 is_stmt 0 view .LVU309
 889 003c 0344     		add	r3, r3, r0
 536:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_FREE_OLDEST
 890              		.loc 1 536 6 view .LVU310
 891 003e 0A2B     		cmp	r3, #10
 892 0040 00F3D280 		bgt	.L93
 893              	.LVL78:
 894              	.L96:
 554:lwIP/src/core/ipv4/ip4_frag.c ****     /* Check if the incoming fragment matches the one currently present
 895              		.loc 1 554 3 is_stmt 1 view .LVU311
 554:lwIP/src/core/ipv4/ip4_frag.c ****     /* Check if the incoming fragment matches the one currently present
 896              		.loc 1 554 12 is_stmt 0 view .LVU312
 897 0044 DFF88882 		ldr	r8, .L201+8
 898 0048 D8F80030 		ldr	r3, [r8]
 899 004c 0393     		str	r3, [sp, #12]
 900              	.LVL79:
 554:lwIP/src/core/ipv4/ip4_frag.c ****     /* Check if the incoming fragment matches the one currently present
 901              		.loc 1 554 30 is_stmt 1 view .LVU313
 554:lwIP/src/core/ipv4/ip4_frag.c ****     /* Check if the incoming fragment matches the one currently present
 902              		.loc 1 554 3 is_stmt 0 view .LVU314
 903 004e 002B     		cmp	r3, #0
 904 0050 00F0D680 		beq	.L95
 905 0054 1C46     		mov	r4, r3
 558:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: matching previous fragment ID=%"X16_F"\n",
 906              		.loc 1 558 9 view .LVU315
 907 0056 DAF80C20 		ldr	r2, [r10, #12]	@ unaligned
 908 005a 03E0     		b	.L99
 909              	.LVL80:
 910              	.L97:
 554:lwIP/src/core/ipv4/ip4_frag.c ****     /* Check if the incoming fragment matches the one currently present
 911              		.loc 1 554 47 discriminator 2 view .LVU316
 912 005c 2468     		ldr	r4, [r4]
 913              	.LVL81:
 554:lwIP/src/core/ipv4/ip4_frag.c ****     /* Check if the incoming fragment matches the one currently present
 914              		.loc 1 554 30 is_stmt 1 discriminator 2 view .LVU317
 554:lwIP/src/core/ipv4/ip4_frag.c ****     /* Check if the incoming fragment matches the one currently present
 915              		.loc 1 554 3 is_stmt 0 discriminator 2 view .LVU318
 916 005e 002C     		cmp	r4, #0
 917 0060 00F0CE80 		beq	.L95
 918              	.L99:
 558:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: matching previous fragment ID=%"X16_F"\n",
 919              		.loc 1 558 5 is_stmt 1 view .LVU319
 554:lwIP/src/core/ipv4/ip4_frag.c ****     /* Check if the incoming fragment matches the one currently present
 920              		.loc 1 554 43 view .LVU320
 921              	.LVL82:
 558:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: matching previous fragment ID=%"X16_F"\n",
 922              		.loc 1 558 8 is_stmt 0 view .LVU321
 923 0064 6369     		ldr	r3, [r4, #20]
ARM GAS  /tmp/ccHPvcAz.s 			page 52


 924 0066 9342     		cmp	r3, r2
 925 0068 F8D1     		bne	.L97
 558:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: matching previous fragment ID=%"X16_F"\n",
 926              		.loc 1 558 9 discriminator 1 view .LVU322
 927 006a DAF81030 		ldr	r3, [r10, #16]	@ unaligned
 928 006e A169     		ldr	r1, [r4, #24]
 929 0070 9942     		cmp	r1, r3
 930 0072 F3D1     		bne	.L97
 558:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: matching previous fragment ID=%"X16_F"\n",
 931              		.loc 1 558 9 discriminator 2 view .LVU323
 932 0074 A189     		ldrh	r1, [r4, #12]
 933 0076 BAF80430 		ldrh	r3, [r10, #4]	@ unaligned
 934 007a 9942     		cmp	r1, r3
 935 007c EED1     		bne	.L97
 566:lwIP/src/core/ipv4/ip4_frag.c ****     /* Enqueue a new datagram into the datagram queue */
 936              		.loc 1 566 3 is_stmt 1 view .LVU324
 574:lwIP/src/core/ipv4/ip4_frag.c ****         ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 937              		.loc 1 574 5 view .LVU325
 574:lwIP/src/core/ipv4/ip4_frag.c ****         ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 938              		.loc 1 574 11 is_stmt 0 view .LVU326
 939 007e BAF80600 		ldrh	r0, [r10, #6]	@ unaligned
 940              	.LBB103:
 941              	.LBB104:
 942              		.loc 2 937 19 view .LVU327
 943 0082 43BA     		rev16	r3, r0
 944              	.LBE104:
 945              	.LBE103:
 574:lwIP/src/core/ipv4/ip4_frag.c ****         ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 946              		.loc 1 574 11 view .LVU328
 947 0084 80B2     		uxth	r0, r0
 948              	.LVL83:
 949              	.LBB106:
 950              	.LBI103:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 951              		.loc 2 934 30 is_stmt 1 view .LVU329
 952              	.LBB105:
 953              		.loc 2 937 3 view .LVU330
 954              		.loc 2 937 3 is_stmt 0 view .LVU331
 955              	.LBE105:
 956              	.LBE106:
 574:lwIP/src/core/ipv4/ip4_frag.c ****         ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 957              		.loc 1 574 8 view .LVU332
 958 0086 C3F30C03 		ubfx	r3, r3, #0, #13
 959 008a 002B     		cmp	r3, #0
 960 008c 00F09380 		beq	.L142
 961              	.LVL84:
 962              	.L100:
 963              	.LBB107:
 964              	.LBB98:
 965              		.loc 2 937 19 view .LVU333
 966 0090 99FA99F3 		rev16	r3, r9
 967              	.LBE98:
 968              	.LBE107:
 589:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 969              		.loc 1 589 6 view .LVU334
 970 0094 10F02000 		ands	r0, r0, #32
 525:lwIP/src/core/ipv4/ip4_frag.c ****   len = lwip_ntohs(IPH_LEN(fraghdr));
ARM GAS  /tmp/ccHPvcAz.s 			page 53


 971              		.loc 1 525 12 view .LVU335
 972 0098 C3F30C03 		ubfx	r3, r3, #0, #13
 525:lwIP/src/core/ipv4/ip4_frag.c ****   len = lwip_ntohs(IPH_LEN(fraghdr));
 973              		.loc 1 525 10 view .LVU336
 974 009c 4FEAC302 		lsl	r2, r3, #3
 975 00a0 0492     		str	r2, [sp, #16]
 588:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 976              		.loc 1 588 3 is_stmt 1 view .LVU337
 977              	.LVL85:
 589:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 978              		.loc 1 589 3 view .LVU338
 589:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 979              		.loc 1 589 6 is_stmt 0 view .LVU339
 980 00a2 08D1     		bne	.L101
 981              	.LBB108:
 590:lwIP/src/core/ipv4/ip4_frag.c ****     if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
 982              		.loc 1 590 5 is_stmt 1 view .LVU340
 590:lwIP/src/core/ipv4/ip4_frag.c ****     if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
 983              		.loc 1 590 11 is_stmt 0 view .LVU341
 984 00a4 029B     		ldr	r3, [sp, #8]
 985 00a6 D318     		adds	r3, r2, r3
 986 00a8 9BB2     		uxth	r3, r3
 987              	.LVL86:
 591:lwIP/src/core/ipv4/ip4_frag.c ****       /* u16_t overflow, cannot handle this */
 988              		.loc 1 591 5 is_stmt 1 view .LVU342
 591:lwIP/src/core/ipv4/ip4_frag.c ****       /* u16_t overflow, cannot handle this */
 989              		.loc 1 591 8 is_stmt 0 view .LVU343
 990 00aa 9A42     		cmp	r2, r3
 991 00ac 79D8     		bhi	.L102
 591:lwIP/src/core/ipv4/ip4_frag.c ****       /* u16_t overflow, cannot handle this */
 992              		.loc 1 591 50 view .LVU344
 993 00ae 4FF6EB72 		movw	r2, #65515
 591:lwIP/src/core/ipv4/ip4_frag.c ****       /* u16_t overflow, cannot handle this */
 994              		.loc 1 591 8 view .LVU345
 995 00b2 9342     		cmp	r3, r2
 996 00b4 75D8     		bhi	.L102
 997              	.LVL87:
 998              	.L101:
 591:lwIP/src/core/ipv4/ip4_frag.c ****       /* u16_t overflow, cannot handle this */
 999              		.loc 1 591 8 view .LVU346
 1000              	.LBE108:
 598:lwIP/src/core/ipv4/ip4_frag.c ****   if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
 1001              		.loc 1 598 3 is_stmt 1 view .LVU347
 1002              	.LBB109:
 1003              	.LBI109:
 344:lwIP/src/core/ipv4/ip4_frag.c **** {
 1004              		.loc 1 344 1 view .LVU348
 1005              	.LBB110:
 346:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *q;
 1006              		.loc 1 346 3 view .LVU349
 347:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t offset, len;
 1007              		.loc 1 347 3 view .LVU350
 348:lwIP/src/core/ipv4/ip4_frag.c ****   u8_t hlen;
 1008              		.loc 1 348 3 view .LVU351
 349:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_hdr *fraghdr;
 1009              		.loc 1 349 3 view .LVU352
 350:lwIP/src/core/ipv4/ip4_frag.c ****   int valid = 1;
ARM GAS  /tmp/ccHPvcAz.s 			page 54


 1010              		.loc 1 350 3 view .LVU353
 351:lwIP/src/core/ipv4/ip4_frag.c **** 
 1011              		.loc 1 351 3 view .LVU354
 354:lwIP/src/core/ipv4/ip4_frag.c ****   len = lwip_ntohs(IPH_LEN(fraghdr));
 1012              		.loc 1 354 3 view .LVU355
 354:lwIP/src/core/ipv4/ip4_frag.c ****   len = lwip_ntohs(IPH_LEN(fraghdr));
 1013              		.loc 1 354 11 is_stmt 0 view .LVU356
 1014 00b6 7A68     		ldr	r2, [r7, #4]
 1015              	.LVL88:
 355:lwIP/src/core/ipv4/ip4_frag.c ****   hlen = IPH_HL_BYTES(fraghdr);
 1016              		.loc 1 355 3 is_stmt 1 view .LVU357
 1017              	.LBB111:
 1018              	.LBI111:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1019              		.loc 2 934 30 view .LVU358
 1020              	.LBB112:
 1021              		.loc 2 937 3 view .LVU359
 1022              	.LBE112:
 1023              	.LBE111:
 355:lwIP/src/core/ipv4/ip4_frag.c ****   hlen = IPH_HL_BYTES(fraghdr);
 1024              		.loc 1 355 9 is_stmt 0 view .LVU360
 1025 00b8 5388     		ldrh	r3, [r2, #2]	@ unaligned
 356:lwIP/src/core/ipv4/ip4_frag.c ****   if (hlen > len) {
 1026              		.loc 1 356 10 view .LVU361
 1027 00ba 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 1028              	.LBB115:
 1029              	.LBB113:
 1030              		.loc 2 937 19 view .LVU362
 1031 00bc 5BBA     		rev16	r3, r3
 1032              	.LBE113:
 1033              	.LBE115:
 356:lwIP/src/core/ipv4/ip4_frag.c ****   if (hlen > len) {
 1034              		.loc 1 356 10 view .LVU363
 1035 00be 01F00F01 		and	r1, r1, #15
 1036              	.LBB116:
 1037              	.LBB114:
 1038              		.loc 2 937 19 view .LVU364
 1039 00c2 9BB2     		uxth	r3, r3
 1040              	.LVL89:
 1041              		.loc 2 937 19 view .LVU365
 1042              	.LBE114:
 1043              	.LBE116:
 356:lwIP/src/core/ipv4/ip4_frag.c ****   if (hlen > len) {
 1044              		.loc 1 356 3 is_stmt 1 view .LVU366
 357:lwIP/src/core/ipv4/ip4_frag.c ****     /* invalid datagram */
 1045              		.loc 1 357 3 view .LVU367
 357:lwIP/src/core/ipv4/ip4_frag.c ****     /* invalid datagram */
 1046              		.loc 1 357 12 is_stmt 0 view .LVU368
 1047 00c4 4FEA810C 		lsl	ip, r1, #2
 357:lwIP/src/core/ipv4/ip4_frag.c ****     /* invalid datagram */
 1048              		.loc 1 357 6 view .LVU369
 1049 00c8 B3EB810F 		cmp	r3, r1, lsl #2
 1050 00cc 69D3     		bcc	.L102
 361:lwIP/src/core/ipv4/ip4_frag.c ****   offset = IPH_OFFSET_BYTES(fraghdr);
 1051              		.loc 1 361 3 is_stmt 1 view .LVU370
 1052              	.LVL90:
 362:lwIP/src/core/ipv4/ip4_frag.c **** 
ARM GAS  /tmp/ccHPvcAz.s 			page 55


 1053              		.loc 1 362 3 view .LVU371
 1054              	.LBB117:
 1055              	.LBI117:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1056              		.loc 2 934 30 view .LVU372
 1057              	.LBB118:
 1058              		.loc 2 937 3 view .LVU373
 1059              		.loc 2 937 3 is_stmt 0 view .LVU374
 1060              	.LBE118:
 1061              	.LBE117:
 362:lwIP/src/core/ipv4/ip4_frag.c **** 
 1062              		.loc 1 362 12 view .LVU375
 1063 00ce D188     		ldrh	r1, [r2, #6]	@ unaligned
 361:lwIP/src/core/ipv4/ip4_frag.c ****   offset = IPH_OFFSET_BYTES(fraghdr);
 1064              		.loc 1 361 7 view .LVU376
 1065 00d0 A3EB0C0C 		sub	ip, r3, ip
 1066              	.LVL91:
 370:lwIP/src/core/ipv4/ip4_frag.c ****   iprh->start = offset;
 1067              		.loc 1 370 19 view .LVU377
 1068 00d4 0023     		movs	r3, #0
 1069              	.LVL92:
 1070              	.LBB120:
 1071              	.LBB119:
 1072              		.loc 2 937 19 view .LVU378
 1073 00d6 49BA     		rev16	r1, r1
 1074              	.LBE119:
 1075              	.LBE120:
 370:lwIP/src/core/ipv4/ip4_frag.c ****   iprh->start = offset;
 1076              		.loc 1 370 19 view .LVU379
 1077 00d8 1370     		strb	r3, [r2]
 1078              	.LVL93:
 362:lwIP/src/core/ipv4/ip4_frag.c **** 
 1079              		.loc 1 362 12 view .LVU380
 1080 00da C1F30C01 		ubfx	r1, r1, #0, #13
 370:lwIP/src/core/ipv4/ip4_frag.c ****   iprh->start = offset;
 1081              		.loc 1 370 19 view .LVU381
 1082 00de 5370     		strb	r3, [r2, #1]
 1083 00e0 9370     		strb	r3, [r2, #2]
 362:lwIP/src/core/ipv4/ip4_frag.c **** 
 1084              		.loc 1 362 10 view .LVU382
 1085 00e2 C900     		lsls	r1, r1, #3
 1086              	.LVL94:
 367:lwIP/src/core/ipv4/ip4_frag.c ****               sizeof(struct ip_reass_helper) <= IP_HLEN);
 1087              		.loc 1 367 3 is_stmt 1 view .LVU383
 367:lwIP/src/core/ipv4/ip4_frag.c ****               sizeof(struct ip_reass_helper) <= IP_HLEN);
 1088              		.loc 1 367 3 view .LVU384
 367:lwIP/src/core/ipv4/ip4_frag.c ****               sizeof(struct ip_reass_helper) <= IP_HLEN);
 1089              		.loc 1 367 3 view .LVU385
 369:lwIP/src/core/ipv4/ip4_frag.c ****   iprh->next_pbuf = NULL;
 1090              		.loc 1 369 3 view .LVU386
 370:lwIP/src/core/ipv4/ip4_frag.c ****   iprh->start = offset;
 1091              		.loc 1 370 3 view .LVU387
 370:lwIP/src/core/ipv4/ip4_frag.c ****   iprh->start = offset;
 1092              		.loc 1 370 19 is_stmt 0 view .LVU388
 1093 00e4 D370     		strb	r3, [r2, #3]
 371:lwIP/src/core/ipv4/ip4_frag.c ****   iprh->end = (u16_t)(offset + len);
 1094              		.loc 1 371 3 is_stmt 1 view .LVU389
ARM GAS  /tmp/ccHPvcAz.s 			page 56


 372:lwIP/src/core/ipv4/ip4_frag.c ****   if (iprh->end < offset) {
 1095              		.loc 1 372 15 is_stmt 0 view .LVU390
 1096 00e6 8C44     		add	ip, ip, r1
 371:lwIP/src/core/ipv4/ip4_frag.c ****   iprh->end = (u16_t)(offset + len);
 1097              		.loc 1 371 15 view .LVU391
 1098 00e8 9180     		strh	r1, [r2, #4]	@ unaligned
 372:lwIP/src/core/ipv4/ip4_frag.c ****   if (iprh->end < offset) {
 1099              		.loc 1 372 3 is_stmt 1 view .LVU392
 372:lwIP/src/core/ipv4/ip4_frag.c ****   if (iprh->end < offset) {
 1100              		.loc 1 372 15 is_stmt 0 view .LVU393
 1101 00ea 1FFA8CFA 		uxth	r10, ip
 1102              	.LVL95:
 372:lwIP/src/core/ipv4/ip4_frag.c ****   if (iprh->end < offset) {
 1103              		.loc 1 372 13 view .LVU394
 1104 00ee A2F806C0 		strh	ip, [r2, #6]	@ unaligned
 373:lwIP/src/core/ipv4/ip4_frag.c ****     /* u16_t overflow, cannot handle this */
 1105              		.loc 1 373 3 is_stmt 1 view .LVU395
 373:lwIP/src/core/ipv4/ip4_frag.c ****     /* u16_t overflow, cannot handle this */
 1106              		.loc 1 373 6 is_stmt 0 view .LVU396
 1107 00f2 5145     		cmp	r1, r10
 1108 00f4 55D8     		bhi	.L102
 380:lwIP/src/core/ipv4/ip4_frag.c ****     iprh_tmp = (struct ip_reass_helper *)q->payload;
 1109              		.loc 1 380 3 is_stmt 1 view .LVU397
 380:lwIP/src/core/ipv4/ip4_frag.c ****     iprh_tmp = (struct ip_reass_helper *)q->payload;
 1110              		.loc 1 380 10 is_stmt 0 view .LVU398
 1111 00f6 D4F804C0 		ldr	ip, [r4, #4]
 1112              	.LVL96:
 380:lwIP/src/core/ipv4/ip4_frag.c ****     iprh_tmp = (struct ip_reass_helper *)q->payload;
 1113              		.loc 1 380 20 is_stmt 1 view .LVU399
 380:lwIP/src/core/ipv4/ip4_frag.c ****     iprh_tmp = (struct ip_reass_helper *)q->payload;
 1114              		.loc 1 380 3 is_stmt 0 view .LVU400
 1115 00fa BCF1000F 		cmp	ip, #0
 1116 00fe 00F06F81 		beq	.L103
 346:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *q;
 1117              		.loc 1 346 45 view .LVU401
 1118 0102 9E46     		mov	lr, r3
 351:lwIP/src/core/ipv4/ip4_frag.c **** 
 1119              		.loc 1 351 7 view .LVU402
 1120 0104 0123     		movs	r3, #1
 1121 0106 0592     		str	r2, [sp, #20]
 1122 0108 0193     		str	r3, [sp, #4]
 1123 010a 7346     		mov	r3, lr
 1124 010c 14E0     		b	.L110
 1125              	.LVL97:
 1126              	.L104:
 410:lwIP/src/core/ipv4/ip4_frag.c ****       /* received the same datagram twice: no need to keep the datagram */
 1127              		.loc 1 410 15 view .LVU403
 1128 010e 48D0     		beq	.L102
 414:lwIP/src/core/ipv4/ip4_frag.c ****       /* overlap: no need to keep the new datagram */
 1129              		.loc 1 414 38 view .LVU404
 1130 0110 B3F806B0 		ldrh	fp, [r3, #6]	@ unaligned
 414:lwIP/src/core/ipv4/ip4_frag.c ****       /* overlap: no need to keep the new datagram */
 1131              		.loc 1 414 15 view .LVU405
 1132 0114 5945     		cmp	r1, fp
 1133 0116 44D3     		bcc	.L102
 420:lwIP/src/core/ipv4/ip4_frag.c ****         if (iprh_prev->end != iprh_tmp->start) {
 1134              		.loc 1 420 10 view .LVU406
ARM GAS  /tmp/ccHPvcAz.s 			page 57


 1135 0118 BEF1000F 		cmp	lr, #0
 1136 011c 06D0     		beq	.L109
 421:lwIP/src/core/ipv4/ip4_frag.c ****           /* There is a fragment missing between the current
 1137              		.loc 1 421 12 view .LVU407
 1138 011e BEF806C0 		ldrh	ip, [lr, #6]	@ unaligned
 1139              	.LVL98:
 424:lwIP/src/core/ipv4/ip4_frag.c ****         }
 1140              		.loc 1 424 17 view .LVU408
 1141 0122 019A     		ldr	r2, [sp, #4]
 1142 0124 CC45     		cmp	ip, r9
 1143 0126 18BF     		it	ne
 1144 0128 0022     		movne	r2, #0
 1145 012a 0192     		str	r2, [sp, #4]
 1146              	.LVL99:
 1147              	.L109:
 428:lwIP/src/core/ipv4/ip4_frag.c ****     iprh_prev = iprh_tmp;
 1148              		.loc 1 428 5 is_stmt 1 view .LVU409
 428:lwIP/src/core/ipv4/ip4_frag.c ****     iprh_prev = iprh_tmp;
 1149              		.loc 1 428 7 is_stmt 0 view .LVU410
 1150 012c D3F800C0 		ldr	ip, [r3]	@ unaligned
 1151              	.LVL100:
 429:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1152              		.loc 1 429 5 is_stmt 1 view .LVU411
 380:lwIP/src/core/ipv4/ip4_frag.c ****     iprh_tmp = (struct ip_reass_helper *)q->payload;
 1153              		.loc 1 380 20 view .LVU412
 380:lwIP/src/core/ipv4/ip4_frag.c ****     iprh_tmp = (struct ip_reass_helper *)q->payload;
 1154              		.loc 1 380 3 is_stmt 0 view .LVU413
 1155 0130 BCF1000F 		cmp	ip, #0
 1156 0134 00F08C80 		beq	.L195
 1157              	.LVL101:
 1158              	.L110:
 381:lwIP/src/core/ipv4/ip4_frag.c ****     if (iprh->start < iprh_tmp->start) {
 1159              		.loc 1 381 5 is_stmt 1 view .LVU414
 410:lwIP/src/core/ipv4/ip4_frag.c ****       /* received the same datagram twice: no need to keep the datagram */
 1160              		.loc 1 410 12 view .LVU415
 414:lwIP/src/core/ipv4/ip4_frag.c ****       /* overlap: no need to keep the new datagram */
 1161              		.loc 1 414 12 view .LVU416
 420:lwIP/src/core/ipv4/ip4_frag.c ****         if (iprh_prev->end != iprh_tmp->start) {
 1162              		.loc 1 420 7 view .LVU417
 421:lwIP/src/core/ipv4/ip4_frag.c ****           /* There is a fragment missing between the current
 1163              		.loc 1 421 9 view .LVU418
 1164 0138 9E46     		mov	lr, r3
 381:lwIP/src/core/ipv4/ip4_frag.c ****     if (iprh->start < iprh_tmp->start) {
 1165              		.loc 1 381 14 is_stmt 0 view .LVU419
 1166 013a DCF80430 		ldr	r3, [ip, #4]
 1167              	.LVL102:
 382:lwIP/src/core/ipv4/ip4_frag.c ****       /* the new pbuf should be inserted before this */
 1168              		.loc 1 382 5 is_stmt 1 view .LVU420
 382:lwIP/src/core/ipv4/ip4_frag.c ****       /* the new pbuf should be inserted before this */
 1169              		.loc 1 382 31 is_stmt 0 view .LVU421
 1170 013e B3F80490 		ldrh	r9, [r3, #4]	@ unaligned
 382:lwIP/src/core/ipv4/ip4_frag.c ****       /* the new pbuf should be inserted before this */
 1171              		.loc 1 382 8 view .LVU422
 1172 0142 4945     		cmp	r1, r9
 1173 0144 E3D2     		bcs	.L104
 384:lwIP/src/core/ipv4/ip4_frag.c ****       if (iprh_prev != NULL) {
 1174              		.loc 1 384 7 is_stmt 1 view .LVU423
ARM GAS  /tmp/ccHPvcAz.s 			page 58


 1175 0146 059A     		ldr	r2, [sp, #20]
 384:lwIP/src/core/ipv4/ip4_frag.c ****       if (iprh_prev != NULL) {
 1176              		.loc 1 384 23 is_stmt 0 view .LVU424
 1177 0148 C2F800C0 		str	ip, [r2]	@ unaligned
 385:lwIP/src/core/ipv4/ip4_frag.c ****         /* not the fragment with the lowest offset */
 1178              		.loc 1 385 7 is_stmt 1 view .LVU425
 385:lwIP/src/core/ipv4/ip4_frag.c ****         /* not the fragment with the lowest offset */
 1179              		.loc 1 385 10 is_stmt 0 view .LVU426
 1180 014c BEF1000F 		cmp	lr, #0
 1181 0150 00F05381 		beq	.L105
 388:lwIP/src/core/ipv4/ip4_frag.c ****           /* fragment overlaps with previous or following, throw away */
 1182              		.loc 1 388 9 is_stmt 1 view .LVU427
 388:lwIP/src/core/ipv4/ip4_frag.c ****           /* fragment overlaps with previous or following, throw away */
 1183              		.loc 1 388 37 is_stmt 0 view .LVU428
 1184 0154 BEF80630 		ldrh	r3, [lr, #6]	@ unaligned
 1185              	.LVL103:
 388:lwIP/src/core/ipv4/ip4_frag.c ****           /* fragment overlaps with previous or following, throw away */
 1186              		.loc 1 388 44 view .LVU429
 1187 0158 9942     		cmp	r1, r3
 1188 015a 22D3     		bcc	.L102
 1189 015c CA45     		cmp	r10, r9
 1190 015e 20D8     		bhi	.L102
 393:lwIP/src/core/ipv4/ip4_frag.c ****         if (iprh_prev->end != iprh->start) {
 1191              		.loc 1 393 9 is_stmt 1 view .LVU430
 394:lwIP/src/core/ipv4/ip4_frag.c ****           /* There is a fragment missing between the current
 1192              		.loc 1 394 12 is_stmt 0 view .LVU431
 1193 0160 9942     		cmp	r1, r3
 393:lwIP/src/core/ipv4/ip4_frag.c ****         if (iprh_prev->end != iprh->start) {
 1194              		.loc 1 393 30 view .LVU432
 1195 0162 CEF80070 		str	r7, [lr]	@ unaligned
 394:lwIP/src/core/ipv4/ip4_frag.c ****           /* There is a fragment missing between the current
 1196              		.loc 1 394 9 is_stmt 1 view .LVU433
 394:lwIP/src/core/ipv4/ip4_frag.c ****           /* There is a fragment missing between the current
 1197              		.loc 1 394 12 is_stmt 0 view .LVU434
 1198 0166 78D0     		beq	.L106
 1199              	.LVL104:
 1200              	.L141:
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1201              		.loc 1 456 3 is_stmt 1 view .LVU435
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1202              		.loc 1 456 6 is_stmt 0 view .LVU436
 1203 0168 0028     		cmp	r0, #0
 1204 016a 00F02D81 		beq	.L151
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1205              		.loc 1 456 15 view .LVU437
 1206 016e A37F     		ldrb	r3, [r4, #30]	@ zero_extendqisi2
 1207 0170 DB07     		lsls	r3, r3, #31
 1208 0172 00F11F81 		bmi	.L153
 1209              	.LVL105:
 1210              	.L140:
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1211              		.loc 1 456 15 view .LVU438
 1212              	.LBE110:
 1213              	.LBE109:
 599:lwIP/src/core/ipv4/ip4_frag.c ****     goto nullreturn_ipr;
 1214              		.loc 1 599 3 is_stmt 1 view .LVU439
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
ARM GAS  /tmp/ccHPvcAz.s 			page 59


 1215              		.loc 1 607 3 view .LVU440
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1216              		.loc 1 607 24 is_stmt 0 view .LVU441
 1217 0176 2B88     		ldrh	r3, [r5]
 677:lwIP/src/core/ipv4/ip4_frag.c **** 
 1218              		.loc 1 677 10 view .LVU442
 1219 0178 4FF00009 		mov	r9, #0
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1220              		.loc 1 607 24 view .LVU443
 1221 017c 3344     		add	r3, r3, r6
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1222              		.loc 1 607 22 view .LVU444
 1223 017e 2B80     		strh	r3, [r5]	@ movhi
 608:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 1224              		.loc 1 608 3 is_stmt 1 view .LVU445
 1225              	.LBB126:
 614:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1226              		.loc 1 614 37 view .LVU446
 1227              	.LBE126:
 617:lwIP/src/core/ipv4/ip4_frag.c ****     struct ip_reassdata *ipr_prev;
 1228              		.loc 1 617 3 view .LVU447
 1229 0180 0BE0     		b	.L89
 1230              	.LVL106:
 1231              	.L134:
 683:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, NULL);
 1232              		.loc 1 683 5 view .LVU448
 684:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1233              		.loc 1 684 5 view .LVU449
 1234              	.LBB127:
 1235              	.LBI127:
 317:lwIP/src/core/ipv4/ip4_frag.c **** {
 1236              		.loc 1 317 1 view .LVU450
 1237              	.LBB128:
 320:lwIP/src/core/ipv4/ip4_frag.c ****     /* it was the first in the list */
 1238              		.loc 1 320 3 view .LVU451
 322:lwIP/src/core/ipv4/ip4_frag.c ****   } else {
 1239              		.loc 1 322 5 view .LVU452
 322:lwIP/src/core/ipv4/ip4_frag.c ****   } else {
 1240              		.loc 1 322 20 is_stmt 0 view .LVU453
 1241 0182 2368     		ldr	r3, [r4]
 330:lwIP/src/core/ipv4/ip4_frag.c **** }
 1242              		.loc 1 330 3 view .LVU454
 1243 0184 2146     		mov	r1, r4
 1244 0186 0420     		movs	r0, #4
 322:lwIP/src/core/ipv4/ip4_frag.c ****   } else {
 1245              		.loc 1 322 20 view .LVU455
 1246 0188 C8F80030 		str	r3, [r8]
 330:lwIP/src/core/ipv4/ip4_frag.c **** }
 1247              		.loc 1 330 3 is_stmt 1 view .LVU456
 1248 018c FFF7FEFF 		bl	memp_free
 1249              	.LVL107:
 1250              	.L91:
 330:lwIP/src/core/ipv4/ip4_frag.c **** }
 1251              		.loc 1 330 3 is_stmt 0 view .LVU457
 1252              	.LBE128:
 1253              	.LBE127:
 688:lwIP/src/core/ipv4/ip4_frag.c ****   IPFRAG_STATS_INC(ip_frag.drop);
ARM GAS  /tmp/ccHPvcAz.s 			page 60


 1254              		.loc 1 688 59 is_stmt 1 view .LVU458
 689:lwIP/src/core/ipv4/ip4_frag.c ****   pbuf_free(p);
 1255              		.loc 1 689 33 view .LVU459
 690:lwIP/src/core/ipv4/ip4_frag.c ****   return NULL;
 1256              		.loc 1 690 3 view .LVU460
 1257 0190 3846     		mov	r0, r7
 691:lwIP/src/core/ipv4/ip4_frag.c **** }
 1258              		.loc 1 691 10 is_stmt 0 view .LVU461
 1259 0192 4FF00009 		mov	r9, #0
 690:lwIP/src/core/ipv4/ip4_frag.c ****   return NULL;
 1260              		.loc 1 690 3 view .LVU462
 1261 0196 FFF7FEFF 		bl	pbuf_free
 1262              	.LVL108:
 691:lwIP/src/core/ipv4/ip4_frag.c **** }
 1263              		.loc 1 691 3 is_stmt 1 view .LVU463
 1264              	.L89:
 692:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASSEMBLY */
 1265              		.loc 1 692 1 is_stmt 0 view .LVU464
 1266 019a 4846     		mov	r0, r9
 1267 019c 07B0     		add	sp, sp, #28
 1268              	.LCFI8:
 1269              		.cfi_remember_state
 1270              		.cfi_def_cfa_offset 36
 1271              		@ sp needed
 1272 019e BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1273              	.LVL109:
 1274              	.L102:
 1275              	.LCFI9:
 1276              		.cfi_restore_state
 680:lwIP/src/core/ipv4/ip4_frag.c ****   if (ipr->p == NULL) {
 1277              		.loc 1 680 3 is_stmt 1 view .LVU465
 680:lwIP/src/core/ipv4/ip4_frag.c ****   if (ipr->p == NULL) {
 1278              		.loc 1 680 3 view .LVU466
 680:lwIP/src/core/ipv4/ip4_frag.c ****   if (ipr->p == NULL) {
 1279              		.loc 1 680 3 view .LVU467
 681:lwIP/src/core/ipv4/ip4_frag.c ****     /* dropped pbuf after creating a new datagram entry: remove the entry, too */
 1280              		.loc 1 681 3 view .LVU468
 681:lwIP/src/core/ipv4/ip4_frag.c ****     /* dropped pbuf after creating a new datagram entry: remove the entry, too */
 1281              		.loc 1 681 6 is_stmt 0 view .LVU469
 1282 01a2 6368     		ldr	r3, [r4, #4]
 1283 01a4 002B     		cmp	r3, #0
 1284 01a6 F3D1     		bne	.L91
 683:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, NULL);
 1285              		.loc 1 683 5 is_stmt 1 view .LVU470
 683:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, NULL);
 1286              		.loc 1 683 5 view .LVU471
 1287 01a8 039B     		ldr	r3, [sp, #12]
 1288 01aa 9C42     		cmp	r4, r3
 1289 01ac E9D0     		beq	.L134
 683:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, NULL);
 1290              		.loc 1 683 5 discriminator 1 view .LVU472
 1291 01ae 4748     		ldr	r0, .L201+4
 1292 01b0 FFF7FEFF 		bl	printf
 1293              	.LVL110:
 1294              	.L135:
 683:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, NULL);
 1295              		.loc 1 683 5 discriminator 3 view .LVU473
ARM GAS  /tmp/ccHPvcAz.s 			page 61


 683:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, NULL);
 1296              		.loc 1 683 5 discriminator 3 view .LVU474
 683:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, NULL);
 1297              		.loc 1 683 5 discriminator 3 view .LVU475
 683:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, NULL);
 1298              		.loc 1 683 5 discriminator 3 view .LVU476
 683:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, NULL);
 1299              		.loc 1 683 5 discriminator 3 view .LVU477
 683:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_dequeue_datagram(ipr, NULL);
 1300              		.loc 1 683 5 discriminator 3 view .LVU478
 1301 01b4 FEE7     		b	.L135
 1302              	.LVL111:
 1303              	.L142:
 1304              	.LBB129:
 1305              	.LBI129:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1306              		.loc 2 934 30 discriminator 1 view .LVU479
 1307              	.LBB130:
 1308              		.loc 2 937 3 discriminator 1 view .LVU480
 1309              		.loc 2 937 19 is_stmt 0 discriminator 1 view .LVU481
 1310 01b6 E389     		ldrh	r3, [r4, #14]
 1311 01b8 5BBA     		rev16	r3, r3
 1312              	.LBE130:
 1313              	.LBE129:
 574:lwIP/src/core/ipv4/ip4_frag.c ****         ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 1314              		.loc 1 574 63 discriminator 1 view .LVU482
 1315 01ba C3F30C03 		ubfx	r3, r3, #0, #13
 1316 01be 002B     		cmp	r3, #0
 1317 01c0 3FF466AF 		beq	.L100
 580:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1318              		.loc 1 580 7 is_stmt 1 view .LVU483
 1319 01c4 DAF80030 		ldr	r3, [r10]	@ unaligned
 1320 01c8 DAF80400 		ldr	r0, [r10, #4]	@ unaligned
 1321 01cc DAF80810 		ldr	r1, [r10, #8]	@ unaligned
 1322 01d0 DAF80C20 		ldr	r2, [r10, #12]	@ unaligned
 1323 01d4 A360     		str	r3, [r4, #8]	@ unaligned
 1324 01d6 E060     		str	r0, [r4, #12]	@ unaligned
 1325 01d8 2161     		str	r1, [r4, #16]	@ unaligned
 1326 01da 6261     		str	r2, [r4, #20]	@ unaligned
 1327 01dc DAF81030 		ldr	r3, [r10, #16]	@ unaligned
 1328 01e0 A361     		str	r3, [r4, #24]	@ unaligned
 1329              	.LVL112:
 580:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1330              		.loc 1 580 7 is_stmt 0 view .LVU484
 1331 01e2 BAF80600 		ldrh	r0, [r10, #6]	@ unaligned
 1332 01e6 53E7     		b	.L100
 1333              	.LVL113:
 1334              	.L93:
 538:lwIP/src/core/ipv4/ip4_frag.c ****         ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 1335              		.loc 1 538 5 is_stmt 1 view .LVU485
 538:lwIP/src/core/ipv4/ip4_frag.c ****         ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 1336              		.loc 1 538 10 is_stmt 0 view .LVU486
 1337 01e8 0146     		mov	r1, r0
 1338 01ea 5046     		mov	r0, r10
 1339              	.LVL114:
 538:lwIP/src/core/ipv4/ip4_frag.c ****         ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 1340              		.loc 1 538 10 view .LVU487
ARM GAS  /tmp/ccHPvcAz.s 			page 62


 1341 01ec FFF7FEFF 		bl	ip_reass_remove_oldest_datagram
 1342              	.LVL115:
 538:lwIP/src/core/ipv4/ip4_frag.c ****         ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 1343              		.loc 1 538 8 view .LVU488
 1344 01f0 0028     		cmp	r0, #0
 1345 01f2 CDD0     		beq	.L91
 539:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_FREE_OLDEST */
 1346              		.loc 1 539 30 discriminator 1 view .LVU489
 1347 01f4 2B88     		ldrh	r3, [r5]
 1348 01f6 3344     		add	r3, r3, r6
 538:lwIP/src/core/ipv4/ip4_frag.c ****         ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 1349              		.loc 1 538 57 discriminator 1 view .LVU490
 1350 01f8 0A2B     		cmp	r3, #10
 1351 01fa 7FF723AF 		ble	.L96
 1352 01fe C7E7     		b	.L91
 1353              	.L95:
 566:lwIP/src/core/ipv4/ip4_frag.c ****     /* Enqueue a new datagram into the datagram queue */
 1354              		.loc 1 566 3 is_stmt 1 view .LVU491
 568:lwIP/src/core/ipv4/ip4_frag.c ****     /* Bail if unable to enqueue */
 1355              		.loc 1 568 5 view .LVU492
 1356              	.LVL116:
 1357              	.LBB131:
 1358              	.LBI131:
 278:lwIP/src/core/ipv4/ip4_frag.c **** {
 1359              		.loc 1 278 1 view .LVU493
 1360              	.LBB132:
 280:lwIP/src/core/ipv4/ip4_frag.c **** #if ! IP_REASS_FREE_OLDEST
 1361              		.loc 1 280 3 view .LVU494
 286:lwIP/src/core/ipv4/ip4_frag.c ****   if (ipr == NULL) {
 1362              		.loc 1 286 3 view .LVU495
 286:lwIP/src/core/ipv4/ip4_frag.c ****   if (ipr == NULL) {
 1363              		.loc 1 286 32 is_stmt 0 view .LVU496
 1364 0200 0420     		movs	r0, #4
 1365 0202 FFF7FEFF 		bl	memp_malloc
 1366              	.LVL117:
 287:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_FREE_OLDEST
 1367              		.loc 1 287 3 is_stmt 1 view .LVU497
 287:lwIP/src/core/ipv4/ip4_frag.c **** #if IP_REASS_FREE_OLDEST
 1368              		.loc 1 287 6 is_stmt 0 view .LVU498
 1369 0206 0446     		mov	r4, r0
 1370 0208 0028     		cmp	r0, #0
 1371 020a 4ED0     		beq	.L196
 1372              	.L144:
 300:lwIP/src/core/ipv4/ip4_frag.c ****   ipr->timer = IP_REASS_MAXAGE;
 1373              		.loc 1 300 3 is_stmt 1 view .LVU499
 1374 020c 0022     		movs	r2, #0
 304:lwIP/src/core/ipv4/ip4_frag.c ****   reassdatagrams = ipr;
 1375              		.loc 1 304 13 is_stmt 0 view .LVU500
 1376 020e D8F80030 		ldr	r3, [r8]
 301:lwIP/src/core/ipv4/ip4_frag.c **** 
 1377              		.loc 1 301 14 view .LVU501
 1378 0212 0F21     		movs	r1, #15
 308:lwIP/src/core/ipv4/ip4_frag.c ****   return ipr;
 1379              		.loc 1 308 3 view .LVU502
 1380 0214 0394     		str	r4, [sp, #12]
 300:lwIP/src/core/ipv4/ip4_frag.c ****   ipr->timer = IP_REASS_MAXAGE;
 1381              		.loc 1 300 3 view .LVU503
ARM GAS  /tmp/ccHPvcAz.s 			page 63


 1382 0216 E261     		str	r2, [r4, #28]	@ unaligned
 301:lwIP/src/core/ipv4/ip4_frag.c **** 
 1383              		.loc 1 301 3 is_stmt 1 view .LVU504
 300:lwIP/src/core/ipv4/ip4_frag.c ****   ipr->timer = IP_REASS_MAXAGE;
 1384              		.loc 1 300 3 is_stmt 0 view .LVU505
 1385 0218 A260     		str	r2, [r4, #8]	@ unaligned
 1386 021a E260     		str	r2, [r4, #12]	@ unaligned
 1387 021c 2261     		str	r2, [r4, #16]	@ unaligned
 1388 021e 6261     		str	r2, [r4, #20]	@ unaligned
 1389 0220 A261     		str	r2, [r4, #24]	@ unaligned
 1390 0222 6260     		str	r2, [r4, #4]	@ unaligned
 301:lwIP/src/core/ipv4/ip4_frag.c **** 
 1391              		.loc 1 301 14 view .LVU506
 1392 0224 E177     		strb	r1, [r4, #31]
 304:lwIP/src/core/ipv4/ip4_frag.c ****   reassdatagrams = ipr;
 1393              		.loc 1 304 3 is_stmt 1 view .LVU507
 304:lwIP/src/core/ipv4/ip4_frag.c ****   reassdatagrams = ipr;
 1394              		.loc 1 304 13 is_stmt 0 view .LVU508
 1395 0226 2360     		str	r3, [r4]
 305:lwIP/src/core/ipv4/ip4_frag.c ****   /* copy the ip header for later tests and input */
 1396              		.loc 1 305 3 is_stmt 1 view .LVU509
 308:lwIP/src/core/ipv4/ip4_frag.c ****   return ipr;
 1397              		.loc 1 308 3 is_stmt 0 view .LVU510
 1398 0228 DAF80030 		ldr	r3, [r10]	@ unaligned
 1399 022c DAF80400 		ldr	r0, [r10, #4]	@ unaligned
 1400              	.LVL118:
 308:lwIP/src/core/ipv4/ip4_frag.c ****   return ipr;
 1401              		.loc 1 308 3 view .LVU511
 1402 0230 DAF80810 		ldr	r1, [r10, #8]	@ unaligned
 1403 0234 DAF80C20 		ldr	r2, [r10, #12]	@ unaligned
 1404 0238 A360     		str	r3, [r4, #8]	@ unaligned
 1405 023a E060     		str	r0, [r4, #12]	@ unaligned
 1406 023c 2161     		str	r1, [r4, #16]	@ unaligned
 1407 023e 6261     		str	r2, [r4, #20]	@ unaligned
 1408 0240 DAF81030 		ldr	r3, [r10, #16]	@ unaligned
 305:lwIP/src/core/ipv4/ip4_frag.c ****   /* copy the ip header for later tests and input */
 1409              		.loc 1 305 18 view .LVU512
 1410 0244 C8F80040 		str	r4, [r8]
 308:lwIP/src/core/ipv4/ip4_frag.c ****   return ipr;
 1411              		.loc 1 308 3 is_stmt 1 view .LVU513
 1412 0248 A361     		str	r3, [r4, #24]	@ unaligned
 1413              	.LVL119:
 309:lwIP/src/core/ipv4/ip4_frag.c **** }
 1414              		.loc 1 309 3 view .LVU514
 309:lwIP/src/core/ipv4/ip4_frag.c **** }
 1415              		.loc 1 309 3 is_stmt 0 view .LVU515
 1416              	.LBE132:
 1417              	.LBE131:
 570:lwIP/src/core/ipv4/ip4_frag.c ****       goto nullreturn;
 1418              		.loc 1 570 5 is_stmt 1 view .LVU516
 1419 024a BAF80600 		ldrh	r0, [r10, #6]	@ unaligned
 1420 024e 1FE7     		b	.L100
 1421              	.LVL120:
 1422              	.L195:
 1423              	.LBB134:
 1424              	.LBB121:
 441:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
ARM GAS  /tmp/ccHPvcAz.s 			page 64


 1425              		.loc 1 441 10 is_stmt 0 view .LVU517
 1426 0250 5945     		cmp	r1, fp
 1427 0252 9E46     		mov	lr, r3
 1428 0254 059A     		ldr	r2, [sp, #20]
 433:lwIP/src/core/ipv4/ip4_frag.c ****     if (iprh_prev != NULL) {
 1429              		.loc 1 433 3 is_stmt 1 view .LVU518
 434:lwIP/src/core/ipv4/ip4_frag.c ****       /* this is (for now), the fragment with the highest offset:
 1430              		.loc 1 434 5 view .LVU519
 438:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_CHECK_OVERLAP */
 1431              		.loc 1 438 7 view .LVU520
 438:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_CHECK_OVERLAP */
 1432              		.loc 1 438 7 view .LVU521
 438:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_CHECK_OVERLAP */
 1433              		.loc 1 438 7 view .LVU522
 440:lwIP/src/core/ipv4/ip4_frag.c ****       if (iprh_prev->end != iprh->start) {
 1434              		.loc 1 440 7 view .LVU523
 440:lwIP/src/core/ipv4/ip4_frag.c ****       if (iprh_prev->end != iprh->start) {
 1435              		.loc 1 440 28 is_stmt 0 view .LVU524
 1436 0256 1F60     		str	r7, [r3]	@ unaligned
 441:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 1437              		.loc 1 441 7 is_stmt 1 view .LVU525
 441:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 1438              		.loc 1 441 10 is_stmt 0 view .LVU526
 1439 0258 86D1     		bne	.L141
 1440              	.LVL121:
 1441              	.L106:
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1442              		.loc 1 456 3 is_stmt 1 view .LVU527
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1443              		.loc 1 456 6 is_stmt 0 view .LVU528
 1444 025a 0028     		cmp	r0, #0
 1445 025c 00F0AE80 		beq	.L113
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1446              		.loc 1 456 15 view .LVU529
 1447 0260 A37F     		ldrb	r3, [r4, #30]	@ zero_extendqisi2
 1448 0262 DF07     		lsls	r7, r3, #31
 1449              	.LVL122:
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1450              		.loc 1 456 15 view .LVU530
 1451 0264 87D5     		bpl	.L140
 458:lwIP/src/core/ipv4/ip4_frag.c ****       /* then check if the rest of the fragments is here */
 1452              		.loc 1 458 5 is_stmt 1 view .LVU531
 458:lwIP/src/core/ipv4/ip4_frag.c ****       /* then check if the rest of the fragments is here */
 1453              		.loc 1 458 8 is_stmt 0 view .LVU532
 1454 0266 019B     		ldr	r3, [sp, #4]
 1455 0268 002B     		cmp	r3, #0
 1456 026a 00F0A380 		beq	.L153
 1457              	.LVL123:
 1458              	.L116:
 458:lwIP/src/core/ipv4/ip4_frag.c ****       /* then check if the rest of the fragments is here */
 1459              		.loc 1 458 8 view .LVU533
 1460 026e 6368     		ldr	r3, [r4, #4]
 461:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 1461              		.loc 1 461 7 is_stmt 1 view .LVU534
 461:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 1462              		.loc 1 461 10 is_stmt 0 view .LVU535
 1463 0270 002B     		cmp	r3, #0
ARM GAS  /tmp/ccHPvcAz.s 			page 65


 1464 0272 00F09F80 		beq	.L153
 1465              	.L152:
 461:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 1466              		.loc 1 461 65 view .LVU536
 1467 0276 5F68     		ldr	r7, [r3, #4]
 461:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 1468              		.loc 1 461 28 view .LVU537
 1469 0278 BB88     		ldrh	r3, [r7, #4]	@ unaligned
 1470 027a 53B9     		cbnz	r3, .L118
 1471              	.L148:
 465:lwIP/src/core/ipv4/ip4_frag.c ****         q = iprh->next_pbuf;
 1472              		.loc 1 465 9 is_stmt 1 view .LVU538
 1473              	.LVL124:
 466:lwIP/src/core/ipv4/ip4_frag.c ****         while (q != NULL) {
 1474              		.loc 1 466 9 view .LVU539
 466:lwIP/src/core/ipv4/ip4_frag.c ****         while (q != NULL) {
 1475              		.loc 1 466 11 is_stmt 0 view .LVU540
 1476 027c 1368     		ldr	r3, [r2]	@ unaligned
 1477              	.LVL125:
 467:lwIP/src/core/ipv4/ip4_frag.c ****           iprh = (struct ip_reass_helper *)q->payload;
 1478              		.loc 1 467 9 is_stmt 1 view .LVU541
 467:lwIP/src/core/ipv4/ip4_frag.c ****           iprh = (struct ip_reass_helper *)q->payload;
 1479              		.loc 1 467 15 view .LVU542
 1480 027e 23B9     		cbnz	r3, .L120
 1481 0280 28E0     		b	.L119
 1482              	.LVL126:
 1483              	.L197:
 474:lwIP/src/core/ipv4/ip4_frag.c ****         }
 1484              		.loc 1 474 13 is_stmt 0 view .LVU543
 1485 0282 1368     		ldr	r3, [r2]	@ unaligned
 1486              	.LVL127:
 467:lwIP/src/core/ipv4/ip4_frag.c ****           iprh = (struct ip_reass_helper *)q->payload;
 1487              		.loc 1 467 15 is_stmt 1 view .LVU544
 1488 0284 33B3     		cbz	r3, .L119
 467:lwIP/src/core/ipv4/ip4_frag.c ****           iprh = (struct ip_reass_helper *)q->payload;
 1489              		.loc 1 467 15 is_stmt 0 view .LVU545
 1490 0286 B2F806A0 		ldrh	r10, [r2, #6]	@ unaligned
 1491              	.L120:
 1492              	.LVL128:
 468:lwIP/src/core/ipv4/ip4_frag.c ****           if (iprh_prev->end != iprh->start) {
 1493              		.loc 1 468 11 is_stmt 1 view .LVU546
 473:lwIP/src/core/ipv4/ip4_frag.c ****           q = iprh->next_pbuf;
 1494              		.loc 1 473 11 view .LVU547
 468:lwIP/src/core/ipv4/ip4_frag.c ****           if (iprh_prev->end != iprh->start) {
 1495              		.loc 1 468 16 is_stmt 0 view .LVU548
 1496 028a 5A68     		ldr	r2, [r3, #4]
 1497              	.LVL129:
 469:lwIP/src/core/ipv4/ip4_frag.c ****             valid = 0;
 1498              		.loc 1 469 11 is_stmt 1 view .LVU549
 474:lwIP/src/core/ipv4/ip4_frag.c ****         }
 1499              		.loc 1 474 11 view .LVU550
 469:lwIP/src/core/ipv4/ip4_frag.c ****             valid = 0;
 1500              		.loc 1 469 14 is_stmt 0 view .LVU551
 1501 028c 9388     		ldrh	r3, [r2, #4]	@ unaligned
 1502              	.LVL130:
 469:lwIP/src/core/ipv4/ip4_frag.c ****             valid = 0;
 1503              		.loc 1 469 14 view .LVU552
ARM GAS  /tmp/ccHPvcAz.s 			page 66


 1504 028e 5345     		cmp	r3, r10
 1505 0290 F7D0     		beq	.L197
 1506              	.LVL131:
 1507              	.L118:
 482:lwIP/src/core/ipv4/ip4_frag.c ****                       iprh->next_pbuf == NULL);
 1508              		.loc 1 482 11 is_stmt 1 view .LVU553
 490:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1509              		.loc 1 490 5 view .LVU554
 490:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1510              		.loc 1 490 5 is_stmt 0 view .LVU555
 1511              	.LBE121:
 1512              	.LBE134:
 599:lwIP/src/core/ipv4/ip4_frag.c ****     goto nullreturn_ipr;
 1513              		.loc 1 599 3 is_stmt 1 view .LVU556
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1514              		.loc 1 607 3 view .LVU557
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1515              		.loc 1 607 24 is_stmt 0 view .LVU558
 1516 0292 2B88     		ldrh	r3, [r5]
 1517 0294 3344     		add	r3, r3, r6
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1518              		.loc 1 607 22 view .LVU559
 1519 0296 2B80     		strh	r3, [r5]	@ movhi
 608:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 1520              		.loc 1 608 3 is_stmt 1 view .LVU560
 608:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 1521              		.loc 1 608 6 is_stmt 0 view .LVU561
 1522 0298 0028     		cmp	r0, #0
 1523 029a 00F09880 		beq	.L112
 1524              	.L145:
 677:lwIP/src/core/ipv4/ip4_frag.c **** 
 1525              		.loc 1 677 10 view .LVU562
 1526 029e 4FF00009 		mov	r9, #0
 692:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASSEMBLY */
 1527              		.loc 1 692 1 view .LVU563
 1528 02a2 4846     		mov	r0, r9
 1529 02a4 07B0     		add	sp, sp, #28
 1530              	.LCFI10:
 1531              		.cfi_remember_state
 1532              		.cfi_def_cfa_offset 36
 1533              		@ sp needed
 1534 02a6 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1535              	.LVL132:
 1536              	.L196:
 1537              	.LCFI11:
 1538              		.cfi_restore_state
 1539              	.LBB135:
 1540              	.LBB133:
 289:lwIP/src/core/ipv4/ip4_frag.c ****       ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 1541              		.loc 1 289 5 is_stmt 1 view .LVU564
 289:lwIP/src/core/ipv4/ip4_frag.c ****       ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 1542              		.loc 1 289 9 is_stmt 0 view .LVU565
 1543 02aa 3146     		mov	r1, r6
 1544 02ac 5046     		mov	r0, r10
 1545              	.LVL133:
 289:lwIP/src/core/ipv4/ip4_frag.c ****       ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 1546              		.loc 1 289 9 view .LVU566
ARM GAS  /tmp/ccHPvcAz.s 			page 67


 1547 02ae FFF7FEFF 		bl	ip_reass_remove_oldest_datagram
 1548              	.LVL134:
 289:lwIP/src/core/ipv4/ip4_frag.c ****       ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 1549              		.loc 1 289 8 view .LVU567
 1550 02b2 8642     		cmp	r6, r0
 1551 02b4 3FF76CAF 		bgt	.L91
 290:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1552              		.loc 1 290 7 is_stmt 1 view .LVU568
 290:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1553              		.loc 1 290 36 is_stmt 0 view .LVU569
 1554 02b8 0420     		movs	r0, #4
 1555 02ba FFF7FEFF 		bl	memp_malloc
 1556              	.LVL135:
 292:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_FREE_OLDEST */
 1557              		.loc 1 292 5 is_stmt 1 view .LVU570
 292:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_FREE_OLDEST */
 1558              		.loc 1 292 8 is_stmt 0 view .LVU571
 1559 02be 0446     		mov	r4, r0
 1560 02c0 0028     		cmp	r0, #0
 1561 02c2 A3D1     		bne	.L144
 1562 02c4 64E7     		b	.L91
 1563              	.L202:
 1564 02c6 00BF     		.align	2
 1565              	.L201:
 1566 02c8 00000000 		.word	.LANCHOR1
 1567 02cc 2C000000 		.word	.LC8
 1568 02d0 00000000 		.word	.LANCHOR0
 1569              	.LVL136:
 1570              	.L119:
 292:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* IP_REASS_FREE_OLDEST */
 1571              		.loc 1 292 8 view .LVU572
 1572              	.LBE133:
 1573              	.LBE135:
 1574              	.LBB136:
 1575              	.LBB122:
 478:lwIP/src/core/ipv4/ip4_frag.c ****           LWIP_ASSERT("sanity check", ipr->p != NULL);
 1576              		.loc 1 478 9 is_stmt 1 view .LVU573
 479:lwIP/src/core/ipv4/ip4_frag.c ****           LWIP_ASSERT("sanity check",
 1577              		.loc 1 479 11 view .LVU574
 479:lwIP/src/core/ipv4/ip4_frag.c ****           LWIP_ASSERT("sanity check",
 1578              		.loc 1 479 11 view .LVU575
 479:lwIP/src/core/ipv4/ip4_frag.c ****           LWIP_ASSERT("sanity check",
 1579              		.loc 1 479 11 view .LVU576
 480:lwIP/src/core/ipv4/ip4_frag.c ****                       ((struct ip_reass_helper *)ipr->p->payload) != iprh);
 1580              		.loc 1 480 11 view .LVU577
 480:lwIP/src/core/ipv4/ip4_frag.c ****                       ((struct ip_reass_helper *)ipr->p->payload) != iprh);
 1581              		.loc 1 480 11 view .LVU578
 1582 02d4 BA42     		cmp	r2, r7
 1583 02d6 69D0     		beq	.L198
 480:lwIP/src/core/ipv4/ip4_frag.c ****                       ((struct ip_reass_helper *)ipr->p->payload) != iprh);
 1584              		.loc 1 480 11 view .LVU579
 482:lwIP/src/core/ipv4/ip4_frag.c ****                       iprh->next_pbuf == NULL);
 1585              		.loc 1 482 11 view .LVU580
 482:lwIP/src/core/ipv4/ip4_frag.c ****                       iprh->next_pbuf == NULL);
 1586              		.loc 1 482 11 view .LVU581
 1587              	.LVL137:
 482:lwIP/src/core/ipv4/ip4_frag.c ****                       iprh->next_pbuf == NULL);
ARM GAS  /tmp/ccHPvcAz.s 			page 68


 1588              		.loc 1 482 11 view .LVU582
 490:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1589              		.loc 1 490 5 view .LVU583
 490:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1590              		.loc 1 490 5 is_stmt 0 view .LVU584
 1591              	.LBE122:
 1592              	.LBE136:
 599:lwIP/src/core/ipv4/ip4_frag.c ****     goto nullreturn_ipr;
 1593              		.loc 1 599 3 is_stmt 1 view .LVU585
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1594              		.loc 1 607 3 view .LVU586
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1595              		.loc 1 607 24 is_stmt 0 view .LVU587
 1596 02d8 2B88     		ldrh	r3, [r5]
 1597 02da 3344     		add	r3, r3, r6
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1598              		.loc 1 607 22 view .LVU588
 1599 02dc 2B80     		strh	r3, [r5]	@ movhi
 608:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 1600              		.loc 1 608 3 is_stmt 1 view .LVU589
 608:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 1601              		.loc 1 608 6 is_stmt 0 view .LVU590
 1602 02de 0028     		cmp	r0, #0
 1603 02e0 3DD0     		beq	.L146
 1604 02e2 A38B     		ldrh	r3, [r4, #28]
 1605              	.L122:
 1606              	.LBB137:
 618:lwIP/src/core/ipv4/ip4_frag.c ****     /* the totally last fragment (flag more fragments = 0) was received at least
 1607              		.loc 1 618 5 is_stmt 1 view .LVU591
 621:lwIP/src/core/ipv4/ip4_frag.c **** 
 1608              		.loc 1 621 5 view .LVU592
 1609              	.LVL138:
 624:lwIP/src/core/ipv4/ip4_frag.c **** 
 1610              		.loc 1 624 5 view .LVU593
 628:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
 1611              		.loc 1 628 5 is_stmt 0 view .LVU594
 1612 02e4 2246     		mov	r2, r4
 621:lwIP/src/core/ipv4/ip4_frag.c **** 
 1613              		.loc 1 621 11 view .LVU595
 1614 02e6 1433     		adds	r3, r3, #20
 1615              	.LVL139:
 624:lwIP/src/core/ipv4/ip4_frag.c **** 
 1616              		.loc 1 624 7 view .LVU596
 1617 02e8 3E68     		ldr	r6, [r7]	@ unaligned
 1618              	.LVL140:
 627:lwIP/src/core/ipv4/ip4_frag.c ****     SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 1619              		.loc 1 627 5 is_stmt 1 view .LVU597
 628:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
 1620              		.loc 1 628 5 view .LVU598
 1621 02ea 52F808EF 		ldr	lr, [r2, #8]!	@ unaligned
 1622              	.LBB138:
 1623              	.LBB139:
 1624              		.loc 2 937 19 is_stmt 0 view .LVU599
 1625 02ee 5BBA     		rev16	r3, r3
 1626              	.LBE139:
 1627              	.LBE138:
 628:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
ARM GAS  /tmp/ccHPvcAz.s 			page 69


 1628              		.loc 1 628 5 view .LVU600
 1629 02f0 D2F804C0 		ldr	ip, [r2, #4]	@ unaligned
 1630 02f4 9168     		ldr	r1, [r2, #8]	@ unaligned
 1631 02f6 D068     		ldr	r0, [r2, #12]	@ unaligned
 1632 02f8 C7F804C0 		str	ip, [r7, #4]	@ unaligned
 630:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_CHKSUM_SET(fraghdr, 0);
 1633              		.loc 1 630 5 view .LVU601
 1634 02fc 4FF0000C 		mov	ip, #0
 628:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
 1635              		.loc 1 628 5 view .LVU602
 1636 0300 B960     		str	r1, [r7, #8]	@ unaligned
 635:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1637              		.loc 1 635 7 view .LVU603
 1638 0302 1421     		movs	r1, #20
 628:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
 1639              		.loc 1 628 5 view .LVU604
 1640 0304 F860     		str	r0, [r7, #12]	@ unaligned
 635:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1641              		.loc 1 635 7 view .LVU605
 1642 0306 3846     		mov	r0, r7
 628:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
 1643              		.loc 1 628 5 view .LVU606
 1644 0308 C7F800E0 		str	lr, [r7]	@ unaligned
 1645 030c D2F810E0 		ldr	lr, [r2, #16]	@ unaligned
 629:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_OFFSET_SET(fraghdr, 0);
 1646              		.loc 1 629 5 view .LVU607
 1647 0310 7B80     		strh	r3, [r7, #2]	@ unaligned
 628:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
 1648              		.loc 1 628 5 view .LVU608
 1649 0312 C7F810E0 		str	lr, [r7, #16]	@ unaligned
 629:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_OFFSET_SET(fraghdr, 0);
 1650              		.loc 1 629 5 is_stmt 1 view .LVU609
 1651              	.LVL141:
 1652              	.LBB141:
 1653              	.LBI138:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 1654              		.loc 2 934 30 view .LVU610
 1655              	.LBB140:
 1656              		.loc 2 937 3 view .LVU611
 1657              		.loc 2 937 3 is_stmt 0 view .LVU612
 1658              	.LBE140:
 1659              	.LBE141:
 630:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_CHKSUM_SET(fraghdr, 0);
 1660              		.loc 1 630 5 is_stmt 1 view .LVU613
 1661 0316 87F806C0 		strb	ip, [r7, #6]
 1662 031a 87F807C0 		strb	ip, [r7, #7]
 631:lwIP/src/core/ipv4/ip4_frag.c ****     /* @todo: do we need to set/calculate the correct checksum? */
 1663              		.loc 1 631 5 view .LVU614
 1664 031e 87F80AC0 		strb	ip, [r7, #10]
 1665 0322 87F80BC0 		strb	ip, [r7, #11]
 635:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1666              		.loc 1 635 7 view .LVU615
 1667 0326 FFF7FEFF 		bl	inet_chksum
 1668              	.LVL142:
 639:lwIP/src/core/ipv4/ip4_frag.c **** 
 1669              		.loc 1 639 7 is_stmt 0 view .LVU616
 1670 032a D4F80490 		ldr	r9, [r4, #4]
ARM GAS  /tmp/ccHPvcAz.s 			page 70


 635:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1671              		.loc 1 635 7 view .LVU617
 1672 032e 7881     		strh	r0, [r7, #10]	@ unaligned
 639:lwIP/src/core/ipv4/ip4_frag.c **** 
 1673              		.loc 1 639 5 is_stmt 1 view .LVU618
 1674              	.LVL143:
 642:lwIP/src/core/ipv4/ip4_frag.c ****       iprh = (struct ip_reass_helper *)r->payload;
 1675              		.loc 1 642 5 view .LVU619
 642:lwIP/src/core/ipv4/ip4_frag.c ****       iprh = (struct ip_reass_helper *)r->payload;
 1676              		.loc 1 642 11 view .LVU620
 1677 0330 5EB1     		cbz	r6, .L126
 1678              	.L123:
 643:lwIP/src/core/ipv4/ip4_frag.c **** 
 1679              		.loc 1 643 7 view .LVU621
 643:lwIP/src/core/ipv4/ip4_frag.c **** 
 1680              		.loc 1 643 12 is_stmt 0 view .LVU622
 1681 0332 7768     		ldr	r7, [r6, #4]
 1682              	.LVL144:
 646:lwIP/src/core/ipv4/ip4_frag.c ****       pbuf_cat(p, r);
 1683              		.loc 1 646 7 is_stmt 1 view .LVU623
 1684 0334 1421     		movs	r1, #20
 1685 0336 3046     		mov	r0, r6
 1686 0338 FFF7FEFF 		bl	pbuf_remove_header
 1687              	.LVL145:
 647:lwIP/src/core/ipv4/ip4_frag.c ****       r = iprh->next_pbuf;
 1688              		.loc 1 647 7 view .LVU624
 1689 033c 3146     		mov	r1, r6
 1690 033e 4846     		mov	r0, r9
 1691 0340 FFF7FEFF 		bl	pbuf_cat
 1692              	.LVL146:
 648:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1693              		.loc 1 648 7 view .LVU625
 648:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1694              		.loc 1 648 9 is_stmt 0 view .LVU626
 1695 0344 3E68     		ldr	r6, [r7]	@ unaligned
 1696              	.LVL147:
 642:lwIP/src/core/ipv4/ip4_frag.c ****       iprh = (struct ip_reass_helper *)r->payload;
 1697              		.loc 1 642 11 is_stmt 1 view .LVU627
 1698 0346 002E     		cmp	r6, #0
 1699 0348 F3D1     		bne	.L123
 1700              	.LVL148:
 1701              	.L126:
 652:lwIP/src/core/ipv4/ip4_frag.c ****       ipr_prev = NULL;
 1702              		.loc 1 652 5 view .LVU628
 652:lwIP/src/core/ipv4/ip4_frag.c ****       ipr_prev = NULL;
 1703              		.loc 1 652 13 is_stmt 0 view .LVU629
 1704 034a D8F80030 		ldr	r3, [r8]
 652:lwIP/src/core/ipv4/ip4_frag.c ****       ipr_prev = NULL;
 1705              		.loc 1 652 8 view .LVU630
 1706 034e A342     		cmp	r3, r4
 1707 0350 28D0     		beq	.L199
 1708              	.L125:
 656:lwIP/src/core/ipv4/ip4_frag.c ****           break;
 1709              		.loc 1 656 9 is_stmt 1 discriminator 1 view .LVU631
 1710              	.LVL149:
 655:lwIP/src/core/ipv4/ip4_frag.c ****         if (ipr_prev->next == ipr) {
 1711              		.loc 1 655 39 discriminator 1 view .LVU632
ARM GAS  /tmp/ccHPvcAz.s 			page 71


 655:lwIP/src/core/ipv4/ip4_frag.c ****         if (ipr_prev->next == ipr) {
 1712              		.loc 1 655 7 is_stmt 0 discriminator 1 view .LVU633
 1713 0352 1BB3     		cbz	r3, .L200
 656:lwIP/src/core/ipv4/ip4_frag.c ****           break;
 1714              		.loc 1 656 21 view .LVU634
 1715 0354 1A68     		ldr	r2, [r3]
 656:lwIP/src/core/ipv4/ip4_frag.c ****           break;
 1716              		.loc 1 656 12 view .LVU635
 1717 0356 A242     		cmp	r2, r4
 1718 0358 0DD0     		beq	.L127
 1719 035a 1346     		mov	r3, r2
 1720              	.LVL150:
 656:lwIP/src/core/ipv4/ip4_frag.c ****           break;
 1721              		.loc 1 656 12 view .LVU636
 1722 035c F9E7     		b	.L125
 1723              	.LVL151:
 1724              	.L146:
 656:lwIP/src/core/ipv4/ip4_frag.c ****           break;
 1725              		.loc 1 656 12 view .LVU637
 1726              	.LBE137:
 1727              	.LBB148:
 609:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->datagram_len = datagram_len;
 1728              		.loc 1 609 5 is_stmt 1 view .LVU638
 609:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->datagram_len = datagram_len;
 1729              		.loc 1 609 11 is_stmt 0 view .LVU639
 1730 035e 029A     		ldr	r2, [sp, #8]
 1731 0360 049B     		ldr	r3, [sp, #16]
 1732 0362 6168     		ldr	r1, [r4, #4]
 1733 0364 1344     		add	r3, r3, r2
 611:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG,
 1734              		.loc 1 611 16 view .LVU640
 1735 0366 A27F     		ldrb	r2, [r4, #30]	@ zero_extendqisi2
 609:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->datagram_len = datagram_len;
 1736              		.loc 1 609 11 view .LVU641
 1737 0368 9BB2     		uxth	r3, r3
 1738              	.LVL152:
 610:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 1739              		.loc 1 610 5 is_stmt 1 view .LVU642
 611:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG,
 1740              		.loc 1 611 16 is_stmt 0 view .LVU643
 1741 036a 42F00102 		orr	r2, r2, #1
 610:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 1742              		.loc 1 610 23 view .LVU644
 1743 036e A383     		strh	r3, [r4, #28]	@ movhi
 611:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG,
 1744              		.loc 1 611 5 is_stmt 1 view .LVU645
 611:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG,
 1745              		.loc 1 611 16 is_stmt 0 view .LVU646
 1746 0370 A277     		strb	r2, [r4, #30]
 614:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1747              		.loc 1 614 37 is_stmt 1 view .LVU647
 1748              	.LBE148:
 617:lwIP/src/core/ipv4/ip4_frag.c ****     struct ip_reassdata *ipr_prev;
 1749              		.loc 1 617 3 view .LVU648
 1750 0372 4F68     		ldr	r7, [r1, #4]
 1751 0374 B6E7     		b	.L122
 1752              	.LVL153:
ARM GAS  /tmp/ccHPvcAz.s 			page 72


 1753              	.L127:
 1754              	.LBB149:
 663:lwIP/src/core/ipv4/ip4_frag.c **** 
 1755              		.loc 1 663 5 view .LVU649
 1756              	.LBB142:
 1757              	.LBI142:
 317:lwIP/src/core/ipv4/ip4_frag.c **** {
 1758              		.loc 1 317 1 view .LVU650
 1759              	.LBB143:
 320:lwIP/src/core/ipv4/ip4_frag.c ****     /* it was the first in the list */
 1760              		.loc 1 320 3 view .LVU651
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 1761              		.loc 1 325 5 view .LVU652
 326:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1762              		.loc 1 326 5 view .LVU653
 326:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1763              		.loc 1 326 21 is_stmt 0 view .LVU654
 1764 0376 2268     		ldr	r2, [r4]
 326:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1765              		.loc 1 326 16 view .LVU655
 1766 0378 1A60     		str	r2, [r3]
 1767              	.LVL154:
 1768              	.L130:
 330:lwIP/src/core/ipv4/ip4_frag.c **** }
 1769              		.loc 1 330 3 is_stmt 1 view .LVU656
 1770 037a 2146     		mov	r1, r4
 1771 037c 0420     		movs	r0, #4
 1772 037e FFF7FEFF 		bl	memp_free
 1773              	.LVL155:
 330:lwIP/src/core/ipv4/ip4_frag.c **** }
 1774              		.loc 1 330 3 is_stmt 0 view .LVU657
 1775              	.LBE143:
 1776              	.LBE142:
 666:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= clen);
 1777              		.loc 1 666 5 is_stmt 1 view .LVU658
 666:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= clen);
 1778              		.loc 1 666 12 is_stmt 0 view .LVU659
 1779 0382 4846     		mov	r0, r9
 1780 0384 FFF7FEFF 		bl	pbuf_clen
 1781              	.LVL156:
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1782              		.loc 1 667 5 view .LVU660
 1783 0388 2B88     		ldrh	r3, [r5]
 1784              	.LVL157:
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1785              		.loc 1 667 5 is_stmt 1 view .LVU661
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1786              		.loc 1 667 5 view .LVU662
 1787 038a 8342     		cmp	r3, r0
 1788 038c 03D2     		bcs	.L132
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1789              		.loc 1 667 5 discriminator 1 view .LVU663
 1790 038e 1D48     		ldr	r0, .L203
 1791              	.LVL158:
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1792              		.loc 1 667 5 is_stmt 0 discriminator 1 view .LVU664
 1793 0390 FFF7FEFF 		bl	printf
ARM GAS  /tmp/ccHPvcAz.s 			page 73


 1794              	.LVL159:
 1795              	.L133:
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1796              		.loc 1 667 5 is_stmt 1 discriminator 1 view .LVU665
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1797              		.loc 1 667 5 discriminator 1 view .LVU666
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1798              		.loc 1 667 5 discriminator 1 view .LVU667
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1799              		.loc 1 667 5 discriminator 1 view .LVU668
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1800              		.loc 1 667 5 discriminator 1 view .LVU669
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1801              		.loc 1 667 5 discriminator 1 view .LVU670
 1802 0394 FEE7     		b	.L133
 1803              	.LVL160:
 1804              	.L132:
 667:lwIP/src/core/ipv4/ip4_frag.c ****     ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
 1805              		.loc 1 667 5 discriminator 2 view .LVU671
 668:lwIP/src/core/ipv4/ip4_frag.c **** 
 1806              		.loc 1 668 5 discriminator 2 view .LVU672
 668:lwIP/src/core/ipv4/ip4_frag.c **** 
 1807              		.loc 1 668 26 is_stmt 0 discriminator 2 view .LVU673
 1808 0396 1B1A     		subs	r3, r3, r0
 668:lwIP/src/core/ipv4/ip4_frag.c **** 
 1809              		.loc 1 668 24 discriminator 2 view .LVU674
 1810 0398 2B80     		strh	r3, [r5]	@ movhi
 670:lwIP/src/core/ipv4/ip4_frag.c **** 
 1811              		.loc 1 670 36 is_stmt 1 discriminator 2 view .LVU675
 673:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1812              		.loc 1 673 5 discriminator 2 view .LVU676
 673:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1813              		.loc 1 673 12 is_stmt 0 discriminator 2 view .LVU677
 1814 039a FEE6     		b	.L89
 1815              	.LVL161:
 1816              	.L200:
 663:lwIP/src/core/ipv4/ip4_frag.c **** 
 1817              		.loc 1 663 5 is_stmt 1 view .LVU678
 1818              	.LBB146:
 317:lwIP/src/core/ipv4/ip4_frag.c **** {
 1819              		.loc 1 317 1 view .LVU679
 1820              	.LBB144:
 320:lwIP/src/core/ipv4/ip4_frag.c ****     /* it was the first in the list */
 1821              		.loc 1 320 3 view .LVU680
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 1822              		.loc 1 325 5 view .LVU681
 1823 039c 1A48     		ldr	r0, .L203+4
 1824 039e FFF7FEFF 		bl	printf
 1825              	.LVL162:
 1826              	.L131:
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 1827              		.loc 1 325 5 view .LVU682
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 1828              		.loc 1 325 5 view .LVU683
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 1829              		.loc 1 325 5 view .LVU684
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
ARM GAS  /tmp/ccHPvcAz.s 			page 74


 1830              		.loc 1 325 5 view .LVU685
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 1831              		.loc 1 325 5 view .LVU686
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 1832              		.loc 1 325 5 view .LVU687
 1833 03a2 FEE7     		b	.L131
 1834              	.LVL163:
 1835              	.L199:
 325:lwIP/src/core/ipv4/ip4_frag.c ****     prev->next = ipr->next;
 1836              		.loc 1 325 5 is_stmt 0 view .LVU688
 1837              	.LBE144:
 1838              	.LBE146:
 663:lwIP/src/core/ipv4/ip4_frag.c **** 
 1839              		.loc 1 663 5 is_stmt 1 view .LVU689
 1840              	.LBB147:
 317:lwIP/src/core/ipv4/ip4_frag.c **** {
 1841              		.loc 1 317 1 view .LVU690
 1842              	.LBB145:
 320:lwIP/src/core/ipv4/ip4_frag.c ****     /* it was the first in the list */
 1843              		.loc 1 320 3 view .LVU691
 322:lwIP/src/core/ipv4/ip4_frag.c ****   } else {
 1844              		.loc 1 322 5 view .LVU692
 322:lwIP/src/core/ipv4/ip4_frag.c ****   } else {
 1845              		.loc 1 322 20 is_stmt 0 view .LVU693
 1846 03a4 2368     		ldr	r3, [r4]
 1847 03a6 C8F80030 		str	r3, [r8]
 1848 03aa E6E7     		b	.L130
 1849              	.LVL164:
 1850              	.L198:
 322:lwIP/src/core/ipv4/ip4_frag.c ****   } else {
 1851              		.loc 1 322 20 view .LVU694
 1852              	.LBE145:
 1853              	.LBE147:
 1854              	.LBE149:
 1855              	.LBB150:
 1856              	.LBB123:
 480:lwIP/src/core/ipv4/ip4_frag.c ****                       ((struct ip_reass_helper *)ipr->p->payload) != iprh);
 1857              		.loc 1 480 11 is_stmt 1 view .LVU695
 1858 03ac 1748     		ldr	r0, .L203+8
 1859 03ae FFF7FEFF 		bl	printf
 1860              	.LVL165:
 1861              	.L121:
 480:lwIP/src/core/ipv4/ip4_frag.c ****                       ((struct ip_reass_helper *)ipr->p->payload) != iprh);
 1862              		.loc 1 480 11 view .LVU696
 480:lwIP/src/core/ipv4/ip4_frag.c ****                       ((struct ip_reass_helper *)ipr->p->payload) != iprh);
 1863              		.loc 1 480 11 view .LVU697
 480:lwIP/src/core/ipv4/ip4_frag.c ****                       ((struct ip_reass_helper *)ipr->p->payload) != iprh);
 1864              		.loc 1 480 11 view .LVU698
 480:lwIP/src/core/ipv4/ip4_frag.c ****                       ((struct ip_reass_helper *)ipr->p->payload) != iprh);
 1865              		.loc 1 480 11 view .LVU699
 480:lwIP/src/core/ipv4/ip4_frag.c ****                       ((struct ip_reass_helper *)ipr->p->payload) != iprh);
 1866              		.loc 1 480 11 view .LVU700
 480:lwIP/src/core/ipv4/ip4_frag.c ****                       ((struct ip_reass_helper *)ipr->p->payload) != iprh);
 1867              		.loc 1 480 11 view .LVU701
 1868 03b2 FEE7     		b	.L121
 1869              	.LVL166:
 1870              	.L153:
ARM GAS  /tmp/ccHPvcAz.s 			page 75


 482:lwIP/src/core/ipv4/ip4_frag.c ****                       iprh->next_pbuf == NULL);
 1871              		.loc 1 482 11 view .LVU702
 490:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1872              		.loc 1 490 5 view .LVU703
 490:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1873              		.loc 1 490 5 is_stmt 0 view .LVU704
 1874              	.LBE123:
 1875              	.LBE150:
 599:lwIP/src/core/ipv4/ip4_frag.c ****     goto nullreturn_ipr;
 1876              		.loc 1 599 3 is_stmt 1 view .LVU705
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1877              		.loc 1 607 3 view .LVU706
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1878              		.loc 1 607 24 is_stmt 0 view .LVU707
 1879 03b4 2B88     		ldrh	r3, [r5]
 1880 03b6 3344     		add	r3, r3, r6
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1881              		.loc 1 607 22 view .LVU708
 1882 03b8 2B80     		strh	r3, [r5]	@ movhi
 608:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 1883              		.loc 1 608 3 is_stmt 1 view .LVU709
 1884 03ba 70E7     		b	.L145
 1885              	.LVL167:
 1886              	.L113:
 1887              	.LBB151:
 1888              	.LBB124:
 458:lwIP/src/core/ipv4/ip4_frag.c ****       /* then check if the rest of the fragments is here */
 1889              		.loc 1 458 5 view .LVU710
 458:lwIP/src/core/ipv4/ip4_frag.c ****       /* then check if the rest of the fragments is here */
 1890              		.loc 1 458 8 is_stmt 0 view .LVU711
 1891 03bc 019B     		ldr	r3, [sp, #4]
 1892 03be 1BB1     		cbz	r3, .L151
 1893 03c0 6368     		ldr	r3, [r4, #4]
 461:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 1894              		.loc 1 461 7 is_stmt 1 view .LVU712
 461:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 1895              		.loc 1 461 10 is_stmt 0 view .LVU713
 1896 03c2 002B     		cmp	r3, #0
 1897 03c4 7FF457AF 		bne	.L152
 1898              	.LVL168:
 1899              	.L151:
 482:lwIP/src/core/ipv4/ip4_frag.c ****                       iprh->next_pbuf == NULL);
 1900              		.loc 1 482 11 is_stmt 1 view .LVU714
 490:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1901              		.loc 1 490 5 view .LVU715
 490:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1902              		.loc 1 490 5 is_stmt 0 view .LVU716
 1903              	.LBE124:
 1904              	.LBE151:
 599:lwIP/src/core/ipv4/ip4_frag.c ****     goto nullreturn_ipr;
 1905              		.loc 1 599 3 is_stmt 1 view .LVU717
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1906              		.loc 1 607 3 view .LVU718
 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1907              		.loc 1 607 24 is_stmt 0 view .LVU719
 1908 03c8 2B88     		ldrh	r3, [r5]
 1909 03ca 3344     		add	r3, r3, r6
ARM GAS  /tmp/ccHPvcAz.s 			page 76


 607:lwIP/src/core/ipv4/ip4_frag.c ****   if (is_last) {
 1910              		.loc 1 607 22 view .LVU720
 1911 03cc 2B80     		strh	r3, [r5]	@ movhi
 608:lwIP/src/core/ipv4/ip4_frag.c ****     u16_t datagram_len = (u16_t)(offset + len);
 1912              		.loc 1 608 3 is_stmt 1 view .LVU721
 1913              	.L112:
 1914              	.LBB152:
 609:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->datagram_len = datagram_len;
 1915              		.loc 1 609 5 view .LVU722
 1916              	.LVL169:
 610:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 1917              		.loc 1 610 5 view .LVU723
 611:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG,
 1918              		.loc 1 611 16 is_stmt 0 view .LVU724
 1919 03ce A37F     		ldrb	r3, [r4, #30]	@ zero_extendqisi2
 609:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->datagram_len = datagram_len;
 1920              		.loc 1 609 11 view .LVU725
 1921 03d0 049A     		ldr	r2, [sp, #16]
 1922 03d2 0299     		ldr	r1, [sp, #8]
 611:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG,
 1923              		.loc 1 611 16 view .LVU726
 1924 03d4 43F00103 		orr	r3, r3, #1
 609:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->datagram_len = datagram_len;
 1925              		.loc 1 609 11 view .LVU727
 1926 03d8 0A44     		add	r2, r2, r1
 611:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG,
 1927              		.loc 1 611 16 view .LVU728
 1928 03da A377     		strb	r3, [r4, #30]
 610:lwIP/src/core/ipv4/ip4_frag.c ****     ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 1929              		.loc 1 610 23 view .LVU729
 1930 03dc A283     		strh	r2, [r4, #28]	@ movhi
 611:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_DEBUGF(IP_REASS_DEBUG,
 1931              		.loc 1 611 5 is_stmt 1 view .LVU730
 614:lwIP/src/core/ipv4/ip4_frag.c ****   }
 1932              		.loc 1 614 37 view .LVU731
 1933              	.LBE152:
 617:lwIP/src/core/ipv4/ip4_frag.c ****     struct ip_reassdata *ipr_prev;
 1934              		.loc 1 617 3 view .LVU732
 1935 03de 5EE7     		b	.L145
 1936              	.LVL170:
 1937              	.L103:
 1938              	.LBB153:
 1939              	.LBB125:
 433:lwIP/src/core/ipv4/ip4_frag.c ****     if (iprh_prev != NULL) {
 1940              		.loc 1 433 3 view .LVU733
 434:lwIP/src/core/ipv4/ip4_frag.c ****       /* this is (for now), the fragment with the highest offset:
 1941              		.loc 1 434 5 view .LVU734
 446:lwIP/src/core/ipv4/ip4_frag.c ****                   ipr->p == NULL);
 1942              		.loc 1 446 7 view .LVU735
 446:lwIP/src/core/ipv4/ip4_frag.c ****                   ipr->p == NULL);
 1943              		.loc 1 446 7 view .LVU736
 446:lwIP/src/core/ipv4/ip4_frag.c ****                   ipr->p == NULL);
 1944              		.loc 1 446 7 view .LVU737
 450:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1945              		.loc 1 450 7 view .LVU738
 450:lwIP/src/core/ipv4/ip4_frag.c ****     }
 1946              		.loc 1 450 14 is_stmt 0 view .LVU739
ARM GAS  /tmp/ccHPvcAz.s 			page 77


 1947 03e0 6760     		str	r7, [r4, #4]
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1948              		.loc 1 456 3 is_stmt 1 view .LVU740
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1949              		.loc 1 456 6 is_stmt 0 view .LVU741
 1950 03e2 20B1     		cbz	r0, .L139
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1951              		.loc 1 456 15 view .LVU742
 1952 03e4 A37F     		ldrb	r3, [r4, #30]	@ zero_extendqisi2
 1953 03e6 D907     		lsls	r1, r3, #31
 1954              	.LVL171:
 456:lwIP/src/core/ipv4/ip4_frag.c ****     /* and had no holes so far */
 1955              		.loc 1 456 15 view .LVU743
 1956 03e8 3FF541AF 		bmi	.L116
 1957 03ec C3E6     		b	.L140
 1958              	.LVL172:
 1959              	.L139:
 461:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 1960              		.loc 1 461 7 is_stmt 1 view .LVU744
 461:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 1961              		.loc 1 461 65 is_stmt 0 view .LVU745
 1962 03ee 7F68     		ldr	r7, [r7, #4]
 1963              	.LVL173:
 461:lwIP/src/core/ipv4/ip4_frag.c ****         valid = 0;
 1964              		.loc 1 461 28 view .LVU746
 1965 03f0 BB88     		ldrh	r3, [r7, #4]	@ unaligned
 1966 03f2 002B     		cmp	r3, #0
 1967 03f4 3FF442AF 		beq	.L148
 1968 03f8 E6E7     		b	.L151
 1969              	.LVL174:
 1970              	.L105:
 401:lwIP/src/core/ipv4/ip4_frag.c ****           /* fragment overlaps with following, throw away */
 1971              		.loc 1 401 9 is_stmt 1 view .LVU747
 401:lwIP/src/core/ipv4/ip4_frag.c ****           /* fragment overlaps with following, throw away */
 1972              		.loc 1 401 12 is_stmt 0 view .LVU748
 1973 03fa CA45     		cmp	r10, r9
 1974 03fc 3FF6D1AE 		bhi	.L102
 407:lwIP/src/core/ipv4/ip4_frag.c ****       }
 1975              		.loc 1 407 9 is_stmt 1 view .LVU749
 407:lwIP/src/core/ipv4/ip4_frag.c ****       }
 1976              		.loc 1 407 16 is_stmt 0 view .LVU750
 1977 0400 6760     		str	r7, [r4, #4]
 1978              	.LVL175:
 433:lwIP/src/core/ipv4/ip4_frag.c ****     if (iprh_prev != NULL) {
 1979              		.loc 1 433 3 is_stmt 1 view .LVU751
 1980 0402 2AE7     		b	.L106
 1981              	.L204:
 1982              		.align	2
 1983              	.L203:
 1984 0404 10000000 		.word	.LC7
 1985 0408 20000000 		.word	.LC2
 1986 040c 00000000 		.word	.LC6
 1987              	.LBE125:
 1988              	.LBE153:
 1989              		.cfi_endproc
 1990              	.LFE111:
 1992              		.section	.rodata.ip4_frag.str1.4,"aMS",%progbits,1
ARM GAS  /tmp/ccHPvcAz.s 			page 78


 1993              		.align	2
 1994              	.LC9:
 1995 0000 6970345F 		.ascii	"ip4_frag(): pbuf too short\000"
 1995      66726167 
 1995      28293A20 
 1995      70627566 
 1995      20746F6F 
 1996 001b 00       		.align	2
 1997              	.LC10:
 1998 001c 74686973 		.ascii	"this needs a pbuf in one piece!\000"
 1998      206E6565 
 1998      64732061 
 1998      20706275 
 1998      6620696E 
 1999              		.align	2
 2000              	.LC11:
 2001 003c 702D3E6C 		.ascii	"p->len >= poff\000"
 2001      656E203E 
 2001      3D20706F 
 2001      666600
 2002              		.section	.text.ip4_frag,"ax",%progbits
 2003              		.align	1
 2004              		.p2align 2,,3
 2005              		.global	ip4_frag
 2006              		.syntax unified
 2007              		.thumb
 2008              		.thumb_func
 2009              		.fpu fpv4-sp-d16
 2011              	ip4_frag:
 2012              	.LVL176:
 2013              	.LFB115:
 725:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
 726:lwIP/src/core/ipv4/ip4_frag.c **** 
 727:lwIP/src/core/ipv4/ip4_frag.c **** /**
 728:lwIP/src/core/ipv4/ip4_frag.c ****  * Fragment an IP datagram if too large for the netif.
 729:lwIP/src/core/ipv4/ip4_frag.c ****  *
 730:lwIP/src/core/ipv4/ip4_frag.c ****  * Chop the datagram in MTU sized chunks and send them in order
 731:lwIP/src/core/ipv4/ip4_frag.c ****  * by pointing PBUF_REFs into p.
 732:lwIP/src/core/ipv4/ip4_frag.c ****  *
 733:lwIP/src/core/ipv4/ip4_frag.c ****  * @param p ip packet to send
 734:lwIP/src/core/ipv4/ip4_frag.c ****  * @param netif the netif on which to send
 735:lwIP/src/core/ipv4/ip4_frag.c ****  * @param dest destination ip address to which to send
 736:lwIP/src/core/ipv4/ip4_frag.c ****  *
 737:lwIP/src/core/ipv4/ip4_frag.c ****  * @return ERR_OK if sent successfully, err_t otherwise
 738:lwIP/src/core/ipv4/ip4_frag.c ****  */
 739:lwIP/src/core/ipv4/ip4_frag.c **** err_t
 740:lwIP/src/core/ipv4/ip4_frag.c **** ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
 741:lwIP/src/core/ipv4/ip4_frag.c **** {
 2014              		.loc 1 741 1 view -0
 2015              		.cfi_startproc
 2016              		@ args = 0, pretend = 0, frame = 32
 2017              		@ frame_needed = 0, uses_anonymous_args = 0
 742:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *rambuf;
 2018              		.loc 1 742 3 view .LVU753
 743:lwIP/src/core/ipv4/ip4_frag.c **** #if !LWIP_NETIF_TX_SINGLE_PBUF
 744:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *newpbuf;
 2019              		.loc 1 744 3 view .LVU754
ARM GAS  /tmp/ccHPvcAz.s 			page 79


 745:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t newpbuflen = 0;
 2020              		.loc 1 745 3 view .LVU755
 746:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t left_to_copy;
 2021              		.loc 1 746 3 view .LVU756
 747:lwIP/src/core/ipv4/ip4_frag.c **** #endif
 748:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_hdr *original_iphdr;
 2022              		.loc 1 748 3 view .LVU757
 749:lwIP/src/core/ipv4/ip4_frag.c ****   struct ip_hdr *iphdr;
 2023              		.loc 1 749 3 view .LVU758
 750:lwIP/src/core/ipv4/ip4_frag.c ****   const u16_t nfb = (u16_t)((netif->mtu - IP_HLEN) / 8);
 2024              		.loc 1 750 3 view .LVU759
 741:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *rambuf;
 2025              		.loc 1 741 1 is_stmt 0 view .LVU760
 2026 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2027              	.LCFI12:
 2028              		.cfi_def_cfa_offset 36
 2029              		.cfi_offset 4, -36
 2030              		.cfi_offset 5, -32
 2031              		.cfi_offset 6, -28
 2032              		.cfi_offset 7, -24
 2033              		.cfi_offset 8, -20
 2034              		.cfi_offset 9, -16
 2035              		.cfi_offset 10, -12
 2036              		.cfi_offset 11, -8
 2037              		.cfi_offset 14, -4
 751:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t left, fragsize;
 752:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t ofo;
 753:lwIP/src/core/ipv4/ip4_frag.c ****   int last;
 754:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t poff = IP_HLEN;
 755:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t tmp;
 756:lwIP/src/core/ipv4/ip4_frag.c ****   int mf_set;
 757:lwIP/src/core/ipv4/ip4_frag.c **** 
 758:lwIP/src/core/ipv4/ip4_frag.c ****   original_iphdr = (struct ip_hdr *)p->payload;
 2038              		.loc 1 758 18 view .LVU761
 2039 0004 D0F804A0 		ldr	r10, [r0, #4]
 741:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *rambuf;
 2040              		.loc 1 741 1 view .LVU762
 2041 0008 2DED028B 		vpush.64	{d8}
 2042              	.LCFI13:
 2043              		.cfi_def_cfa_offset 44
 2044              		.cfi_offset 80, -44
 2045              		.cfi_offset 81, -40
 759:lwIP/src/core/ipv4/ip4_frag.c ****   iphdr = original_iphdr;
 760:lwIP/src/core/ipv4/ip4_frag.c ****   if (IPH_HL_BYTES(iphdr) != IP_HLEN) {
 2046              		.loc 1 760 7 view .LVU763
 2047 000c 9AF80030 		ldrb	r3, [r10]	@ zero_extendqisi2
 741:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *rambuf;
 2048              		.loc 1 741 1 view .LVU764
 2049 0010 8BB0     		sub	sp, sp, #44
 2050              	.LCFI14:
 2051              		.cfi_def_cfa_offset 88
 2052              		.loc 1 760 7 view .LVU765
 2053 0012 03F00F03 		and	r3, r3, #15
 741:lwIP/src/core/ipv4/ip4_frag.c ****   struct pbuf *rambuf;
 2054              		.loc 1 741 1 view .LVU766
 2055 0016 0591     		str	r1, [sp, #20]
 2056              	.LVL177:
ARM GAS  /tmp/ccHPvcAz.s 			page 80


 751:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t left, fragsize;
 2057              		.loc 1 751 3 is_stmt 1 view .LVU767
 752:lwIP/src/core/ipv4/ip4_frag.c ****   int last;
 2058              		.loc 1 752 3 view .LVU768
 753:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t poff = IP_HLEN;
 2059              		.loc 1 753 3 view .LVU769
 754:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t tmp;
 2060              		.loc 1 754 3 view .LVU770
 755:lwIP/src/core/ipv4/ip4_frag.c ****   int mf_set;
 2061              		.loc 1 755 3 view .LVU771
 756:lwIP/src/core/ipv4/ip4_frag.c **** 
 2062              		.loc 1 756 3 view .LVU772
 758:lwIP/src/core/ipv4/ip4_frag.c ****   iphdr = original_iphdr;
 2063              		.loc 1 758 3 view .LVU773
 759:lwIP/src/core/ipv4/ip4_frag.c ****   if (IPH_HL_BYTES(iphdr) != IP_HLEN) {
 2064              		.loc 1 759 3 view .LVU774
 2065              		.loc 1 760 3 view .LVU775
 2066              		.loc 1 760 6 is_stmt 0 view .LVU776
 2067 0018 052B     		cmp	r3, #5
 2068 001a 40F0EE80 		bne	.L225
 761:lwIP/src/core/ipv4/ip4_frag.c ****     /* ip4_frag() does not support IP options */
 762:lwIP/src/core/ipv4/ip4_frag.c ****     return ERR_VAL;
 763:lwIP/src/core/ipv4/ip4_frag.c ****   }
 764:lwIP/src/core/ipv4/ip4_frag.c ****   LWIP_ERROR("ip4_frag(): pbuf too short", p->len >= IP_HLEN, return ERR_VAL);
 2069              		.loc 1 764 3 view .LVU777
 2070 001e 4389     		ldrh	r3, [r0, #10]
 2071 0020 0546     		mov	r5, r0
 2072              		.loc 1 764 3 is_stmt 1 view .LVU778
 2073              		.loc 1 764 3 view .LVU779
 2074 0022 132B     		cmp	r3, #19
 2075 0024 40F2BF80 		bls	.L241
 2076              		.loc 1 764 3 discriminator 2 view .LVU780
 765:lwIP/src/core/ipv4/ip4_frag.c **** 
 766:lwIP/src/core/ipv4/ip4_frag.c ****   /* Save original offset */
 767:lwIP/src/core/ipv4/ip4_frag.c ****   tmp = lwip_ntohs(IPH_OFFSET(iphdr));
 2077              		.loc 1 767 3 discriminator 2 view .LVU781
 2078              	.LVL178:
 2079              	.LBB165:
 2080              	.LBI165:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2081              		.loc 2 934 30 discriminator 2 view .LVU782
 2082              	.LBB166:
 2083              		.loc 2 937 3 discriminator 2 view .LVU783
 2084              	.LBE166:
 2085              	.LBE165:
 2086              		.loc 1 767 9 is_stmt 0 discriminator 2 view .LVU784
 2087 0028 BAF80630 		ldrh	r3, [r10, #6]	@ unaligned
 2088 002c 08EE102A 		vmov	s16, r2	@ int
 768:lwIP/src/core/ipv4/ip4_frag.c ****   ofo = tmp & IP_OFFMASK;
 769:lwIP/src/core/ipv4/ip4_frag.c ****   /* already fragmented? if so, the last fragment we create must have MF, too */
 770:lwIP/src/core/ipv4/ip4_frag.c ****   mf_set = tmp & IP_MF;
 771:lwIP/src/core/ipv4/ip4_frag.c **** 
 772:lwIP/src/core/ipv4/ip4_frag.c ****   left = (u16_t)(p->tot_len - IP_HLEN);
 2089              		.loc 1 772 8 discriminator 2 view .LVU785
 2090 0030 0289     		ldrh	r2, [r0, #8]
 2091              	.LVL179:
 2092              	.LBB168:
ARM GAS  /tmp/ccHPvcAz.s 			page 81


 2093              	.LBB167:
 2094              		.loc 2 937 19 discriminator 2 view .LVU786
 2095 0032 5BBA     		rev16	r3, r3
 2096              	.LVL180:
 2097              		.loc 2 937 19 discriminator 2 view .LVU787
 2098              	.LBE167:
 2099              	.LBE168:
 768:lwIP/src/core/ipv4/ip4_frag.c ****   ofo = tmp & IP_OFFMASK;
 2100              		.loc 1 768 3 is_stmt 1 discriminator 2 view .LVU788
 2101              		.loc 1 772 8 is_stmt 0 discriminator 2 view .LVU789
 2102 0034 143A     		subs	r2, r2, #20
 768:lwIP/src/core/ipv4/ip4_frag.c ****   ofo = tmp & IP_OFFMASK;
 2103              		.loc 1 768 7 discriminator 2 view .LVU790
 2104 0036 C3F30C01 		ubfx	r1, r3, #0, #13
 2105              	.LVL181:
 768:lwIP/src/core/ipv4/ip4_frag.c ****   ofo = tmp & IP_OFFMASK;
 2106              		.loc 1 768 7 discriminator 2 view .LVU791
 2107 003a 03F40053 		and	r3, r3, #8192
 2108              	.LVL182:
 2109              		.loc 1 772 8 discriminator 2 view .LVU792
 2110 003e 92B2     		uxth	r2, r2
 768:lwIP/src/core/ipv4/ip4_frag.c ****   ofo = tmp & IP_OFFMASK;
 2111              		.loc 1 768 7 discriminator 2 view .LVU793
 2112 0040 0391     		str	r1, [sp, #12]
 2113              	.LVL183:
 770:lwIP/src/core/ipv4/ip4_frag.c **** 
 2114              		.loc 1 770 3 is_stmt 1 discriminator 2 view .LVU794
 2115              		.loc 1 772 8 is_stmt 0 discriminator 2 view .LVU795
 2116 0042 0292     		str	r2, [sp, #8]
 2117 0044 0793     		str	r3, [sp, #28]
 2118              	.LVL184:
 2119              		.loc 1 772 3 is_stmt 1 discriminator 2 view .LVU796
 773:lwIP/src/core/ipv4/ip4_frag.c **** 
 774:lwIP/src/core/ipv4/ip4_frag.c ****   while (left) {
 2120              		.loc 1 774 3 discriminator 2 view .LVU797
 2121              		.loc 1 774 9 discriminator 2 view .LVU798
 2122 0046 002A     		cmp	r2, #0
 2123 0048 00F0A880 		beq	.L224
 750:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t left, fragsize;
 2124              		.loc 1 750 35 is_stmt 0 view .LVU799
 2125 004c 059B     		ldr	r3, [sp, #20]
 754:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t tmp;
 2126              		.loc 1 754 9 view .LVU800
 2127 004e 1426     		movs	r6, #20
 745:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t left_to_copy;
 2128              		.loc 1 745 9 view .LVU801
 2129 0050 0024     		movs	r4, #0
 750:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t left, fragsize;
 2130              		.loc 1 750 35 view .LVU802
 2131 0052 9B8B     		ldrh	r3, [r3, #28]
 750:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t left, fragsize;
 2132              		.loc 1 750 52 view .LVU803
 2133 0054 B3F11402 		subs	r2, r3, #20
 2134              	.LVL185:
 750:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t left, fragsize;
 2135              		.loc 1 750 52 view .LVU804
 2136 0058 48BF     		it	mi
ARM GAS  /tmp/ccHPvcAz.s 			page 82


 2137 005a A3F10D02 		submi	r2, r3, #13
 750:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t left, fragsize;
 2138              		.loc 1 750 15 view .LVU805
 2139 005e C2F3CF03 		ubfx	r3, r2, #3, #16
 2140 0062 0893     		str	r3, [sp, #32]
 775:lwIP/src/core/ipv4/ip4_frag.c ****     /* Fill this fragment */
 776:lwIP/src/core/ipv4/ip4_frag.c ****     fragsize = LWIP_MIN(left, (u16_t)(nfb * 8));
 2141              		.loc 1 776 16 view .LVU806
 2142 0064 DB00     		lsls	r3, r3, #3
 2143 0066 9BB2     		uxth	r3, r3
 2144 0068 0693     		str	r3, [sp, #24]
 2145              	.LVL186:
 2146              	.L223:
 2147              		.loc 1 776 5 is_stmt 1 view .LVU807
 2148              		.loc 1 776 14 is_stmt 0 view .LVU808
 2149 006a 069B     		ldr	r3, [sp, #24]
 777:lwIP/src/core/ipv4/ip4_frag.c **** 
 778:lwIP/src/core/ipv4/ip4_frag.c **** #if LWIP_NETIF_TX_SINGLE_PBUF
 779:lwIP/src/core/ipv4/ip4_frag.c ****     rambuf = pbuf_alloc(PBUF_IP, fragsize, PBUF_RAM);
 780:lwIP/src/core/ipv4/ip4_frag.c ****     if (rambuf == NULL) {
 781:lwIP/src/core/ipv4/ip4_frag.c ****       goto memerr;
 782:lwIP/src/core/ipv4/ip4_frag.c ****     }
 783:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("this needs a pbuf in one piece!",
 784:lwIP/src/core/ipv4/ip4_frag.c ****                 (rambuf->len == rambuf->tot_len) && (rambuf->next == NULL));
 785:lwIP/src/core/ipv4/ip4_frag.c ****     poff += pbuf_copy_partial(p, rambuf->payload, fragsize, poff);
 786:lwIP/src/core/ipv4/ip4_frag.c ****     /* make room for the IP header */
 787:lwIP/src/core/ipv4/ip4_frag.c ****     if (pbuf_add_header(rambuf, IP_HLEN)) {
 788:lwIP/src/core/ipv4/ip4_frag.c ****       pbuf_free(rambuf);
 789:lwIP/src/core/ipv4/ip4_frag.c ****       goto memerr;
 790:lwIP/src/core/ipv4/ip4_frag.c ****     }
 791:lwIP/src/core/ipv4/ip4_frag.c ****     /* fill in the IP header */
 792:lwIP/src/core/ipv4/ip4_frag.c ****     SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 793:lwIP/src/core/ipv4/ip4_frag.c ****     iphdr = (struct ip_hdr *)rambuf->payload;
 794:lwIP/src/core/ipv4/ip4_frag.c **** #else /* LWIP_NETIF_TX_SINGLE_PBUF */
 795:lwIP/src/core/ipv4/ip4_frag.c ****     /* When not using a static buffer, create a chain of pbufs.
 796:lwIP/src/core/ipv4/ip4_frag.c ****      * The first will be a PBUF_RAM holding the link and IP header.
 797:lwIP/src/core/ipv4/ip4_frag.c ****      * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
 798:lwIP/src/core/ipv4/ip4_frag.c ****      * but limited to the size of an mtu.
 799:lwIP/src/core/ipv4/ip4_frag.c ****      */
 800:lwIP/src/core/ipv4/ip4_frag.c ****     rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 2150              		.loc 1 800 14 view .LVU809
 2151 006c 4FF42072 		mov	r2, #640
 776:lwIP/src/core/ipv4/ip4_frag.c **** 
 2152              		.loc 1 776 14 view .LVU810
 2153 0070 029F     		ldr	r7, [sp, #8]
 2154              		.loc 1 800 14 view .LVU811
 2155 0072 1421     		movs	r1, #20
 2156 0074 0E20     		movs	r0, #14
 776:lwIP/src/core/ipv4/ip4_frag.c **** 
 2157              		.loc 1 776 14 view .LVU812
 2158 0076 BB42     		cmp	r3, r7
 2159 0078 28BF     		it	cs
 2160 007a 3B46     		movcs	r3, r7
 2161 007c 0493     		str	r3, [sp, #16]
 2162              	.LVL187:
 2163              		.loc 1 800 5 is_stmt 1 view .LVU813
 2164              		.loc 1 800 14 is_stmt 0 view .LVU814
ARM GAS  /tmp/ccHPvcAz.s 			page 83


 2165 007e FFF7FEFF 		bl	pbuf_alloc
 2166              	.LVL188:
 801:lwIP/src/core/ipv4/ip4_frag.c ****     if (rambuf == NULL) {
 2167              		.loc 1 801 5 is_stmt 1 view .LVU815
 2168              		.loc 1 801 8 is_stmt 0 view .LVU816
 2169 0082 8046     		mov	r8, r0
 2170 0084 0028     		cmp	r0, #0
 2171 0086 00F0B580 		beq	.L226
 802:lwIP/src/core/ipv4/ip4_frag.c ****       goto memerr;
 803:lwIP/src/core/ipv4/ip4_frag.c ****     }
 804:lwIP/src/core/ipv4/ip4_frag.c ****     LWIP_ASSERT("this needs a pbuf in one piece!",
 2172              		.loc 1 804 5 is_stmt 1 view .LVU817
 2173              		.loc 1 804 5 view .LVU818
 2174 008a 4389     		ldrh	r3, [r0, #10]
 2175 008c 132B     		cmp	r3, #19
 2176 008e 40F2AD80 		bls	.L242
 2177              		.loc 1 804 5 discriminator 2 view .LVU819
 805:lwIP/src/core/ipv4/ip4_frag.c ****                 (rambuf->len >= (IP_HLEN)));
 806:lwIP/src/core/ipv4/ip4_frag.c ****     SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 2178              		.loc 1 806 5 discriminator 2 view .LVU820
 2179 0092 4368     		ldr	r3, [r0, #4]
 2180 0094 DAF80020 		ldr	r2, [r10]	@ unaligned
 2181 0098 DAF80470 		ldr	r7, [r10, #4]	@ unaligned
 2182 009c DAF80800 		ldr	r0, [r10, #8]	@ unaligned
 2183              	.LVL189:
 2184              		.loc 1 806 5 is_stmt 0 discriminator 2 view .LVU821
 2185 00a0 DAF80C10 		ldr	r1, [r10, #12]	@ unaligned
 2186 00a4 1A60     		str	r2, [r3]	@ unaligned
 2187 00a6 5F60     		str	r7, [r3, #4]	@ unaligned
 2188 00a8 9860     		str	r0, [r3, #8]	@ unaligned
 2189 00aa D960     		str	r1, [r3, #12]	@ unaligned
 2190 00ac DAF81020 		ldr	r2, [r10, #16]	@ unaligned
 2191 00b0 1A61     		str	r2, [r3, #16]	@ unaligned
 807:lwIP/src/core/ipv4/ip4_frag.c ****     iphdr = (struct ip_hdr *)rambuf->payload;
 2192              		.loc 1 807 5 is_stmt 1 discriminator 2 view .LVU822
 808:lwIP/src/core/ipv4/ip4_frag.c **** 
 809:lwIP/src/core/ipv4/ip4_frag.c ****     left_to_copy = fragsize;
 810:lwIP/src/core/ipv4/ip4_frag.c ****     while (left_to_copy) {
 2193              		.loc 1 810 11 is_stmt 0 discriminator 2 view .LVU823
 2194 00b2 049B     		ldr	r3, [sp, #16]
 807:lwIP/src/core/ipv4/ip4_frag.c ****     iphdr = (struct ip_hdr *)rambuf->payload;
 2195              		.loc 1 807 11 discriminator 2 view .LVU824
 2196 00b4 D8F804B0 		ldr	fp, [r8, #4]
 2197              	.LVL190:
 809:lwIP/src/core/ipv4/ip4_frag.c ****     while (left_to_copy) {
 2198              		.loc 1 809 5 is_stmt 1 discriminator 2 view .LVU825
 2199              		.loc 1 810 5 discriminator 2 view .LVU826
 2200              		.loc 1 810 11 discriminator 2 view .LVU827
 2201 00b8 002B     		cmp	r3, #0
 2202 00ba 37D0     		beq	.L213
 2203              		.loc 1 810 11 is_stmt 0 view .LVU828
 2204 00bc CDF824A0 		str	r10, [sp, #36]
 2205 00c0 9946     		mov	r9, r3
 2206 00c2 C246     		mov	r10, r8
 2207              	.LVL191:
 2208              	.L220:
 2209              	.LBB169:
ARM GAS  /tmp/ccHPvcAz.s 			page 84


 811:lwIP/src/core/ipv4/ip4_frag.c ****       struct pbuf_custom_ref *pcr;
 2210              		.loc 1 811 7 is_stmt 1 view .LVU829
 812:lwIP/src/core/ipv4/ip4_frag.c ****       u16_t plen = (u16_t)(p->len - poff);
 2211              		.loc 1 812 7 view .LVU830
 813:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_ASSERT("p->len >= poff", p->len >= poff);
 2212              		.loc 1 813 7 view .LVU831
 814:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2213              		.loc 1 814 7 view .LVU832
 815:lwIP/src/core/ipv4/ip4_frag.c ****       /* Is this pbuf already empty? */
 816:lwIP/src/core/ipv4/ip4_frag.c ****       if (!newpbuflen) {
 817:lwIP/src/core/ipv4/ip4_frag.c ****         poff = 0;
 2214              		.loc 1 817 9 view .LVU833
 818:lwIP/src/core/ipv4/ip4_frag.c ****         p = p->next;
 2215              		.loc 1 818 9 view .LVU834
 819:lwIP/src/core/ipv4/ip4_frag.c ****         continue;
 820:lwIP/src/core/ipv4/ip4_frag.c ****       }
 821:lwIP/src/core/ipv4/ip4_frag.c ****       pcr = ip_frag_alloc_pbuf_custom_ref();
 2216              		.loc 1 821 7 view .LVU835
 2217              	.LBB170:
 2218              	.LBI170:
 699:lwIP/src/core/ipv4/ip4_frag.c **** {
 2219              		.loc 1 699 1 view .LVU836
 2220              	.LBB171:
 701:lwIP/src/core/ipv4/ip4_frag.c **** }
 2221              		.loc 1 701 3 view .LVU837
 2222              	.LBE171:
 2223              	.LBE170:
 812:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_ASSERT("p->len >= poff", p->len >= poff);
 2224              		.loc 1 812 29 is_stmt 0 view .LVU838
 2225 00c4 6B89     		ldrh	r3, [r5, #10]
 2226              	.LBB175:
 2227              	.LBB172:
 701:lwIP/src/core/ipv4/ip4_frag.c **** }
 2228              		.loc 1 701 36 view .LVU839
 2229 00c6 0520     		movs	r0, #5
 2230              	.LBE172:
 2231              	.LBE175:
 812:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_ASSERT("p->len >= poff", p->len >= poff);
 2232              		.loc 1 812 13 view .LVU840
 2233 00c8 9C1B     		subs	r4, r3, r6
 813:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2234              		.loc 1 813 7 view .LVU841
 2235 00ca B342     		cmp	r3, r6
 812:lwIP/src/core/ipv4/ip4_frag.c ****       LWIP_ASSERT("p->len >= poff", p->len >= poff);
 2236              		.loc 1 812 13 view .LVU842
 2237 00cc A4B2     		uxth	r4, r4
 2238              	.LVL192:
 813:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2239              		.loc 1 813 7 is_stmt 1 view .LVU843
 813:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2240              		.loc 1 813 7 view .LVU844
 813:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2241              		.loc 1 813 7 is_stmt 0 view .LVU845
 2242 00ce 6ED3     		bcc	.L243
 814:lwIP/src/core/ipv4/ip4_frag.c ****       /* Is this pbuf already empty? */
 2243              		.loc 1 814 18 discriminator 2 view .LVU846
 2244 00d0 4C45     		cmp	r4, r9
ARM GAS  /tmp/ccHPvcAz.s 			page 85


 2245 00d2 28BF     		it	cs
 2246 00d4 4C46     		movcs	r4, r9
 2247              	.LVL193:
 816:lwIP/src/core/ipv4/ip4_frag.c ****         poff = 0;
 2248              		.loc 1 816 7 is_stmt 1 discriminator 2 view .LVU847
 816:lwIP/src/core/ipv4/ip4_frag.c ****         poff = 0;
 2249              		.loc 1 816 10 is_stmt 0 discriminator 2 view .LVU848
 2250 00d6 002C     		cmp	r4, #0
 2251 00d8 62D0     		beq	.L240
 2252              	.LBB176:
 2253              	.LBB173:
 701:lwIP/src/core/ipv4/ip4_frag.c **** }
 2254              		.loc 1 701 36 view .LVU849
 2255 00da FFF7FEFF 		bl	memp_malloc
 2256              	.LVL194:
 701:lwIP/src/core/ipv4/ip4_frag.c **** }
 2257              		.loc 1 701 36 view .LVU850
 2258              	.LBE173:
 2259              	.LBE176:
 822:lwIP/src/core/ipv4/ip4_frag.c ****       if (pcr == NULL) {
 823:lwIP/src/core/ipv4/ip4_frag.c ****         pbuf_free(rambuf);
 824:lwIP/src/core/ipv4/ip4_frag.c ****         goto memerr;
 825:lwIP/src/core/ipv4/ip4_frag.c ****       }
 826:lwIP/src/core/ipv4/ip4_frag.c ****       /* Mirror this pbuf, although we might not need all of it. */
 827:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
 2260              		.loc 1 827 7 is_stmt 1 view .LVU851
 2261              	.LBB177:
 2262              	.LBB174:
 701:lwIP/src/core/ipv4/ip4_frag.c **** }
 2263              		.loc 1 701 36 is_stmt 0 view .LVU852
 2264 00de 8046     		mov	r8, r0
 2265              	.LVL195:
 701:lwIP/src/core/ipv4/ip4_frag.c **** }
 2266              		.loc 1 701 36 view .LVU853
 2267              	.LBE174:
 2268              	.LBE177:
 822:lwIP/src/core/ipv4/ip4_frag.c ****       if (pcr == NULL) {
 2269              		.loc 1 822 7 is_stmt 1 view .LVU854
 2270              		.loc 1 827 17 is_stmt 0 view .LVU855
 2271 00e0 4122     		movs	r2, #65
 2272 00e2 2146     		mov	r1, r4
 2273 00e4 0020     		movs	r0, #0
 2274              	.LVL196:
 822:lwIP/src/core/ipv4/ip4_frag.c ****       if (pcr == NULL) {
 2275              		.loc 1 822 10 view .LVU856
 2276 00e6 B8F1000F 		cmp	r8, #0
 2277 00ea 72D0     		beq	.L244
 2278              		.loc 1 827 17 view .LVU857
 2279 00ec 0194     		str	r4, [sp, #4]
 2280 00ee 4346     		mov	r3, r8
 2281 00f0 6F68     		ldr	r7, [r5, #4]
 2282 00f2 3744     		add	r7, r7, r6
 2283 00f4 0097     		str	r7, [sp]
 2284 00f6 FFF7FEFF 		bl	pbuf_alloced_custom
 2285              	.LVL197:
 828:lwIP/src/core/ipv4/ip4_frag.c ****                                     (u8_t *)p->payload + poff, newpbuflen);
 829:lwIP/src/core/ipv4/ip4_frag.c ****       if (newpbuf == NULL) {
ARM GAS  /tmp/ccHPvcAz.s 			page 86


 830:lwIP/src/core/ipv4/ip4_frag.c ****         ip_frag_free_pbuf_custom_ref(pcr);
 831:lwIP/src/core/ipv4/ip4_frag.c ****         pbuf_free(rambuf);
 832:lwIP/src/core/ipv4/ip4_frag.c ****         goto memerr;
 833:lwIP/src/core/ipv4/ip4_frag.c ****       }
 834:lwIP/src/core/ipv4/ip4_frag.c ****       pbuf_ref(p);
 2286              		.loc 1 834 7 is_stmt 1 view .LVU858
 827:lwIP/src/core/ipv4/ip4_frag.c ****                                     (u8_t *)p->payload + poff, newpbuflen);
 2287              		.loc 1 827 17 is_stmt 0 view .LVU859
 2288 00fa 0746     		mov	r7, r0
 2289              	.LVL198:
 829:lwIP/src/core/ipv4/ip4_frag.c ****         ip_frag_free_pbuf_custom_ref(pcr);
 2290              		.loc 1 829 7 is_stmt 1 view .LVU860
 2291              		.loc 1 834 7 is_stmt 0 view .LVU861
 2292 00fc 2846     		mov	r0, r5
 2293              	.LVL199:
 829:lwIP/src/core/ipv4/ip4_frag.c ****         ip_frag_free_pbuf_custom_ref(pcr);
 2294              		.loc 1 829 10 view .LVU862
 2295 00fe 002F     		cmp	r7, #0
 2296 0100 59D0     		beq	.L245
 835:lwIP/src/core/ipv4/ip4_frag.c ****       pcr->original = p;
 836:lwIP/src/core/ipv4/ip4_frag.c ****       pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 837:lwIP/src/core/ipv4/ip4_frag.c **** 
 838:lwIP/src/core/ipv4/ip4_frag.c ****       /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
 839:lwIP/src/core/ipv4/ip4_frag.c ****        * so that it is removed when pbuf_dechain is later called on rambuf.
 840:lwIP/src/core/ipv4/ip4_frag.c ****        */
 841:lwIP/src/core/ipv4/ip4_frag.c ****       pbuf_cat(rambuf, newpbuf);
 842:lwIP/src/core/ipv4/ip4_frag.c ****       left_to_copy = (u16_t)(left_to_copy - newpbuflen);
 2297              		.loc 1 842 20 view .LVU863
 2298 0102 A9EB0409 		sub	r9, r9, r4
 2299              	.LVL200:
 834:lwIP/src/core/ipv4/ip4_frag.c ****       pcr->original = p;
 2300              		.loc 1 834 7 view .LVU864
 2301 0106 FFF7FEFF 		bl	pbuf_ref
 2302              	.LVL201:
 835:lwIP/src/core/ipv4/ip4_frag.c ****       pcr->original = p;
 2303              		.loc 1 835 7 is_stmt 1 view .LVU865
 836:lwIP/src/core/ipv4/ip4_frag.c **** 
 2304              		.loc 1 836 36 is_stmt 0 view .LVU866
 2305 010a 3D4B     		ldr	r3, .L246
 841:lwIP/src/core/ipv4/ip4_frag.c ****       left_to_copy = (u16_t)(left_to_copy - newpbuflen);
 2306              		.loc 1 841 7 view .LVU867
 2307 010c 3946     		mov	r1, r7
 2308              		.loc 1 842 20 view .LVU868
 2309 010e 1FFA89F9 		uxth	r9, r9
 841:lwIP/src/core/ipv4/ip4_frag.c ****       left_to_copy = (u16_t)(left_to_copy - newpbuflen);
 2310              		.loc 1 841 7 view .LVU869
 2311 0112 5046     		mov	r0, r10
 835:lwIP/src/core/ipv4/ip4_frag.c ****       pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 2312              		.loc 1 835 21 view .LVU870
 2313 0114 C8F81450 		str	r5, [r8, #20]
 836:lwIP/src/core/ipv4/ip4_frag.c **** 
 2314              		.loc 1 836 7 is_stmt 1 view .LVU871
 836:lwIP/src/core/ipv4/ip4_frag.c **** 
 2315              		.loc 1 836 36 is_stmt 0 view .LVU872
 2316 0118 C8F81030 		str	r3, [r8, #16]
 841:lwIP/src/core/ipv4/ip4_frag.c ****       left_to_copy = (u16_t)(left_to_copy - newpbuflen);
 2317              		.loc 1 841 7 is_stmt 1 view .LVU873
ARM GAS  /tmp/ccHPvcAz.s 			page 87


 2318 011c FFF7FEFF 		bl	pbuf_cat
 2319              	.LVL202:
 2320              		.loc 1 842 7 view .LVU874
 843:lwIP/src/core/ipv4/ip4_frag.c ****       if (left_to_copy) {
 844:lwIP/src/core/ipv4/ip4_frag.c ****         poff = 0;
 2321              		.loc 1 844 9 view .LVU875
 845:lwIP/src/core/ipv4/ip4_frag.c ****         p = p->next;
 2322              		.loc 1 845 9 view .LVU876
 843:lwIP/src/core/ipv4/ip4_frag.c ****       if (left_to_copy) {
 2323              		.loc 1 843 7 view .LVU877
 843:lwIP/src/core/ipv4/ip4_frag.c ****       if (left_to_copy) {
 2324              		.loc 1 843 10 is_stmt 0 view .LVU878
 2325 0120 B9F1000F 		cmp	r9, #0
 2326 0124 3CD1     		bne	.L240
 2327 0126 D046     		mov	r8, r10
 2328              	.LVL203:
 843:lwIP/src/core/ipv4/ip4_frag.c ****       if (left_to_copy) {
 2329              		.loc 1 843 10 view .LVU879
 2330 0128 DDF824A0 		ldr	r10, [sp, #36]
 2331              	.LVL204:
 2332              	.L213:
 843:lwIP/src/core/ipv4/ip4_frag.c ****       if (left_to_copy) {
 2333              		.loc 1 843 10 view .LVU880
 2334              	.LBE169:
 846:lwIP/src/core/ipv4/ip4_frag.c ****       }
 847:lwIP/src/core/ipv4/ip4_frag.c ****     }
 848:lwIP/src/core/ipv4/ip4_frag.c ****     poff = (u16_t)(poff + newpbuflen);
 2335              		.loc 1 848 5 is_stmt 1 view .LVU881
 849:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
 850:lwIP/src/core/ipv4/ip4_frag.c **** 
 851:lwIP/src/core/ipv4/ip4_frag.c ****     /* Correct header */
 852:lwIP/src/core/ipv4/ip4_frag.c ****     last = (left <= netif->mtu - IP_HLEN);
 2336              		.loc 1 852 26 is_stmt 0 view .LVU882
 2337 012c 059B     		ldr	r3, [sp, #20]
 848:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
 2338              		.loc 1 848 10 view .LVU883
 2339 012e 2644     		add	r6, r6, r4
 853:lwIP/src/core/ipv4/ip4_frag.c **** 
 854:lwIP/src/core/ipv4/ip4_frag.c ****     /* Set new offset and MF flag */
 855:lwIP/src/core/ipv4/ip4_frag.c ****     tmp = (IP_OFFMASK & (ofo));
 856:lwIP/src/core/ipv4/ip4_frag.c ****     if (!last || mf_set) {
 2340              		.loc 1 856 8 view .LVU884
 2341 0130 0299     		ldr	r1, [sp, #8]
 852:lwIP/src/core/ipv4/ip4_frag.c **** 
 2342              		.loc 1 852 26 view .LVU885
 2343 0132 9A8B     		ldrh	r2, [r3, #28]
 848:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
 2344              		.loc 1 848 10 view .LVU886
 2345 0134 B6B2     		uxth	r6, r6
 2346              	.LVL205:
 852:lwIP/src/core/ipv4/ip4_frag.c **** 
 2347              		.loc 1 852 5 is_stmt 1 view .LVU887
 855:lwIP/src/core/ipv4/ip4_frag.c ****     if (!last || mf_set) {
 2348              		.loc 1 855 5 view .LVU888
 855:lwIP/src/core/ipv4/ip4_frag.c ****     if (!last || mf_set) {
 2349              		.loc 1 855 9 is_stmt 0 view .LVU889
 2350 0136 039B     		ldr	r3, [sp, #12]
ARM GAS  /tmp/ccHPvcAz.s 			page 88


 2351              	.LVL206:
 852:lwIP/src/core/ipv4/ip4_frag.c **** 
 2352              		.loc 1 852 18 view .LVU890
 2353 0138 133A     		subs	r2, r2, #19
 855:lwIP/src/core/ipv4/ip4_frag.c ****     if (!last || mf_set) {
 2354              		.loc 1 855 9 view .LVU891
 2355 013a C3F30C03 		ubfx	r3, r3, #0, #13
 2356              	.LVL207:
 2357              		.loc 1 856 5 is_stmt 1 view .LVU892
 2358              		.loc 1 856 8 is_stmt 0 view .LVU893
 2359 013e 8A42     		cmp	r2, r1
 2360 0140 51DD     		ble	.L227
 2361 0142 079A     		ldr	r2, [sp, #28]
 2362 0144 002A     		cmp	r2, #0
 2363 0146 4ED1     		bne	.L227
 2364              	.L221:
 857:lwIP/src/core/ipv4/ip4_frag.c ****       /* the last fragment has MF set if the input frame had it */
 858:lwIP/src/core/ipv4/ip4_frag.c ****       tmp = tmp | IP_MF;
 859:lwIP/src/core/ipv4/ip4_frag.c ****     }
 860:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
 2365              		.loc 1 860 5 is_stmt 1 view .LVU894
 2366              	.LVL208:
 2367              	.LBB180:
 2368              	.LBI180:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2369              		.loc 2 934 30 view .LVU895
 2370              	.LBB181:
 2371              		.loc 2 937 3 view .LVU896
 2372              	.LBE181:
 2373              	.LBE180:
 861:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_LEN_SET(iphdr, lwip_htons((u16_t)(fragsize + IP_HLEN)));
 2374              		.loc 1 861 5 is_stmt 0 view .LVU897
 2375 0148 049A     		ldr	r2, [sp, #16]
 2376              	.LBB183:
 2377              	.LBB182:
 2378              		.loc 2 937 19 view .LVU898
 2379 014a 5BBA     		rev16	r3, r3
 2380              	.LVL209:
 2381              		.loc 2 937 19 view .LVU899
 2382              	.LBE182:
 2383              	.LBE183:
 862:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_CHKSUM_SET(iphdr, 0);
 2384              		.loc 1 862 5 view .LVU900
 2385 014c 0027     		movs	r7, #0
 863:lwIP/src/core/ipv4/ip4_frag.c **** #if CHECKSUM_GEN_IP
 864:lwIP/src/core/ipv4/ip4_frag.c ****     IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
 865:lwIP/src/core/ipv4/ip4_frag.c ****       IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 2386              		.loc 1 865 7 view .LVU901
 2387 014e 1421     		movs	r1, #20
 861:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_CHKSUM_SET(iphdr, 0);
 2388              		.loc 1 861 5 view .LVU902
 2389 0150 1432     		adds	r2, r2, #20
 860:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_LEN_SET(iphdr, lwip_htons((u16_t)(fragsize + IP_HLEN)));
 2390              		.loc 1 860 5 view .LVU903
 2391 0152 ABF80630 		strh	r3, [fp, #6]	@ unaligned
 861:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_CHKSUM_SET(iphdr, 0);
 2392              		.loc 1 861 5 is_stmt 1 view .LVU904
ARM GAS  /tmp/ccHPvcAz.s 			page 89


 2393              	.LVL210:
 2394              	.LBB184:
 2395              	.LBI184:
 934:STM32_XPD/CMSIS/Include/cmsis_gcc.h **** {
 2396              		.loc 2 934 30 view .LVU905
 2397              	.LBB185:
 2398              		.loc 2 937 3 view .LVU906
 2399              		.loc 2 937 3 is_stmt 0 view .LVU907
 2400              	.LBE185:
 2401              	.LBE184:
 862:lwIP/src/core/ipv4/ip4_frag.c **** #if CHECKSUM_GEN_IP
 2402              		.loc 1 862 5 view .LVU908
 2403 0156 8BF80A70 		strb	r7, [fp, #10]
 2404              		.loc 1 865 7 view .LVU909
 2405 015a 5846     		mov	r0, fp
 2406              	.LBB187:
 2407              	.LBB186:
 2408              		.loc 2 937 19 view .LVU910
 2409 015c 52BA     		rev16	r2, r2
 2410              	.LBE186:
 2411              	.LBE187:
 862:lwIP/src/core/ipv4/ip4_frag.c **** #if CHECKSUM_GEN_IP
 2412              		.loc 1 862 5 view .LVU911
 2413 015e 8BF80B70 		strb	r7, [fp, #11]
 861:lwIP/src/core/ipv4/ip4_frag.c ****     IPH_CHKSUM_SET(iphdr, 0);
 2414              		.loc 1 861 5 view .LVU912
 2415 0162 ABF80220 		strh	r2, [fp, #2]	@ unaligned
 862:lwIP/src/core/ipv4/ip4_frag.c **** #if CHECKSUM_GEN_IP
 2416              		.loc 1 862 5 is_stmt 1 view .LVU913
 2417              		.loc 1 865 7 view .LVU914
 2418 0166 FFF7FEFF 		bl	inet_chksum
 2419              	.LVL211:
 866:lwIP/src/core/ipv4/ip4_frag.c ****     }
 867:lwIP/src/core/ipv4/ip4_frag.c **** #endif /* CHECKSUM_GEN_IP */
 868:lwIP/src/core/ipv4/ip4_frag.c **** 
 869:lwIP/src/core/ipv4/ip4_frag.c ****     /* No need for separate header pbuf - we allowed room for it in rambuf
 870:lwIP/src/core/ipv4/ip4_frag.c ****      * when allocated.
 871:lwIP/src/core/ipv4/ip4_frag.c ****      */
 872:lwIP/src/core/ipv4/ip4_frag.c ****     netif->output(netif, rambuf, dest);
 2420              		.loc 1 872 5 is_stmt 0 view .LVU915
 2421 016a 059F     		ldr	r7, [sp, #20]
 2422 016c 18EE102A 		vmov	r2, s16	@ int
 2423 0170 4146     		mov	r1, r8
 2424 0172 3B69     		ldr	r3, [r7, #16]
 865:lwIP/src/core/ipv4/ip4_frag.c ****     }
 2425              		.loc 1 865 7 view .LVU916
 2426 0174 ABF80A00 		strh	r0, [fp, #10]	@ unaligned
 2427              		.loc 1 872 5 is_stmt 1 view .LVU917
 2428 0178 3846     		mov	r0, r7
 2429 017a 9847     		blx	r3
 2430              	.LVL212:
 873:lwIP/src/core/ipv4/ip4_frag.c ****     IPFRAG_STATS_INC(ip_frag.xmit);
 2431              		.loc 1 873 35 view .LVU918
 874:lwIP/src/core/ipv4/ip4_frag.c **** 
 875:lwIP/src/core/ipv4/ip4_frag.c ****     /* Unfortunately we can't reuse rambuf - the hardware may still be
 876:lwIP/src/core/ipv4/ip4_frag.c ****      * using the buffer. Instead we free it (and the ensuing chain) and
 877:lwIP/src/core/ipv4/ip4_frag.c ****      * recreate it next time round the loop. If we're lucky the hardware
ARM GAS  /tmp/ccHPvcAz.s 			page 90


 878:lwIP/src/core/ipv4/ip4_frag.c ****      * will have already sent the packet, the free will really free, and
 879:lwIP/src/core/ipv4/ip4_frag.c ****      * there will be zero memory penalty.
 880:lwIP/src/core/ipv4/ip4_frag.c ****      */
 881:lwIP/src/core/ipv4/ip4_frag.c **** 
 882:lwIP/src/core/ipv4/ip4_frag.c ****     pbuf_free(rambuf);
 2432              		.loc 1 882 5 view .LVU919
 2433 017c 4046     		mov	r0, r8
 2434 017e FFF7FEFF 		bl	pbuf_free
 2435              	.LVL213:
 883:lwIP/src/core/ipv4/ip4_frag.c ****     left = (u16_t)(left - fragsize);
 2436              		.loc 1 883 5 view .LVU920
 2437              		.loc 1 883 10 is_stmt 0 view .LVU921
 2438 0182 029B     		ldr	r3, [sp, #8]
 2439 0184 049A     		ldr	r2, [sp, #16]
 884:lwIP/src/core/ipv4/ip4_frag.c ****     ofo = (u16_t)(ofo + nfb);
 2440              		.loc 1 884 9 view .LVU922
 2441 0186 0899     		ldr	r1, [sp, #32]
 883:lwIP/src/core/ipv4/ip4_frag.c ****     left = (u16_t)(left - fragsize);
 2442              		.loc 1 883 10 view .LVU923
 2443 0188 9B1A     		subs	r3, r3, r2
 2444              		.loc 1 884 9 view .LVU924
 2445 018a 039A     		ldr	r2, [sp, #12]
 2446 018c 0A44     		add	r2, r2, r1
 883:lwIP/src/core/ipv4/ip4_frag.c ****     left = (u16_t)(left - fragsize);
 2447              		.loc 1 883 10 view .LVU925
 2448 018e 9BB2     		uxth	r3, r3
 2449              		.loc 1 884 9 view .LVU926
 2450 0190 92B2     		uxth	r2, r2
 883:lwIP/src/core/ipv4/ip4_frag.c ****     left = (u16_t)(left - fragsize);
 2451              		.loc 1 883 10 view .LVU927
 2452 0192 0293     		str	r3, [sp, #8]
 2453              	.LVL214:
 2454              		.loc 1 884 5 is_stmt 1 view .LVU928
 2455              		.loc 1 884 9 is_stmt 0 view .LVU929
 2456 0194 0392     		str	r2, [sp, #12]
 2457              	.LVL215:
 774:lwIP/src/core/ipv4/ip4_frag.c ****     /* Fill this fragment */
 2458              		.loc 1 774 9 is_stmt 1 view .LVU930
 2459 0196 002B     		cmp	r3, #0
 2460 0198 7FF467AF 		bne	.L223
 2461              	.LVL216:
 2462              	.L224:
 885:lwIP/src/core/ipv4/ip4_frag.c ****   }
 886:lwIP/src/core/ipv4/ip4_frag.c ****   MIB2_STATS_INC(mib2.ipfragoks);
 887:lwIP/src/core/ipv4/ip4_frag.c ****   return ERR_OK;
 2463              		.loc 1 887 10 is_stmt 0 view .LVU931
 2464 019c 0020     		movs	r0, #0
 2465 019e 13E0     		b	.L206
 2466              	.LVL217:
 2467              	.L240:
 2468              	.LBB188:
 845:lwIP/src/core/ipv4/ip4_frag.c ****       }
 2469              		.loc 1 845 11 view .LVU932
 2470 01a0 2D68     		ldr	r5, [r5]
 2471              	.LVL218:
 845:lwIP/src/core/ipv4/ip4_frag.c ****       }
 2472              		.loc 1 845 11 view .LVU933
ARM GAS  /tmp/ccHPvcAz.s 			page 91


 2473              	.LBE188:
 810:lwIP/src/core/ipv4/ip4_frag.c ****       struct pbuf_custom_ref *pcr;
 2474              		.loc 1 810 11 is_stmt 1 view .LVU934
 745:lwIP/src/core/ipv4/ip4_frag.c ****   u16_t left_to_copy;
 2475              		.loc 1 745 9 is_stmt 0 view .LVU935
 2476 01a2 0026     		movs	r6, #0
 2477 01a4 8EE7     		b	.L220
 2478              	.LVL219:
 2479              	.L241:
 764:lwIP/src/core/ipv4/ip4_frag.c **** 
 2480              		.loc 1 764 3 is_stmt 1 discriminator 1 view .LVU936
 2481 01a6 1748     		ldr	r0, .L246+4
 2482              	.LVL220:
 764:lwIP/src/core/ipv4/ip4_frag.c **** 
 2483              		.loc 1 764 3 is_stmt 0 discriminator 1 view .LVU937
 2484 01a8 FFF7FEFF 		bl	printf
 2485              	.LVL221:
 2486              	.L208:
 764:lwIP/src/core/ipv4/ip4_frag.c **** 
 2487              		.loc 1 764 3 is_stmt 1 discriminator 1 view .LVU938
 764:lwIP/src/core/ipv4/ip4_frag.c **** 
 2488              		.loc 1 764 3 discriminator 1 view .LVU939
 764:lwIP/src/core/ipv4/ip4_frag.c **** 
 2489              		.loc 1 764 3 discriminator 1 view .LVU940
 764:lwIP/src/core/ipv4/ip4_frag.c **** 
 2490              		.loc 1 764 3 discriminator 1 view .LVU941
 764:lwIP/src/core/ipv4/ip4_frag.c **** 
 2491              		.loc 1 764 3 discriminator 1 view .LVU942
 764:lwIP/src/core/ipv4/ip4_frag.c **** 
 2492              		.loc 1 764 3 discriminator 1 view .LVU943
 2493 01ac FEE7     		b	.L208
 2494              	.LVL222:
 2495              	.L243:
 2496              	.LBB189:
 813:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2497              		.loc 1 813 7 discriminator 1 view .LVU944
 2498 01ae 1648     		ldr	r0, .L246+8
 2499 01b0 FFF7FEFF 		bl	printf
 2500              	.LVL223:
 2501              	.L215:
 813:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2502              		.loc 1 813 7 discriminator 3 view .LVU945
 813:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2503              		.loc 1 813 7 discriminator 3 view .LVU946
 813:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2504              		.loc 1 813 7 discriminator 3 view .LVU947
 813:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2505              		.loc 1 813 7 discriminator 3 view .LVU948
 813:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2506              		.loc 1 813 7 discriminator 3 view .LVU949
 813:lwIP/src/core/ipv4/ip4_frag.c ****       newpbuflen = LWIP_MIN(left_to_copy, plen);
 2507              		.loc 1 813 7 discriminator 3 view .LVU950
 2508 01b4 FEE7     		b	.L215
 2509              	.LVL224:
 2510              	.L245:
 830:lwIP/src/core/ipv4/ip4_frag.c ****         pbuf_free(rambuf);
 2511              		.loc 1 830 9 view .LVU951
ARM GAS  /tmp/ccHPvcAz.s 			page 92


 2512              	.LBB178:
 2513              	.LBI178:
 706:lwIP/src/core/ipv4/ip4_frag.c **** {
 2514              		.loc 1 706 1 view .LVU952
 2515              	.LBB179:
 708:lwIP/src/core/ipv4/ip4_frag.c ****   memp_free(MEMP_FRAG_PBUF, p);
 2516              		.loc 1 708 3 view .LVU953
 708:lwIP/src/core/ipv4/ip4_frag.c ****   memp_free(MEMP_FRAG_PBUF, p);
 2517              		.loc 1 708 3 view .LVU954
 708:lwIP/src/core/ipv4/ip4_frag.c ****   memp_free(MEMP_FRAG_PBUF, p);
 2518              		.loc 1 708 3 view .LVU955
 709:lwIP/src/core/ipv4/ip4_frag.c **** }
 2519              		.loc 1 709 3 view .LVU956
 2520 01b6 4146     		mov	r1, r8
 2521 01b8 0520     		movs	r0, #5
 2522              	.LVL225:
 709:lwIP/src/core/ipv4/ip4_frag.c **** }
 2523              		.loc 1 709 3 is_stmt 0 view .LVU957
 2524 01ba FFF7FEFF 		bl	memp_free
 2525              	.LVL226:
 709:lwIP/src/core/ipv4/ip4_frag.c **** }
 2526              		.loc 1 709 3 view .LVU958
 2527              	.LBE179:
 2528              	.LBE178:
 831:lwIP/src/core/ipv4/ip4_frag.c ****         goto memerr;
 2529              		.loc 1 831 9 is_stmt 1 view .LVU959
 2530 01be 5046     		mov	r0, r10
 2531 01c0 FFF7FEFF 		bl	pbuf_free
 2532              	.LVL227:
 832:lwIP/src/core/ipv4/ip4_frag.c ****       }
 2533              		.loc 1 832 9 view .LVU960
 2534              	.LBE189:
 888:lwIP/src/core/ipv4/ip4_frag.c **** memerr:
 889:lwIP/src/core/ipv4/ip4_frag.c ****   MIB2_STATS_INC(mib2.ipfragfails);
 890:lwIP/src/core/ipv4/ip4_frag.c ****   return ERR_MEM;
 2535              		.loc 1 890 10 is_stmt 0 view .LVU961
 2536 01c4 4FF0FF30 		mov	r0, #-1
 2537              	.LVL228:
 2538              	.L206:
 891:lwIP/src/core/ipv4/ip4_frag.c **** }
 2539              		.loc 1 891 1 view .LVU962
 2540 01c8 0BB0     		add	sp, sp, #44
 2541              	.LCFI15:
 2542              		.cfi_remember_state
 2543              		.cfi_def_cfa_offset 44
 2544              		@ sp needed
 2545 01ca BDEC028B 		vldm	sp!, {d8}
 2546              	.LCFI16:
 2547              		.cfi_restore 80
 2548              		.cfi_restore 81
 2549              		.cfi_def_cfa_offset 36
 2550 01ce BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2551              	.LVL229:
 2552              	.L244:
 2553              	.LCFI17:
 2554              		.cfi_restore_state
 2555              	.LBB190:
ARM GAS  /tmp/ccHPvcAz.s 			page 93


 823:lwIP/src/core/ipv4/ip4_frag.c ****         goto memerr;
 2556              		.loc 1 823 9 is_stmt 1 view .LVU963
 2557 01d2 5046     		mov	r0, r10
 2558 01d4 FFF7FEFF 		bl	pbuf_free
 2559              	.LVL230:
 824:lwIP/src/core/ipv4/ip4_frag.c ****       }
 2560              		.loc 1 824 9 view .LVU964
 2561              	.LBE190:
 890:lwIP/src/core/ipv4/ip4_frag.c **** }
 2562              		.loc 1 890 10 is_stmt 0 view .LVU965
 2563 01d8 4FF0FF30 		mov	r0, #-1
 2564              		.loc 1 891 1 view .LVU966
 2565 01dc 0BB0     		add	sp, sp, #44
 2566              	.LCFI18:
 2567              		.cfi_remember_state
 2568              		.cfi_def_cfa_offset 44
 2569              		@ sp needed
 2570 01de BDEC028B 		vldm	sp!, {d8}
 2571              	.LCFI19:
 2572              		.cfi_restore 80
 2573              		.cfi_restore 81
 2574              		.cfi_def_cfa_offset 36
 2575              	.LVL231:
 2576              		.loc 1 891 1 view .LVU967
 2577 01e2 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2578              	.LVL232:
 2579              	.L227:
 2580              	.LCFI20:
 2581              		.cfi_restore_state
 858:lwIP/src/core/ipv4/ip4_frag.c ****     }
 2582              		.loc 1 858 7 is_stmt 1 view .LVU968
 858:lwIP/src/core/ipv4/ip4_frag.c ****     }
 2583              		.loc 1 858 11 is_stmt 0 view .LVU969
 2584 01e6 43F40053 		orr	r3, r3, #8192
 2585              	.LVL233:
 858:lwIP/src/core/ipv4/ip4_frag.c ****     }
 2586              		.loc 1 858 11 view .LVU970
 2587 01ea ADE7     		b	.L221
 2588              	.LVL234:
 2589              	.L242:
 804:lwIP/src/core/ipv4/ip4_frag.c ****                 (rambuf->len >= (IP_HLEN)));
 2590              		.loc 1 804 5 is_stmt 1 discriminator 1 view .LVU971
 2591 01ec 0748     		ldr	r0, .L246+12
 2592              	.LVL235:
 804:lwIP/src/core/ipv4/ip4_frag.c ****                 (rambuf->len >= (IP_HLEN)));
 2593              		.loc 1 804 5 is_stmt 0 discriminator 1 view .LVU972
 2594 01ee FFF7FEFF 		bl	printf
 2595              	.LVL236:
 2596              	.L212:
 804:lwIP/src/core/ipv4/ip4_frag.c ****                 (rambuf->len >= (IP_HLEN)));
 2597              		.loc 1 804 5 is_stmt 1 discriminator 2 view .LVU973
 804:lwIP/src/core/ipv4/ip4_frag.c ****                 (rambuf->len >= (IP_HLEN)));
 2598              		.loc 1 804 5 discriminator 2 view .LVU974
 804:lwIP/src/core/ipv4/ip4_frag.c ****                 (rambuf->len >= (IP_HLEN)));
 2599              		.loc 1 804 5 discriminator 2 view .LVU975
 804:lwIP/src/core/ipv4/ip4_frag.c ****                 (rambuf->len >= (IP_HLEN)));
 2600              		.loc 1 804 5 discriminator 2 view .LVU976
ARM GAS  /tmp/ccHPvcAz.s 			page 94


 804:lwIP/src/core/ipv4/ip4_frag.c ****                 (rambuf->len >= (IP_HLEN)));
 2601              		.loc 1 804 5 discriminator 2 view .LVU977
 804:lwIP/src/core/ipv4/ip4_frag.c ****                 (rambuf->len >= (IP_HLEN)));
 2602              		.loc 1 804 5 discriminator 2 view .LVU978
 2603 01f2 FEE7     		b	.L212
 2604              	.LVL237:
 2605              	.L226:
 890:lwIP/src/core/ipv4/ip4_frag.c **** }
 2606              		.loc 1 890 10 is_stmt 0 view .LVU979
 2607 01f4 4FF0FF30 		mov	r0, #-1
 2608              	.LVL238:
 890:lwIP/src/core/ipv4/ip4_frag.c **** }
 2609              		.loc 1 890 10 view .LVU980
 2610 01f8 E6E7     		b	.L206
 2611              	.LVL239:
 2612              	.L225:
 762:lwIP/src/core/ipv4/ip4_frag.c ****   }
 2613              		.loc 1 762 12 view .LVU981
 2614 01fa 6FF00500 		mvn	r0, #5
 2615              	.LVL240:
 762:lwIP/src/core/ipv4/ip4_frag.c ****   }
 2616              		.loc 1 762 12 view .LVU982
 2617 01fe E3E7     		b	.L206
 2618              	.L247:
 2619              		.align	2
 2620              	.L246:
 2621 0200 00000000 		.word	ipfrag_free_pbuf_custom
 2622 0204 00000000 		.word	.LC9
 2623 0208 3C000000 		.word	.LC11
 2624 020c 1C000000 		.word	.LC10
 2625              		.cfi_endproc
 2626              	.LFE115:
 2628              		.section	.bss.ip_reass_pbufcount,"aw",%nobits
 2629              		.align	1
 2630              		.set	.LANCHOR1,. + 0
 2633              	ip_reass_pbufcount:
 2634 0000 0000     		.space	2
 2635              		.section	.bss.reassdatagrams,"aw",%nobits
 2636              		.align	2
 2637              		.set	.LANCHOR0,. + 0
 2640              	reassdatagrams:
 2641 0000 00000000 		.space	4
 2642              		.text
 2643              	.Letext0:
 2644              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
 2645              		.file 4 "/usr/arm-none-eabi/include/sys/lock.h"
 2646              		.file 5 "/usr/arm-none-eabi/include/sys/_types.h"
 2647              		.file 6 "/usr/lib/gcc/arm-none-eabi/9.2.0/include/stddef.h"
 2648              		.file 7 "/usr/arm-none-eabi/include/sys/reent.h"
 2649              		.file 8 "/usr/arm-none-eabi/include/stdlib.h"
 2650              		.file 9 "/usr/arm-none-eabi/include/sys/_stdint.h"
 2651              		.file 10 "lwIP/src/include/lwip/arch.h"
 2652              		.file 11 "/usr/arm-none-eabi/include/ctype.h"
 2653              		.file 12 "lwIP/src/include/lwip/err.h"
 2654              		.file 13 "lwIP/src/include/lwip/pbuf.h"
 2655              		.file 14 "lwIP/src/include/lwip/ip4_addr.h"
 2656              		.file 15 "lwIP/src/include/lwip/ip_addr.h"
ARM GAS  /tmp/ccHPvcAz.s 			page 95


 2657              		.file 16 "lwIP/src/include/lwip/memp.h"
 2658              		.file 17 "lwIP/src/include/lwip/priv/memp_priv.h"
 2659              		.file 18 "lwIP/src/include/lwip/netif.h"
 2660              		.file 19 "lwIP/src/include/lwip/prot/ip4.h"
 2661              		.file 20 "lwIP/src/include/lwip/ip.h"
 2662              		.file 21 "lwIP/src/include/lwip/ip4_frag.h"
 2663              		.file 22 "/usr/arm-none-eabi/include/stdio.h"
 2664              		.file 23 "lwIP/src/include/lwip/inet_chksum.h"
 2665              		.file 24 "lwIP/src/include/lwip/icmp.h"
ARM GAS  /tmp/ccHPvcAz.s 			page 96


DEFINED SYMBOLS
                            *ABS*:0000000000000000 ip4_frag.c
     /tmp/ccHPvcAz.s:18     .rodata.ipfrag_free_pbuf_custom.str1.4:0000000000000000 $d
     /tmp/ccHPvcAz.s:22     .text.ipfrag_free_pbuf_custom:0000000000000000 $t
     /tmp/ccHPvcAz.s:30     .text.ipfrag_free_pbuf_custom:0000000000000000 ipfrag_free_pbuf_custom
     /tmp/ccHPvcAz.s:113    .text.ipfrag_free_pbuf_custom:0000000000000024 $d
     /tmp/ccHPvcAz.s:118    .rodata.ip_reass_free_complete_datagram.part.0.str1.4:0000000000000000 $d
     /tmp/ccHPvcAz.s:128    .text.ip_reass_free_complete_datagram.part.0:0000000000000000 $t
     /tmp/ccHPvcAz.s:135    .text.ip_reass_free_complete_datagram.part.0:0000000000000000 ip_reass_free_complete_datagram.part.0
     /tmp/ccHPvcAz.s:383    .text.ip_reass_free_complete_datagram.part.0:00000000000000c8 $d
     /tmp/ccHPvcAz.s:392    .rodata.ip_reass_remove_oldest_datagram.str1.4:0000000000000000 $d
     /tmp/ccHPvcAz.s:399    .text.ip_reass_remove_oldest_datagram:0000000000000000 $t
     /tmp/ccHPvcAz.s:406    .text.ip_reass_remove_oldest_datagram:0000000000000000 ip_reass_remove_oldest_datagram
     /tmp/ccHPvcAz.s:600    .text.ip_reass_remove_oldest_datagram:0000000000000090 $d
     /tmp/ccHPvcAz.s:609    .text.ip_reass_tmr:0000000000000000 $t
     /tmp/ccHPvcAz.s:617    .text.ip_reass_tmr:0000000000000000 ip_reass_tmr
     /tmp/ccHPvcAz.s:754    .text.ip_reass_tmr:0000000000000048 $d
     /tmp/ccHPvcAz.s:764    .rodata.ip4_reass.str1.4:0000000000000000 $d
     /tmp/ccHPvcAz.s:774    .text.ip4_reass:0000000000000000 $t
     /tmp/ccHPvcAz.s:782    .text.ip4_reass:0000000000000000 ip4_reass
     /tmp/ccHPvcAz.s:1566   .text.ip4_reass:00000000000002c8 $d
     /tmp/ccHPvcAz.s:1582   .text.ip4_reass:00000000000002d4 $t
     /tmp/ccHPvcAz.s:1984   .text.ip4_reass:0000000000000404 $d
     /tmp/ccHPvcAz.s:1993   .rodata.ip4_frag.str1.4:0000000000000000 $d
     /tmp/ccHPvcAz.s:2003   .text.ip4_frag:0000000000000000 $t
     /tmp/ccHPvcAz.s:2011   .text.ip4_frag:0000000000000000 ip4_frag
     /tmp/ccHPvcAz.s:2621   .text.ip4_frag:0000000000000200 $d
     /tmp/ccHPvcAz.s:2629   .bss.ip_reass_pbufcount:0000000000000000 $d
     /tmp/ccHPvcAz.s:2633   .bss.ip_reass_pbufcount:0000000000000000 ip_reass_pbufcount
     /tmp/ccHPvcAz.s:2636   .bss.reassdatagrams:0000000000000000 $d
     /tmp/ccHPvcAz.s:2640   .bss.reassdatagrams:0000000000000000 reassdatagrams

UNDEFINED SYMBOLS
pbuf_free
memp_free
printf
pbuf_clen
icmp_time_exceeded
memp_malloc
inet_chksum
pbuf_remove_header
pbuf_cat
pbuf_alloc
pbuf_alloced_custom
pbuf_ref
